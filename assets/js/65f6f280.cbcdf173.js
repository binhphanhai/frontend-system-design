"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8632],{336:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"project-detail/web-socket","title":"WebSockets: Real-Time Communication Under the Hood","description":"Table of Contents","source":"@site/docs/project-detail/web-socket.md","sourceDirName":"project-detail","slug":"/project-detail/web-socket","permalink":"/frontend-system-design/docs/project-detail/web-socket","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/web-socket.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Dexie.js and IndexedDB: Under the Hood","permalink":"/frontend-system-design/docs/project-detail/dexie-and-indexed-db"},"next":{"title":"Web Workers: Background Threading in the Browser","permalink":"/frontend-system-design/docs/project-detail/web-worker"}}');var o=t(4848),a=t(8453);const r={},i="WebSockets: Real-Time Communication Under the Hood",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Advantages",id:"key-advantages",level:3},{value:"Common Use Cases",id:"common-use-cases",level:3},{value:"Getting Started with WebSockets",id:"getting-started-with-websockets",level:2},{value:"Basic Client Implementation",id:"basic-client-implementation",level:3},{value:"Enhanced WebSocket Client Class",id:"enhanced-websocket-client-class",level:3},{value:"WebSocket Protocol Deep Dive",id:"websocket-protocol-deep-dive",level:2},{value:"Protocol Overview",id:"protocol-overview",level:3},{value:"HTTP to WebSocket Upgrade Process",id:"http-to-websocket-upgrade-process",level:3},{value:"WebSocket Header Analysis",id:"websocket-header-analysis",level:3},{value:"Connection Establishment and Handshake",id:"connection-establishment-and-handshake",level:2},{value:"Client-Side Connection Process",id:"client-side-connection-process",level:3},{value:"Server-Side Handshake Validation",id:"server-side-handshake-validation",level:3},{value:"Frame Structure and Message Types",id:"frame-structure-and-message-types",level:2},{value:"WebSocket Frame Format",id:"websocket-frame-format",level:3},{value:"Frame Processing Implementation",id:"frame-processing-implementation",level:3},{value:"Connection Management and Lifecycle",id:"connection-management-and-lifecycle",level:2},{value:"Keep-Alive and Heartbeat",id:"keep-alive-and-heartbeat",level:3},{value:"Connection Pool Management",id:"connection-pool-management",level:3},{value:"Server-Side Implementation",id:"server-side-implementation",level:2},{value:"Node.js WebSocket Server",id:"nodejs-websocket-server",level:3},{value:"Real-Time Communication Patterns",id:"real-time-communication-patterns",level:2},{value:"Request-Response Pattern",id:"request-response-pattern",level:3},{value:"Pub/Sub Pattern",id:"pubsub-pattern",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Secure WebSocket Implementation",id:"secure-websocket-implementation",level:3},{value:"Rate Limiting and DDoS Protection",id:"rate-limiting-and-ddos-protection",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Connection Pooling and Load Balancing",id:"connection-pooling-and-load-balancing",level:3},{value:"Message Compression and Batching",id:"message-compression-and-batching",level:3},{value:"Real-World Implementation Examples",id:"real-world-implementation-examples",level:2},{value:"Real-Time Chat Application",id:"real-time-chat-application",level:3},{value:"Error Handling and Debugging",id:"error-handling-and-debugging",level:2},{value:"Comprehensive Error Handling",id:"comprehensive-error-handling",level:3},{value:"WebSocket Debugging Tools",id:"websocket-debugging-tools",level:3},{value:"Best Practices and Common Pitfalls",id:"best-practices-and-common-pitfalls",level:2},{value:"Connection Management Best Practices",id:"connection-management-best-practices",level:3},{value:"Message Handling Best Practices",id:"message-handling-best-practices",level:3},{value:"Performance Optimization Tips",id:"performance-optimization-tips",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Future Considerations",id:"future-considerations",level:3},{value:"Further Resources",id:"further-resources",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"websockets-real-time-communication-under-the-hood",children:"WebSockets: Real-Time Communication Under the Hood"})}),"\n",(0,o.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getting-started-with-websockets",children:"Getting Started with WebSockets"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#websocket-protocol-deep-dive",children:"WebSocket Protocol Deep Dive"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#connection-establishment-and-handshake",children:"Connection Establishment and Handshake"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#frame-structure-and-message-types",children:"Frame Structure and Message Types"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#connection-management-and-lifecycle",children:"Connection Management and Lifecycle"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#server-side-implementation",children:"Server-Side Implementation"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#real-time-communication-patterns",children:"Real-Time Communication Patterns"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#security-considerations",children:"Security Considerations"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#real-world-implementation-examples",children:"Real-World Implementation Examples"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#error-handling-and-debugging",children:"Error Handling and Debugging"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#websocket-libraries-and-frameworks",children:"WebSocket Libraries and Frameworks"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#best-practices-and-common-pitfalls",children:"Best Practices and Common Pitfalls"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(n.p,{children:"WebSockets provide a full-duplex communication channel between a client and server over a single TCP connection. Unlike traditional HTTP requests, WebSockets enable real-time, bidirectional communication with minimal overhead, making them ideal for applications requiring instant data exchange."}),"\n",(0,o.jsxs)(n.p,{children:["As defined in the ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API",children:"WebSocket API specification"}),", WebSockets overcome the limitations of HTTP polling by establishing a persistent connection that allows both client and server to send data at any time."]}),"\n",(0,o.jsx)(n.h3,{id:"key-advantages",children:"Key Advantages"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Full-Duplex Communication"}),": Both client and server can send data simultaneously"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Low Latency"}),": No HTTP header overhead after initial handshake"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Real-Time Updates"}),": Instant data exchange without polling"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Efficient Resource Usage"}),": Single persistent connection vs multiple HTTP requests"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Binary and Text Support"}),": Flexible data transmission formats"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Real-time chat applications"}),"\n",(0,o.jsx)(n.li,{children:"Live gaming and multiplayer experiences"}),"\n",(0,o.jsx)(n.li,{children:"Financial trading platforms"}),"\n",(0,o.jsx)(n.li,{children:"Collaborative editing tools"}),"\n",(0,o.jsx)(n.li,{children:"Live notifications and alerts"}),"\n",(0,o.jsx)(n.li,{children:"IoT device communication"}),"\n",(0,o.jsx)(n.li,{children:"Real-time analytics dashboards"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"getting-started-with-websockets",children:"Getting Started with WebSockets"}),"\n",(0,o.jsx)(n.h3,{id:"basic-client-implementation",children:"Basic Client Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// Create a new WebSocket connection\nconst socket = new WebSocket("ws://localhost:8080");\n\n// Connection opened\nsocket.addEventListener("open", (event) => {\n  console.log("Connected to WebSocket server");\n  socket.send("Hello Server!");\n});\n\n// Listen for messages\nsocket.addEventListener("message", (event) => {\n  console.log("Message from server:", event.data);\n});\n\n// Handle errors\nsocket.addEventListener("error", (event) => {\n  console.error("WebSocket error:", event);\n});\n\n// Connection closed\nsocket.addEventListener("close", (event) => {\n  console.log("Connection closed:", event.code, event.reason);\n});\n'})}),"\n",(0,o.jsx)(n.h3,{id:"enhanced-websocket-client-class",children:"Enhanced WebSocket Client Class"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class WebSocketClient {\n  constructor(url, protocols = []) {\n    this.url = url;\n    this.protocols = protocols;\n    this.socket = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectInterval = 1000;\n    this.messageQueue = [];\n    this.eventListeners = {};\n  }\n\n  connect() {\n    try {\n      this.socket = new WebSocket(this.url, this.protocols);\n      this.setupEventListeners();\n    } catch (error) {\n      console.error("Failed to create WebSocket:", error);\n      this.handleReconnect();\n    }\n  }\n\n  setupEventListeners() {\n    this.socket.onopen = (event) => {\n      console.log("WebSocket connected");\n      this.reconnectAttempts = 0;\n      this.processMessageQueue();\n      this.emit("open", event);\n    };\n\n    this.socket.onmessage = (event) => {\n      const data = this.parseMessage(event.data);\n      this.emit("message", data);\n    };\n\n    this.socket.onerror = (event) => {\n      console.error("WebSocket error:", event);\n      this.emit("error", event);\n    };\n\n    this.socket.onclose = (event) => {\n      console.log("WebSocket closed:", event.code, event.reason);\n      this.emit("close", event);\n\n      if (!event.wasClean) {\n        this.handleReconnect();\n      }\n    };\n  }\n\n  send(data) {\n    if (this.isConnected()) {\n      const message = this.formatMessage(data);\n      this.socket.send(message);\n    } else {\n      this.messageQueue.push(data);\n    }\n  }\n\n  isConnected() {\n    return this.socket && this.socket.readyState === WebSocket.OPEN;\n  }\n\n  parseMessage(data) {\n    try {\n      return JSON.parse(data);\n    } catch {\n      return data;\n    }\n  }\n\n  formatMessage(data) {\n    return typeof data === "object" ? JSON.stringify(data) : data;\n  }\n\n  processMessageQueue() {\n    while (this.messageQueue.length > 0) {\n      const message = this.messageQueue.shift();\n      this.send(message);\n    }\n  }\n\n  handleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Reconnecting... Attempt ${this.reconnectAttempts}`);\n\n      setTimeout(() => {\n        this.connect();\n      }, this.reconnectInterval * this.reconnectAttempts);\n    } else {\n      console.error("Max reconnection attempts reached");\n      this.emit("maxReconnectAttemptsReached");\n    }\n  }\n\n  on(event, callback) {\n    if (!this.eventListeners[event]) {\n      this.eventListeners[event] = [];\n    }\n    this.eventListeners[event].push(callback);\n  }\n\n  off(event, callback) {\n    if (this.eventListeners[event]) {\n      this.eventListeners[event] = this.eventListeners[event].filter(\n        (cb) => cb !== callback\n      );\n    }\n  }\n\n  emit(event, data) {\n    if (this.eventListeners[event]) {\n      this.eventListeners[event].forEach((callback) => callback(data));\n    }\n  }\n\n  close(code = 1000, reason = "Normal closure") {\n    if (this.socket) {\n      this.socket.close(code, reason);\n    }\n  }\n\n  getState() {\n    if (!this.socket) return "UNINITIALIZED";\n\n    switch (this.socket.readyState) {\n      case WebSocket.CONNECTING:\n        return "CONNECTING";\n      case WebSocket.OPEN:\n        return "OPEN";\n      case WebSocket.CLOSING:\n        return "CLOSING";\n      case WebSocket.CLOSED:\n        return "CLOSED";\n      default:\n        return "UNKNOWN";\n    }\n  }\n}\n\n// Usage example\nconst client = new WebSocketClient("ws://localhost:8080");\n\nclient.on("open", () => {\n  console.log("Connected successfully");\n  client.send({ type: "greeting", message: "Hello from client!" });\n});\n\nclient.on("message", (data) => {\n  console.log("Received:", data);\n});\n\nclient.on("error", (error) => {\n  console.error("Connection error:", error);\n});\n\nclient.connect();\n'})}),"\n",(0,o.jsx)(n.h2,{id:"websocket-protocol-deep-dive",children:"WebSocket Protocol Deep Dive"}),"\n",(0,o.jsx)(n.h3,{id:"protocol-overview",children:"Protocol Overview"}),"\n",(0,o.jsx)(n.p,{children:"WebSockets operate over TCP and use HTTP/1.1 for the initial handshake. Once established, the connection switches to the WebSocket protocol, enabling bidirectional communication with minimal overhead."}),"\n",(0,o.jsx)(n.h3,{id:"http-to-websocket-upgrade-process",children:"HTTP to WebSocket Upgrade Process"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Client Request:\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\nSec-WebSocket-Protocol: chat, superchat\nOrigin: http://example.com\n\nServer Response:\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\nSec-WebSocket-Protocol: chat\n"})}),"\n",(0,o.jsx)(n.h3,{id:"websocket-header-analysis",children:"WebSocket Header Analysis"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// WebSocket handshake validation\nclass WebSocketHandshake {\n  static generateKey() {\n    // Generate 16-byte random value and encode as base64\n    const bytes = new Uint8Array(16);\n    crypto.getRandomValues(bytes);\n    return btoa(String.fromCharCode(...bytes));\n  }\n\n  static validateAcceptKey(clientKey, serverAccept) {\n    const magicString = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";\n    const concatenated = clientKey + magicString;\n\n    // SHA-1 hash and base64 encode\n    return crypto.subtle\n      .digest("SHA-1", new TextEncoder().encode(concatenated))\n      .then((hashBuffer) => {\n        const hashArray = new Uint8Array(hashBuffer);\n        const expectedAccept = btoa(String.fromCharCode(...hashArray));\n        return expectedAccept === serverAccept;\n      });\n  }\n\n  static parseUpgradeHeaders(headers) {\n    return {\n      upgrade: headers.get("Upgrade")?.toLowerCase(),\n      connection: headers.get("Connection")?.toLowerCase(),\n      key: headers.get("Sec-WebSocket-Key"),\n      version: headers.get("Sec-WebSocket-Version"),\n      protocol: headers.get("Sec-WebSocket-Protocol"),\n      extensions: headers.get("Sec-WebSocket-Extensions"),\n    };\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"connection-establishment-and-handshake",children:"Connection Establishment and Handshake"}),"\n",(0,o.jsx)(n.h3,{id:"client-side-connection-process",children:"Client-Side Connection Process"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class WebSocketConnection {\n  constructor(url, options = {}) {\n    this.url = url;\n    this.options = {\n      protocols: options.protocols || [],\n      timeout: options.timeout || 30000,\n      ...options,\n    };\n    this.connectionState = "IDLE";\n  }\n\n  async connect() {\n    return new Promise((resolve, reject) => {\n      this.connectionState = "CONNECTING";\n\n      const socket = new WebSocket(this.url, this.options.protocols);\n      const timeout = setTimeout(() => {\n        socket.close();\n        reject(new Error("Connection timeout"));\n      }, this.options.timeout);\n\n      socket.onopen = () => {\n        clearTimeout(timeout);\n        this.connectionState = "CONNECTED";\n        this.socket = socket;\n        this.setupHeartbeat();\n        resolve(socket);\n      };\n\n      socket.onerror = (error) => {\n        clearTimeout(timeout);\n        this.connectionState = "ERROR";\n        reject(error);\n      };\n\n      socket.onclose = () => {\n        clearTimeout(timeout);\n        this.connectionState = "CLOSED";\n        this.cleanup();\n      };\n    });\n  }\n\n  setupHeartbeat() {\n    this.heartbeatInterval = setInterval(() => {\n      if (this.socket?.readyState === WebSocket.OPEN) {\n        this.socket.send(JSON.stringify({ type: "ping" }));\n      }\n    }, 30000); // Send ping every 30 seconds\n  }\n\n  cleanup() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"server-side-handshake-validation",children:"Server-Side Handshake Validation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// Node.js WebSocket server handshake handling\nconst crypto = require("crypto");\nconst { EventEmitter } = require("events");\n\nclass WebSocketServer extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.port = options.port || 8080;\n    this.protocols = options.protocols || [];\n  }\n\n  handleUpgrade(request, socket, head) {\n    const headers = request.headers;\n\n    // Validate WebSocket headers\n    if (!this.validateHeaders(headers)) {\n      socket.write("HTTP/1.1 400 Bad Request\\r\\n\\r\\n");\n      socket.destroy();\n      return;\n    }\n\n    // Generate accept key\n    const acceptKey = this.generateAcceptKey(headers["sec-websocket-key"]);\n\n    // Select protocol\n    const selectedProtocol = this.selectProtocol(\n      headers["sec-websocket-protocol"]\n    );\n\n    // Send handshake response\n    const responseHeaders = [\n      "HTTP/1.1 101 Switching Protocols",\n      "Upgrade: websocket",\n      "Connection: Upgrade",\n      `Sec-WebSocket-Accept: ${acceptKey}`,\n    ];\n\n    if (selectedProtocol) {\n      responseHeaders.push(`Sec-WebSocket-Protocol: ${selectedProtocol}`);\n    }\n\n    socket.write(responseHeaders.join("\\r\\n") + "\\r\\n\\r\\n");\n\n    // Create WebSocket connection\n    const websocket = new WebSocketConnection(socket);\n    this.emit("connection", websocket);\n  }\n\n  validateHeaders(headers) {\n    return (\n      headers.upgrade?.toLowerCase() === "websocket" &&\n      headers.connection?.toLowerCase().includes("upgrade") &&\n      headers["sec-websocket-key"] &&\n      headers["sec-websocket-version"] === "13"\n    );\n  }\n\n  generateAcceptKey(clientKey) {\n    const magicString = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";\n    const hash = crypto\n      .createHash("sha1")\n      .update(clientKey + magicString)\n      .digest("base64");\n    return hash;\n  }\n\n  selectProtocol(requestedProtocols) {\n    if (!requestedProtocols) return null;\n\n    const protocols = requestedProtocols.split(",").map((p) => p.trim());\n    return protocols.find((protocol) => this.protocols.includes(protocol));\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"frame-structure-and-message-types",children:"Frame Structure and Message Types"}),"\n",(0,o.jsx)(n.h3,{id:"websocket-frame-format",children:"WebSocket Frame Format"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:" 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-------+-+-------------+-------------------------------+\n|F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n|N|V|V|V|       |S|             |   (if payload len==126/127)   |\n| |1|2|3|       |K|             |                               |\n+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n|     Extended payload length continued, if payload len == 127  |\n+ - - - - - - - - - - - - - - - +-------------------------------+\n|                               |Masking-key, if MASK set to 1  |\n+-------------------------------+-------------------------------+\n| Masking-key (continued)       |          Payload Data         |\n+-------------------------------- - - - - - - - - - - - - - - - +\n:                     Payload Data continued ...                :\n+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n|                     Payload Data continued ...                |\n+---------------------------------------------------------------+\n"})}),"\n",(0,o.jsx)(n.h3,{id:"frame-processing-implementation",children:"Frame Processing Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class WebSocketFrame {\n  constructor() {\n    this.fin = false;\n    this.rsv1 = false;\n    this.rsv2 = false;\n    this.rsv3 = false;\n    this.opcode = 0;\n    this.masked = false;\n    this.payloadLength = 0;\n    this.maskingKey = null;\n    this.payload = null;\n  }\n\n  static OPCODES = {\n    CONTINUATION: 0x0,\n    TEXT: 0x1,\n    BINARY: 0x2,\n    CLOSE: 0x8,\n    PING: 0x9,\n    PONG: 0xa,\n  };\n\n  static createTextFrame(data, masked = true) {\n    const frame = new WebSocketFrame();\n    frame.fin = true;\n    frame.opcode = WebSocketFrame.OPCODES.TEXT;\n    frame.masked = masked;\n    frame.payload = Buffer.from(data, "utf8");\n    frame.payloadLength = frame.payload.length;\n\n    if (masked) {\n      frame.maskingKey = crypto.randomBytes(4);\n      frame.payload = WebSocketFrame.maskPayload(\n        frame.payload,\n        frame.maskingKey\n      );\n    }\n\n    return frame;\n  }\n\n  static createBinaryFrame(data, masked = true) {\n    const frame = new WebSocketFrame();\n    frame.fin = true;\n    frame.opcode = WebSocketFrame.OPCODES.BINARY;\n    frame.masked = masked;\n    frame.payload = Buffer.isBuffer(data) ? data : Buffer.from(data);\n    frame.payloadLength = frame.payload.length;\n\n    if (masked) {\n      frame.maskingKey = crypto.randomBytes(4);\n      frame.payload = WebSocketFrame.maskPayload(\n        frame.payload,\n        frame.maskingKey\n      );\n    }\n\n    return frame;\n  }\n\n  static createPingFrame(data = Buffer.alloc(0)) {\n    const frame = new WebSocketFrame();\n    frame.fin = true;\n    frame.opcode = WebSocketFrame.OPCODES.PING;\n    frame.payload = data;\n    frame.payloadLength = data.length;\n    return frame;\n  }\n\n  static createPongFrame(data = Buffer.alloc(0)) {\n    const frame = new WebSocketFrame();\n    frame.fin = true;\n    frame.opcode = WebSocketFrame.OPCODES.PONG;\n    frame.payload = data;\n    frame.payloadLength = data.length;\n    return frame;\n  }\n\n  static maskPayload(payload, maskingKey) {\n    const masked = Buffer.alloc(payload.length);\n    for (let i = 0; i < payload.length; i++) {\n      masked[i] = payload[i] ^ maskingKey[i % 4];\n    }\n    return masked;\n  }\n\n  toBuffer() {\n    let headerLength = 2;\n    let payloadLengthBytes = 0;\n\n    // Determine payload length representation\n    if (this.payloadLength < 126) {\n      payloadLengthBytes = 0;\n    } else if (this.payloadLength < 65536) {\n      payloadLengthBytes = 2;\n      headerLength += 2;\n    } else {\n      payloadLengthBytes = 8;\n      headerLength += 8;\n    }\n\n    if (this.masked) {\n      headerLength += 4;\n    }\n\n    const buffer = Buffer.alloc(headerLength + this.payloadLength);\n    let offset = 0;\n\n    // First byte: FIN + RSV + Opcode\n    buffer[offset] =\n      (this.fin ? 0x80 : 0) |\n      (this.rsv1 ? 0x40 : 0) |\n      (this.rsv2 ? 0x20 : 0) |\n      (this.rsv3 ? 0x10 : 0) |\n      (this.opcode & 0x0f);\n    offset++;\n\n    // Second byte: MASK + Payload length\n    if (this.payloadLength < 126) {\n      buffer[offset] = (this.masked ? 0x80 : 0) | this.payloadLength;\n    } else if (this.payloadLength < 65536) {\n      buffer[offset] = (this.masked ? 0x80 : 0) | 126;\n      offset++;\n      buffer.writeUInt16BE(this.payloadLength, offset);\n      offset += 2;\n    } else {\n      buffer[offset] = (this.masked ? 0x80 : 0) | 127;\n      offset++;\n      buffer.writeUInt32BE(0, offset); // High 32 bits\n      buffer.writeUInt32BE(this.payloadLength, offset + 4); // Low 32 bits\n      offset += 8;\n    }\n    offset++;\n\n    // Masking key\n    if (this.masked && this.maskingKey) {\n      this.maskingKey.copy(buffer, offset);\n      offset += 4;\n    }\n\n    // Payload\n    if (this.payload) {\n      this.payload.copy(buffer, offset);\n    }\n\n    return buffer;\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"connection-management-and-lifecycle",children:"Connection Management and Lifecycle"}),"\n",(0,o.jsx)(n.h3,{id:"keep-alive-and-heartbeat",children:"Keep-Alive and Heartbeat"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class WebSocketKeepAlive {\n  constructor(socket, options = {}) {\n    this.socket = socket;\n    this.pingInterval = options.pingInterval || 30000;\n    this.pongTimeout = options.pongTimeout || 5000;\n    this.maxMissedPongs = options.maxMissedPongs || 3;\n    this.missedPongs = 0;\n    this.isAlive = true;\n  }\n\n  start() {\n    this.heartbeatTimer = setInterval(() => {\n      if (!this.isAlive) {\n        this.missedPongs++;\n\n        if (this.missedPongs >= this.maxMissedPongs) {\n          console.log("Connection appears dead, closing");\n          this.socket.terminate();\n          return;\n        }\n      }\n\n      this.isAlive = false;\n      this.socket.ping();\n\n      // Set timeout for pong response\n      this.pongTimer = setTimeout(() => {\n        console.log("Pong timeout");\n        this.isAlive = false;\n      }, this.pongTimeout);\n    }, this.pingInterval);\n\n    this.socket.on("pong", () => {\n      this.isAlive = true;\n      this.missedPongs = 0;\n      if (this.pongTimer) {\n        clearTimeout(this.pongTimer);\n      }\n    });\n  }\n\n  stop() {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n    }\n    if (this.pongTimer) {\n      clearTimeout(this.pongTimer);\n    }\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"connection-pool-management",children:"Connection Pool Management"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class WebSocketPool {\n  constructor(options = {}) {\n    this.connections = new Map();\n    this.groups = new Map();\n    this.maxConnections = options.maxConnections || 1000;\n    this.cleanupInterval = options.cleanupInterval || 60000;\n    this.startCleanup();\n  }\n\n  addConnection(id, socket, metadata = {}) {\n    if (this.connections.size >= this.maxConnections) {\n      throw new Error("Maximum connections reached");\n    }\n\n    const connection = {\n      id,\n      socket,\n      metadata,\n      connectedAt: Date.now(),\n      lastActivity: Date.now(),\n    };\n\n    this.connections.set(id, connection);\n    this.setupConnectionHandlers(connection);\n\n    console.log(`Connection added: ${id} (Total: ${this.connections.size})`);\n    return connection;\n  }\n\n  removeConnection(id) {\n    const connection = this.connections.get(id);\n    if (connection) {\n      connection.socket.terminate();\n      this.connections.delete(id);\n      this.removeFromAllGroups(id);\n      console.log(\n        `Connection removed: ${id} (Total: ${this.connections.size})`\n      );\n    }\n  }\n\n  setupConnectionHandlers(connection) {\n    connection.socket.on("message", (data) => {\n      connection.lastActivity = Date.now();\n    });\n\n    connection.socket.on("close", () => {\n      this.removeConnection(connection.id);\n    });\n\n    connection.socket.on("error", (error) => {\n      console.error(`Connection error for ${connection.id}:`, error);\n      this.removeConnection(connection.id);\n    });\n  }\n\n  broadcast(message, excludeId = null) {\n    const data =\n      typeof message === "string" ? message : JSON.stringify(message);\n    let sent = 0;\n\n    this.connections.forEach((connection) => {\n      if (connection.id !== excludeId && connection.socket.readyState === 1) {\n        connection.socket.send(data);\n        sent++;\n      }\n    });\n\n    return sent;\n  }\n\n  broadcastToGroup(groupId, message, excludeId = null) {\n    const group = this.groups.get(groupId);\n    if (!group) return 0;\n\n    const data =\n      typeof message === "string" ? message : JSON.stringify(message);\n    let sent = 0;\n\n    group.forEach((connectionId) => {\n      if (connectionId !== excludeId) {\n        const connection = this.connections.get(connectionId);\n        if (connection && connection.socket.readyState === 1) {\n          connection.socket.send(data);\n          sent++;\n        }\n      }\n    });\n\n    return sent;\n  }\n\n  addToGroup(groupId, connectionId) {\n    if (!this.groups.has(groupId)) {\n      this.groups.set(groupId, new Set());\n    }\n    this.groups.get(groupId).add(connectionId);\n  }\n\n  removeFromGroup(groupId, connectionId) {\n    const group = this.groups.get(groupId);\n    if (group) {\n      group.delete(connectionId);\n      if (group.size === 0) {\n        this.groups.delete(groupId);\n      }\n    }\n  }\n\n  removeFromAllGroups(connectionId) {\n    this.groups.forEach((group, groupId) => {\n      group.delete(connectionId);\n      if (group.size === 0) {\n        this.groups.delete(groupId);\n      }\n    });\n  }\n\n  startCleanup() {\n    this.cleanupTimer = setInterval(() => {\n      const now = Date.now();\n      const staleConnections = [];\n\n      this.connections.forEach((connection) => {\n        // Remove connections inactive for more than 10 minutes\n        if (now - connection.lastActivity > 600000) {\n          staleConnections.push(connection.id);\n        }\n      });\n\n      staleConnections.forEach((id) => this.removeConnection(id));\n\n      if (staleConnections.length > 0) {\n        console.log(`Cleaned up ${staleConnections.length} stale connections`);\n      }\n    }, this.cleanupInterval);\n  }\n\n  getStats() {\n    const now = Date.now();\n    let activeConnections = 0;\n    let totalGroups = this.groups.size;\n\n    this.connections.forEach((connection) => {\n      if (connection.socket.readyState === 1) {\n        activeConnections++;\n      }\n    });\n\n    return {\n      totalConnections: this.connections.size,\n      activeConnections,\n      totalGroups,\n      uptime: now - this.startTime,\n    };\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"server-side-implementation",children:"Server-Side Implementation"}),"\n",(0,o.jsx)(n.h3,{id:"nodejs-websocket-server",children:"Node.js WebSocket Server"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'const WebSocket = require("ws");\nconst http = require("http");\nconst crypto = require("crypto");\n\nclass CustomWebSocketServer {\n  constructor(options = {}) {\n    this.port = options.port || 8080;\n    this.server = http.createServer();\n    this.wss = new WebSocket.Server({ server: this.server });\n    this.connectionPool = new WebSocketPool();\n    this.messageHandlers = new Map();\n    this.middleware = [];\n\n    this.setupRoutes();\n    this.setupWebSocketHandlers();\n  }\n\n  setupRoutes() {\n    this.server.on("request", (req, res) => {\n      if (req.url === "/health") {\n        res.writeHead(200, { "Content-Type": "application/json" });\n        res.end(JSON.stringify(this.connectionPool.getStats()));\n      } else {\n        res.writeHead(404);\n        res.end("Not Found");\n      }\n    });\n  }\n\n  setupWebSocketHandlers() {\n    this.wss.on("connection", (ws, req) => {\n      const connectionId = this.generateConnectionId();\n      const connection = this.connectionPool.addConnection(connectionId, ws, {\n        userAgent: req.headers["user-agent"],\n        ip: req.connection.remoteAddress,\n      });\n\n      // Setup keep-alive\n      const keepAlive = new WebSocketKeepAlive(ws);\n      keepAlive.start();\n\n      ws.on("message", async (data) => {\n        try {\n          await this.processMessage(connection, data);\n        } catch (error) {\n          console.error("Error processing message:", error);\n          this.sendError(ws, "Message processing failed");\n        }\n      });\n\n      ws.on("close", () => {\n        keepAlive.stop();\n        console.log(`Client disconnected: ${connectionId}`);\n      });\n\n      // Send welcome message\n      this.send(ws, {\n        type: "connection",\n        id: connectionId,\n        message: "Connected successfully",\n      });\n    });\n  }\n\n  async processMessage(connection, rawData) {\n    // Apply middleware\n    for (const middleware of this.middleware) {\n      const result = await middleware(connection, rawData);\n      if (result === false) return; // Middleware rejected the message\n    }\n\n    let message;\n    try {\n      message = JSON.parse(rawData.toString());\n    } catch (error) {\n      this.sendError(connection.socket, "Invalid JSON");\n      return;\n    }\n\n    const handler = this.messageHandlers.get(message.type);\n    if (handler) {\n      await handler(connection, message);\n    } else {\n      this.sendError(\n        connection.socket,\n        `Unknown message type: ${message.type}`\n      );\n    }\n  }\n\n  addMessageHandler(type, handler) {\n    this.messageHandlers.set(type, handler);\n  }\n\n  addMiddleware(middleware) {\n    this.middleware.push(middleware);\n  }\n\n  send(ws, data) {\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify(data));\n    }\n  }\n\n  sendError(ws, message) {\n    this.send(ws, { type: "error", message });\n  }\n\n  broadcast(message, excludeId = null) {\n    return this.connectionPool.broadcast(message, excludeId);\n  }\n\n  generateConnectionId() {\n    return crypto.randomBytes(16).toString("hex");\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      console.log(`WebSocket server listening on port ${this.port}`);\n    });\n  }\n}\n\n// Usage example\nconst server = new CustomWebSocketServer({ port: 8080 });\n\n// Add authentication middleware\nserver.addMiddleware(async (connection, data) => {\n  // Check authentication token\n  const message = JSON.parse(data.toString());\n  if (message.type !== "auth" && !connection.authenticated) {\n    server.sendError(connection.socket, "Authentication required");\n    return false;\n  }\n  return true;\n});\n\n// Add message handlers\nserver.addMessageHandler("auth", async (connection, message) => {\n  // Validate token\n  if (message.token === "valid-token") {\n    connection.authenticated = true;\n    server.send(connection.socket, { type: "auth", status: "success" });\n  } else {\n    server.sendError(connection.socket, "Invalid token");\n    connection.socket.close();\n  }\n});\n\nserver.addMessageHandler("chat", async (connection, message) => {\n  if (!connection.authenticated) return;\n\n  const chatMessage = {\n    type: "chat",\n    id: crypto.randomUUID(),\n    user: connection.metadata.userId,\n    message: message.content,\n    timestamp: Date.now(),\n  };\n\n  server.broadcast(chatMessage, connection.id);\n});\n\nserver.start();\n'})}),"\n",(0,o.jsx)(n.h2,{id:"real-time-communication-patterns",children:"Real-Time Communication Patterns"}),"\n",(0,o.jsx)(n.h3,{id:"request-response-pattern",children:"Request-Response Pattern"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class WebSocketRPC {\n  constructor(socket) {\n    this.socket = socket;\n    this.pendingRequests = new Map();\n    this.requestId = 0;\n    this.setupMessageHandler();\n  }\n\n  setupMessageHandler() {\n    this.socket.addEventListener("message", (event) => {\n      const data = JSON.parse(event.data);\n\n      if (data.id && this.pendingRequests.has(data.id)) {\n        const { resolve, reject } = this.pendingRequests.get(data.id);\n        this.pendingRequests.delete(data.id);\n\n        if (data.error) {\n          reject(new Error(data.error));\n        } else {\n          resolve(data.result);\n        }\n      }\n    });\n  }\n\n  async call(method, params = {}, timeout = 5000) {\n    return new Promise((resolve, reject) => {\n      const id = ++this.requestId;\n\n      const timer = setTimeout(() => {\n        this.pendingRequests.delete(id);\n        reject(new Error("Request timeout"));\n      }, timeout);\n\n      this.pendingRequests.set(id, {\n        resolve: (result) => {\n          clearTimeout(timer);\n          resolve(result);\n        },\n        reject: (error) => {\n          clearTimeout(timer);\n          reject(error);\n        },\n      });\n\n      this.socket.send(\n        JSON.stringify({\n          id,\n          method,\n          params,\n        })\n      );\n    });\n  }\n}\n\n// Usage\nconst rpc = new WebSocketRPC(socket);\n\ntry {\n  const result = await rpc.call("getUserProfile", { userId: 123 });\n  console.log("User profile:", result);\n} catch (error) {\n  console.error("RPC error:", error);\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"pubsub-pattern",children:"Pub/Sub Pattern"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class WebSocketPubSub {\n  constructor(socket) {\n    this.socket = socket;\n    this.subscriptions = new Map();\n    this.setupMessageHandler();\n  }\n\n  setupMessageHandler() {\n    this.socket.addEventListener("message", (event) => {\n      const data = JSON.parse(event.data);\n\n      if (data.type === "publish") {\n        const callbacks = this.subscriptions.get(data.channel);\n        if (callbacks) {\n          callbacks.forEach((callback) => {\n            try {\n              callback(data.payload);\n            } catch (error) {\n              console.error("Subscription callback error:", error);\n            }\n          });\n        }\n      }\n    });\n  }\n\n  subscribe(channel, callback) {\n    if (!this.subscriptions.has(channel)) {\n      this.subscriptions.set(channel, new Set());\n\n      // Send subscription request to server\n      this.socket.send(\n        JSON.stringify({\n          type: "subscribe",\n          channel,\n        })\n      );\n    }\n\n    this.subscriptions.get(channel).add(callback);\n\n    // Return unsubscribe function\n    return () => {\n      const callbacks = this.subscriptions.get(channel);\n      if (callbacks) {\n        callbacks.delete(callback);\n\n        if (callbacks.size === 0) {\n          this.subscriptions.delete(channel);\n\n          // Send unsubscription request to server\n          this.socket.send(\n            JSON.stringify({\n              type: "unsubscribe",\n              channel,\n            })\n          );\n        }\n      }\n    };\n  }\n\n  publish(channel, payload) {\n    this.socket.send(\n      JSON.stringify({\n        type: "publish",\n        channel,\n        payload,\n      })\n    );\n  }\n}\n\n// Usage\nconst pubsub = new WebSocketPubSub(socket);\n\n// Subscribe to user events\nconst unsubscribe = pubsub.subscribe("user.events", (data) => {\n  console.log("User event:", data);\n});\n\n// Publish a message\npubsub.publish("user.events", {\n  action: "login",\n  userId: 123,\n  timestamp: Date.now(),\n});\n\n// Unsubscribe later\nunsubscribe();\n'})}),"\n",(0,o.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,o.jsx)(n.h3,{id:"secure-websocket-implementation",children:"Secure WebSocket Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class SecureWebSocketClient {\n  constructor(url, options = {}) {\n    this.url = url;\n    this.options = options;\n    this.authToken = null;\n    this.csrfToken = null;\n  }\n\n  async connect(credentials) {\n    // Use WSS for secure connections\n    const secureUrl = this.url.replace("ws://", "wss://");\n\n    // Get authentication token\n    this.authToken = await this.authenticate(credentials);\n    this.csrfToken = await this.getCSRFToken();\n\n    const socket = new WebSocket(secureUrl, [], {\n      headers: {\n        Authorization: `Bearer ${this.authToken}`,\n        "X-CSRF-Token": this.csrfToken,\n      },\n    });\n\n    return new Promise((resolve, reject) => {\n      socket.onopen = () => {\n        this.socket = socket;\n        this.setupSecurityHandlers();\n        resolve(socket);\n      };\n\n      socket.onerror = reject;\n    });\n  }\n\n  setupSecurityHandlers() {\n    this.socket.addEventListener("message", (event) => {\n      try {\n        const data = JSON.parse(event.data);\n\n        // Validate message structure\n        if (!this.validateMessage(data)) {\n          console.warn("Invalid message structure received");\n          return;\n        }\n\n        // Check for token refresh\n        if (data.type === "token_refresh") {\n          this.authToken = data.token;\n        }\n\n        this.handleMessage(data);\n      } catch (error) {\n        console.error("Message processing error:", error);\n      }\n    });\n  }\n\n  validateMessage(data) {\n    // Implement message validation logic\n    return (\n      typeof data === "object" &&\n      data !== null &&\n      typeof data.type === "string" &&\n      data.type.length > 0\n    );\n  }\n\n  sendSecureMessage(data) {\n    const message = {\n      ...data,\n      timestamp: Date.now(),\n      nonce: crypto.randomUUID(),\n      auth: this.authToken,\n    };\n\n    this.socket.send(JSON.stringify(message));\n  }\n\n  async authenticate(credentials) {\n    const response = await fetch("/api/auth", {\n      method: "POST",\n      headers: { "Content-Type": "application/json" },\n      body: JSON.stringify(credentials),\n    });\n\n    const data = await response.json();\n    return data.token;\n  }\n\n  async getCSRFToken() {\n    const response = await fetch("/api/csrf-token");\n    const data = await response.json();\n    return data.token;\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"rate-limiting-and-ddos-protection",children:"Rate Limiting and DDoS Protection"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class WebSocketRateLimiter {\n  constructor(options = {}) {\n    this.windowMs = options.windowMs || 60000; // 1 minute\n    this.maxRequests = options.maxRequests || 100;\n    this.clients = new Map();\n    this.cleanupInterval = setInterval(() => this.cleanup(), this.windowMs);\n  }\n\n  checkLimit(clientId) {\n    const now = Date.now();\n    const client = this.clients.get(clientId) || {\n      requests: [],\n      blocked: false,\n    };\n\n    // Remove old requests outside the window\n    client.requests = client.requests.filter(\n      (timestamp) => now - timestamp < this.windowMs\n    );\n\n    // Check if client is blocked\n    if (client.blocked && client.blockExpiry > now) {\n      return false;\n    }\n\n    // Check rate limit\n    if (client.requests.length >= this.maxRequests) {\n      client.blocked = true;\n      client.blockExpiry = now + this.windowMs;\n      this.clients.set(clientId, client);\n      return false;\n    }\n\n    // Add current request\n    client.requests.push(now);\n    client.blocked = false;\n    this.clients.set(clientId, client);\n\n    return true;\n  }\n\n  cleanup() {\n    const now = Date.now();\n    for (const [clientId, client] of this.clients.entries()) {\n      // Remove expired blocks and old request records\n      if (client.blocked && client.blockExpiry <= now) {\n        client.blocked = false;\n        client.requests = [];\n      }\n\n      // Remove clients with no recent activity\n      if (client.requests.length === 0 && !client.blocked) {\n        this.clients.delete(clientId);\n      }\n    }\n  }\n\n  destroy() {\n    clearInterval(this.cleanupInterval);\n  }\n}\n\n// Server integration\nconst rateLimiter = new WebSocketRateLimiter({\n  windowMs: 60000, // 1 minute\n  maxRequests: 50, // 50 requests per minute\n});\n\nserver.addMiddleware(async (connection, data) => {\n  const clientId = connection.metadata.ip;\n\n  if (!rateLimiter.checkLimit(clientId)) {\n    server.sendError(connection.socket, "Rate limit exceeded");\n    return false;\n  }\n\n  return true;\n});\n'})}),"\n",(0,o.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(n.h3,{id:"connection-pooling-and-load-balancing",children:"Connection Pooling and Load Balancing"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class WebSocketLoadBalancer {\n  constructor(servers) {\n    this.servers = servers.map((server, index) => ({\n      ...server,\n      id: index,\n      connections: 0,\n      healthy: true,\n    }));\n    this.currentIndex = 0;\n    this.healthCheckInterval = setInterval(() => this.healthCheck(), 30000);\n  }\n\n  getServer() {\n    // Round-robin with health check\n    const healthyServers = this.servers.filter((server) => server.healthy);\n\n    if (healthyServers.length === 0) {\n      throw new Error("No healthy servers available");\n    }\n\n    const server = healthyServers[this.currentIndex % healthyServers.length];\n    this.currentIndex = (this.currentIndex + 1) % healthyServers.length;\n\n    return server;\n  }\n\n  async healthCheck() {\n    for (const server of this.servers) {\n      try {\n        const response = await fetch(\n          `http://${server.host}:${server.port}/health`\n        );\n        server.healthy = response.ok;\n      } catch (error) {\n        server.healthy = false;\n      }\n    }\n  }\n\n  connect(url) {\n    const server = this.getServer();\n    const serverUrl = `ws://${server.host}:${server.port}${url}`;\n\n    const socket = new WebSocket(serverUrl);\n\n    socket.addEventListener("open", () => {\n      server.connections++;\n    });\n\n    socket.addEventListener("close", () => {\n      server.connections--;\n    });\n\n    return socket;\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"message-compression-and-batching",children:"Message Compression and Batching"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class WebSocketOptimizer {\n  constructor(socket, options = {}) {\n    this.socket = socket;\n    this.batchSize = options.batchSize || 10;\n    this.batchTimeout = options.batchTimeout || 100;\n    this.compressionThreshold = options.compressionThreshold || 1024;\n    this.messageQueue = [];\n    this.batchTimer = null;\n  }\n\n  send(data) {\n    this.messageQueue.push({\n      data,\n      timestamp: Date.now(),\n    });\n\n    if (this.messageQueue.length >= this.batchSize) {\n      this.flush();\n    } else if (!this.batchTimer) {\n      this.batchTimer = setTimeout(() => this.flush(), this.batchTimeout);\n    }\n  }\n\n  flush() {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = null;\n    }\n\n    if (this.messageQueue.length === 0) return;\n\n    const messages = this.messageQueue.splice(0);\n\n    if (messages.length === 1) {\n      this.sendSingle(messages[0].data);\n    } else {\n      this.sendBatch(messages.map((m) => m.data));\n    }\n  }\n\n  sendSingle(data) {\n    const serialized = JSON.stringify(data);\n\n    if (serialized.length > this.compressionThreshold) {\n      this.sendCompressed(serialized);\n    } else {\n      this.socket.send(serialized);\n    }\n  }\n\n  sendBatch(messages) {\n    const batchMessage = {\n      type: "batch",\n      messages,\n      count: messages.length,\n    };\n\n    this.sendSingle(batchMessage);\n  }\n\n  async sendCompressed(data) {\n    try {\n      // Use compression (browser CompressionStream API)\n      const stream = new CompressionStream("gzip");\n      const writer = stream.writable.getWriter();\n      const reader = stream.readable.getReader();\n\n      writer.write(new TextEncoder().encode(data));\n      writer.close();\n\n      const chunks = [];\n      let done = false;\n\n      while (!done) {\n        const { value, done: readerDone } = await reader.read();\n        done = readerDone;\n        if (value) chunks.push(value);\n      }\n\n      const compressed = new Uint8Array(\n        chunks.reduce((acc, chunk) => acc + chunk.length, 0)\n      );\n\n      let offset = 0;\n      for (const chunk of chunks) {\n        compressed.set(chunk, offset);\n        offset += chunk.length;\n      }\n\n      this.socket.send(compressed);\n    } catch (error) {\n      console.warn("Compression failed, sending uncompressed:", error);\n      this.socket.send(data);\n    }\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"real-world-implementation-examples",children:"Real-World Implementation Examples"}),"\n",(0,o.jsx)(n.h3,{id:"real-time-chat-application",children:"Real-Time Chat Application"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class ChatApplication {\n  constructor() {\n    this.socket = null;\n    this.messages = [];\n    this.users = new Map();\n    this.currentRoom = null;\n    this.typing = new Set();\n  }\n\n  async connect(username, room) {\n    const socket = new WebSocketClient("ws://localhost:8080/chat");\n\n    socket.on("open", () => {\n      socket.send({\n        type: "join",\n        username,\n        room,\n      });\n    });\n\n    socket.on("message", (data) => {\n      this.handleMessage(data);\n    });\n\n    this.socket = socket;\n    await socket.connect();\n    this.currentRoom = room;\n  }\n\n  handleMessage(data) {\n    switch (data.type) {\n      case "message":\n        this.addMessage(data);\n        break;\n      case "userJoined":\n        this.addUser(data.user);\n        break;\n      case "userLeft":\n        this.removeUser(data.user);\n        break;\n      case "typing":\n        this.handleTyping(data);\n        break;\n      case "stopTyping":\n        this.handleStopTyping(data);\n        break;\n    }\n  }\n\n  sendMessage(content) {\n    const message = {\n      type: "message",\n      content,\n      room: this.currentRoom,\n      timestamp: Date.now(),\n    };\n\n    this.socket.send(message);\n  }\n\n  startTyping() {\n    this.socket.send({\n      type: "typing",\n      room: this.currentRoom,\n    });\n  }\n\n  stopTyping() {\n    this.socket.send({\n      type: "stopTyping",\n      room: this.currentRoom,\n    });\n  }\n\n  addMessage(message) {\n    this.messages.push(message);\n    this.renderMessage(message);\n  }\n\n  addUser(user) {\n    this.users.set(user.id, user);\n    this.updateUserList();\n  }\n\n  removeUser(user) {\n    this.users.delete(user.id);\n    this.updateUserList();\n  }\n\n  handleTyping(data) {\n    this.typing.add(data.user);\n    this.updateTypingIndicator();\n  }\n\n  handleStopTyping(data) {\n    this.typing.delete(data.user);\n    this.updateTypingIndicator();\n  }\n\n  renderMessage(message) {\n    const messagesContainer = document.getElementById("messages");\n    const messageElement = document.createElement("div");\n    messageElement.className = "message";\n    messageElement.innerHTML = `\n      <span class="username">${message.username}:</span>\n      <span class="content">${message.content}</span>\n      <span class="timestamp">${new Date(\n        message.timestamp\n      ).toLocaleTimeString()}</span>\n    `;\n    messagesContainer.appendChild(messageElement);\n    messagesContainer.scrollTop = messagesContainer.scrollHeight;\n  }\n\n  updateUserList() {\n    const userList = document.getElementById("userList");\n    userList.innerHTML = "";\n\n    this.users.forEach((user) => {\n      const userElement = document.createElement("div");\n      userElement.className = "user";\n      userElement.textContent = user.username;\n      userList.appendChild(userElement);\n    });\n  }\n\n  updateTypingIndicator() {\n    const indicator = document.getElementById("typingIndicator");\n\n    if (this.typing.size > 0) {\n      const users = Array.from(this.typing).join(", ");\n      indicator.textContent = `${users} ${\n        this.typing.size === 1 ? "is" : "are"\n      } typing...`;\n      indicator.style.display = "block";\n    } else {\n      indicator.style.display = "none";\n    }\n  }\n}\n\n// Initialize chat application\nconst chat = new ChatApplication();\n\ndocument.getElementById("joinButton").addEventListener("click", async () => {\n  const username = document.getElementById("username").value;\n  const room = document.getElementById("room").value;\n\n  if (username && room) {\n    await chat.connect(username, room);\n    document.getElementById("loginForm").style.display = "none";\n    document.getElementById("chatContainer").style.display = "block";\n  }\n});\n\ndocument.getElementById("messageInput").addEventListener("keypress", (e) => {\n  if (e.key === "Enter") {\n    const content = e.target.value.trim();\n    if (content) {\n      chat.sendMessage(content);\n      e.target.value = "";\n    }\n  }\n});\n\n// Typing indicators\nlet typingTimer;\ndocument.getElementById("messageInput").addEventListener("input", () => {\n  chat.startTyping();\n\n  clearTimeout(typingTimer);\n  typingTimer = setTimeout(() => {\n    chat.stopTyping();\n  }, 1000);\n});\n'})}),"\n",(0,o.jsx)(n.h2,{id:"error-handling-and-debugging",children:"Error Handling and Debugging"}),"\n",(0,o.jsx)(n.h3,{id:"comprehensive-error-handling",children:"Comprehensive Error Handling"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class WebSocketErrorHandler {\n  constructor(socket) {\n    this.socket = socket;\n    this.errorCounts = new Map();\n    this.setupErrorHandlers();\n  }\n\n  setupErrorHandlers() {\n    this.socket.addEventListener("error", (event) => {\n      this.handleError("connection", event);\n    });\n\n    this.socket.addEventListener("close", (event) => {\n      if (!event.wasClean) {\n        this.handleError("close", event);\n      }\n    });\n\n    // Catch message parsing errors\n    const originalOnMessage = this.socket.onmessage;\n    this.socket.onmessage = (event) => {\n      try {\n        if (originalOnMessage) {\n          originalOnMessage.call(this.socket, event);\n        }\n      } catch (error) {\n        this.handleError("message", error, event.data);\n      }\n    };\n  }\n\n  handleError(type, error, context = null) {\n    const errorInfo = {\n      type,\n      error: error.message || error.toString(),\n      timestamp: Date.now(),\n      context,\n      stack: error.stack,\n    };\n\n    // Track error frequency\n    const key = `${type}:${error.message}`;\n    this.errorCounts.set(key, (this.errorCounts.get(key) || 0) + 1);\n\n    // Log error\n    console.error("WebSocket error:", errorInfo);\n\n    // Report to error tracking service\n    this.reportError(errorInfo);\n\n    // Handle specific error types\n    switch (type) {\n      case "connection":\n        this.handleConnectionError(error);\n        break;\n      case "close":\n        this.handleCloseError(error);\n        break;\n      case "message":\n        this.handleMessageError(error, context);\n        break;\n    }\n  }\n\n  handleConnectionError(error) {\n    // Implement connection error recovery\n    console.log("Attempting to recover from connection error");\n  }\n\n  handleCloseError(event) {\n    const closeReasons = {\n      1000: "Normal closure",\n      1001: "Going away",\n      1002: "Protocol error",\n      1003: "Unsupported data",\n      1004: "Reserved",\n      1005: "No status received",\n      1006: "Abnormal closure",\n      1007: "Invalid frame payload data",\n      1008: "Policy violation",\n      1009: "Message too big",\n      1010: "Missing extension",\n      1011: "Internal error",\n      1015: "TLS handshake failure",\n    };\n\n    const reason = closeReasons[event.code] || "Unknown reason";\n    console.log(`Connection closed: ${event.code} - ${reason}`);\n  }\n\n  handleMessageError(error, data) {\n    console.error("Failed to process message:", data, error);\n  }\n\n  reportError(errorInfo) {\n    // Send to error tracking service\n    if (window.errorTracker) {\n      window.errorTracker.captureException(errorInfo);\n    }\n  }\n\n  getErrorStats() {\n    return Object.fromEntries(this.errorCounts);\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"websocket-debugging-tools",children:"WebSocket Debugging Tools"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'class WebSocketDebugger {\n  constructor(socket) {\n    this.socket = socket;\n    this.logs = [];\n    this.stats = {\n      messagesSent: 0,\n      messagesReceived: 0,\n      bytesSent: 0,\n      bytesReceived: 0,\n      connectTime: null,\n      lastActivity: null,\n    };\n\n    this.setupLogging();\n  }\n\n  setupLogging() {\n    const originalSend = this.socket.send.bind(this.socket);\n    this.socket.send = (data) => {\n      this.logMessage("sent", data);\n      this.stats.messagesSent++;\n      this.stats.bytesSent += this.getDataSize(data);\n      this.stats.lastActivity = Date.now();\n      return originalSend(data);\n    };\n\n    this.socket.addEventListener("open", (event) => {\n      this.stats.connectTime = Date.now();\n      this.logEvent("connected", event);\n    });\n\n    this.socket.addEventListener("message", (event) => {\n      this.logMessage("received", event.data);\n      this.stats.messagesReceived++;\n      this.stats.bytesReceived += this.getDataSize(event.data);\n      this.stats.lastActivity = Date.now();\n    });\n\n    this.socket.addEventListener("close", (event) => {\n      this.logEvent("closed", event);\n    });\n\n    this.socket.addEventListener("error", (event) => {\n      this.logEvent("error", event);\n    });\n  }\n\n  logMessage(direction, data) {\n    const entry = {\n      type: "message",\n      direction,\n      data: this.formatData(data),\n      size: this.getDataSize(data),\n      timestamp: Date.now(),\n    };\n\n    this.logs.push(entry);\n    this.trimLogs();\n\n    console.log(`WebSocket ${direction}:`, entry);\n  }\n\n  logEvent(type, event) {\n    const entry = {\n      type: "event",\n      event: type,\n      details: this.formatEvent(event),\n      timestamp: Date.now(),\n    };\n\n    this.logs.push(entry);\n    this.trimLogs();\n\n    console.log(`WebSocket ${type}:`, entry);\n  }\n\n  formatData(data) {\n    if (typeof data === "string") {\n      try {\n        return JSON.parse(data);\n      } catch {\n        return data;\n      }\n    }\n    return data;\n  }\n\n  formatEvent(event) {\n    return {\n      type: event.type,\n      code: event.code,\n      reason: event.reason,\n      wasClean: event.wasClean,\n    };\n  }\n\n  getDataSize(data) {\n    if (typeof data === "string") {\n      return new Blob([data]).size;\n    } else if (data instanceof ArrayBuffer) {\n      return data.byteLength;\n    } else if (data instanceof Blob) {\n      return data.size;\n    }\n    return 0;\n  }\n\n  trimLogs() {\n    if (this.logs.length > 1000) {\n      this.logs = this.logs.slice(-500);\n    }\n  }\n\n  exportLogs() {\n    return {\n      logs: this.logs,\n      stats: this.stats,\n      exportTime: Date.now(),\n    };\n  }\n\n  printStats() {\n    console.table(this.stats);\n  }\n}\n\n// Usage\nconst debugger = new WebSocketDebugger(socket);\n\n// Export logs for analysis\nconst logs = debugger.exportLogs();\nconsole.log("WebSocket debug data:", logs);\n'})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices-and-common-pitfalls",children:"Best Practices and Common Pitfalls"}),"\n",(0,o.jsx)(n.h3,{id:"connection-management-best-practices",children:"Connection Management Best Practices"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// \u2705 Good: Proper connection lifecycle management\nclass RobustWebSocketClient {\n  constructor(url, options = {}) {\n    this.url = url;\n    this.options = options;\n    this.socket = null;\n    this.reconnectEnabled = true;\n    this.eventListeners = new Map();\n  }\n\n  async connect() {\n    return new Promise((resolve, reject) => {\n      try {\n        this.socket = new WebSocket(this.url);\n\n        const timeout = setTimeout(() => {\n          this.socket.close();\n          reject(new Error("Connection timeout"));\n        }, 10000);\n\n        this.socket.onopen = () => {\n          clearTimeout(timeout);\n          resolve();\n        };\n\n        this.socket.onerror = (error) => {\n          clearTimeout(timeout);\n          reject(error);\n        };\n\n        this.setupEventHandlers();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  setupEventHandlers() {\n    this.socket.onclose = (event) => {\n      if (this.reconnectEnabled && !event.wasClean) {\n        this.handleReconnect();\n      }\n    };\n  }\n\n  disconnect() {\n    this.reconnectEnabled = false;\n    if (this.socket) {\n      this.socket.close(1000, "Normal closure");\n    }\n  }\n}\n\n// \u274c Bad: No error handling or connection management\nclass BadWebSocketClient {\n  constructor(url) {\n    this.socket = new WebSocket(url); // Can throw immediately\n    // No error handling, no reconnection logic\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"message-handling-best-practices",children:"Message Handling Best Practices"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// \u2705 Good: Structured message handling with validation\nclass MessageHandler {\n  constructor() {\n    this.handlers = new Map();\n    this.middleware = [];\n  }\n\n  addHandler(type, handler) {\n    this.handlers.set(type, handler);\n  }\n\n  async processMessage(rawData) {\n    try {\n      let message = this.parseMessage(rawData);\n\n      // Apply middleware\n      for (const middleware of this.middleware) {\n        message = await middleware(message);\n        if (!message) return; // Middleware rejected message\n      }\n\n      // Validate message structure\n      if (!this.validateMessage(message)) {\n        throw new Error("Invalid message structure");\n      }\n\n      // Handle message\n      const handler = this.handlers.get(message.type);\n      if (handler) {\n        await handler(message);\n      } else {\n        console.warn(`No handler for message type: ${message.type}`);\n      }\n    } catch (error) {\n      console.error("Message processing error:", error);\n    }\n  }\n\n  parseMessage(data) {\n    if (typeof data === "string") {\n      return JSON.parse(data);\n    }\n    return data;\n  }\n\n  validateMessage(message) {\n    return message && typeof message.type === "string";\n  }\n}\n\n// \u274c Bad: No error handling or validation\nclass BadMessageHandler {\n  handleMessage(data) {\n    const message = JSON.parse(data); // Can throw\n    this.handlers[message.type](message); // Can be undefined\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"performance-optimization-tips",children:"Performance Optimization Tips"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// \u2705 Good: Efficient message batching and throttling\nclass OptimizedWebSocket {\n  constructor(socket) {\n    this.socket = socket;\n    this.messageQueue = [];\n    this.batchTimer = null;\n    this.lastSend = 0;\n    this.minInterval = 16; // ~60fps\n  }\n\n  send(data) {\n    const now = Date.now();\n\n    if (now - this.lastSend < this.minInterval) {\n      // Batch messages to avoid flooding\n      this.messageQueue.push(data);\n      this.scheduleBatch();\n    } else {\n      this.sendImmediate(data);\n    }\n  }\n\n  sendImmediate(data) {\n    this.socket.send(JSON.stringify(data));\n    this.lastSend = Date.now();\n  }\n\n  scheduleBatch() {\n    if (!this.batchTimer) {\n      this.batchTimer = setTimeout(() => {\n        this.flushBatch();\n      }, this.minInterval);\n    }\n  }\n\n  flushBatch() {\n    if (this.messageQueue.length > 0) {\n      const batch = {\n        type: "batch",\n        messages: this.messageQueue.splice(0),\n      };\n      this.sendImmediate(batch);\n    }\n    this.batchTimer = null;\n  }\n}\n\n// \u274c Bad: Sending messages without any throttling\nclass BadWebSocket {\n  send(data) {\n    this.socket.send(JSON.stringify(data)); // Can flood the connection\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"WebSockets provide a powerful foundation for real-time web applications, enabling efficient bidirectional communication between clients and servers. Understanding the underlying protocol, from the initial HTTP handshake to frame-level communication, is crucial for building robust applications."}),"\n",(0,o.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Protocol Understanding"}),": The WebSocket handshake process and frame structure enable efficient real-time communication while maintaining compatibility with existing web infrastructure."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Connection Management"}),": Proper connection lifecycle management, including reconnection strategies and heartbeat mechanisms, ensures reliable real-time communication."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Security Considerations"}),": Implementing proper authentication, rate limiting, and using secure connections (WSS) is essential for production applications."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Performance Optimization"}),": Message batching, compression, and efficient connection pooling can significantly improve application performance."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Error Handling"}),": Comprehensive error handling and debugging tools are crucial for maintaining stable WebSocket connections in production environments."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"future-considerations",children:"Future Considerations"}),"\n",(0,o.jsx)(n.p,{children:"WebSocket technology continues to evolve with new standards like WebTransport providing enhanced capabilities for specific use cases. However, WebSockets remain the standard choice for most real-time web applications due to their widespread support and proven reliability."}),"\n",(0,o.jsx)(n.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API",children:"WebSocket API Documentation"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc6455",children:"RFC 6455 - The WebSocket Protocol"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers",children:"WebSocket Security Considerations"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://socket.io/docs/",children:"Socket.IO Documentation"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebTransport",children:"WebTransport API"})}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The WebSocket ecosystem continues to grow with libraries and frameworks that simplify development while providing advanced features like automatic reconnection, room management, and scaling solutions for production applications."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var s=t(6540);const o={},a=s.createContext(o);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);