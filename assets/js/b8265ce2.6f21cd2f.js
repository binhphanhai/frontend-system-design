"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5640],{3492:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"project-detail/simple-interpreter","title":"Simple Interpreter: Vietnamese Programming Language Cheatsheet","description":"Table of Contents","source":"@site/docs/project-detail/simple-interpreter.md","sourceDirName":"project-detail","slug":"/project-detail/simple-interpreter","permalink":"/frontend-system-design/docs/project-detail/simple-interpreter","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/simple-interpreter.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Single-SPA: Microfrontend Framework","permalink":"/frontend-system-design/docs/project-detail/single-spa"}}');var i=r(4848),s=r(8453);const a={},o="Simple Interpreter: Vietnamese Programming Language Cheatsheet",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Project Overview",id:"project-overview",level:2},{value:"Technology Stack",id:"technology-stack",level:3},{value:"Project Structure",id:"project-structure",level:3},{value:"Interpreter Architecture",id:"interpreter-architecture",level:2},{value:"Three-Phase Compilation Pipeline",id:"three-phase-compilation-pipeline",level:3},{value:"Component Relationships",id:"component-relationships",level:3},{value:"Lexical Analysis (Tokenization)",id:"lexical-analysis-tokenization",level:2},{value:"Token Definition System",id:"token-definition-system",level:3},{value:"Lexer Implementation",id:"lexer-implementation",level:3},{value:"Parsing and AST Generation",id:"parsing-and-ast-generation",level:2},{value:"AST Node Definitions",id:"ast-node-definitions",level:3},{value:"Parser Implementation",id:"parser-implementation",level:3},{value:"Interpreter Execution",id:"interpreter-execution",level:2},{value:"Visitor Pattern for AST Traversal",id:"visitor-pattern-for-ast-traversal",level:3},{value:"Language Features",id:"language-features",level:2},{value:"Example Programs",id:"example-programs",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Memory Management",id:"memory-management",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Browser Integration",id:"browser-integration",level:2},{value:"Web Integration Layer",id:"web-integration-layer",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Code Organization",id:"code-organization",level:3},{value:"Testing Strategy",id:"testing-strategy",level:3},{value:"Conclusion",id:"conclusion",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"simple-interpreter-vietnamese-programming-language-cheatsheet",children:"Simple Interpreter: Vietnamese Programming Language Cheatsheet"})}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#project-overview",children:"Project Overview"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#interpreter-architecture",children:"Interpreter Architecture"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#lexical-analysis-tokenization",children:"Lexical Analysis (Tokenization)"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#parsing-and-ast-generation",children:"Parsing and AST Generation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#interpreter-execution",children:"Interpreter Execution"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#language-features",children:"Language Features"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#implementation-details",children:"Implementation Details"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#browser-integration",children:"Browser Integration"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Vietnamese programming language interpreter (Next.js + TypeScript)"}),"\n",(0,i.jsx)(n.li,{children:"Runs fully in browser (client-side)"}),"\n",(0,i.jsxs)(n.li,{children:["Based on ",(0,i.jsx)(n.a,{href:"https://github.com/binhphanhai/newbie-interpreter",children:"newbie-interpreter GitHub"})]}),"\n",(0,i.jsx)(n.li,{children:"Features: interactive code editor, real-time execution"}),"\n",(0,i.jsxs)(n.li,{children:["Goals:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Educational: Show interpreter construction"}),"\n",(0,i.jsx)(n.li,{children:"Accessible: Vietnamese keywords"}),"\n",(0,i.jsx)(n.li,{children:"Interactive: Real-time browser execution"}),"\n",(0,i.jsx)(n.li,{children:"Portable: No server needed"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"project-overview",children:"Project Overview"}),"\n",(0,i.jsx)(n.h3,{id:"technology-stack",children:"Technology Stack"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Next.js + TypeScript frontend"}),"\n",(0,i.jsx)(n.li,{children:"React components + CSS modules"}),"\n",(0,i.jsx)(n.li,{children:"Static export (GitHub Pages)"}),"\n",(0,i.jsxs)(n.li,{children:["Interpreter core:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Lexer: TypeScript tokenization"}),"\n",(0,i.jsx)(n.li,{children:"Parser: Recursive descent"}),"\n",(0,i.jsx)(n.li,{children:"AST: Abstract Syntax Tree"}),"\n",(0,i.jsx)(n.li,{children:"Executor: Tree-walking interpreter"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// Project configuration from package.json perspective\r\n// This object maps out the entire technical ecosystem of the interpreter\r\nconst projectStack = {\r\n  // Frontend framework choice - Next.js provides excellent developer experience\r\n  // with built-in TypeScript support and optimized bundling\r\n  frontend: "Next.js with TypeScript",\r\n\r\n  // UI layer - React components with CSS modules for scoped styling\r\n  // CSS modules prevent style conflicts and improve maintainability\r\n  ui: "React components with CSS modules",\r\n\r\n  // Deployment strategy - Static export enables hosting on GitHub Pages\r\n  // No server required, making the interpreter fully client-side\r\n  deployment: "Static export for GitHub Pages",\r\n\r\n  // Core interpreter components - each serves a specific role in the compilation pipeline\r\n  interpreter: {\r\n    // Lexer: Converts raw text into meaningful tokens (words, operators, etc.)\r\n    lexer: "TypeScript-based tokenization",\r\n\r\n    // Parser: Builds a tree structure (AST) from the stream of tokens\r\n    // Uses recursive descent parsing for readable and maintainable code\r\n    parser: "Recursive descent parser",\r\n\r\n    // AST: Intermediate representation that captures program structure\r\n    // Makes it easy to traverse and manipulate the program before execution\r\n    ast: "Abstract Syntax Tree representation",\r\n\r\n    // Executor: Walks through the AST and actually runs the program\r\n    // Tree-walking is simple to implement and debug\r\n    executor: "Tree-walking interpreter",\r\n  },\r\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"project-structure",children:"Project Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"newbie-interpreter/\r\n\u251c\u2500\u2500 component/          # React UI components\r\n\u251c\u2500\u2500 helper/            # Core interpreter logic \u2b50\r\n\u2502   \u251c\u2500\u2500 lexer.ts       # Tokenization\r\n\u2502   \u251c\u2500\u2500 parser.ts      # AST generation\r\n\u2502   \u251c\u2500\u2500 ast.ts         # AST node definitions\r\n\u2502   \u2514\u2500\u2500 interpreter.ts # Execution engine\r\n\u251c\u2500\u2500 examples/          # Sample programs\r\n\u251c\u2500\u2500 pages/            # Next.js pages\r\n\u2514\u2500\u2500 public/           # Static assets\n"})}),"\n",(0,i.jsx)(n.h2,{id:"interpreter-architecture",children:"Interpreter Architecture"}),"\n",(0,i.jsx)(n.h3,{id:"three-phase-compilation-pipeline",children:"Three-Phase Compilation Pipeline"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Lexical Analysis: Text \u2192 Tokens"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Syntax Analysis: Tokens \u2192 AST"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"Execution: AST \u2192 Results"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:'Input: Vietnamese code string (e.g. "g\xe1n a = 10")'}),"\n",(0,i.jsx)(n.li,{children:"Output: Program output + variable states"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Simplified interpreter pipeline\r\n// This class orchestrates the entire interpretation process from source code to execution\r\nclass InterpreterPipeline {\r\n  constructor() {\r\n    // Initialize the three core components of the interpreter\r\n    // Each component handles a specific phase of the compilation process\r\n    this.lexer = new Lexer(); // Phase 1: Text \u2192 Tokens\r\n    this.parser = new Parser(); // Phase 2: Tokens \u2192 AST\r\n    this.interpreter = new Interpreter(); // Phase 3: AST \u2192 Results\r\n  }\r\n\r\n  execute(sourceCode) {\r\n    // Phase 1: Lexical Analysis (Text \u2192 Tokens)\r\n    // Convert raw Vietnamese text into a stream of meaningful tokens\r\n    // Example: \"g\xe1n a = 10\" becomes [GAN, IDENTIFIER(a), ASSIGN, NUMBER(10)]\r\n    const tokens = this.lexer.tokenize(sourceCode);\r\n\r\n    // Phase 2: Syntax Analysis (Tokens \u2192 AST)\r\n    // Build an Abstract Syntax Tree that represents the program's structure\r\n    // This validates syntax and creates a tree-like representation of the code\r\n    const ast = this.parser.parse(tokens);\r\n\r\n    // Phase 3: Execution (AST \u2192 Result)\r\n    // Walk through the AST and actually execute the program\r\n    // Variables are stored, expressions are evaluated, and output is generated\r\n    const result = this.interpreter.evaluate(ast);\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\n// Example Vietnamese code execution\r\n// This demonstrates a simple program with variable assignment and arithmetic\r\nconst code = `\r\ng\xe1n a = 10    // Assign value 10 to variable 'a'\r\ng\xe1n b = 20    // Assign value 20 to variable 'b'\r\nin (a + b)    // Print the sum of a and b (should output 30)\r\n`;\r\n\r\n// Create interpreter instance and execute the Vietnamese code\r\nconst interpreter = new InterpreterPipeline();\r\nconst output = interpreter.execute(code); // \u2192 30\r\n\r\n// The execution flow:\r\n// 1. Lexer converts text into tokens: [GAN, IDENTIFIER(a), ASSIGN, NUMBER(10), ...]\r\n// 2. Parser builds AST with assignment and print statement nodes\r\n// 3. Interpreter executes: creates variables a=10, b=20, then prints 30\n"})}),"\n",(0,i.jsx)(n.h3,{id:"component-relationships",children:"Component Relationships"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Data flow: Source code \u2192 Lexer \u2192 Parser \u2192 Interpreter"}),"\n",(0,i.jsx)(n.li,{children:"Lexer: Text \u2192 Token stream (keywords, operators, etc.)"}),"\n",(0,i.jsx)(n.li,{children:"Parser: Token stream \u2192 AST (program structure)"}),"\n",(0,i.jsx)(n.li,{children:"Interpreter: AST \u2192 Execution result (output, variables)"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// Interpreter component architecture\r\n// This object defines the clear separation of concerns and data flow between components\r\nconst interpreterArchitecture = {\r\n  // Starting point: Vietnamese source code as plain text\r\n  input: "Vietnamese source code",\r\n\r\n  // LEXER COMPONENT: First phase of interpretation\r\n  lexer: {\r\n    // Takes raw Vietnamese text character by character\r\n    input: "Raw text",\r\n\r\n    // Produces a sequence of tokens (keywords, operators, literals, etc.)\r\n    // Example: "g\xe1n x = 5" \u2192 [GAN_TOKEN, IDENTIFIER_TOKEN(x), ASSIGN_TOKEN, NUMBER_TOKEN(5)]\r\n    output: "Token stream",\r\n\r\n    // Primary job: Convert text into meaningful symbols that the parser can understand\r\n    // Handles: keyword recognition, string parsing, number parsing, operator detection\r\n    responsibility: "Character-by-character analysis",\r\n  },\r\n\r\n  // PARSER COMPONENT: Second phase of interpretation\r\n  parser: {\r\n    // Consumes the stream of tokens produced by the lexer\r\n    input: "Token stream",\r\n\r\n    // Builds a hierarchical tree structure representing program logic\r\n    // Each node represents a language construct (statement, expression, etc.)\r\n    output: "Abstract Syntax Tree",\r\n\r\n    // Primary job: Ensure syntax is correct and build meaningful program structure\r\n    // Handles: Grammar validation, precedence rules, AST node creation\r\n    responsibility: "Syntax validation and structure building",\r\n  },\r\n\r\n  // INTERPRETER COMPONENT: Third phase of interpretation\r\n  interpreter: {\r\n    // Works with the structured AST built by the parser\r\n    input: "Abstract Syntax Tree",\r\n\r\n    // Produces actual program results: printed output, variable values, etc.\r\n    // Example: Final result might be { output: ["30"], variables: {a: 10, b: 20} }\r\n    output: "Execution result",\r\n\r\n    // Primary job: Actually run the program by walking through the AST\r\n    // Handles: Variable storage, expression evaluation, statement execution\r\n    responsibility: "Tree traversal and evaluation",\r\n  },\r\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"lexical-analysis-tokenization",children:"Lexical Analysis (Tokenization)"}),"\n",(0,i.jsx)(n.h3,{id:"token-definition-system",children:"Token Definition System"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Enum for all token types (literals, identifiers, keywords, operators, delimiters, special)"}),"\n",(0,i.jsx)(n.li,{children:"Token interface: type, value, line, column"}),"\n",(0,i.jsx)(n.li,{children:'Example: "g\xe1n x = 10" \u2192 [GAN, IDENTIFIER(x), ASSIGN, NUMBER(10)]'}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Token types for Vietnamese programming language\r\n// This enum defines every possible type of token our lexer can recognize\r\nenum TokenType {\r\n  // LITERALS: Raw values that appear directly in code\r\n  NUMBER = "NUMBER", // Numeric literals: 42, 3.14, -7\r\n  STRING = "STRING", // Text literals: "Xin ch\xe0o", "Hello World"\r\n  BOOLEAN = "BOOLEAN", // Boolean literals: \u0111\xfang (true), sai (false)\r\n\r\n  // IDENTIFIERS: User-defined names for variables, functions, etc.\r\n  IDENTIFIER = "IDENTIFIER", // Variable names: myVar, userName, t\u1ed5ng\r\n\r\n  // KEYWORDS (Vietnamese): Reserved words that have special meaning\r\n  GAN = "GAN", // g\xe1n (assign) - for variable assignment\r\n  NEU = "NEU", // n\u1ebfu (if) - conditional statements\r\n  KHAC = "KHAC", // kh\xe1c (else) - alternative branch in conditionals\r\n  LAP = "LAP", // l\u1eb7p (loop) - for iteration constructs\r\n  HAM = "HAM", // h\xe0m (function) - function definitions\r\n  TRA_VE = "TRA_VE", // tr\u1ea3 v\u1ec1 (return) - return statements\r\n  IN = "IN", // in (print) - output statements\r\n\r\n  // OPERATORS: Symbols that perform operations on values\r\n  PLUS = "PLUS", // + (addition or string concatenation)\r\n  MINUS = "MINUS", // - (subtraction or negation)\r\n  MULTIPLY = "MULTIPLY", // * (multiplication)\r\n  DIVIDE = "DIVIDE", // / (division)\r\n  ASSIGN = "ASSIGN", // = (assignment operator)\r\n  EQUAL = "EQUAL", // == (equality comparison)\r\n  NOT_EQUAL = "NOT_EQUAL", // != (inequality comparison)\r\n\r\n  // DELIMITERS: Symbols that structure and separate code elements\r\n  LPAREN = "LPAREN", // ( (left parenthesis - grouping, function calls)\r\n  RPAREN = "RPAREN", // ) (right parenthesis)\r\n  LBRACE = "LBRACE", // { (left brace - code blocks)\r\n  RBRACE = "RBRACE", // } (right brace)\r\n  SEMICOLON = "SEMICOLON", // ; (statement terminator)\r\n  NEWLINE = "NEWLINE", // \\n (line breaks - statement separators)\r\n\r\n  // SPECIAL: Control tokens for parsing state\r\n  EOF = "EOF", // End of file marker - signals completion\r\n}\r\n\r\n// Token interface: Structure that holds token information\r\n// Every token created by the lexer must conform to this interface\r\ninterface Token {\r\n  type: TokenType; // What kind of token this is (from enum above)\r\n  value: string; // The actual text content (e.g., "g\xe1n", "42", "myVar")\r\n  line: number; // Line number where token appears (1-based)\r\n  column: number; // Column position where token starts (1-based)\r\n}\r\n\r\n// Example tokens that would be created:\r\n// Input: "g\xe1n x = 10"\r\n// Tokens: [\r\n//   { type: TokenType.GAN, value: "g\xe1n", line: 1, column: 1 },\r\n//   { type: TokenType.IDENTIFIER, value: "x", line: 1, column: 5 },\r\n//   { type: TokenType.ASSIGN, value: "=", line: 1, column: 7 },\r\n//   { type: TokenType.NUMBER, value: "10", line: 1, column: 9 }\r\n// ]\n'})}),"\n",(0,i.jsx)(n.h3,{id:"lexer-implementation",children:"Lexer Implementation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Converts Vietnamese code to tokens (character by character)"}),"\n",(0,i.jsx)(n.li,{children:"Tracks line/column for errors"}),"\n",(0,i.jsx)(n.li,{children:"Handles Unicode, escape sequences, whitespace, comments, lookahead"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'class Lexer {\r\n  // Core state variables for tracking position in the source code\r\n  private text: string; // The complete source code being tokenized\r\n  private position: number; // Current character index (0-based)\r\n  private currentChar: string | null; // Character at current position (null if EOF)\r\n  private line: number; // Current line number (1-based for human-readable errors)\r\n  private column: number; // Current column position (1-based)\r\n\r\n  constructor(text: string) {\r\n    // Initialize lexer with source code\r\n    this.text = text;\r\n    this.position = 0;\r\n\r\n    // Set current character to first character, or null if empty string\r\n    this.currentChar = this.text[0] || null;\r\n\r\n    // Start position tracking at line 1, column 1 (human-readable coordinates)\r\n    this.line = 1;\r\n    this.column = 1;\r\n  }\r\n\r\n  // CHARACTER NAVIGATION METHODS\r\n  // These methods handle moving through the source code while maintaining position tracking\r\n\r\n  private advance(): void {\r\n    // Move to the next character in the source code\r\n    // This method is crucial for maintaining accurate line/column tracking\r\n\r\n    if (this.currentChar === "\\n") {\r\n      // When encountering a newline, increment line and reset column\r\n      this.line++;\r\n      this.column = 1;\r\n    } else {\r\n      // For any other character, just move to the next column\r\n      this.column++;\r\n    }\r\n\r\n    // Move to next position in the source code\r\n    this.position++;\r\n\r\n    // Update currentChar to the new character, or null if we\'ve reached the end\r\n    this.currentChar =\r\n      this.position < this.text.length ? this.text[this.position] : null;\r\n  }\r\n\r\n  private peek(): string | null {\r\n    // Look at the next character without advancing position\r\n    // This is essential for recognizing multi-character operators like "==" and "!="\r\n    const peekPos = this.position + 1;\r\n    return peekPos < this.text.length ? this.text[peekPos] : null;\r\n  }\r\n\r\n  // WHITESPACE AND COMMENT HANDLING\r\n  // These methods skip over characters that don\'t contribute to the program logic\r\n\r\n  private skipWhitespace(): void {\r\n    // Skip over spaces, tabs, and other whitespace characters\r\n    // NOTE: We preserve newlines because they can be significant in our language\r\n    while (\r\n      this.currentChar &&\r\n      /\\s/.test(this.currentChar) && // Match any whitespace character\r\n      this.currentChar !== "\\n" // But preserve newlines for statement separation\r\n    ) {\r\n      this.advance();\r\n    }\r\n  }\r\n\r\n  private skipComment(): void {\r\n    // Handle single-line comments that start with "//"\r\n    // Comments extend to the end of the line and are completely ignored\r\n    if (this.currentChar === "/" && this.peek() === "/") {\r\n      // Skip the entire comment line\r\n      while (this.currentChar && this.currentChar !== "\\n") {\r\n        this.advance();\r\n      }\r\n      // Note: The newline character is left for the main tokenizer to handle\r\n    }\r\n  }\r\n\r\n  // TOKEN CONSTRUCTION METHODS\r\n  // These methods build specific types of tokens from character sequences\r\n\r\n  private readNumber(): Token {\r\n    // Parse numeric literals (integers and floating-point numbers)\r\n    // Examples: 42, 3.14, 0, 999.999\r\n    const start = { line: this.line, column: this.column };\r\n    let value = "";\r\n\r\n    // Keep reading digits and decimal points\r\n    while (this.currentChar && /[\\d.]/.test(this.currentChar)) {\r\n      value += this.currentChar;\r\n      this.advance();\r\n    }\r\n\r\n    // Return the complete number token with position information\r\n    return {\r\n      type: TokenType.NUMBER,\r\n      value, // String representation: "42", "3.14"\r\n      line: start.line, // Line where number starts\r\n      column: start.column, // Column where number starts\r\n    };\r\n  }\r\n\r\n  private readString(): Token {\r\n    // Parse string literals enclosed in double quotes\r\n    // Supports escape sequences for special characters\r\n    // Examples: "Hello", "Xin ch\xe0o", "Line 1\\nLine 2"\r\n    const start = { line: this.line, column: this.column };\r\n    let value = "";\r\n\r\n    this.advance(); // Skip opening quote character\r\n\r\n    // Read characters until we find the closing quote\r\n    while (this.currentChar && this.currentChar !== \'"\') {\r\n      if (this.currentChar === "\\\\") {\r\n        // Handle escape sequences (backslash followed by special character)\r\n        this.advance(); // Skip the backslash\r\n\r\n        // Process the escaped character\r\n        switch (this.currentChar) {\r\n          case "n":\r\n            value += "\\n"; // \\n becomes actual newline\r\n            break;\r\n          case "t":\r\n            value += "\\t"; // \\t becomes actual tab\r\n            break;\r\n          case "\\\\":\r\n            value += "\\\\"; // \\\\ becomes single backslash\r\n            break;\r\n          case \'"\':\r\n            value += \'"\'; // \\" becomes literal quote mark\r\n            break;\r\n          default:\r\n            // For unknown escape sequences, include the character as-is\r\n            value += this.currentChar;\r\n        }\r\n      } else {\r\n        // Regular character - add directly to string value\r\n        value += this.currentChar;\r\n      }\r\n      this.advance();\r\n    }\r\n\r\n    this.advance(); // Skip closing quote character\r\n\r\n    return {\r\n      type: TokenType.STRING,\r\n      value, // Processed string content (escape sequences resolved)\r\n      line: start.line,\r\n      column: start.column,\r\n    };\r\n  }\r\n\r\n  private readIdentifier(): Token {\r\n    // Parse identifiers and Vietnamese keywords\r\n    // Supports Vietnamese Unicode characters, which is crucial for our language\r\n    // Examples: myVar, userName, t\u1ed5ng, g\xe1n, n\u1ebfu, kh\xe1c\r\n    const start = { line: this.line, column: this.column };\r\n    let value = "";\r\n\r\n    // Read all valid identifier characters\r\n    // Regex includes: a-z, A-Z, Vietnamese characters (\xc0-\u1ef9), digits (0-9), underscore (_)\r\n    while (this.currentChar && /[a-zA-Z\xc0-\u1ef90-9_]/.test(this.currentChar)) {\r\n      value += this.currentChar;\r\n      this.advance();\r\n    }\r\n\r\n    // VIETNAMESE KEYWORD RECOGNITION\r\n    // Check if the identifier is actually a reserved Vietnamese keyword\r\n    const keywordMap = new Map([\r\n      ["g\xe1n", TokenType.GAN], // Assignment keyword\r\n      ["n\u1ebfu", TokenType.NEU], // If conditional keyword\r\n      ["kh\xe1c", TokenType.KHAC], // Else keyword\r\n      ["l\u1eb7p", TokenType.LAP], // Loop keyword\r\n      ["h\xe0m", TokenType.HAM], // Function keyword\r\n      ["tr\u1ea3_v\u1ec1", TokenType.TRA_VE], // Return keyword\r\n      ["in", TokenType.IN], // Print/output keyword\r\n      ["\u0111\xfang", TokenType.BOOLEAN], // Boolean true keyword\r\n      ["sai", TokenType.BOOLEAN], // Boolean false keyword\r\n    ]);\r\n\r\n    // Determine token type: keyword if found in map, otherwise it\'s an identifier\r\n    const tokenType = keywordMap.get(value) || TokenType.IDENTIFIER;\r\n\r\n    return {\r\n      type: tokenType,\r\n      value, // The actual text: "g\xe1n", "myVar", etc.\r\n      line: start.line,\r\n      column: start.column,\r\n    };\r\n  }\r\n\r\n  // Main tokenization method\r\n  public tokenize(): Token[] {\r\n    const tokens: Token[] = [];\r\n\r\n    while (this.currentChar) {\r\n      this.skipWhitespace();\r\n\r\n      if (!this.currentChar) break;\r\n\r\n      // Handle newlines\r\n      if (this.currentChar === "\\n") {\r\n        tokens.push({\r\n          type: TokenType.NEWLINE,\r\n          value: "\\n",\r\n          line: this.line,\r\n          column: this.column,\r\n        });\r\n        this.advance();\r\n        continue;\r\n      }\r\n\r\n      // Handle comments\r\n      if (this.currentChar === "/" && this.peek() === "/") {\r\n        this.skipComment();\r\n        continue;\r\n      }\r\n\r\n      // Handle numbers\r\n      if (/\\d/.test(this.currentChar)) {\r\n        tokens.push(this.readNumber());\r\n        continue;\r\n      }\r\n\r\n      // Handle strings\r\n      if (this.currentChar === \'"\') {\r\n        tokens.push(this.readString());\r\n        continue;\r\n      }\r\n\r\n      // Handle identifiers and keywords\r\n      if (/[a-zA-Z\xc0-\u1ef9_]/.test(this.currentChar)) {\r\n        tokens.push(this.readIdentifier());\r\n        continue;\r\n      }\r\n\r\n      // Handle operators and delimiters\r\n      const char = this.currentChar;\r\n      const nextChar = this.peek();\r\n\r\n      switch (char) {\r\n        case "+":\r\n          tokens.push({\r\n            type: TokenType.PLUS,\r\n            value: "+",\r\n            line: this.line,\r\n            column: this.column,\r\n          });\r\n          this.advance();\r\n          break;\r\n        case "-":\r\n          tokens.push({\r\n            type: TokenType.MINUS,\r\n            value: "-",\r\n            line: this.line,\r\n            column: this.column,\r\n          });\r\n          this.advance();\r\n          break;\r\n        case "*":\r\n          tokens.push({\r\n            type: TokenType.MULTIPLY,\r\n            value: "*",\r\n            line: this.line,\r\n            column: this.column,\r\n          });\r\n          this.advance();\r\n          break;\r\n        case "/":\r\n          tokens.push({\r\n            type: TokenType.DIVIDE,\r\n            value: "/",\r\n            line: this.line,\r\n            column: this.column,\r\n          });\r\n          this.advance();\r\n          break;\r\n        case "=":\r\n          if (nextChar === "=") {\r\n            tokens.push({\r\n              type: TokenType.EQUAL,\r\n              value: "==",\r\n              line: this.line,\r\n              column: this.column,\r\n            });\r\n            this.advance();\r\n            this.advance();\r\n          } else {\r\n            tokens.push({\r\n              type: TokenType.ASSIGN,\r\n              value: "=",\r\n              line: this.line,\r\n              column: this.column,\r\n            });\r\n            this.advance();\r\n          }\r\n          break;\r\n        case "!":\r\n          if (nextChar === "=") {\r\n            tokens.push({\r\n              type: TokenType.NOT_EQUAL,\r\n              value: "!=",\r\n              line: this.line,\r\n              column: this.column,\r\n            });\r\n            this.advance();\r\n            this.advance();\r\n          } else {\r\n            throw new Error(\r\n              `Unexpected character: ${char} at line ${this.line}, column ${this.column}`\r\n            );\r\n          }\r\n          break;\r\n        case "(":\r\n          tokens.push({\r\n            type: TokenType.LPAREN,\r\n            value: "(",\r\n            line: this.line,\r\n            column: this.column,\r\n          });\r\n          this.advance();\r\n          break;\r\n        case ")":\r\n          tokens.push({\r\n            type: TokenType.RPAREN,\r\n            value: ")",\r\n            line: this.line,\r\n            column: this.column,\r\n          });\r\n          this.advance();\r\n          break;\r\n        case "{":\r\n          tokens.push({\r\n            type: TokenType.LBRACE,\r\n            value: "{",\r\n            line: this.line,\r\n            column: this.column,\r\n          });\r\n          this.advance();\r\n          break;\r\n        case "}":\r\n          tokens.push({\r\n            type: TokenType.RBRACE,\r\n            value: "}",\r\n            line: this.line,\r\n            column: this.column,\r\n          });\r\n          this.advance();\r\n          break;\r\n        case ";":\r\n          tokens.push({\r\n            type: TokenType.SEMICOLON,\r\n            value: ";",\r\n            line: this.line,\r\n            column: this.column,\r\n          });\r\n          this.advance();\r\n          break;\r\n        default:\r\n          throw new Error(\r\n            `Unexpected character: ${char} at line ${this.line}, column ${this.column}`\r\n          );\r\n      }\r\n    }\r\n\r\n    tokens.push({\r\n      type: TokenType.EOF,\r\n      value: "",\r\n      line: this.line,\r\n      column: this.column,\r\n    });\r\n\r\n    return tokens;\r\n  }\r\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"parsing-and-ast-generation",children:"Parsing and AST Generation"}),"\n",(0,i.jsx)(n.h3,{id:"ast-node-definitions",children:"AST Node Definitions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"AST = tree structure for program"}),"\n",(0,i.jsx)(n.li,{children:"Node types: NumberLiteral, StringLiteral, BooleanLiteral, Identifier, BinaryExpression, AssignmentStatement, PrintStatement, IfStatement, Program"}),"\n",(0,i.jsx)(n.li,{children:"Uses Visitor pattern for traversal"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// ABSTRACT BASE CLASS FOR ALL AST NODES\r\n// This ensures all nodes can be visited by the interpreter using the visitor pattern\r\nabstract class ASTNode {\r\n  // Every AST node must implement the accept method for visitor pattern\r\n  // This allows different visitors (interpreter, pretty-printer, etc.) to process nodes\r\n  abstract accept<T>(visitor: ASTVisitor<T>): T;\r\n}\r\n\r\n// EXPRESSION NODES\r\n// These represent values and computations that produce results\r\n\r\nclass NumberLiteral extends ASTNode {\r\n  constructor(public value: number) {\r\n    // Store the actual numeric value (e.g., 42, 3.14)\r\n    super();\r\n  }\r\n\r\n  accept<T>(visitor: ASTVisitor<T>): T {\r\n    // Delegate to visitor\'s number literal handler\r\n    return visitor.visitNumberLiteral(this);\r\n  }\r\n}\r\n\r\nclass StringLiteral extends ASTNode {\r\n  constructor(public value: string) {\r\n    // Store string content (e.g., "Hello", "Xin ch\xe0o")\r\n    super();\r\n  }\r\n\r\n  accept<T>(visitor: ASTVisitor<T>): T {\r\n    return visitor.visitStringLiteral(this);\r\n  }\r\n}\r\n\r\nclass BooleanLiteral extends ASTNode {\r\n  constructor(public value: boolean) {\r\n    // Store true/false value (\u0111\xfang/sai in Vietnamese)\r\n    super();\r\n  }\r\n\r\n  accept<T>(visitor: ASTVisitor<T>): T {\r\n    return visitor.visitBooleanLiteral(this);\r\n  }\r\n}\r\n\r\nclass Identifier extends ASTNode {\r\n  constructor(public name: string) {\r\n    // Store variable name (e.g., "x", "userName", "t\u1ed5ng")\r\n    super();\r\n  }\r\n\r\n  accept<T>(visitor: ASTVisitor<T>): T {\r\n    return visitor.visitIdentifier(this);\r\n  }\r\n}\r\n\r\nclass BinaryExpression extends ASTNode {\r\n  constructor(\r\n    public left: ASTNode, // Left operand (can be any expression)\r\n    public operator: Token, // Operator token (+, -, *, /, ==, !=)\r\n    public right: ASTNode // Right operand (can be any expression)\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  accept<T>(visitor: ASTVisitor<T>): T {\r\n    return visitor.visitBinaryExpression(this);\r\n  }\r\n}\r\n\r\n// STATEMENT NODES\r\n// These represent actions or declarations that don\'t produce values directly\r\n\r\nclass AssignmentStatement extends ASTNode {\r\n  constructor(\r\n    public identifier: Identifier, // Variable being assigned to (e.g., "x", "sum")\r\n    public value: ASTNode // Expression that produces the value to assign\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  accept<T>(visitor: ASTVisitor<T>): T {\r\n    return visitor.visitAssignmentStatement(this);\r\n  }\r\n}\r\n\r\nclass PrintStatement extends ASTNode {\r\n  constructor(public expression: ASTNode) {\r\n    // Expression to evaluate and print\r\n    super();\r\n  }\r\n\r\n  accept<T>(visitor: ASTVisitor<T>): T {\r\n    return visitor.visitPrintStatement(this);\r\n  }\r\n}\r\n\r\nclass IfStatement extends ASTNode {\r\n  constructor(\r\n    public condition: ASTNode, // Boolean expression to test\r\n    public thenBranch: ASTNode[], // Statements to execute if condition is true\r\n    public elseBranch?: ASTNode[] // Optional statements for else branch\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  accept<T>(visitor: ASTVisitor<T>): T {\r\n    return visitor.visitIfStatement(this);\r\n  }\r\n}\r\n\r\n// ROOT NODE\r\n// This represents the entire program as a sequence of statements\r\nclass Program extends ASTNode {\r\n  constructor(public statements: ASTNode[]) {\r\n    // All top-level statements in the program\r\n    super();\r\n  }\r\n\r\n  accept<T>(visitor: ASTVisitor<T>): T {\r\n    return visitor.visitProgram(this);\r\n  }\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"parser-implementation",children:"Parser Implementation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Consumes tokens, builds AST"}),"\n",(0,i.jsx)(n.li,{children:"Grammar: assignment, print, if/else, expressions, precedence"}),"\n",(0,i.jsx)(n.li,{children:"Throws errors for unexpected tokens"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class Parser {\r\n  private tokens: Token[];\r\n  private current: number;\r\n\r\n  constructor(tokens: Token[]) {\r\n    this.tokens = tokens;\r\n    this.current = 0;\r\n  }\r\n\r\n  // Utility methods\r\n  private peek(): Token {\r\n    return this.tokens[this.current];\r\n  }\r\n\r\n  private previous(): Token {\r\n    return this.tokens[this.current - 1];\r\n  }\r\n\r\n  private isAtEnd(): boolean {\r\n    return this.peek().type === TokenType.EOF;\r\n  }\r\n\r\n  private advance(): Token {\r\n    if (!this.isAtEnd()) this.current++;\r\n    return this.previous();\r\n  }\r\n\r\n  private check(type: TokenType): boolean {\r\n    if (this.isAtEnd()) return false;\r\n    return this.peek().type === type;\r\n  }\r\n\r\n  private match(...types: TokenType[]): boolean {\r\n    for (const type of types) {\r\n      if (this.check(type)) {\r\n        this.advance();\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private consume(type: TokenType, message: string): Token {\r\n    if (this.check(type)) return this.advance();\r\n    throw new Error(\r\n      `${message}. Got ${this.peek().type} at line ${this.peek().line}`\r\n    );\r\n  }\r\n\r\n  // Grammar rules\r\n  public parse(): Program {\r\n    const statements: ASTNode[] = [];\r\n\r\n    while (!this.isAtEnd()) {\r\n      if (this.match(TokenType.NEWLINE)) continue;\r\n      statements.push(this.statement());\r\n    }\r\n\r\n    return new Program(statements);\r\n  }\r\n\r\n  private statement(): ASTNode {\r\n    if (this.match(TokenType.GAN)) return this.assignmentStatement();\r\n    if (this.match(TokenType.IN)) return this.printStatement();\r\n    if (this.match(TokenType.NEU)) return this.ifStatement();\r\n\r\n    throw new Error(\r\n      `Unexpected token: ${this.peek().value} at line ${this.peek().line}`\r\n    );\r\n  }\r\n\r\n  private assignmentStatement(): AssignmentStatement {\r\n    const identifier = this.consume(\r\n      TokenType.IDENTIFIER,\r\n      \"Expected identifier after 'g\xe1n'\"\r\n    );\r\n    this.consume(TokenType.ASSIGN, \"Expected '=' after identifier\");\r\n    const value = this.expression();\r\n\r\n    return new AssignmentStatement(new Identifier(identifier.value), value);\r\n  }\r\n\r\n  private printStatement(): PrintStatement {\r\n    this.consume(TokenType.LPAREN, \"Expected '(' after 'in'\");\r\n    const expression = this.expression();\r\n    this.consume(TokenType.RPAREN, \"Expected ')' after expression\");\r\n\r\n    return new PrintStatement(expression);\r\n  }\r\n\r\n  private ifStatement(): IfStatement {\r\n    this.consume(TokenType.LPAREN, \"Expected '(' after 'n\u1ebfu'\");\r\n    const condition = this.expression();\r\n    this.consume(TokenType.RPAREN, \"Expected ')' after condition\");\r\n\r\n    this.consume(TokenType.LBRACE, \"Expected '{' before if body\");\r\n    const thenBranch: ASTNode[] = [];\r\n\r\n    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {\r\n      if (this.match(TokenType.NEWLINE)) continue;\r\n      thenBranch.push(this.statement());\r\n    }\r\n\r\n    this.consume(TokenType.RBRACE, \"Expected '}' after if body\");\r\n\r\n    let elseBranch: ASTNode[] | undefined;\r\n    if (this.match(TokenType.KHAC)) {\r\n      this.consume(TokenType.LBRACE, \"Expected '{' before else body\");\r\n      elseBranch = [];\r\n\r\n      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {\r\n        if (this.match(TokenType.NEWLINE)) continue;\r\n        elseBranch.push(this.statement());\r\n      }\r\n\r\n      this.consume(TokenType.RBRACE, \"Expected '}' after else body\");\r\n    }\r\n\r\n    return new IfStatement(condition, thenBranch, elseBranch);\r\n  }\r\n\r\n  private expression(): ASTNode {\r\n    return this.equality();\r\n  }\r\n\r\n  private equality(): ASTNode {\r\n    let expr = this.comparison();\r\n\r\n    while (this.match(TokenType.EQUAL, TokenType.NOT_EQUAL)) {\r\n      const operator = this.previous();\r\n      const right = this.comparison();\r\n      expr = new BinaryExpression(expr, operator, right);\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  private comparison(): ASTNode {\r\n    return this.term();\r\n  }\r\n\r\n  private term(): ASTNode {\r\n    let expr = this.factor();\r\n\r\n    while (this.match(TokenType.MINUS, TokenType.PLUS)) {\r\n      const operator = this.previous();\r\n      const right = this.factor();\r\n      expr = new BinaryExpression(expr, operator, right);\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  private factor(): ASTNode {\r\n    let expr = this.unary();\r\n\r\n    while (this.match(TokenType.DIVIDE, TokenType.MULTIPLY)) {\r\n      const operator = this.previous();\r\n      const right = this.unary();\r\n      expr = new BinaryExpression(expr, operator, right);\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  private unary(): ASTNode {\r\n    if (this.match(TokenType.MINUS)) {\r\n      const operator = this.previous();\r\n      const right = this.unary();\r\n      return new BinaryExpression(new NumberLiteral(0), operator, right);\r\n    }\r\n\r\n    return this.primary();\r\n  }\r\n\r\n  private primary(): ASTNode {\r\n    if (this.match(TokenType.BOOLEAN)) {\r\n      return new BooleanLiteral(this.previous().value === \"\u0111\xfang\");\r\n    }\r\n\r\n    if (this.match(TokenType.NUMBER)) {\r\n      return new NumberLiteral(parseFloat(this.previous().value));\r\n    }\r\n\r\n    if (this.match(TokenType.STRING)) {\r\n      return new StringLiteral(this.previous().value);\r\n    }\r\n\r\n    if (this.match(TokenType.IDENTIFIER)) {\r\n      return new Identifier(this.previous().value);\r\n    }\r\n\r\n    if (this.match(TokenType.LPAREN)) {\r\n      const expr = this.expression();\r\n      this.consume(TokenType.RPAREN, \"Expected ')' after expression\");\r\n      return expr;\r\n    }\r\n\r\n    throw new Error(\r\n      `Unexpected token: ${this.peek().value} at line ${this.peek().line}`\r\n    );\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"interpreter-execution",children:"Interpreter Execution"}),"\n",(0,i.jsx)(n.h3,{id:"visitor-pattern-for-ast-traversal",children:"Visitor Pattern for AST Traversal"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Interpreter implements ASTVisitor"}),"\n",(0,i.jsx)(n.li,{children:"Walks AST, evaluates nodes"}),"\n",(0,i.jsx)(n.li,{children:"Handles: assignment, print, if/else, binary ops, literals, identifiers"}),"\n",(0,i.jsx)(n.li,{children:"Helper: isTruthy, isEqual, checkNumberOperands, stringify"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'interface ASTVisitor<T> {\r\n  visitProgram(node: Program): T;\r\n  visitAssignmentStatement(node: AssignmentStatement): T;\r\n  visitPrintStatement(node: PrintStatement): T;\r\n  visitIfStatement(node: IfStatement): T;\r\n  visitBinaryExpression(node: BinaryExpression): T;\r\n  visitNumberLiteral(node: NumberLiteral): T;\r\n  visitStringLiteral(node: StringLiteral): T;\r\n  visitBooleanLiteral(node: BooleanLiteral): T;\r\n  visitIdentifier(node: Identifier): T;\r\n}\r\n\r\nclass Interpreter implements ASTVisitor<any> {\r\n  private environment: Map<string, any>;\r\n  private output: string[];\r\n\r\n  constructor() {\r\n    this.environment = new Map();\r\n    this.output = [];\r\n  }\r\n\r\n  public interpret(program: Program): {\r\n    output: string[];\r\n    environment: Map<string, any>;\r\n  } {\r\n    this.visitProgram(program);\r\n    return {\r\n      output: this.output,\r\n      environment: new Map(this.environment),\r\n    };\r\n  }\r\n\r\n  visitProgram(node: Program): void {\r\n    for (const statement of node.statements) {\r\n      statement.accept(this);\r\n    }\r\n  }\r\n\r\n  visitAssignmentStatement(node: AssignmentStatement): void {\r\n    const value = node.value.accept(this);\r\n    this.environment.set(node.identifier.name, value);\r\n  }\r\n\r\n  visitPrintStatement(node: PrintStatement): void {\r\n    const value = node.expression.accept(this);\r\n    const output = this.stringify(value);\r\n    this.output.push(output);\r\n  }\r\n\r\n  visitIfStatement(node: IfStatement): void {\r\n    const condition = node.condition.accept(this);\r\n\r\n    if (this.isTruthy(condition)) {\r\n      for (const statement of node.thenBranch) {\r\n        statement.accept(this);\r\n      }\r\n    } else if (node.elseBranch) {\r\n      for (const statement of node.elseBranch) {\r\n        statement.accept(this);\r\n      }\r\n    }\r\n  }\r\n\r\n  visitBinaryExpression(node: BinaryExpression): any {\r\n    const left = node.left.accept(this);\r\n    const right = node.right.accept(this);\r\n\r\n    switch (node.operator.type) {\r\n      case TokenType.PLUS:\r\n        if (typeof left === "number" && typeof right === "number") {\r\n          return left + right;\r\n        }\r\n        if (typeof left === "string" || typeof right === "string") {\r\n          return this.stringify(left) + this.stringify(right);\r\n        }\r\n        throw new Error(`Cannot add ${typeof left} and ${typeof right}`);\r\n\r\n      case TokenType.MINUS:\r\n        this.checkNumberOperands(node.operator, left, right);\r\n        return left - right;\r\n\r\n      case TokenType.MULTIPLY:\r\n        this.checkNumberOperands(node.operator, left, right);\r\n        return left * right;\r\n\r\n      case TokenType.DIVIDE:\r\n        this.checkNumberOperands(node.operator, left, right);\r\n        if (right === 0) throw new Error("Division by zero");\r\n        return left / right;\r\n\r\n      case TokenType.EQUAL:\r\n        return this.isEqual(left, right);\r\n\r\n      case TokenType.NOT_EQUAL:\r\n        return !this.isEqual(left, right);\r\n\r\n      default:\r\n        throw new Error(`Unknown binary operator: ${node.operator.type}`);\r\n    }\r\n  }\r\n\r\n  visitNumberLiteral(node: NumberLiteral): number {\r\n    return node.value;\r\n  }\r\n\r\n  visitStringLiteral(node: StringLiteral): string {\r\n    return node.value;\r\n  }\r\n\r\n  visitBooleanLiteral(node: BooleanLiteral): boolean {\r\n    return node.value;\r\n  }\r\n\r\n  visitIdentifier(node: Identifier): any {\r\n    if (this.environment.has(node.name)) {\r\n      return this.environment.get(node.name);\r\n    }\r\n    throw new Error(`Undefined variable: ${node.name}`);\r\n  }\r\n\r\n  // Helper methods\r\n  private isTruthy(value: any): boolean {\r\n    if (value === null || value === undefined) return false;\r\n    if (typeof value === "boolean") return value;\r\n    return true;\r\n  }\r\n\r\n  private isEqual(a: any, b: any): boolean {\r\n    return a === b;\r\n  }\r\n\r\n  private checkNumberOperands(operator: Token, left: any, right: any): void {\r\n    if (typeof left !== "number" || typeof right !== "number") {\r\n      throw new Error(`Operands must be numbers for ${operator.value}`);\r\n    }\r\n  }\r\n\r\n  private stringify(value: any): string {\r\n    if (value === null || value === undefined) return "nil";\r\n    if (typeof value === "boolean") return value ? "\u0111\xfang" : "sai";\r\n    return value.toString();\r\n  }\r\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"language-features",children:"Language Features"}),"\n",(0,i.jsx)(n.h3,{id:"example-programs",children:"Example Programs"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Example 1: Arithmetic, variables"}),"\n",(0,i.jsx)(n.li,{children:"Example 2: String operations, concatenation"}),"\n",(0,i.jsx)(n.li,{children:"Example 3: If/else with Vietnamese keywords"}),"\n",(0,i.jsx)(n.li,{children:"Example 4: Operator precedence, parentheses"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// EXAMPLE 1: Basic arithmetic and variables\r\n// This example demonstrates variable assignment and arithmetic operations\r\n// Execution flow: create variables \u2192 perform calculation \u2192 store result \u2192 print output\r\nconst example1 = `\r\ng\xe1n a = 10        // Assign 10 to variable \'a\'\r\ng\xe1n b = 20        // Assign 20 to variable \'b\'  \r\ng\xe1n sum = a + b   // Calculate sum: 10 + 20 = 30, assign to \'sum\'\r\nin (sum)          // Print the value of sum\r\n`;\r\n// Expected output: 30\r\n// Variables after execution: {a: 10, b: 20, sum: 30}\r\n\r\n// EXAMPLE 2: String operations and concatenation\r\n// Shows how strings work with Vietnamese text and concatenation operator\r\nconst example2 = `\r\ng\xe1n firstName = "Nguy\u1ec5n"               // Vietnamese first name\r\ng\xe1n lastName = "V\u0103n A"                 // Vietnamese last name\r\ng\xe1n fullName = firstName + " " + lastName  // Concatenate with space\r\nin (fullName)                          // Print complete name\r\n`;\r\n// Expected output: "Nguy\u1ec5n V\u0103n A"\r\n// Demonstrates: String literals, concatenation, Vietnamese Unicode support\r\n\r\n// EXAMPLE 3: Conditional statements with Vietnamese keywords\r\n// Shows if-else logic using Vietnamese conditional keywords\r\nconst example3 = `\r\ng\xe1n age = 18                    // Set age variable\r\nn\u1ebfu (age >= 18) {              // If age is 18 or greater\r\n  in ("\u0110\u1ee7 tu\u1ed5i b\u1ea7u c\u1eed")        // Print voting age message\r\n} kh\xe1c {                       // Else (otherwise)\r\n  in ("Ch\u01b0a \u0111\u1ee7 tu\u1ed5i b\u1ea7u c\u1eed")   // Print underage message  \r\n}\r\n`;\r\n// Expected output: "\u0110\u1ee7 tu\u1ed5i b\u1ea7u c\u1eed" (Old enough to vote)\r\n// Shows: Comparison operators, conditional branching, Vietnamese text output\r\n\r\n// EXAMPLE 4: Complex expressions with operator precedence\r\n// Demonstrates arithmetic operator precedence and parentheses grouping\r\nconst example4 = `\r\ng\xe1n x = 5                          // Base value\r\ng\xe1n y = 3                          // Second value\r\ng\xe1n result = (x + y) * 2 - 1       // Complex calculation with precedence\r\nin (result)                        // Print final result\r\n`;\r\n// Expected output: 15\r\n// Calculation breakdown: (5 + 3) * 2 - 1 = 8 * 2 - 1 = 16 - 1 = 15\r\n// Shows: Operator precedence, parentheses grouping, multi-step calculations\n'})}),"\n",(0,i.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Hierarchical error system: InterpreterError (base), RuntimeError, SyntaxError"}),"\n",(0,i.jsx)(n.li,{children:"Tracks line/column for precise messages"}),"\n",(0,i.jsx)(n.li,{children:"Usage: try/catch, print error with location"}),"\n",(0,i.jsx)(n.li,{children:"Common errors: undefined variable, division by zero, type mismatch, syntax issues"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// BASE ERROR CLASS\r\n// All interpreter errors inherit from this class to provide consistent error handling\r\nclass InterpreterError extends Error {\r\n  constructor(\r\n    message: string, // Human-readable error description\r\n    public line?: number, // Line number where error occurred (optional)\r\n    public column?: number // Column position where error occurred (optional)\r\n  ) {\r\n    super(message);\r\n    this.name = "InterpreterError";\r\n  }\r\n}\r\n\r\n// RUNTIME ERROR CLASS\r\n// Errors that occur during program execution (division by zero, undefined variables, etc.)\r\nclass RuntimeError extends InterpreterError {\r\n  constructor(message: string, line?: number, column?: number) {\r\n    super(`Runtime Error: ${message}`, line, column);\r\n    this.name = "RuntimeError";\r\n  }\r\n}\r\n\r\n// SYNTAX ERROR CLASS\r\n// Errors in program structure detected during parsing phase\r\nclass SyntaxError extends InterpreterError {\r\n  constructor(message: string, line?: number, column?: number) {\r\n    super(`Syntax Error: ${message}`, line, column);\r\n    this.name = "SyntaxError";\r\n  }\r\n}\r\n\r\n// ERROR HANDLING IN PRACTICE\r\n// This shows how to use the error system when executing Vietnamese code\r\ntry {\r\n  // Attempt to interpret the Vietnamese program\r\n  const result = interpreter.interpret(program);\r\n  console.log("Output:", result.output.join("\\n"));\r\n} catch (error) {\r\n  if (error instanceof InterpreterError) {\r\n    // Handle known interpreter errors with detailed location info\r\n    console.error(`${error.name} at line ${error.line}: ${error.message}`);\r\n\r\n    // Example output: "Runtime Error at line 3: Undefined variable: t\u1ed5ng"\r\n    // Example output: "Syntax Error at line 1: Expected \')\' after expression"\r\n  } else {\r\n    // Handle unexpected system errors\r\n    console.error("Unexpected error:", error.message);\r\n  }\r\n}\r\n\r\n// COMMON ERROR SCENARIOS:\r\n// 1. Runtime Errors:\r\n//    - "Undefined variable: myVar" (using undefined variable)\r\n//    - "Division by zero" (mathematical error)\r\n//    - "Cannot add string and number" (type mismatch)\r\n//\r\n// 2. Syntax Errors:\r\n//    - "Expected \'=\' after identifier" (missing assignment operator)\r\n//    - "Unexpected token: }" (mismatched braces)\r\n//    - "Expected \')\' after expression" (unclosed parentheses)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,i.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Environment class: variable storage, supports parent scopes"}),"\n",(0,i.jsx)(n.li,{children:"Methods: define, get, set"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class Environment {\r\n  private variables: Map<string, any>;\r\n  private parent: Environment | null;\r\n\r\n  constructor(parent: Environment | null = null) {\r\n    this.variables = new Map();\r\n    this.parent = parent;\r\n  }\r\n\r\n  define(name: string, value: any): void {\r\n    this.variables.set(name, value);\r\n  }\r\n\r\n  get(name: string): any {\r\n    if (this.variables.has(name)) {\r\n      return this.variables.get(name);\r\n    }\r\n\r\n    if (this.parent) {\r\n      return this.parent.get(name);\r\n    }\r\n\r\n    throw new RuntimeError(`Undefined variable: ${name}`);\r\n  }\r\n\r\n  set(name: string, value: any): void {\r\n    if (this.variables.has(name)) {\r\n      this.variables.set(name, value);\r\n      return;\r\n    }\r\n\r\n    if (this.parent) {\r\n      this.parent.set(name, value);\r\n      return;\r\n    }\r\n\r\n    throw new RuntimeError(`Undefined variable: ${name}`);\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"OptimizedInterpreter: memoization for repeated expressions"}),"\n",(0,i.jsx)(n.li,{children:"Caches results of binary expressions"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class OptimizedInterpreter extends Interpreter {\r\n  private cache: Map<string, any>;\r\n\r\n  constructor() {\r\n    super();\r\n    this.cache = new Map();\r\n  }\r\n\r\n  // Memoization for repeated expressions\r\n  private memoize(key: string, computation: () => any): any {\r\n    if (this.cache.has(key)) {\r\n      return this.cache.get(key);\r\n    }\r\n\r\n    const result = computation();\r\n    this.cache.set(key, result);\r\n    return result;\r\n  }\r\n\r\n  // Optimized binary expression evaluation\r\n  visitBinaryExpression(node: BinaryExpression): any {\r\n    const cacheKey = `${node.left.constructor.name}_${node.operator.value}_${node.right.constructor.name}`;\r\n\r\n    return this.memoize(cacheKey, () => {\r\n      return super.visitBinaryExpression(node);\r\n    });\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"browser-integration",children:"Browser Integration"}),"\n",(0,i.jsx)(n.h3,{id:"web-integration-layer",children:"Web Integration Layer"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"BrowserInterpreter: wraps core interpreter for web"}),"\n",(0,i.jsx)(n.li,{children:"Handles DOM, error display, real-time feedback"}),"\n",(0,i.jsx)(n.li,{children:"Methods: execute, displayOutput, displayEnvironment, displayError"}),"\n",(0,i.jsx)(n.li,{children:"Example React component usage"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// BROWSER-SPECIFIC INTERPRETER WRAPPER\r\n// This class bridges the gap between the core interpreter and web browser environment\r\nclass BrowserInterpreter {\r\n  private interpreter: Interpreter; // Core interpreter instance\r\n  private outputElement: HTMLElement; // DOM element for displaying results\r\n\r\n  constructor(outputElementId: string) {\r\n    // Initialize the core interpreter\r\n    this.interpreter = new Interpreter();\r\n\r\n    // Get reference to output DOM element (throws if not found)\r\n    this.outputElement = document.getElementById(outputElementId)!;\r\n  }\r\n\r\n  public execute(code: string): void {\r\n    try {\r\n      // STEP 1: Clear previous execution results\r\n      // This ensures clean state for each execution\r\n      this.outputElement.innerHTML = "";\r\n\r\n      // STEP 2: Lexical analysis - Convert text to tokens\r\n      const lexer = new Lexer(code);\r\n      const tokens = lexer.tokenize();\r\n\r\n      // STEP 3: Parsing - Build Abstract Syntax Tree\r\n      const parser = new Parser(tokens);\r\n      const program = parser.parse();\r\n\r\n      // STEP 4: Execution - Run the program and collect results\r\n      const result = this.interpreter.interpret(program);\r\n\r\n      // STEP 5: Display results in web interface\r\n      this.displayOutput(result.output); // Show program output\r\n      this.displayEnvironment(result.environment); // Show variable states\r\n    } catch (error) {\r\n      // Handle and display any errors that occurred during execution\r\n      this.displayError(error);\r\n    }\r\n  }\r\n\r\n  // DISPLAY METHODS FOR WEB INTERFACE\r\n  // These methods create DOM elements to show execution results to users\r\n\r\n  private displayOutput(output: string[]): void {\r\n    // Create a container for program output (from \'in\' statements)\r\n    const outputDiv = document.createElement("div");\r\n    outputDiv.className = "interpreter-output";\r\n\r\n    // Join all output lines with newlines for display\r\n    outputDiv.textContent = output.join("\\n");\r\n\r\n    // Add to the main output container\r\n    this.outputElement.appendChild(outputDiv);\r\n  }\r\n\r\n  private displayEnvironment(env: Map<string, any>): void {\r\n    // Create a container to show current variable states\r\n    const envDiv = document.createElement("div");\r\n    envDiv.className = "interpreter-environment";\r\n\r\n    // Add a title for the variables section\r\n    const title = document.createElement("h4");\r\n    title.textContent = "Variables:";\r\n    envDiv.appendChild(title);\r\n\r\n    // Display each variable and its current value\r\n    env.forEach((value, name) => {\r\n      const varDiv = document.createElement("div");\r\n      varDiv.textContent = `${name}: ${value}`; // Format: "variableName: value"\r\n      envDiv.appendChild(varDiv);\r\n    });\r\n\r\n    // Add the variables display to the main output\r\n    this.outputElement.appendChild(envDiv);\r\n  }\r\n\r\n  private displayError(error: any): void {\r\n    // Create a container for error messages with distinct styling\r\n    const errorDiv = document.createElement("div");\r\n    errorDiv.className = "interpreter-error"; // CSS class for error styling (red text, etc.)\r\n\r\n    // Display the error message\r\n    errorDiv.textContent = error.message;\r\n\r\n    // Add error to the output (errors are shown prominently)\r\n    this.outputElement.appendChild(errorDiv);\r\n  }\r\n}\r\n\r\n// Usage in React component\r\nconst InterpreterComponent: React.FC = () => {\r\n  const [code, setCode] = useState("");\r\n  const outputRef = useRef<HTMLDivElement>(null);\r\n  const interpreterRef = useRef<BrowserInterpreter>();\r\n\r\n  useEffect(() => {\r\n    if (outputRef.current) {\r\n      interpreterRef.current = new BrowserInterpreter(outputRef.current.id);\r\n    }\r\n  }, []);\r\n\r\n  const handleExecute = () => {\r\n    if (interpreterRef.current) {\r\n      interpreterRef.current.execute(code);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className="interpreter-container">\r\n      <textarea\r\n        value={code}\r\n        onChange={(e) => setCode(e.target.value)}\r\n        placeholder="Nh\u1eadp m\xe3 Vietnamese \u1edf \u0111\xe2y..."\r\n        className="code-editor"\r\n      />\r\n      <button onClick={handleExecute}>Ch\u1ea1y m\xe3</button>\r\n      <div\r\n        id="interpreter-output"\r\n        ref={outputRef}\r\n        className="output-container"\r\n      />\r\n    </div>\r\n  );\r\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"code-organization",children:"Code Organization"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Modular interpreter design: InterpreterModule, ModularInterpreter"}),"\n",(0,i.jsx)(n.li,{children:"Register modules, execute code, debug option"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Modular interpreter design\r\ninterface InterpreterModule {\r\n  name: string;\r\n  version: string;\r\n  dependencies: string[];\r\n}\r\n\r\nclass ModularInterpreter {\r\n  private modules: Map<string, InterpreterModule>;\r\n  private lexer: Lexer;\r\n  private parser: Parser;\r\n  private interpreter: Interpreter;\r\n\r\n  constructor() {\r\n    this.modules = new Map();\r\n    this.initializeCore();\r\n  }\r\n\r\n  private initializeCore(): void {\r\n    this.lexer = new Lexer("");\r\n    this.parser = new Parser([]);\r\n    this.interpreter = new Interpreter();\r\n  }\r\n\r\n  public registerModule(module: InterpreterModule): void {\r\n    this.modules.set(module.name, module);\r\n  }\r\n\r\n  public execute(code: string, options: { debug?: boolean } = {}): any {\r\n    if (options.debug) {\r\n      console.log("Executing code:", code);\r\n    }\r\n\r\n    const tokens = this.lexer.tokenize();\r\n    const ast = this.parser.parse();\r\n    const result = this.interpreter.interpret(ast);\r\n\r\n    return result;\r\n  }\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"testing-strategy",children:"Testing Strategy"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Unit tests for interpreter: arithmetic, string concat, conditionals"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Unit tests for interpreter components\r\ndescribe("Vietnamese Interpreter", () => {\r\n  let interpreter: Interpreter;\r\n\r\n  beforeEach(() => {\r\n    interpreter = new Interpreter();\r\n  });\r\n\r\n  test("should handle basic arithmetic", () => {\r\n    const code = "g\xe1n result = 10 + 5\\nin (result)";\r\n    const result = interpreter.execute(code);\r\n    expect(result.output).toContain("15");\r\n  });\r\n\r\n  test("should handle string concatenation", () => {\r\n    const code = \'g\xe1n greeting = "Xin " + "ch\xe0o"\\nin (greeting)\';\r\n    const result = interpreter.execute(code);\r\n    expect(result.output).toContain("Xin ch\xe0o");\r\n  });\r\n\r\n  test("should handle conditional statements", () => {\r\n    const code = `\r\n      g\xe1n age = 20\r\n      n\u1ebfu (age >= 18) {\r\n        in ("Ng\u01b0\u1eddi l\u1edbn")\r\n      } kh\xe1c {\r\n        in ("Tr\u1ebb em")\r\n      }\r\n    `;\r\n    const result = interpreter.execute(code);\r\n    expect(result.output).toContain("Ng\u01b0\u1eddi l\u1edbn");\r\n  });\r\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Full interpreter pipeline: Lexer \u2192 Parser \u2192 AST \u2192 Interpreter"}),"\n",(0,i.jsx)(n.li,{children:"Vietnamese keywords, localized errors"}),"\n",(0,i.jsx)(n.li,{children:"Browser-based, real-time feedback"}),"\n",(0,i.jsx)(n.li,{children:"Modular, extensible, educational"}),"\n",(0,i.jsx)(n.li,{children:"TypeScript, Visitor pattern, error handling, memoization"}),"\n",(0,i.jsxs)(n.li,{children:["See ",(0,i.jsx)(n.a,{href:"https://github.com/binhphanhai/newbie-interpreter",children:"newbie-interpreter repo"})," for more"]}),"\n",(0,i.jsx)(n.li,{children:"Further: functions, loops, arrays, modules, stdlib"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(6540);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);