"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6724],{2272:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"project-detail/styled-component","title":"Styled Components: CSS-in-JS Simplified","description":"Table of Contents","source":"@site/docs/project-detail/styled-component.md","sourceDirName":"project-detail","slug":"/project-detail/styled-component","permalink":"/frontend-system-design/docs/project-detail/styled-component","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/styled-component.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Service Workers: The Gateway to Progressive Web Apps","permalink":"/frontend-system-design/docs/project-detail/service-worker"},"next":{"title":"Ant Design: Enterprise-Class UI Library","permalink":"/frontend-system-design/docs/project-detail/ant-design"}}');var s=r(4848),o=r(8453);const i={},a="Styled Components: CSS-in-JS Simplified",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Benefits",id:"key-benefits",level:3},{value:"Getting Started",id:"getting-started",level:2},{value:"Installation",id:"installation",level:3},{value:"Babel Configuration",id:"babel-configuration",level:3},{value:"Basic Usage and Syntax",id:"basic-usage-and-syntax",level:2},{value:"Creating Styled Components",id:"creating-styled-components",level:3},{value:"Styling Existing Components",id:"styling-existing-components",level:3},{value:"Under the Hood: How Styled Components Work",id:"under-the-hood-how-styled-components-work",level:2},{value:"Tagged Template Literals Processing",id:"tagged-template-literals-processing",level:3},{value:"CSS Generation and Injection",id:"css-generation-and-injection",level:3},{value:"Dynamic Styling with Props",id:"dynamic-styling-with-props",level:2},{value:"Props-Based Conditional Styling",id:"props-based-conditional-styling",level:3},{value:"Helper Functions for Complex Logic",id:"helper-functions-for-complex-logic",level:3},{value:"Theming System",id:"theming-system",level:2},{value:"Theme Provider and Theme Access",id:"theme-provider-and-theme-access",level:3},{value:"Dynamic Theme Switching",id:"dynamic-theme-switching",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Extending and Composition",id:"extending-and-composition",level:3},{value:"Polymorphic Components",id:"polymorphic-components",level:3},{value:"Global Styles and CSS Reset",id:"global-styles-and-css-reset",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Optimization Techniques",id:"optimization-techniques",level:3},{value:"Server-Side Rendering (SSR)",id:"server-side-rendering-ssr",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Component Organization",id:"component-organization",level:3},{value:"Naming Conventions",id:"naming-conventions",level:3},{value:"Performance Guidelines",id:"performance-guidelines",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Further Resources",id:"further-resources",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"styled-components-css-in-js-simplified",children:"Styled Components: CSS-in-JS Simplified"})}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getting-started",children:"Getting Started"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#basic-usage-and-syntax",children:"Basic Usage and Syntax"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#under-the-hood-how-styled-components-work",children:"Under the Hood: How Styled Components Work"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#dynamic-styling-with-props",children:"Dynamic Styling with Props"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#theming-system",children:"Theming System"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#advanced-patterns",children:"Advanced Patterns"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["Styled Components is a popular CSS-in-JS library for React and React Native that allows you to write actual CSS code to style your components using tagged template literals. As highlighted in the ",(0,s.jsx)(n.a,{href:"https://github.com/styled-components/styled-components",children:"official Styled Components repository"}),", it removes the mapping between components and styles, making component-level styling intuitive and maintainable."]}),"\n",(0,s.jsx)(n.h3,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Component-scoped styling"}),": No more global CSS conflicts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic styling"}),": Props-based conditional styling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic vendor prefixing"}),": Cross-browser compatibility out of the box"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dead code elimination"}),": Unused styles are automatically removed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Theming support"}),": Consistent design system implementation"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,s.jsx)(n.h3,{id:"installation",children:"Installation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this section covers"}),": Setting up styled-components in your React project with all necessary dependencies and development tools."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Steps explained"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Install the core styled-components library"}),"\n",(0,s.jsx)(n.li,{children:"Add TypeScript support for better development experience"}),"\n",(0,s.jsx)(n.li,{children:"Install Babel plugin for enhanced debugging and performance"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Expected outcome"}),": A fully configured styled-components setup ready for development."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Step 1: Install the core styled-components library\r\n# This provides the main functionality for CSS-in-JS styling\r\nnpm install styled-components\r\n\r\n# Step 2: Install TypeScript definitions (recommended for TypeScript projects)\r\n# Provides type safety and IntelliSense support in your IDE\r\nnpm install --save-dev @types/styled-components\r\n\r\n# Step 3: Install Babel plugin for enhanced development experience\r\n# Enables better component names in DevTools and improved performance\r\nnpm install --save-dev babel-plugin-styled-components\n"})}),"\n",(0,s.jsx)(n.h3,{id:"babel-configuration",children:"Babel Configuration"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Configure Babel to optimize styled-components for development and production builds."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Configuration benefits"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"displayName"}),": Shows readable component names in React DevTools"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fileName"}),": Includes file names in component names for easier debugging"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ssr"}),": Enables server-side rendering support"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input"}),": Babel configuration file\r\n",(0,s.jsx)(n.strong,{children:"Output"}),": Enhanced development experience and optimized builds"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// .babelrc or babel.config.js\r\n// Configuration file that tells Babel how to transform styled-components\r\n{\r\n  "plugins": [\r\n    [\r\n      "babel-plugin-styled-components",\r\n      {\r\n        // Shows component names like "Button" instead of generic class names in DevTools\r\n        "displayName": true,\r\n        // Includes file path in component names for easier debugging\r\n        "fileName": true,\r\n        // Enables server-side rendering optimizations\r\n        "ssr": true\r\n      }\r\n    ]\r\n  ]\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"basic-usage-and-syntax",children:"Basic Usage and Syntax"}),"\n",(0,s.jsx)(n.h3,{id:"creating-styled-components",children:"Creating Styled Components"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this code demonstrates"}),": How to create your first styled component using tagged template literals."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Process breakdown"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Import the styled function from styled-components"}),"\n",(0,s.jsx)(n.li,{children:"Use template literals to define CSS styles"}),"\n",(0,s.jsx)(n.li,{children:"styled-components automatically generates unique class names"}),"\n",(0,s.jsx)(n.li,{children:"The component can be used like any other React component"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input"}),": CSS styles written in template literal syntax\r\n",(0,s.jsx)(n.strong,{children:"Output"}),": A React component with scoped styles and unique class names"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key benefits"}),": No CSS class name conflicts, component-scoped styling, pseudo-selector support"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Import the main styled function\r\nimport styled from "styled-components";\r\n\r\n// Create a styled button component using tagged template literals\r\n// This creates a React component that renders a <button> with the specified styles\r\nconst Button = styled.button`\r\n  /* Base styles - these apply to all button instances */\r\n  background-color: #007bff; /* Primary blue color */\r\n  color: white; /* White text for contrast */\r\n  border: none; /* Remove default button border */\r\n  padding: 12px 24px; /* Internal spacing */\r\n  border-radius: 4px; /* Rounded corners */\r\n  font-size: 16px; /* Readable text size */\r\n  cursor: pointer; /* Show it\'s clickable */\r\n  transition: background-color 0.2s ease; /* Smooth color transitions */\r\n\r\n  /* Pseudo-selectors work just like in regular CSS */\r\n  &:hover {\r\n    background-color: #0056b3; /* Darker blue on hover */\r\n  }\r\n\r\n  /* Handle disabled state styling */\r\n  &:disabled {\r\n    background-color: #6c757d; /* Gray background when disabled */\r\n    cursor: not-allowed; /* Show disabled cursor */\r\n  }\r\n`;\r\n\r\n// Usage: Styled components work exactly like regular React components\r\n// They accept all standard HTML attributes and props\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      {/* Regular button with default styling */}\r\n      <Button>Click me</Button>\r\n\r\n      {/* Button with disabled attribute - will use disabled styles */}\r\n      <Button disabled>Disabled</Button>\r\n    </div>\r\n  );\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"styling-existing-components",children:"Styling Existing Components"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Learn how to apply styled-components to existing React components (third-party libraries, custom components)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use cases"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Styling components from libraries like React Router, Material-UI, etc."}),"\n",(0,s.jsx)(n.li,{children:"Creating component hierarchies with nested styling"}),"\n",(0,s.jsx)(n.li,{children:"Maintaining component functionality while changing appearance"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input"}),": Existing React component + CSS styles\r\n",(0,s.jsx)(n.strong,{children:"Output"}),": New styled component that wraps the original with custom styles"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Example: Styling a third-party component (React Router\'s Link)\r\nimport { Link } from "react-router-dom";\r\n\r\n// Wrap an existing component with styled-components\r\n// The Link component keeps all its original functionality (routing)\r\n// but gets our custom styling\r\nconst StyledLink = styled(Link)`\r\n  color: #007bff; /* Blue color for links */\r\n  text-decoration: none; /* Remove default underline */\r\n  font-weight: 600; /* Make text semi-bold */\r\n\r\n  /* Add hover effects */\r\n  &:hover {\r\n    text-decoration: underline; /* Show underline on hover */\r\n  }\r\n`;\r\n\r\n// Advanced: Using component selectors for nested styling\r\n// This demonstrates how to style child components within parent components\r\nconst Card = styled.div`\r\n  /* Base card styling */\r\n  padding: 20px; /* Internal spacing */\r\n  border: 1px solid #e0e0e0; /* Light gray border */\r\n  border-radius: 8px; /* Rounded corners */\r\n\r\n  /* Nested component styling using component selector */\r\n  /* This targets StyledLink components that are children of this Card */\r\n  ${StyledLink} {\r\n    display: block; /* Make links block-level elements */\r\n    margin-top: 10px; /* Add space above each link */\r\n  }\r\n`;\r\n\r\n// Usage example:\r\n// <Card>\r\n//   <p>Card content</p>\r\n//   <StyledLink to="/page1">Link 1</StyledLink>\r\n//   <StyledLink to="/page2">Link 2</StyledLink>\r\n// </Card>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"under-the-hood-how-styled-components-work",children:"Under the Hood: How Styled Components Work"}),"\n",(0,s.jsx)(n.h3,{id:"tagged-template-literals-processing",children:"Tagged Template Literals Processing"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this section explains"}),": The internal mechanism of how styled-components processes template literals and converts them into React components."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Process flow"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Parse template literal strings and expressions"}),"\n",(0,s.jsx)(n.li,{children:"Evaluate dynamic expressions (functions with props)"}),"\n",(0,s.jsx)(n.li,{children:"Generate unique CSS class names"}),"\n",(0,s.jsx)(n.li,{children:"Inject CSS rules into the DOM"}),"\n",(0,s.jsx)(n.li,{children:"Return a React component with the generated class"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input"}),": Template literal with CSS + dynamic expressions\r\n",(0,s.jsx)(n.strong,{children:"Output"}),": React component with unique class name and injected styles"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Why this matters"}),": Understanding this helps with debugging and performance optimization."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Simplified representation of how styled-components processes template literals\r\n// This is NOT the actual implementation, but shows the conceptual flow\r\nfunction styledComponentsProcessor(template, ...expressions) {\r\n  // Step 1: Parse and combine template literal parts with dynamic expressions\r\n  const cssString = template.reduce((result, string, i) => {\r\n    // Get the expression at the current position\r\n    const expression = expressions[i - 1];\r\n\r\n    // If expression is a function, call it with props to get the value\r\n    // If it\'s a static value, use it directly\r\n    const evaluatedExpression =\r\n      typeof expression === "function" ? expression(props) : expression;\r\n\r\n    // Combine the static string with the evaluated expression\r\n    return result + evaluatedExpression + string;\r\n  });\r\n\r\n  // Step 2: Generate a unique class name for this component\r\n  // This ensures style isolation between different components\r\n  const className = generateUniqueClassName(cssString);\r\n\r\n  // Step 3: Inject the CSS styles into the document head\r\n  // This creates actual CSS rules that browsers can use\r\n  injectStyles(className, cssString);\r\n\r\n  // Step 4: Return a React component that uses the generated class\r\n  return createStyledComponent(className);\r\n}\r\n\r\n// Conceptual implementation of the styled object\r\n// Each HTML element (button, div, span, etc.) gets its own method\r\nconst styled = {\r\n  // Example for button elements\r\n  button: (template, ...expressions) => {\r\n    // Return a function that creates React elements\r\n    return (props) => {\r\n      // Process the template with current props\r\n      const className = processTemplate(template, expressions, props);\r\n\r\n      // Create a button element with the generated class and all passed props\r\n      return React.createElement("button", { ...props, className });\r\n    };\r\n  },\r\n  // Similar methods exist for div, span, p, etc.\r\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"css-generation-and-injection",children:"CSS Generation and Injection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Understand how styled-components manages CSS rules in the browser and maintains performance."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key concepts"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Dynamic style sheet creation and management"}),"\n",(0,s.jsx)(n.li,{children:"Unique class name generation to prevent conflicts"}),"\n",(0,s.jsx)(n.li,{children:"Efficient CSS rule injection and cleanup"}),"\n",(0,s.jsx)(n.li,{children:"Memory management for unused styles"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Process flow"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create a style sheet in the document head"}),"\n",(0,s.jsx)(n.li,{children:"Generate unique class names for each component"}),"\n",(0,s.jsx)(n.li,{children:"Inject CSS rules into the style sheet"}),"\n",(0,s.jsx)(n.li,{children:"Track and cleanup unused styles"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance benefits"}),": Prevents duplicate styles, enables dead code elimination, manages memory usage"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Simplified representation of how styled-components manages CSS\r\n// This shows the conceptual approach to style management\r\nclass StyleManager {\r\n  constructor() {\r\n    // Map to track injected styles and prevent duplicates\r\n    this.styles = new Map();\r\n    // Reference to the style sheet for CSS rule manipulation\r\n    this.sheet = this.createStyleSheet();\r\n  }\r\n\r\n  // Creates a new style sheet in the document head\r\n  createStyleSheet() {\r\n    // Create a new <style> element\r\n    const style = document.createElement(\"style\");\r\n    style.type = \"text/css\";\r\n\r\n    // Add it to the document head so browsers can use the styles\r\n    document.head.appendChild(style);\r\n\r\n    // Return the CSSStyleSheet interface for rule manipulation\r\n    return style.sheet;\r\n  }\r\n\r\n  // Generates unique class names to prevent style conflicts\r\n  generateClassName(componentId, hash) {\r\n    // Format: sc-{componentId}-{hash}\r\n    // Example: \"sc-button-abc123\"\r\n    return `sc-${componentId}-${hash}`;\r\n  }\r\n\r\n  // Injects CSS rules into the style sheet\r\n  injectStyles(className, cssText) {\r\n    // Check if we've already injected this style to avoid duplicates\r\n    if (!this.styles.has(className)) {\r\n      // Create a CSS rule string\r\n      const rule = `.${className} { ${cssText} }`;\r\n\r\n      // Insert the rule at the end of the style sheet\r\n      this.sheet.insertRule(rule, this.sheet.cssRules.length);\r\n\r\n      // Track that we've injected this style\r\n      this.styles.set(className, cssText);\r\n    }\r\n  }\r\n\r\n  // Removes unused styles to prevent memory leaks\r\n  removeStyles(className) {\r\n    // Only proceed if the style exists\r\n    if (this.styles.has(className)) {\r\n      // Find the CSS rule in the style sheet\r\n      for (let i = 0; i < this.sheet.cssRules.length; i++) {\r\n        // Check if this rule matches our class name\r\n        if (this.sheet.cssRules[i].selectorText.includes(className)) {\r\n          // Remove the rule from the style sheet\r\n          this.sheet.deleteRule(i);\r\n          break;\r\n        }\r\n      }\r\n      // Remove from our tracking map\r\n      this.styles.delete(className);\r\n    }\r\n  }\r\n}\r\n\r\n// Example usage:\r\n// const manager = new StyleManager();\r\n// manager.injectStyles('sc-button-abc123', 'background: blue; color: white;');\r\n// Results in: .sc-button-abc123 { background: blue; color: white; }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"dynamic-styling-with-props",children:"Dynamic Styling with Props"}),"\n",(0,s.jsx)(n.h3,{id:"props-based-conditional-styling",children:"Props-Based Conditional Styling"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this demonstrates"}),": How to create dynamic, reusable components that change their appearance based on props."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key concepts"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Functions in template literals receive props as arguments"}),"\n",(0,s.jsx)(n.li,{children:"Conditional logic can determine styles based on prop values"}),"\n",(0,s.jsx)(n.li,{children:"TypeScript interfaces provide type safety for props"}),"\n",(0,s.jsx)(n.li,{children:"Destructuring props makes code cleaner"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input"}),": Component props (size, variant, outlined, etc.)\r\n",(0,s.jsx)(n.strong,{children:"Output"}),": Dynamic CSS styles based on prop values"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),": Single component handles multiple visual variations, reducing code duplication"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Example of a highly configurable button component\r\n// This single component can handle multiple sizes, variants, and styles\r\nconst Button = styled.button`\r\n  /* Dynamic padding based on size prop */\r\n  padding: ${(props) => (props.size === "large" ? "16px 32px" : "8px 16px")};\r\n\r\n  /* Background color determined by variant prop */\r\n  background-color: ${(props) => {\r\n    // Switch statement allows for multiple variants\r\n    switch (props.variant) {\r\n      case "primary":\r\n        return "#007bff"; // Blue for primary actions\r\n      case "secondary":\r\n        return "#6c757d"; // Gray for secondary actions\r\n      case "danger":\r\n        return "#dc3545"; // Red for destructive actions\r\n      default:\r\n        return "#f8f9fa"; // Light gray as default\r\n    }\r\n  }};\r\n\r\n  /* Text color adapts to background */\r\n  color: ${(props) => (props.variant === "default" ? "#212529" : "white")};\r\n\r\n  /* Conditional border for outlined style */\r\n  border: 2px solid ${(props) =>\r\n      props.outlined ? "currentColor" : "transparent"};\r\n\r\n  /* Override background for outlined buttons */\r\n  background-color: ${(props) => props.outlined && "transparent"};\r\n`;\r\n\r\n// TypeScript interface for better development experience\r\n// Defines exactly what props the component accepts\r\ninterface ButtonProps {\r\n  variant?: "primary" | "secondary" | "danger" | "default"; // Color scheme\r\n  size?: "small" | "medium" | "large"; // Size variations\r\n  outlined?: boolean; // Style variant\r\n  fullWidth?: boolean; // Layout option\r\n}\r\n\r\n// TypeScript-enabled styled component with type safety\r\n// The <ButtonProps> generic provides IntelliSense and type checking\r\nconst TypedButton =\r\n  styled.button <\r\n  ButtonProps >\r\n  `\r\n  /* Using destructuring for cleaner prop access */\r\n  padding: ${({ size }) => {\r\n    // Object lookup is cleaner than switch statements\r\n    const sizes = {\r\n      small: "4px 8px",\r\n      medium: "8px 16px",\r\n      large: "12px 24px",\r\n    };\r\n    // Provide default value if size is undefined\r\n    return sizes[size || "medium"];\r\n  }};\r\n  \r\n  /* Conditional width styling */\r\n  width: ${({ fullWidth }) => fullWidth && "100%"};\r\n  \r\n  /* Other base styles would go here */\r\n`;\r\n\r\n// Usage examples:\r\n// <Button variant="primary" size="large">Primary Button</Button>\r\n// <Button variant="danger" outlined>Outlined Danger</Button>\r\n// <TypedButton fullWidth variant="secondary">Full Width</TypedButton>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"helper-functions-for-complex-logic",children:"Helper Functions for Complex Logic"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Extract complex styling logic into reusable utility functions for cleaner, more maintainable styled components."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduces code duplication across multiple components"}),"\n",(0,s.jsx)(n.li,{children:"Makes complex logic easier to test and maintain"}),"\n",(0,s.jsx)(n.li,{children:"Improves readability of styled component definitions"}),"\n",(0,s.jsx)(n.li,{children:"Enables consistent styling patterns across your application"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pattern"}),": Create utility functions that return style objects or values, then use them in styled components."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input"}),": Props or configuration values\r\n",(0,s.jsx)(n.strong,{children:"Output"}),": Style values or CSS properties"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Utility function that encapsulates button variant logic\r\n// This keeps the styled component clean and makes the logic reusable\r\nconst getButtonVariant = (variant) => {\r\n  // Define all possible button variants in one place\r\n  const variants = {\r\n    primary: { bg: "#007bff", color: "white" }, // Blue primary button\r\n    secondary: { bg: "#6c757d", color: "white" }, // Gray secondary button\r\n    success: { bg: "#28a745", color: "white" }, // Green success button\r\n    danger: { bg: "#dc3545", color: "white" }, // Red danger button\r\n  };\r\n\r\n  // Return the variant object, or default to primary if variant doesn\'t exist\r\n  return variants[variant] || variants.primary;\r\n};\r\n\r\n// Clean, readable styled component that uses the utility function\r\nconst Button = styled.button`\r\n  /* Use helper function for background color */\r\n  background-color: ${(props) => getButtonVariant(props.variant).bg};\r\n\r\n  /* Use helper function for text color */\r\n  color: ${(props) => getButtonVariant(props.variant).color};\r\n\r\n  /* Standard button styling */\r\n  padding: 12px 24px; /* Comfortable button size */\r\n  border: none; /* Remove default border */\r\n  border-radius: 4px; /* Rounded corners */\r\n  cursor: pointer; /* Show it\'s interactive */\r\n  transition: all 0.2s ease; /* Smooth animations */\r\n\r\n  /* Interactive hover effects */\r\n  &:hover {\r\n    transform: translateY(-1px); /* Slight lift effect */\r\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow */\r\n  }\r\n`;\r\n\r\n// Usage examples:\r\n// <Button variant="primary">Primary Action</Button>\r\n// <Button variant="danger">Delete Item</Button>\r\n// <Button variant="success">Save Changes</Button>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"theming-system",children:"Theming System"}),"\n",(0,s.jsx)(n.h3,{id:"theme-provider-and-theme-access",children:"Theme Provider and Theme Access"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this demonstrates"}),": How to create a centralized design system using ThemeProvider for consistent styling across your entire application."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key concepts"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ThemeProvider uses React Context to make theme available to all child components"}),"\n",(0,s.jsx)(n.li,{children:"Theme objects organize design tokens (colors, spacing, typography, breakpoints)"}),"\n",(0,s.jsxs)(n.li,{children:["Components access theme via the ",(0,s.jsx)(n.code,{children:"theme"})," prop in template literals"]}),"\n",(0,s.jsx)(n.li,{children:"Responsive design is easier with centralized breakpoint definitions"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Consistent design system across the app"}),"\n",(0,s.jsx)(n.li,{children:"Easy theme switching (light/dark modes)"}),"\n",(0,s.jsx)(n.li,{children:"Centralized design token management"}),"\n",(0,s.jsx)(n.li,{children:"Better maintainability and scalability"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Flow"}),": Define theme \u2192 Wrap app with ThemeProvider \u2192 Access theme in styled components"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import styled, { ThemeProvider } from "styled-components";\r\n\r\n// Central theme object - the single source of truth for your design system\r\nconst theme = {\r\n  // Color palette - organized by purpose\r\n  colors: {\r\n    primary: "#007bff", // Main brand color\r\n    secondary: "#6c757d", // Secondary actions\r\n    success: "#28a745", // Success states\r\n    danger: "#dc3545", // Error/danger states\r\n    light: "#f8f9fa", // Light backgrounds\r\n    dark: "#212529", // Dark text/backgrounds\r\n  },\r\n\r\n  // Spacing scale - consistent spacing throughout the app\r\n  spacing: {\r\n    xs: "4px", // Extra small spacing\r\n    sm: "8px", // Small spacing\r\n    md: "16px", // Medium spacing (base unit)\r\n    lg: "24px", // Large spacing\r\n    xl: "32px", // Extra large spacing\r\n  },\r\n\r\n  // Responsive breakpoints - mobile-first approach\r\n  breakpoints: {\r\n    mobile: "576px", // Small devices\r\n    tablet: "768px", // Medium devices\r\n    desktop: "992px", // Large devices\r\n    wide: "1200px", // Extra large devices\r\n  },\r\n\r\n  // Typography system - consistent text styling\r\n  typography: {\r\n    fontFamily: "Arial, sans-serif",\r\n    fontSize: {\r\n      small: "12px", // Small text\r\n      medium: "16px", // Body text\r\n      large: "20px", // Headings\r\n      xlarge: "24px", // Large headings\r\n    },\r\n  },\r\n};\r\n\r\n// Styled component that uses theme values\r\n// The { theme } parameter gives access to the theme object\r\nconst ThemedButton = styled.button`\r\n  /* Use theme colors for consistency */\r\n  background-color: ${({ theme }) => theme.colors.primary};\r\n  color: white;\r\n\r\n  /* Combine spacing values for padding */\r\n  padding: ${({ theme }) => `${theme.spacing.sm} ${theme.spacing.md}`};\r\n\r\n  /* Use theme typography */\r\n  font-family: ${({ theme }) => theme.typography.fontFamily};\r\n  font-size: ${({ theme }) => theme.typography.fontSize.medium};\r\n\r\n  /* Standard button styles */\r\n  border: none;\r\n  border-radius: 4px;\r\n  cursor: pointer;\r\n\r\n  /* Responsive design using theme breakpoints */\r\n  @media (min-width: ${({ theme }) => theme.breakpoints.tablet}) {\r\n    /* Larger padding on tablet and up */\r\n    padding: ${({ theme }) => `${theme.spacing.md} ${theme.spacing.lg}`};\r\n  }\r\n`;\r\n\r\n// App component wrapped with ThemeProvider\r\n// This makes the theme available to ALL child components\r\nfunction App() {\r\n  return (\r\n    <ThemeProvider theme={theme}>\r\n      {/* All components inside can now access the theme */}\r\n      <ThemedButton>Themed Button</ThemedButton>\r\n      {/* Other components can also use the theme */}\r\n    </ThemeProvider>\r\n  );\r\n}\r\n\r\n// Additional themed components can be created anywhere in the app:\r\n// const ThemedCard = styled.div`\r\n//   background: ${({ theme }) => theme.colors.light};\r\n//   padding: ${({ theme }) => theme.spacing.lg};\r\n// `;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"dynamic-theme-switching",children:"Dynamic Theme Switching"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this demonstrates"}),": How to implement theme switching (like dark/light mode) using React state and ThemeProvider."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key concepts"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multiple theme objects for different modes"}),"\n",(0,s.jsx)(n.li,{children:"React state to track current theme"}),"\n",(0,s.jsx)(n.li,{children:"Conditional theme selection based on state"}),"\n",(0,s.jsx)(n.li,{children:"Smooth transitions between themes using CSS transitions"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use cases"}),": Dark/light mode, seasonal themes, user preference settings, accessibility themes"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Implementation steps"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Define multiple theme objects"}),"\n",(0,s.jsx)(n.li,{children:"Use React state to track active theme"}),"\n",(0,s.jsx)(n.li,{children:"Conditionally pass theme to ThemeProvider"}),"\n",(0,s.jsx)(n.li,{children:"Add transitions for smooth theme changes"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { useState } from "react";\r\n\r\n// Light theme configuration\r\nconst lightTheme = {\r\n  colors: {\r\n    background: "#ffffff", // White background\r\n    text: "#000000", // Black text for contrast\r\n    // Add more light theme colors as needed\r\n  },\r\n};\r\n\r\n// Dark theme configuration\r\nconst darkTheme = {\r\n  colors: {\r\n    background: "#000000", // Black background\r\n    text: "#ffffff", // White text for contrast\r\n    // Add more dark theme colors as needed\r\n  },\r\n};\r\n\r\n// Main app component with theme switching logic\r\nfunction ThemeToggleApp() {\r\n  // State to track whether dark theme is active\r\n  const [isDark, setIsDark] = useState(false);\r\n\r\n  // Conditionally select theme based on state\r\n  const currentTheme = isDark ? darkTheme : lightTheme;\r\n\r\n  return (\r\n    // ThemeProvider with dynamic theme\r\n    <ThemeProvider theme={currentTheme}>\r\n      <Container>\r\n        {/* Button to toggle between themes */}\r\n        <button onClick={() => setIsDark(!isDark)}>\r\n          Switch to {isDark ? "Light" : "Dark"} Theme\r\n        </button>\r\n\r\n        {/* Your app content goes here */}\r\n        {/* All child components will automatically use the new theme */}\r\n      </Container>\r\n    </ThemeProvider>\r\n  );\r\n}\r\n\r\n// Container component that responds to theme changes\r\nconst Container = styled.div`\r\n  /* Use theme colors - these will change when theme switches */\r\n  background-color: ${({ theme }) => theme.colors.background};\r\n  color: ${({ theme }) => theme.colors.text};\r\n\r\n  /* Layout styles */\r\n  min-height: 100vh; /* Full viewport height */\r\n  padding: 20px; /* Comfortable padding */\r\n\r\n  /* Smooth transition when theme changes */\r\n  transition: all 0.3s ease;\r\n`;\r\n\r\n// Advanced theme switching with localStorage persistence:\r\n// function useTheme() {\r\n//   const [isDark, setIsDark] = useState(() => {\r\n//     // Load theme preference from localStorage\r\n//     return localStorage.getItem(\'theme\') === \'dark\';\r\n//   });\r\n//\r\n//   const toggleTheme = () => {\r\n//     setIsDark(!isDark);\r\n//     // Save theme preference\r\n//     localStorage.setItem(\'theme\', !isDark ? \'dark\' : \'light\');\r\n//   };\r\n//\r\n//   return { isDark, toggleTheme };\r\n// }\n'})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"extending-and-composition",children:"Extending and Composition"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this demonstrates"}),": How to build component hierarchies using inheritance and composition patterns in styled-components."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key benefits"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduces code duplication by sharing common styles"}),"\n",(0,s.jsx)(n.li,{children:"Creates consistent base styles across component variants"}),"\n",(0,s.jsx)(n.li,{children:"Makes it easy to maintain and update shared styling"}),"\n",(0,s.jsx)(n.li,{children:"Follows DRY (Don't Repeat Yourself) principles"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pattern"}),": Create base components with shared styles, then extend them for specific variants."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use cases"}),": Button variants, card types, form input variations, typography scales"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Base button component with shared styles\r\n// This contains all the common styling that every button variant will have\r\nconst BaseButton = styled.button`\r\n  /* Common button properties shared by all variants */\r\n  padding: 12px 24px; /* Standard button size */\r\n  border: none; /* Remove default browser border */\r\n  border-radius: 4px; /* Rounded corners */\r\n  cursor: pointer; /* Show it's clickable */\r\n  font-size: 16px; /* Readable text size */\r\n  transition: all 0.2s ease; /* Smooth interactions */\r\n\r\n  /* Base styles that variants can override */\r\n  display: inline-block;\r\n  text-align: center;\r\n  text-decoration: none;\r\n  font-weight: 400;\r\n`;\r\n\r\n// Primary button extends BaseButton with specific styling\r\n// Inherits all BaseButton styles and adds variant-specific ones\r\nconst PrimaryButton = styled(BaseButton)`\r\n  /* Primary button specific styles */\r\n  background-color: #007bff; /* Blue background */\r\n  color: white; /* White text */\r\n\r\n  /* Primary button hover state */\r\n  &:hover {\r\n    background-color: #0056b3; /* Darker blue on hover */\r\n  }\r\n\r\n  /* Primary button focus state for accessibility */\r\n  &:focus {\r\n    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);\r\n  }\r\n`;\r\n\r\n// Outline button variant with different styling approach\r\nconst OutlineButton = styled(BaseButton)`\r\n  /* Outline button specific styles */\r\n  background-color: transparent; /* No background initially */\r\n  color: #007bff; /* Blue text */\r\n  border: 2px solid #007bff; /* Blue border */\r\n\r\n  /* Outline button hover state - inverts colors */\r\n  &:hover {\r\n    background-color: #007bff; /* Fill with blue background */\r\n    color: white; /* White text */\r\n  }\r\n\r\n  /* Outline button active state */\r\n  &:active {\r\n    background-color: #0056b3;\r\n    border-color: #0056b3;\r\n  }\r\n`;\r\n\r\n// Usage examples:\r\n// <BaseButton>Basic Button</BaseButton>\r\n// <PrimaryButton>Primary Action</PrimaryButton>\r\n// <OutlineButton>Secondary Action</OutlineButton>\r\n\r\n// You can create as many variants as needed:\r\n// const DangerButton = styled(BaseButton)`\r\n//   background-color: #dc3545;\r\n//   color: white;\r\n//   &:hover { background-color: #c82333; }\r\n// `;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"polymorphic-components",children:"Polymorphic Components"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this demonstrates"}),": How to create flexible components that can render as different HTML elements or React components while maintaining the same styling."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key concepts"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"as"})," prop allows changing the underlying HTML element"]}),"\n",(0,s.jsx)(n.li,{children:"Same styles can be applied to different semantic elements"}),"\n",(0,s.jsx)(n.li,{children:"Works with both HTML elements and React components"}),"\n",(0,s.jsx)(n.li,{children:"Maintains accessibility and semantic meaning"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduces component duplication"}),"\n",(0,s.jsx)(n.li,{children:"Maintains consistent styling across different element types"}),"\n",(0,s.jsx)(n.li,{children:"Improves semantic HTML usage"}),"\n",(0,s.jsx)(n.li,{children:"Better accessibility support"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use cases"}),": Typography systems, layout components, navigation elements"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Flexible text component that can render as any text element\r\n// This single component can handle paragraphs, headings, spans, etc.\r\nconst Text = styled.p`\r\n  /* Base text styling applied regardless of element type */\r\n  margin: 0; /* Reset browser defaults */\r\n  font-size: 16px; /* Base font size */\r\n  line-height: 1.5; /* Good readability */\r\n  color: ${({ theme }) => theme.colors.text}; /* Theme-aware text color */\r\n\r\n  /* Additional properties you might want */\r\n  font-family: inherit; /* Use parent font family */\r\n  font-weight: normal; /* Normal weight by default */\r\n`;\r\n\r\n// Examples showing the flexibility of polymorphic components\r\nfunction TextExamples() {\r\n  return (\r\n    <>\r\n      {/* Default usage - renders as <p> element */}\r\n      <Text>Default paragraph</Text>\r\n\r\n      {/* Renders as <span> for inline text */}\r\n      <Text as="span">Rendered as span</Text>\r\n\r\n      {/* Renders as <h2> for semantic heading */}\r\n      <Text as="h2">Rendered as heading</Text>\r\n\r\n      {/* Renders as custom React component */}\r\n      <Text as={Link} to="/home">\r\n        Rendered as Link component\r\n      </Text>\r\n\r\n      {/* Other HTML elements */}\r\n      <Text as="label">Form label text</Text>\r\n      <Text as="div">Block-level text</Text>\r\n      <Text as="strong">Important text</Text>\r\n    </>\r\n  );\r\n}\r\n\r\n// Advanced polymorphic component with conditional styling\r\nconst FlexibleButton = styled.button`\r\n  /* Base button styles */\r\n  padding: 12px 24px;\r\n  border: none;\r\n  border-radius: 4px;\r\n  cursor: pointer;\r\n\r\n  /* Conditional styling based on the \'as\' prop */\r\n  ${({ as }) =>\r\n    as === "a" &&\r\n    `\r\n    text-decoration: none;\r\n    display: inline-block;\r\n  `}\r\n`;\r\n\r\n// Usage:\r\n// <FlexibleButton>Regular Button</FlexibleButton>\r\n// <FlexibleButton as="a" href="/link">Link styled as button</FlexibleButton>\r\n// <FlexibleButton as={RouterLink} to="/page">Router Link Button</FlexibleButton>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"global-styles-and-css-reset",children:"Global Styles and CSS Reset"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this demonstrates"}),": How to apply global styles and CSS resets using styled-components' ",(0,s.jsx)(n.code,{children:"createGlobalStyle"})," function."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key concepts"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Global styles affect the entire document, not just components"}),"\n",(0,s.jsx)(n.li,{children:"CSS resets normalize browser default styles"}),"\n",(0,s.jsx)(n.li,{children:"Global styles can access theme values"}),"\n",(0,s.jsx)(n.li,{children:"Should be rendered at the root level of your app"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use cases"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"CSS resets and normalizations"}),"\n",(0,s.jsx)(n.li,{children:"Global font and color settings"}),"\n",(0,s.jsx)(n.li,{children:"Base HTML element styling"}),"\n",(0,s.jsx)(n.li,{children:"Third-party component overrides"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Best practices"}),": Keep global styles minimal, use them for base styles only"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { createGlobalStyle } from "styled-components";\r\n\r\n// Global style component that injects CSS into the document head\r\n// This affects ALL elements in your application\r\nconst GlobalStyle = createGlobalStyle`\r\n  /* Universal box-sizing for more predictable layouts */\r\n  * {\r\n    box-sizing: border-box;    /* Include padding and border in element width/height */\r\n  }\r\n\r\n  /* Reset and base styles for the body element */\r\n  body {\r\n    margin: 0;                 /* Remove default browser margins */\r\n    padding: 0;                /* Remove default browser padding */\r\n    \r\n    /* Theme-aware typography */\r\n    font-family: ${({ theme }) => theme.typography.fontFamily};\r\n    background-color: ${({ theme }) => theme.colors.background};\r\n    color: ${({ theme }) => theme.colors.text};\r\n    \r\n    /* Additional body styles for better UX */\r\n    line-height: 1.6;          /* Improve text readability */\r\n    -webkit-font-smoothing: antialiased;  /* Better font rendering on macOS */\r\n  }\r\n\r\n  /* Consistent heading spacing using theme values */\r\n  h1, h2, h3, h4, h5, h6 {\r\n    margin: 0 0 ${({ theme }) => theme.spacing.md} 0;  /* Bottom margin only */\r\n    font-weight: 600;          /* Slightly bolder headings */\r\n    line-height: 1.2;          /* Tighter line height for headings */\r\n  }\r\n\r\n  /* Reset button styles to inherit from parent */\r\n  button {\r\n    font-family: inherit;      /* Use same font as parent */\r\n    font-size: inherit;        /* Don\'t let browser override font size */\r\n  }\r\n  \r\n  /* Remove default list styling when lists are used for navigation */\r\n  ul, ol {\r\n    padding-left: 0;\r\n    margin: 0;\r\n  }\r\n  \r\n  /* Better link styling */\r\n  a {\r\n    color: ${({ theme }) => theme.colors.primary};\r\n    text-decoration: none;\r\n    \r\n    &:hover {\r\n      text-decoration: underline;\r\n    }\r\n  }\r\n  \r\n  /* Responsive images by default */\r\n  img {\r\n    max-width: 100%;\r\n    height: auto;\r\n  }\r\n`;\r\n\r\n// App component with global styles applied\r\nfunction App() {\r\n  return (\r\n    <ThemeProvider theme={theme}>\r\n      {/* Global styles must be inside ThemeProvider to access theme */}\r\n      <GlobalStyle />\r\n\r\n      {/* Rest of your application components */}\r\n      {/* All components will inherit these global styles */}\r\n    </ThemeProvider>\r\n  );\r\n}\r\n\r\n// Note: GlobalStyle is a component, not a regular styled component\r\n// It should be rendered once at the root level of your application\r\n// Multiple GlobalStyle components can be used if needed\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this section covers"}),": Performance optimization strategies to ensure your styled-components render efficiently and don't cause unnecessary re-renders."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key optimization principles"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Minimize function calls in template literals"}),"\n",(0,s.jsx)(n.li,{children:"Use static object syntax for unchanging styles"}),"\n",(0,s.jsx)(n.li,{children:"Memoize expensive computations"}),"\n",(0,s.jsx)(n.li,{children:"Extract complex logic outside of styled components"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance impact"}),": Proper optimization can reduce bundle size and improve runtime performance"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Technique 1: Use object styles for completely static styles\r\n// This is more performant than template literals for static content\r\n// because it doesn\'t need to be processed on every render\r\nconst StaticButton = styled.button({\r\n  padding: "12px 24px" /* Static padding value */,\r\n  border: "none" /* Static border removal */,\r\n  borderRadius: "4px" /* Static border radius */,\r\n  cursor: "pointer" /* Static cursor style */,\r\n  // Use this approach when styles never change based on props or theme\r\n});\r\n\r\n// Technique 2: Memoize expensive computations using css helper\r\nimport { css } from "styled-components";\r\n\r\n// Pre-computed CSS blocks that can be reused\r\n// These are created once and cached, not recreated on every render\r\nconst buttonVariants = {\r\n  primary: css`\r\n    background-color: #007bff; /* Primary blue background */\r\n    color: white; /* White text */\r\n  `,\r\n  secondary: css`\r\n    background-color: #6c757d; /* Secondary gray background */\r\n    color: white; /* White text */\r\n  `,\r\n  // Add more variants as needed\r\n};\r\n\r\n// Optimized button that uses pre-computed variants\r\nconst OptimizedButton = styled.button`\r\n  /* Static styles that never change */\r\n  padding: 12px 24px;\r\n  border: none;\r\n  border-radius: 4px;\r\n  cursor: pointer;\r\n\r\n  /* Dynamic styles using memoized CSS blocks */\r\n  ${(props) => buttonVariants[props.variant] || buttonVariants.primary}\r\n`;\r\n\r\n// Technique 3: Avoid inline functions - they hurt performance\r\n\r\n// \u274c BAD: Creates new function on every render\r\n// This causes styled-components to think the styles changed\r\n// even when the props are the same\r\nconst BadButton = styled.button`\r\n  color: ${(props) => (props.primary ? "white" : "black")};\r\n`;\r\n\r\n// \u2705 GOOD: Extract function outside of component\r\n// This function is created once and reused\r\nconst getButtonColor = (props) => (props.primary ? "white" : "black");\r\n\r\nconst GoodButton = styled.button`\r\n  color: ${getButtonColor}; /* Reference to stable function */\r\n`;\r\n\r\n// \u2705 ALTERNATIVE: Use css helper for conditional styles\r\nconst AlternativeButton = styled.button`\r\n  ${(props) =>\r\n    props.primary &&\r\n    css`\r\n      color: white;\r\n      background-color: blue;\r\n    `}\r\n  ${(props) =>\r\n    !props.primary &&\r\n    css`\r\n      color: black;\r\n      background-color: gray;\r\n    `}\r\n`;\r\n\r\n// Performance tip: For frequently changing props, consider using CSS custom properties\r\nconst CSSVariableButton = styled.button`\r\n  --button-color: ${(props) => props.color};\r\n  color: var(--button-color);\r\n  /* Browser handles the CSS variable changes more efficiently */\r\n`;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"server-side-rendering-ssr",children:"Server-Side Rendering (SSR)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this demonstrates"}),": How to properly configure styled-components for server-side rendering to prevent styling issues and improve performance."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"SSR challenges with CSS-in-JS"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Styles are generated at runtime, but SSR happens before JavaScript runs"}),"\n",(0,s.jsx)(n.li,{children:"Without proper setup, you get unstyled content flash (FOUC)"}),"\n",(0,s.jsx)(n.li,{children:"Style injection must happen on the server and be rehydrated on the client"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),": Use ServerStyleSheet to collect styles during SSR and inject them into the initial HTML"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),": Faster first paint, better SEO, no flash of unstyled content"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Server-side rendering setup for Next.js\r\n// This ensures styles are available immediately when the page loads\r\nimport Document from \"next/document\";\r\nimport { ServerStyleSheet } from \"styled-components\";\r\n\r\n// Custom Document component that handles SSR style injection\r\nexport default class MyDocument extends Document {\r\n  static async getInitialProps(ctx) {\r\n    // Create a new ServerStyleSheet instance for this request\r\n    const sheet = new ServerStyleSheet();\r\n\r\n    // Store the original renderPage function\r\n    const originalRenderPage = ctx.renderPage;\r\n\r\n    try {\r\n      // Override renderPage to collect styles during rendering\r\n      ctx.renderPage = () =>\r\n        originalRenderPage({\r\n          // Enhance the App component to collect styles\r\n          enhanceApp: (App) => (props) =>\r\n            // Wrap the app with ServerStyleSheet to collect all styled-component styles\r\n            sheet.collectStyles(<App {...props} />),\r\n        });\r\n\r\n      // Get the initial props from the default Document\r\n      const initialProps = await Document.getInitialProps(ctx);\r\n\r\n      // Return the props with collected styles\r\n      return {\r\n        ...initialProps,\r\n        styles: (\r\n          <>\r\n            {/* Include any existing styles */}\r\n            {initialProps.styles}\r\n            {/* Add the collected styled-components styles */}\r\n            {sheet.getStyleElement()}\r\n          </>\r\n        ),\r\n      };\r\n    } finally {\r\n      // Clean up the style sheet to prevent memory leaks\r\n      sheet.seal();\r\n    }\r\n  }\r\n}\r\n\r\n// Alternative setup for other SSR frameworks (Express + React):\r\n// import { renderToString } from 'react-dom/server';\r\n// import { ServerStyleSheet } from 'styled-components';\r\n//\r\n// app.get('/', (req, res) => {\r\n//   const sheet = new ServerStyleSheet();\r\n//   try {\r\n//     const html = renderToString(\r\n//       sheet.collectStyles(<App />)\r\n//     );\r\n//     const styleTags = sheet.getStyleTags();\r\n//\r\n//     res.send(`\r\n//       <!DOCTYPE html>\r\n//       <html>\r\n//         <head>\r\n//           ${styleTags}\r\n//         </head>\r\n//         <body>\r\n//           <div id=\"root\">${html}</div>\r\n//         </body>\r\n//       </html>\r\n//     `);\r\n//   } finally {\r\n//     sheet.seal();\r\n//   }\r\n// });\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"component-organization",children:"Component Organization"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this demonstrates"}),": Best practices for organizing styled components in a maintainable and scalable way."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Organization benefits"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Clear separation of concerns"}),"\n",(0,s.jsx)(n.li,{children:"Easy to locate and maintain styles"}),"\n",(0,s.jsx)(n.li,{children:"Consistent file structure across the project"}),"\n",(0,s.jsx)(n.li,{children:"Better collaboration in team environments"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Recommended structure"}),": Keep styled components in separate files but close to their usage"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Alternative patterns"}),": Co-location, style directories, theme-based organization"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// File structure approach 1: Separate styles file\r\n// ComponentName/index.js - Main component logic\r\nimport { StyledWrapper, StyledTitle } from "./styles";\r\n\r\n// Clean component file focused on logic and structure\r\nexport function MyComponent({ title, children }) {\r\n  return (\r\n    <StyledWrapper>\r\n      <StyledTitle>{title}</StyledTitle>\r\n      {children}\r\n    </StyledWrapper>\r\n  );\r\n}\r\n\r\n// ComponentName/styles.js - All styling for this component\r\n// This keeps styles organized and easy to find\r\nexport const StyledWrapper = styled.div`\r\n  padding: 20px; /* Container spacing */\r\n  border: 1px solid #e0e0e0; /* Light border */\r\n  border-radius: 8px; /* Rounded corners */\r\n  background-color: white; /* Clean background */\r\n\r\n  /* Add responsive behavior */\r\n  @media (max-width: 768px) {\r\n    padding: 16px; /* Less padding on mobile */\r\n  }\r\n`;\r\n\r\nexport const StyledTitle = styled.h2`\r\n  margin: 0 0 16px 0; /* Bottom margin only */\r\n  color: #333; /* Dark gray text */\r\n  font-size: 1.5rem; /* Relative font size */\r\n  font-weight: 600; /* Semi-bold weight */\r\n  line-height: 1.2; /* Tight line height for headings */\r\n`;\r\n\r\n// Alternative approach 1: Co-location (styles in same file)\r\n// MyComponent.js\r\n// const StyledWrapper = styled.div`...`;\r\n// const StyledTitle = styled.h2`...`;\r\n// export function MyComponent() { ... }\r\n\r\n// Alternative approach 2: Theme-based organization\r\n// styles/\r\n//   components/\r\n//     Button.js\r\n//     Card.js\r\n//   layout/\r\n//     Grid.js\r\n//     Container.js\r\n//   typography/\r\n//     Heading.js\r\n//     Text.js\r\n\r\n// Alternative approach 3: Feature-based organization\r\n// features/\r\n//   user-profile/\r\n//     components/\r\n//       UserCard/\r\n//         index.js\r\n//         styles.js\r\n//     styles/\r\n//       shared.js\n'})}),"\n",(0,s.jsx)(n.h3,{id:"naming-conventions",children:"Naming Conventions"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this covers"}),": Best practices for naming styled components to improve code readability and maintainability."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Naming principles"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use descriptive names that indicate purpose or content"}),"\n",(0,s.jsx)(n.li,{children:"Include the component type or role in the name"}),"\n",(0,s.jsx)(n.li,{children:"Avoid generic names that don't provide context"}),"\n",(0,s.jsx)(n.li,{children:"Be consistent across your codebase"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),": Easier debugging, better code understanding, improved team collaboration"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// \u2705 GOOD: Clear, descriptive names that explain purpose\r\nconst NavigationHeader = styled.header`\r\n  /* Clearly indicates this is a header for navigation */\r\n  display: flex;\r\n  justify-content: space-between;\r\n  padding: 1rem 2rem;\r\n  background-color: white;\r\n  border-bottom: 1px solid #e0e0e0;\r\n`;\r\n\r\nconst PrimaryActionButton = styled.button`\r\n  /* Name indicates this is the main action button */\r\n  background-color: #007bff;\r\n  color: white;\r\n  padding: 12px 24px;\r\n  border: none;\r\n  border-radius: 4px;\r\n  font-weight: 600;\r\n`;\r\n\r\nconst ProductCardContainer = styled.div`\r\n  /* Clearly shows this contains product card content */\r\n  display: flex;\r\n  flex-direction: column;\r\n  border: 1px solid #ddd;\r\n  border-radius: 8px;\r\n  padding: 16px;\r\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\r\n`;\r\n\r\n// \u2705 MORE GOOD EXAMPLES:\r\nconst UserProfileSection = styled.section``;\r\nconst SearchInputField = styled.input``;\r\nconst LoadingSpinner = styled.div``;\r\nconst ErrorMessageText = styled.p``;\r\nconst ModalOverlay = styled.div``;\r\n\r\n// \u274c AVOID: Generic or unclear names\r\nconst Wrapper = styled.div`\r\n  /* What does this wrap? Too generic */\r\n`;\r\n\r\nconst Container = styled.div`\r\n  /* What does this contain? Not descriptive */\r\n`;\r\n\r\nconst StyledDiv = styled.div`\r\n  /* Just says it's styled, but doesn't indicate purpose */\r\n`;\r\n\r\nconst Component = styled.div`\r\n  /* Extremely generic, provides no information */\r\n`;\r\n\r\n// \u274c MORE TO AVOID:\r\nconst Box = styled.div`;          /* Too generic */\r\nconst Element = styled.span`; /* Meaningless */\r\nconst Thing = styled.div`;        /* Unhelpful */\r\nconst MyStyledComponent = styled.div`; /* Not descriptive */\r\n\r\n// \u2705 NAMING PATTERNS TO FOLLOW:\r\n// For layout: HeaderSection, MainContent, SidebarPanel\r\n// For UI elements: SubmitButton, CancelLink, ErrorIcon\r\n// For cards/containers: ProductCard, UserProfile, CommentBlock\r\n// For form elements: EmailInput, PasswordField, SubmitButton\r\n// For navigation: NavLink, BreadcrumbItem, MenuToggle\n"})}),"\n",(0,s.jsx)(n.h3,{id:"performance-guidelines",children:"Performance Guidelines"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this covers"}),": Performance best practices to ensure your styled components render efficiently and don't cause performance bottlenecks."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key performance principles"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Keep complex logic outside of template literals"}),"\n",(0,s.jsx)(n.li,{children:"Use simple conditions for dynamic styles"}),"\n",(0,s.jsx)(n.li,{children:"Extract expensive computations to external functions"}),"\n",(0,s.jsx)(n.li,{children:"Order styles logically (static first, then dynamic)"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance impact"}),": Following these guidelines prevents unnecessary re-renders and keeps your app responsive"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// \u2705 GOOD: Well-structured component with performance in mind\r\nconst Button = styled.button`\r\n  /* Static styles first - these never change and are most efficient */\r\n  padding: 12px 24px; /* Always the same padding */\r\n  border: none; /* Always remove border */\r\n  border-radius: 4px; /* Always rounded corners */\r\n  cursor: pointer; /* Always show pointer cursor */\r\n  font-size: 16px; /* Consistent font size */\r\n  transition: all 0.2s ease; /* Smooth transitions */\r\n\r\n  /* Simple dynamic styles - minimal performance impact */\r\n  background-color: ${(props) => (props.primary ? "#007bff" : "#6c757d")};\r\n  color: ${(props) => (props.primary ? "white" : "#333")};\r\n\r\n  /* Complex logic extracted to external functions - computed once */\r\n  ${(props) => getButtonVariant(props.variant)}\r\n  ${(props) => getButtonSize(props.size)}\r\n`;\r\n\r\n// External functions are created once, not on every render\r\nconst getButtonVariant = (variant) => {\r\n  const variants = {\r\n    success: "background-color: #28a745; color: white;",\r\n    danger: "background-color: #dc3545; color: white;",\r\n    warning: "background-color: #ffc107; color: black;",\r\n  };\r\n  return variants[variant] || "";\r\n};\r\n\r\nconst getButtonSize = (size) => {\r\n  const sizes = {\r\n    small: "padding: 6px 12px; font-size: 14px;",\r\n    large: "padding: 16px 32px; font-size: 18px;",\r\n  };\r\n  return sizes[size] || "";\r\n};\r\n\r\n// \u274c BAD: Expensive computations inside template literals\r\nconst BadButton = styled.button`\r\n  /* This runs on EVERY render, even when props haven\'t changed */\r\n  color: ${(props) => {\r\n    // Complex computation that happens repeatedly\r\n    const colors = calculateColors(props.theme); // Expensive function call\r\n    const matchedColor = colors.find((color) => color.name === props.variant);\r\n    const finalColor = matchedColor?.value || "black";\r\n\r\n    // Additional processing that slows down renders\r\n    return finalColor.toUpperCase();\r\n  }};\r\n\r\n  /* Another expensive operation */\r\n  font-size: ${(props) => {\r\n    // Complex calculation on every render\r\n    const baseSize = 16;\r\n    const multiplier =\r\n      props.theme.typography.sizeMultipliers.find((m) => m.name === props.size)\r\n        ?.value || 1;\r\n    return `${baseSize * multiplier}px`;\r\n  }};\r\n`;\r\n\r\n// \u2705 BETTER: Extract complex logic to memoized functions or external modules\r\nimport { useMemo } from "react";\r\n\r\n// Memoized computation (if used in a component)\r\nconst OptimizedComponent = ({ variant, theme }) => {\r\n  const buttonColor = useMemo(() => {\r\n    const colors = calculateColors(theme);\r\n    return colors.find((color) => color.name === variant)?.value || "black";\r\n  }, [variant, theme]);\r\n\r\n  return <OptimizedButton color={buttonColor}>Click me</OptimizedButton>;\r\n};\r\n\r\nconst OptimizedButton = styled.button`\r\n  /* Use the pre-computed value */\r\n  color: ${(props) => props.color};\r\n`;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Styled Components revolutionizes how we approach styling in React applications by bringing CSS directly into the component paradigm. By leveraging tagged template literals and providing powerful features like theming, props-based styling, and automatic scoping, it eliminates many traditional CSS pain points while maintaining the full power of CSS."}),"\n",(0,s.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Component-Scoped Styling"}),": Eliminates global CSS conflicts through automatic scoping"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic Styling"}),": Props-based conditional styling enables flexible, reusable components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Powerful Theming"}),": Centralized theme management with context-based propagation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance Considerations"}),": Proper usage patterns ensure optimal runtime performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Developer Experience"}),": Excellent tooling support and debugging capabilities"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Styled Components continues to be a popular choice for modern React applications, offering a balance of flexibility, maintainability, and performance. As referenced in the ",(0,s.jsx)(n.a,{href:"https://github.com/styled-components/styled-components",children:"Styled Components GitHub repository"}),", the library remains actively maintained with a strong community and comprehensive documentation."]}),"\n",(0,s.jsx)(n.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://styled-components.com/docs",children:"Styled Components Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/styled-components/styled-components",children:"Styled Components GitHub Repository"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://styled-components.com/docs/best-practices",children:"CSS-in-JS Best Practices"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://styled-components.com/docs/faqs#performance",children:"Performance Optimization Guide"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(6540);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);