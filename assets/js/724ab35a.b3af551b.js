"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9398],{2017:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"project-detail/recharts","title":"Recharts: React Data Visualization Library","description":"Table of Contents","source":"@site/docs/project-detail/recharts.md","sourceDirName":"project-detail","slug":"/project-detail/recharts","permalink":"/frontend-system-design/docs/project-detail/recharts","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/recharts.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"React Router: Declarative Routing for React","permalink":"/frontend-system-design/docs/project-detail/react-router"},"next":{"title":"Single-SPA: Microfrontend Framework","permalink":"/frontend-system-design/docs/project-detail/single-spa"}}');var i=t(4848),s=t(8453);const r={},o="Recharts: React Data Visualization Library",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Principles",id:"key-principles",level:3},{value:"Getting Started",id:"getting-started",level:2},{value:"Installation",id:"installation",level:3},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Component Composition",id:"component-composition",level:3},{value:"Data Structure",id:"data-structure",level:3},{value:"Under the Hood: How Recharts Works",id:"under-the-hood-how-recharts-works",level:2},{value:"Component Rendering Process",id:"component-rendering-process",level:3},{value:"D3 Integration",id:"d3-integration",level:3},{value:"Component Architecture",id:"component-architecture",level:2},{value:"Container Components",id:"container-components",level:3},{value:"Data Components",id:"data-components",level:3},{value:"Data Processing and Scaling",id:"data-processing-and-scaling",level:2},{value:"Domain and Range Calculations",id:"domain-and-range-calculations",level:3},{value:"Data Transformation",id:"data-transformation",level:3},{value:"SVG Rendering System",id:"svg-rendering-system",level:2},{value:"SVG Structure",id:"svg-structure",level:3},{value:"Animation System",id:"animation-system",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Custom Components",id:"custom-components",level:3},{value:"Event Handling",id:"event-handling",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Memoization and Optimization",id:"memoization-and-optimization",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Component Organization",id:"component-organization",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Further Resources",id:"further-resources",level:3}];function d(n){const e={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"recharts-react-data-visualization-library",children:"Recharts: React Data Visualization Library"})}),"\n",(0,i.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#getting-started",children:"Getting Started"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#core-concepts",children:"Core Concepts"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#under-the-hood-how-recharts-works",children:"Under the Hood: How Recharts Works"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#component-architecture",children:"Component Architecture"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#data-processing-and-scaling",children:"Data Processing and Scaling"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#svg-rendering-system",children:"SVG Rendering System"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#advanced-features",children:"Advanced Features"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(e.p,{children:["Recharts is a React charting library built with React and D3. As highlighted in the ",(0,i.jsx)(e.a,{href:"https://github.com/recharts/recharts",children:"Recharts GitHub repository"}),", it provides a redefined chart library that emphasizes simplicity, native SVG support, and declarative components for building data visualizations."]}),"\n",(0,i.jsx)(e.h3,{id:"key-principles",children:"Key Principles"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Simply deploy with React components"}),": Declarative API that feels natural to React developers"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Native SVG support"}),": Lightweight with minimal dependencies"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Declarative components"}),": Compose charts using React component patterns"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,i.jsx)(e.h3,{id:"installation",children:"Installation"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"What this does"}),": Install Recharts library and its peer dependency ",(0,i.jsx)(e.code,{children:"react-is"})," which is required for React component type checking."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Input"}),": Package manager command",(0,i.jsx)(e.br,{}),"\n",(0,i.jsx)(e.strong,{children:"Output"}),": Recharts library installed in your project with all dependencies"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Install Recharts with npm (most common)\nnpm install recharts react-is\n\n# Or using yarn (alternative package manager)\nyarn add recharts react-is\n\n# Or using pnpm (faster, disk space efficient)\npnpm add recharts react-is\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Note"}),": ",(0,i.jsx)(e.code,{children:"react-is"})," is a peer dependency that Recharts uses internally for React component validation and type checking."]}),"\n",(0,i.jsx)(e.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"What this code does"}),": Creates a responsive line chart displaying sales and profit data over time with interactive features like tooltips and legends."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Import necessary Recharts components"}),"\n",(0,i.jsx)(e.li,{children:"Define sample data with consistent structure"}),"\n",(0,i.jsx)(e.li,{children:"Create a responsive chart component with multiple data lines"}),"\n",(0,i.jsx)(e.li,{children:"Configure visual elements (grid, axes, tooltips)"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Input"}),": Array of data objects with consistent properties",(0,i.jsx)(e.br,{}),"\n",(0,i.jsx)(e.strong,{children:"Output"}),": Interactive line chart rendered as SVG"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'import React from "react";\nimport {\n  LineChart, // Main chart container for line charts\n  Line, // Individual line component for data series\n  XAxis, // Horizontal axis component\n  YAxis, // Vertical axis component\n  CartesianGrid, // Background grid lines\n  Tooltip, // Interactive hover information\n  Legend, // Chart legend for data series\n  ResponsiveContainer, // Auto-sizing wrapper\n} from "recharts";\n\n// Sample data: Each object represents one data point with multiple metrics\nconst data = [\n  { name: "Jan", sales: 4000, profit: 2400, expenses: 2400 },\n  { name: "Feb", sales: 3000, profit: 1398, expenses: 2210 },\n  { name: "Mar", sales: 2000, profit: 9800, expenses: 2290 },\n  { name: "Apr", sales: 2780, profit: 3908, expenses: 2000 },\n  { name: "May", sales: 1890, profit: 4800, expenses: 2181 },\n  { name: "Jun", sales: 2390, profit: 3800, expenses: 2500 },\n];\n\nconst SimpleChart = () => {\n  return (\n    // ResponsiveContainer automatically adjusts chart size to parent\n    <ResponsiveContainer width="100%" height={400}>\n      <LineChart\n        data={data} // Pass data to chart\n        margin={{ top: 20, right: 30, left: 20, bottom: 5 }} // Chart padding\n      >\n        {/* Grid lines for better readability */}\n        <CartesianGrid strokeDasharray="3 3" />\n\n        {/* X-axis showing month names */}\n        <XAxis dataKey="name" />\n\n        {/* Y-axis with automatic scaling */}\n        <YAxis />\n\n        {/* Interactive tooltip on hover */}\n        <Tooltip />\n\n        {/* Legend showing data series names */}\n        <Legend />\n\n        {/* First data line: Sales */}\n        <Line\n          type="monotone" // Smooth curved line\n          dataKey="sales" // Data property to plot\n          stroke="#8884d8" // Line color (blue)\n          strokeWidth={2} // Line thickness\n          dot={{ r: 4 }} // Regular dot size\n          activeDot={{ r: 6 }} // Hover dot size (larger)\n        />\n\n        {/* Second data line: Profit */}\n        <Line\n          type="monotone" // Smooth curved line\n          dataKey="profit" // Data property to plot\n          stroke="#82ca9d" // Line color (green)\n          strokeWidth={2} // Line thickness\n        />\n      </LineChart>\n    </ResponsiveContainer>\n  );\n};\n\nexport default SimpleChart;\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Key Features"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Responsive Design"}),": Automatically adapts to container size"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Multiple Data Series"}),": Can display multiple metrics on same chart"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Interactive Elements"}),": Hover tooltips and clickable legend"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Smooth Curves"}),": Uses monotone interpolation for natural-looking lines"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsx)(e.h3,{id:"component-composition",children:"Component Composition"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"What this demonstrates"}),": How Recharts uses React's composition pattern to build complex charts from small, reusable components."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Concept"}),": Instead of monolithic chart components, you compose charts by combining specialized components for different purposes (containers, visual elements, coordinate systems, interactions)."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Benefits"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Modularity"}),": Each component has a single responsibility"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Reusability"}),": Components can be mixed and matched across chart types"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Flexibility"}),": Easy to customize or replace individual parts"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// 1. CHART CONTAINERS - Define the chart type and layout\nimport {\n  LineChart, // For line/trend visualizations\n  BarChart, // For categorical comparisons\n  PieChart, // For part-to-whole relationships\n  AreaChart, // For cumulative data over time\n  ScatterChart, // For correlation analysis\n} from "recharts";\n\n// 2. VISUAL ELEMENTS - Components that render actual data\nimport {\n  Line, // Line segments connecting data points\n  Bar, // Rectangular bars for categorical data\n  Pie, // Pie slices for proportional data\n  Area, // Filled areas under lines\n  Scatter, // Individual points for scatter plots\n} from "recharts";\n\n// 3. COORDINATE SYSTEM - Components that define chart axes and grids\nimport {\n  XAxis, // Horizontal axis (usually categories or time)\n  YAxis, // Vertical axis (usually values)\n  ZAxis, // Third dimension for bubble charts\n  PolarGrid, // Circular grid for polar charts\n  RadialBar, // Radial bars for circular bar charts\n} from "recharts";\n\n// 4. LAYOUT AND INTERACTION - Components for user experience\nimport {\n  CartesianGrid, // Background grid lines\n  Tooltip, // Hover information boxes\n  Legend, // Chart legend for data series\n  ResponsiveContainer, // Auto-sizing wrapper\n} from "recharts";\n\n// Example of composition: Building a chart by combining components\nconst ComposedChart = () => (\n  <ResponsiveContainer width="100%" height={400}>\n    {/* Chart container defines the chart type */}\n    <LineChart data={data}>\n      {/* Coordinate system components */}\n      <CartesianGrid strokeDasharray="3 3" /> {/* Background grid */}\n      <XAxis dataKey="name" /> {/* X-axis using \'name\' field */}\n      <YAxis /> {/* Y-axis with auto-scaling */}\n      {/* Interactive elements */}\n      <Tooltip /> {/* Show data on hover */}\n      <Legend /> {/* Show series names */}\n      {/* Data visualization components */}\n      <Line dataKey="sales" stroke="#8884d8" /> {/* Sales line in blue */}\n      <Line dataKey="profit" stroke="#82ca9d" /> {/* Profit line in green */}\n    </LineChart>\n  </ResponsiveContainer>\n);\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Component Hierarchy"}),":"]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"ResponsiveContainer"})," (outermost wrapper)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Chart Container"})," (LineChart, BarChart, etc.)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Coordinate Components"})," (XAxis, YAxis, Grid)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Interactive Components"})," (Tooltip, Legend)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Data Components"})," (Line, Bar, Area, etc.)"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"data-structure",children:"Data Structure"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"What this shows"}),": Different data structures that Recharts can work with, from simple to complex scenarios."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Key Principle"}),": Recharts expects data as an array of objects where each object represents one data point with consistent properties."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Requirements"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Array format (not single objects)"}),"\n",(0,i.jsx)(e.li,{children:"Consistent property names across all data points"}),"\n",(0,i.jsx)(e.li,{children:"Flat structure preferred (though nesting is possible with custom accessors)"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// 1. BASIC DATA STRUCTURE - Most common pattern\n// Each object = one data point, properties = different metrics\nconst chartData = [\n  { category: "A", value: 100, secondary: 200 }, // Data point 1\n  { category: "B", value: 150, secondary: 180 }, // Data point 2\n  { category: "C", value: 120, secondary: 220 }, // Data point 3\n];\n// Usage: <XAxis dataKey="category" /> <Line dataKey="value" />\n\n// 2. COMPLEX DATA WITH NESTED OBJECTS - Requires custom accessors\n// Useful when you have hierarchical data from APIs\nconst complexData = [\n  {\n    month: "Jan", // Primary identifier\n    metrics: {\n      // Nested metrics object\n      revenue: 4000,\n      costs: 2400,\n      users: 1200,\n    },\n    breakdown: [\n      // Array of sub-categories\n      { type: "product", value: 3000 },\n      { type: "service", value: 1000 },\n    ],\n  },\n  // ... more months\n];\n// Usage: <Line dataKey="metrics.revenue" /> or custom accessor function\n\n// 3. TIME SERIES DATA - For temporal visualizations\n// Common in dashboards and monitoring applications\nconst timeSeriesData = [\n  { timestamp: "2024-01-01T00:00:00Z", value: 100, trend: "up" },\n  { timestamp: "2024-01-02T00:00:00Z", value: 120, trend: "up" },\n  { timestamp: "2024-01-03T00:00:00Z", value: 98, trend: "down" },\n];\n// Usage: <XAxis dataKey="timestamp" type="category" />\n//        <Line dataKey="value" />\n\n// 4. MULTI-METRIC DATA - Multiple measurements per data point\nconst businessData = [\n  {\n    quarter: "Q1",\n    revenue: 100000,\n    expenses: 75000,\n    profit: 25000,\n    growth: 15.5, // Percentage\n    customers: 1250, // Count\n  },\n  {\n    quarter: "Q2",\n    revenue: 120000,\n    expenses: 85000,\n    profit: 35000,\n    growth: 20.0,\n    customers: 1500,\n  },\n];\n// Can plot multiple lines: revenue, expenses, profit on same chart\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Data Structure Best Practices"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Consistent Keys"}),": All objects should have the same property names"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Flat Structure"}),": Avoid deep nesting when possible"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Meaningful Names"}),": Use descriptive property names for better accessibility"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Proper Types"}),": Numbers for numeric data, strings for categories"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"No Missing Values"}),": Handle nulls/undefined before passing to charts"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"under-the-hood-how-recharts-works",children:"Under the Hood: How Recharts Works"}),"\n",(0,i.jsx)(e.h3,{id:"component-rendering-process",children:"Component Rendering Process"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"What this shows"}),": The internal workings of how Recharts transforms data into SVG visualizations."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Process Overview"}),":"]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Data Processing"}),": Calculate domains and ranges from input data"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Scale Creation"}),": Use D3 to create mathematical functions that map data to pixel coordinates"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Path Generation"}),": Convert data points into SVG path strings"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"SVG Rendering"}),": Compose final SVG with all visual elements"]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Key Insight"}),": Recharts uses D3 for mathematical calculations but React for DOM rendering, combining the best of both libraries."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// Simplified Recharts rendering concept - shows the internal process\nclass LineChart extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      data: props.data, // Chart data\n      width: props.width, // Total chart width\n      height: props.height, // Total chart height\n    };\n  }\n\n  // STEP 1: Process data and calculate scales\n  // This transforms raw data into mathematical coordinate systems\n  processData() {\n    const { data, width, height, margin } = this.props;\n\n    // Calculate available space for actual chart (excluding margins)\n    const chartWidth = width - margin.left - margin.right; // Space for data\n    const chartHeight = height - margin.top - margin.bottom; // Space for data\n\n    // Create D3 scales to map data values to pixel coordinates\n    const xScale = d3\n      .scaleLinear() // Linear scale for continuous data\n      .domain(d3.extent(data, (d) => d.x)) // Input range: [min_x, max_x]\n      .range([0, chartWidth]); // Output range: [0, chart_width]\n\n    const yScale = d3\n      .scaleLinear() // Linear scale for continuous data\n      .domain(d3.extent(data, (d) => d.y)) // Input range: [min_y, max_y]\n      .range([chartHeight, 0]); // Output range: [chart_height, 0] - inverted for SVG\n\n    return { xScale, yScale, chartWidth, chartHeight };\n  }\n\n  // STEP 2: Generate SVG path data\n  // Converts data points into a single SVG path string\n  generatePath(data, xScale, yScale) {\n    const line = d3\n      .line() // D3 line generator\n      .x((d) => xScale(d.x)) // X coordinate from data\n      .y((d) => yScale(d.y)) // Y coordinate from data\n      .curve(d3.curveMonotoneX); // Smooth curve interpolation\n\n    return line(data); // Returns SVG path string like "M10,20L30,40L50,60"\n  }\n\n  // STEP 3: Render SVG elements\n  // Combines all visual elements into final SVG structure\n  render() {\n    // Get calculated scales and dimensions\n    const { xScale, yScale, chartWidth, chartHeight } = this.processData();\n\n    // Generate path string for the line\n    const pathData = this.generatePath(this.props.data, xScale, yScale);\n\n    return (\n      <svg width={this.props.width} height={this.props.height}>\n        {/* Main chart group with margin offset */}\n        <g\n          transform={`translate(${this.props.margin.left}, ${this.props.margin.top})`}\n        >\n          {/* Invisible chart area for event handling */}\n          <rect\n            width={chartWidth}\n            height={chartHeight}\n            fill="transparent"\n            className="chart-background"\n          />\n          {/* Background grid lines for readability */}\n          {this.renderGrid(xScale, yScale, chartWidth, chartHeight)}\n          {/* Chart axes with labels and tick marks */}\n          {this.renderXAxis(xScale, chartHeight)} {/* Bottom axis */}\n          {this.renderYAxis(yScale)} {/* Left axis */}\n          {/* The actual data line */}\n          <path\n            d={pathData} // SVG path string\n            fill="none" // No fill, just stroke\n            stroke="#8884d8" // Line color\n            strokeWidth={2} // Line thickness\n            className="data-line"\n          />\n          {/* Individual data points as circles */}\n          {this.renderDataPoints(this.props.data, xScale, yScale)}\n        </g>\n      </svg>\n    );\n  }\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Rendering Pipeline"}),":"]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Props \u2192 State"}),": Receive data and dimensions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Data \u2192 Scales"}),": Calculate mathematical mappings"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Scales \u2192 Paths"}),": Generate SVG path strings"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Paths \u2192 SVG"}),": Render final visual elements"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Interactions"}),": Handle mouse events and updates"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"d3-integration",children:"D3 Integration"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"What this demonstrates"}),": How Recharts leverages D3's mathematical functions while keeping React in control of rendering."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Architecture"}),': Recharts uses D3 as a "calculation engine" rather than a rendering library. D3 handles complex mathematical transformations (scales, shapes, statistics) while React manages the DOM and component lifecycle.']}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Benefits"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Performance"}),": D3's optimized mathematical functions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Flexibility"}),": Access to D3's extensive scale and shape libraries"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"React Integration"}),": Maintain React's declarative programming model"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Best of Both"}),": D3's math power + React's component architecture"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// How Recharts uses D3 for calculations while React handles rendering\nimport * as d3 from "d3-scale"; // Scaling functions\nimport * as d3Array from "d3-array"; // Array manipulation utilities\nimport * as d3Shape from "d3-shape"; // Path generation functions\n\nclass Chart {\n  // SCALE CREATION: Maps data values to visual coordinates\n  createScales(data, domain, range) {\n    // 1. LINEAR SCALE - For continuous numerical data\n    // Maps continuous input domain to continuous output range\n    const linearScale = d3\n      .scaleLinear()\n      .domain(domain) // Input range: [min_value, max_value]\n      .range(range); // Output range: [min_pixel, max_pixel]\n    // Example: domain([0, 100]) \u2192 range([0, 400]) means value 50 \u2192 pixel 200\n\n    // 2. BAND SCALE - For categorical data (bars, columns)\n    // Divides range into equal bands for each category\n    const bandScale = d3\n      .scaleBand()\n      .domain(data.map((d) => d.category)) // All category names\n      .range(range) // Available pixel space\n      .padding(0.1); // Space between bands (10%)\n    // Example: categories ["A", "B", "C"] \u2192 bands at pixels [0-120], [140-260], [280-400]\n\n    // 3. TIME SCALE - For temporal data (dates, timestamps)\n    // Handles time-based data with intelligent tick generation\n    const timeScale = d3\n      .scaleTime()\n      .domain(d3Array.extent(data, (d) => new Date(d.date))) // [earliest, latest]\n      .range(range); // Pixel range\n    // Example: domain([Jan 1, Dec 31]) \u2192 range([0, 800]) for one year timeline\n\n    return { linearScale, bandScale, timeScale };\n  }\n\n  // PATH GENERATION: Converts data points into SVG path strings\n  generateShapes(data, scales) {\n    // 1. LINE PATH - Connects data points with lines\n    const line = d3Shape\n      .line()\n      .x((d) => scales.xScale(d.x)) // X coordinate from data\n      .y((d) => scales.yScale(d.y)) // Y coordinate from data\n      .curve(d3Shape.curveMonotoneX); // Smooth interpolation\n    // Output: "M10,20L30,15L50,25" (SVG path string)\n\n    // 2. AREA PATH - Filled area under a line\n    const area = d3Shape\n      .area()\n      .x((d) => scales.xScale(d.x)) // X coordinate\n      .y0(scales.yScale(0)) // Bottom baseline (usually 0)\n      .y1((d) => scales.yScale(d.y)) // Top line (data values)\n      .curve(d3Shape.curveMonotoneX); // Smooth curves\n    // Output: Area path string for filled regions\n\n    // 3. PIE/ARC PATHS - For pie charts and donut charts\n    const pie = d3Shape\n      .pie()\n      .value((d) => d.value) // Extract numeric value\n      .sort(null); // Don\'t sort data automatically\n\n    const arc = d3Shape\n      .arc()\n      .innerRadius(0) // 0 = pie chart, >0 = donut chart\n      .outerRadius(100); // Size of pie\n\n    // Generate individual arc paths for each data slice\n    const pieData = pie(data); // Calculate angles and positions\n    const pieArcs = pieData.map(arc); // Convert to SVG path strings\n\n    return {\n      linePath: line(data), // Single line path\n      areaPath: area(data), // Single area path\n      pieArcs: pieArcs, // Array of arc paths\n    };\n  }\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"D3 vs React Responsibilities"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"D3 Handles"}),": Mathematical calculations, scales, path generation, data transformations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"React Handles"}),": Component lifecycle, DOM updates, event handling, state management"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"component-architecture",children:"Component Architecture"}),"\n",(0,i.jsx)(e.h3,{id:"container-components",children:"Container Components"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"What this shows"}),": How Recharts creates container components that manage chart layout, coordinate systems, and provide context to child components."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Purpose"}),': Container components handle the "infrastructure" concerns like sizing, scaling, and coordinate systems, allowing data components to focus purely on visualization.']}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Key Concepts"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Context Sharing"}),": Pass calculated scales and dimensions to all child components"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Responsive Design"}),": Automatically adapt to container size changes"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Separation of Concerns"}),": Containers handle layout, children handle data visualization"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// Chart containers manage layout and coordinate system\nconst ChartContainer = ({ width, height, children, data }) => {\n  // CONTEXT CREATION: Calculate and share common chart properties\n  const chartContext = {\n    data, // Raw chart data\n    scales: calculateScales(data, width, height), // D3 scale functions\n    dimensions: { width, height }, // Chart dimensions\n  };\n\n  // CONTEXT PROVIDER: Makes chart properties available to all children\n  return (\n    <ChartContext.Provider value={chartContext}>\n      <svg width={width} height={height}>\n        {/* All child components can access chartContext via useContext */}\n        {children}\n      </svg>\n    </ChartContext.Provider>\n  );\n};\n\n// RESPONSIVE CONTAINER: Automatically adjusts chart size to fit parent\nconst ResponsiveContainer = ({ children, aspect = 2 }) => {\n  // State to track current container dimensions\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const containerRef = useRef(); // Reference to DOM element\n\n  useEffect(() => {\n    // DIMENSION CALCULATION: Measure parent container and update chart size\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        const { offsetWidth } = containerRef.current; // Get available width\n        setDimensions({\n          width: offsetWidth, // Use full width\n          height: offsetWidth / aspect, // Calculate height from aspect ratio\n        });\n      }\n    };\n\n    // INITIAL SIZING: Set dimensions on first render\n    updateDimensions();\n\n    // RESPONSIVE UPDATES: Listen for window resize events\n    window.addEventListener("resize", updateDimensions);\n\n    // CLEANUP: Remove event listener when component unmounts\n    return () => window.removeEventListener("resize", updateDimensions);\n  }, [aspect]);\n\n  return (\n    <div\n      ref={containerRef}\n      style={{ width: "100%", height: "100%" }} // Fill parent container\n    >\n      {/* Only render chart when dimensions are available */}\n      {dimensions.width > 0 && React.cloneElement(children, dimensions)}\n    </div>\n  );\n};\n\n// USAGE EXAMPLE: How containers work together\nconst App = () => (\n  <ResponsiveContainer aspect={2}>\n    {" "}\n    {/* Outer responsive wrapper */}\n    <ChartContainer data={data}>\n      {" "}\n      {/* Inner chart context provider */}\n      <Line dataKey="sales" />{" "}\n      {/* Data component (gets context automatically) */}\n      <XAxis dataKey="month" /> {/* Axis component (gets scales from context) */}\n    </ChartContainer>\n  </ResponsiveContainer>\n);\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Container Responsibilities"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Layout Management"}),": Handle margins, padding, and available space"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Scale Calculation"}),": Create and share D3 scale functions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Responsive Behavior"}),": Adapt to container size changes"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Context Provision"}),": Share common properties with child components"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Event Coordination"}),": Manage interactions between components"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"data-components",children:"Data Components"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"What this shows"}),": How individual data visualization components render SVG elements based on processed data and scales."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Purpose"}),': Data components are the "visual elements" that actually draw your data. They receive scales from container components and transform data points into SVG paths, rectangles, circles, etc.']}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Key Principles"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Single Responsibility"}),": Each component handles one visualization type"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Performance"}),": Use memoization for expensive calculations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Flexibility"}),": Accept styling props for customization"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// LINE COMPONENT: Renders connected data points as SVG path\nconst Line = ({ dataKey, stroke, strokeWidth, data, xScale, yScale }) => {\n  // MEMOIZED PATH CALCULATION: Only recalculate when dependencies change\n  const pathData = useMemo(() => {\n    // Create D3 line generator with current scales\n    const line = d3\n      .line()\n      .x((d, i) => xScale(i)) // X position using index\n      .y((d) => yScale(d[dataKey])) // Y position using data value\n      .curve(d3.curveMonotoneX); // Smooth curve interpolation\n\n    return line(data); // Generate SVG path string: "M10,20L30,15L50,25..."\n  }, [data, dataKey, xScale, yScale]); // Recalculate when any dependency changes\n\n  // RENDER SVG PATH: Single path element for entire line\n  return (\n    <path\n      d={pathData} // SVG path string from D3\n      fill="none" // Lines have no fill, only stroke\n      stroke={stroke} // Line color\n      strokeWidth={strokeWidth} // Line thickness\n      className="recharts-line" // CSS class for styling\n    />\n  );\n};\n\n// BAR COMPONENT: Renders individual rectangles for categorical data\nconst Bar = ({ data, dataKey, fill, xScale, yScale }) => {\n  // RENDER MULTIPLE RECTANGLES: One rect per data point\n  return (\n    <g className="recharts-bar">\n      {" "}\n      {/* Group element to contain all bars */}\n      {data.map((entry, index) => (\n        <rect\n          key={index} // Unique key for React\n          x={xScale(index)} // Left edge position\n          y={yScale(entry[dataKey])} // Top edge position (SVG y=0 is top)\n          width={xScale.bandwidth()} // Bar width from band scale\n          height={yScale(0) - yScale(entry[dataKey])} // Bar height (distance from 0 to value)\n          fill={fill} // Bar color\n          className="recharts-bar-rectangle" // CSS class for individual bars\n        />\n      ))}\n    </g>\n  );\n};\n\n// AREA COMPONENT: Renders filled area under a line\nconst Area = ({ data, dataKey, fill, xScale, yScale }) => {\n  // GENERATE AREA PATH: Similar to line but with baseline\n  const areaPath = useMemo(() => {\n    const area = d3\n      .area()\n      .x((d, i) => xScale(i)) // X coordinate\n      .y0(yScale(0)) // Bottom baseline (usually 0)\n      .y1((d) => yScale(d[dataKey])) // Top line (data values)\n      .curve(d3.curveMonotoneX); // Smooth curves\n\n    return area(data); // Returns closed path that can be filled\n  }, [data, dataKey, xScale, yScale]);\n\n  return (\n    <path\n      d={areaPath}\n      fill={fill} // Areas have fill color\n      fillOpacity={0.6} // Semi-transparent\n      stroke="none" // No outline\n      className="recharts-area"\n    />\n  );\n};\n\n// SCATTER COMPONENT: Renders individual points\nconst Scatter = ({ data, dataKey, fill, xScale, yScale }) => {\n  return (\n    <g className="recharts-scatter">\n      {data.map((entry, index) => (\n        <circle\n          key={index}\n          cx={xScale(entry.x)} // Center X coordinate\n          cy={yScale(entry[dataKey])} // Center Y coordinate\n          r={4} // Radius\n          fill={fill} // Point color\n          className="recharts-scatter-point"\n        />\n      ))}\n    </g>\n  );\n};\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Data Component Patterns"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Path-based"}),": Line, Area (single SVG path for all data)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Shape-based"}),": Bar, Scatter (individual SVG shapes per data point)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memoization"}),": Cache expensive calculations using useMemo"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Responsive"}),": Automatically adapt when scales change"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"data-processing-and-scaling",children:"Data Processing and Scaling"}),"\n",(0,i.jsx)(e.h3,{id:"domain-and-range-calculations",children:"Domain and Range Calculations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// Data domain calculation\nconst calculateDomain = (data, dataKey, type = "number") => {\n  switch (type) {\n    case "number":\n      return d3.extent(data, (d) => d[dataKey]);\n\n    case "category":\n      return data.map((d) => d[dataKey]);\n\n    case "time":\n      return d3.extent(data, (d) => new Date(d[dataKey]));\n\n    default:\n      return [0, 1];\n  }\n};\n\n// Scale creation and management\nclass ScaleManager {\n  constructor(data, width, height, margin) {\n    this.data = data;\n    this.width = width;\n    this.height = height;\n    this.margin = margin;\n\n    this.chartWidth = width - margin.left - margin.right;\n    this.chartHeight = height - margin.top - margin.bottom;\n  }\n\n  createLinearScale(dataKey, range = [this.chartHeight, 0]) {\n    const domain = d3.extent(this.data, (d) => d[dataKey]);\n    return d3.scaleLinear().domain(domain).range(range);\n  }\n\n  createBandScale(dataKey, range = [0, this.chartWidth]) {\n    const domain = this.data.map((d) => d[dataKey]);\n    return d3.scaleBand().domain(domain).range(range).padding(0.1);\n  }\n\n  createTimeScale(dataKey, range = [0, this.chartWidth]) {\n    const domain = d3.extent(this.data, (d) => new Date(d[dataKey]));\n    return d3.scaleTime().domain(domain).range(range);\n  }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"data-transformation",children:"Data Transformation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// Data processing pipeline\nconst processChartData = (rawData, config) => {\n  // 1. Filter and validate data\n  const validData = rawData.filter(\n    (item) =>\n      item != null &&\n      typeof item === "object" &&\n      config.dataKeys.every((key) => item[key] != null)\n  );\n\n  // 2. Sort data if needed\n  const sortedData = config.sortBy\n    ? validData.sort((a, b) => a[config.sortBy] - b[config.sortBy])\n    : validData;\n\n  // 3. Aggregate data if needed\n  const aggregatedData = config.groupBy\n    ? groupAndAggregate(sortedData, config.groupBy, config.aggregation)\n    : sortedData;\n\n  // 4. Calculate derived values\n  const enrichedData = aggregatedData.map((item) => ({\n    ...item,\n    // Add calculated fields\n    total: config.dataKeys.reduce((sum, key) => sum + (item[key] || 0), 0),\n    percentage: (item[config.primaryKey] / config.total) * 100,\n  }));\n\n  return enrichedData;\n};\n\n// Data aggregation helper\nconst groupAndAggregate = (data, groupKey, aggregation) => {\n  const grouped = d3.group(data, (d) => d[groupKey]);\n\n  return Array.from(grouped, ([key, values]) => ({\n    [groupKey]: key,\n    ...Object.keys(aggregation).reduce((acc, field) => {\n      const aggFunc = aggregation[field];\n      const fieldValues = values.map((v) => v[field]);\n\n      acc[field] =\n        aggFunc === "sum"\n          ? d3.sum(fieldValues)\n          : aggFunc === "mean"\n          ? d3.mean(fieldValues)\n          : d3.max(fieldValues);\n\n      return acc;\n    }, {}),\n  }));\n};\n'})}),"\n",(0,i.jsx)(e.h2,{id:"svg-rendering-system",children:"SVG Rendering System"}),"\n",(0,i.jsx)(e.h3,{id:"svg-structure",children:"SVG Structure"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// SVG chart structure\nconst ChartSVG = ({ width, height, margin, children }) => {\n  return (\n    <svg\n      width={width}\n      height={height}\n      viewBox={`0 0 ${width} ${height}`}\n      className="recharts-wrapper"\n    >\n      {/* Definitions for gradients, patterns, etc. */}\n      <defs>\n        <linearGradient id="colorGradient" x1="0%" y1="0%" x2="0%" y2="100%">\n          <stop offset="0%" stopColor="#8884d8" stopOpacity={0.8} />\n          <stop offset="100%" stopColor="#8884d8" stopOpacity={0.1} />\n        </linearGradient>\n      </defs>\n\n      {/* Main chart group with margin translation */}\n      <g transform={`translate(${margin.left}, ${margin.top})`}>\n        {/* Background */}\n        <rect\n          width={width - margin.left - margin.right}\n          height={height - margin.top - margin.bottom}\n          fill="transparent"\n          className="recharts-chart-background"\n        />\n\n        {/* Chart content */}\n        {children}\n      </g>\n    </svg>\n  );\n};\n'})}),"\n",(0,i.jsx)(e.h3,{id:"animation-system",children:"Animation System"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// Animation utilities\nconst useAnimation = (targetValue, duration = 300) => {\n  const [currentValue, setCurrentValue] = useState(0);\n\n  useEffect(() => {\n    const startValue = currentValue;\n    const startTime = Date.now();\n\n    const animate = () => {\n      const elapsed = Date.now() - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n\n      // Easing function\n      const easedProgress = 1 - Math.pow(1 - progress, 3);\n\n      const newValue = startValue + (targetValue - startValue) * easedProgress;\n      setCurrentValue(newValue);\n\n      if (progress < 1) {\n        requestAnimationFrame(animate);\n      }\n    };\n\n    requestAnimationFrame(animate);\n  }, [targetValue, duration]);\n\n  return currentValue;\n};\n\n// Animated line component\nconst AnimatedLine = ({ data, dataKey, xScale, yScale }) => {\n  const animatedData = useAnimation(data.length);\n\n  const pathData = useMemo(() => {\n    const animatedLength = Math.floor(animatedData);\n    const visibleData = data.slice(0, animatedLength);\n\n    const line = d3\n      .line()\n      .x((d, i) => xScale(i))\n      .y((d) => yScale(d[dataKey]))\n      .curve(d3.curveMonotoneX);\n\n    return line(visibleData);\n  }, [data, dataKey, xScale, yScale, animatedData]);\n\n  return <path d={pathData} fill="none" stroke="#8884d8" strokeWidth={2} />;\n};\n'})}),"\n",(0,i.jsx)(e.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"What this section covers"}),": Advanced customization techniques including custom components, event handling, and interactive behaviors that go beyond basic chart functionality."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"When to use"}),": When you need specialized visualizations, custom interactions, or behavior that isn't available through standard Recharts props."]}),"\n",(0,i.jsx)(e.h3,{id:"custom-components",children:"Custom Components"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"What this demonstrates"}),": How to create completely custom components that integrate with Recharts' coordinate system and data flow."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Key Benefits"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Full Control"}),": Design exactly the visualization you need"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Integration"}),": Automatically receive position and data from Recharts"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Reusability"}),": Create components that work across different chart types"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// CUSTOM TOOLTIP: Enhanced tooltip with rich formatting and conditional content\nconst CustomTooltip = ({ active, payload, label }) => {\n  // Only show tooltip when hovering over data points\n  if (active && payload && payload.length) {\n    return (\n      <div\n        className="custom-tooltip"\n        style={{\n          backgroundColor: "rgba(255, 255, 255, 0.95)",\n          border: "1px solid #ccc",\n          borderRadius: "4px",\n          padding: "10px",\n          boxShadow: "0 2px 8px rgba(0,0,0,0.1)",\n        }}\n      >\n        {/* Header showing the category/time */}\n        <p\n          className="label"\n          style={{ fontWeight: "bold", marginBottom: "8px" }}\n        >\n          {`${label}`}\n        </p>\n\n        {/* Data values with color coding */}\n        {payload.map((entry, index) => (\n          <p\n            key={index}\n            style={{\n              color: entry.color,\n              margin: "4px 0",\n              display: "flex",\n              justifyContent: "space-between",\n              minWidth: "120px",\n            }}\n          >\n            <span>{entry.dataKey}:</span>\n            <strong>{formatValue(entry.value)}</strong> {/* Custom formatting */}\n          </p>\n        ))}\n\n        {/* Additional calculated information */}\n        <div\n          style={{\n            borderTop: "1px solid #eee",\n            paddingTop: "8px",\n            marginTop: "8px",\n          }}\n        >\n          <p>Total: {calculateTotal(payload)}</p>\n          <p>Change: {calculateChange(payload)}%</p>\n        </div>\n      </div>\n    );\n  }\n  return null; // Hide tooltip when not active\n};\n\n// CUSTOM DOT: Conditional styling based on data values\nconst CustomDot = ({ cx, cy, payload }) => {\n  // Dynamic styling based on data properties\n  const isHighValue = payload.value > 1000;\n  const isNegative = payload.value < 0;\n\n  // Different styles for different data conditions\n  const dotStyle = {\n    high: { r: 6, fill: "#ff7300", stroke: "#fff" },\n    normal: { r: 4, fill: "#8884d8", stroke: "#fff" },\n    negative: { r: 5, fill: "#ff4444", stroke: "#fff" },\n  };\n\n  const style = isNegative\n    ? dotStyle.negative\n    : isHighValue\n    ? dotStyle.high\n    : dotStyle.normal;\n\n  return (\n    <circle\n      cx={cx} // X position from Recharts\n      cy={cy} // Y position from Recharts\n      r={style.r} // Dynamic radius\n      fill={style.fill} // Dynamic color\n      stroke={style.stroke} // Border color\n      strokeWidth={2}\n      className="custom-dot"\n      // Add hover effects\n      style={{ cursor: "pointer" }}\n    />\n  );\n};\n\n// CUSTOM LEGEND: Interactive legend with filtering capabilities\nconst CustomLegend = ({ payload, onLegendClick }) => {\n  return (\n    <div\n      className="custom-legend"\n      style={{\n        display: "flex",\n        justifyContent: "center",\n        flexWrap: "wrap",\n        marginTop: "20px",\n      }}\n    >\n      {payload.map((entry, index) => (\n        <div\n          key={index}\n          onClick={() => onLegendClick(entry.dataKey)} // Interactive click\n          style={{\n            display: "flex",\n            alignItems: "center",\n            margin: "0 15px",\n            cursor: "pointer",\n            opacity: entry.inactive ? 0.5 : 1, // Show active/inactive state\n          }}\n        >\n          {/* Color indicator */}\n          <div\n            style={{\n              width: "12px",\n              height: "12px",\n              backgroundColor: entry.color,\n              marginRight: "8px",\n              borderRadius: "2px",\n            }}\n          />\n\n          {/* Legend text */}\n          <span style={{ fontSize: "14px" }}>{entry.value}</span>\n        </div>\n      ))}\n    </div>\n  );\n};\n\n// USAGE: Chart with custom components\nconst CustomChart = () => {\n  const [hiddenSeries, setHiddenSeries] = useState([]);\n\n  const handleLegendClick = (dataKey) => {\n    setHiddenSeries(\n      (prev) =>\n        prev.includes(dataKey)\n          ? prev.filter((key) => key !== dataKey) // Show series\n          : [...prev, dataKey] // Hide series\n    );\n  };\n\n  return (\n    <LineChart data={data}>\n      {/* Custom dot component for each data point */}\n      <Line\n        dataKey="value"\n        dot={<CustomDot />}\n        hide={hiddenSeries.includes("value")} // Conditional visibility\n      />\n\n      {/* Custom tooltip with enhanced information */}\n      <Tooltip content={<CustomTooltip />} />\n\n      {/* Custom interactive legend */}\n      <Legend content={<CustomLegend onLegendClick={handleLegendClick} />} />\n    </LineChart>\n  );\n};\n'})}),"\n",(0,i.jsx)(e.h3,{id:"event-handling",children:"Event Handling"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"What this demonstrates"}),": How to add interactivity to charts through mouse events, creating dynamic and responsive user experiences."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Common Use Cases"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Data selection and filtering"}),"\n",(0,i.jsx)(e.li,{children:"Drill-down navigation"}),"\n",(0,i.jsx)(e.li,{children:"Hover effects and highlighting"}),"\n",(0,i.jsx)(e.li,{children:"Data export or sharing"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// INTERACTIVE CHART: Comprehensive event handling with state management\nconst InteractiveChart = () => {\n  // State for tracking user interactions\n  const [selectedData, setSelectedData] = useState(null); // Currently selected data point\n  const [hoveredIndex, setHoveredIndex] = useState(null); // Currently hovered bar index\n  const [zoomedRange, setZoomedRange] = useState(null); // Zoom selection range\n\n  // MOUSE ENTER: Highlight hovered element\n  const handleMouseEnter = (data, index, event) => {\n    setHoveredIndex(index);\n\n    // Optional: Show additional UI feedback\n    event.target.style.opacity = "0.8";\n\n    console.log("Hovering over:", data);\n  };\n\n  // MOUSE LEAVE: Remove highlight\n  const handleMouseLeave = (event) => {\n    setHoveredIndex(null);\n\n    // Reset visual feedback\n    event.target.style.opacity = "1";\n  };\n\n  // CLICK: Select data point for detailed view\n  const handleClick = (data, index, event) => {\n    setSelectedData(data);\n\n    // Prevent event bubbling\n    event.stopPropagation();\n\n    console.log("Selected data:", data);\n\n    // Optional: Trigger external actions\n    // onDataSelect(data);\n    // navigateToDetail(data.id);\n  };\n\n  // DOUBLE CLICK: Reset selection or zoom\n  const handleDoubleClick = () => {\n    setSelectedData(null);\n    setZoomedRange(null);\n  };\n\n  // BRUSH SELECTION: Handle range selection for zooming\n  const handleBrushChange = (range) => {\n    if (range && range.startIndex !== range.endIndex) {\n      setZoomedRange(range);\n      console.log("Zoom range:", range);\n    }\n  };\n\n  return (\n    <div onDoubleClick={handleDoubleClick}>\n      {" "}\n      {/* Container for global events */}\n      <BarChart\n        data={data}\n        onMouseDown={(e) => console.log("Chart mouse down")}\n      >\n        <Bar\n          dataKey="value"\n          fill="#8884d8"\n          // Individual bar event handlers\n          onMouseEnter={handleMouseEnter}\n          onMouseLeave={handleMouseLeave}\n          onClick={handleClick}\n          // Dynamic styling based on interaction state\n          style={{\n            cursor: "pointer",\n            filter:\n              hoveredIndex !== null && hoveredIndex !== data.indexOf()\n                ? "brightness(0.7)"\n                : "brightness(1)",\n          }}\n        />\n\n        {/* Conditional highlighting for selected data */}\n        {selectedData && (\n          <Bar\n            dataKey="value"\n            data={[selectedData]} // Only show selected data\n            fill="#ff7300" // Different color for selection\n            isAnimationActive={false}\n          />\n        )}\n\n        <Tooltip\n          content={({ active, payload, label }) => {\n            if (active && payload) {\n              return (\n                <div>\n                  <p>{`${label}: ${payload[0].value}`}</p>\n                  {hoveredIndex !== null && <p>Index: {hoveredIndex}</p>}\n                  <p>Click to select</p>\n                </div>\n              );\n            }\n            return null;\n          }}\n        />\n\n        {/* Brush for range selection */}\n        <Brush dataKey="name" height={30} onChange={handleBrushChange} />\n      </BarChart>\n      {/* Display selected data information */}\n      {selectedData && (\n        <div className="selected-data-panel">\n          <h3>Selected Data</h3>\n          <p>Value: {selectedData.value}</p>\n          <p>Category: {selectedData.name}</p>\n          <button onClick={() => setSelectedData(null)}>Clear Selection</button>\n        </div>\n      )}\n    </div>\n  );\n};\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Event Handling Best Practices"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Performance"}),": Use event delegation for large datasets"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Accessibility"}),": Ensure keyboard navigation works"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"State Management"}),": Keep interaction state separate from data"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"User Feedback"}),": Provide clear visual feedback for interactions"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Why this matters"}),": Charts with large datasets or frequent updates can cause performance issues. This section shows optimization techniques to maintain smooth interactions."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Common Performance Issues"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Re-rendering on every data change"}),"\n",(0,i.jsx)(e.li,{children:"Expensive calculations on each render"}),"\n",(0,i.jsx)(e.li,{children:"Large datasets overwhelming the browser"}),"\n",(0,i.jsx)(e.li,{children:"Frequent resize events causing layout thrashing"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"memoization-and-optimization",children:"Memoization and Optimization"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"What this demonstrates"}),": Techniques to cache expensive calculations and prevent unnecessary re-renders using React optimization patterns."]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Key Strategies"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"React.memo"}),": Prevent re-renders when props haven't changed"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"useMemo"}),": Cache expensive data transformations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Debouncing"}),": Limit frequency of expensive operations"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// OPTIMIZED CHART COMPONENT: Uses multiple optimization techniques\nconst OptimizedChart = React.memo(({ data, width, height }) => {\n  // MEMOIZE EXPENSIVE DATA PROCESSING: Only recalculate when data changes\n  const processedData = useMemo(() => {\n    console.log("Processing data..."); // This should only log when data actually changes\n\n    return data.map((item) => ({\n      ...item,\n      // Example expensive calculations that we want to cache\n      calculated: expensiveCalculation(item), // Mathematical transformations\n      normalized: item.value / maxValue, // Normalization\n      trend: calculateTrend(item, previousData), // Trend analysis\n    }));\n  }, [data]); // Only recalculate when \'data\' reference changes\n\n  // MEMOIZE SCALE CALCULATIONS: Recreate scales only when dependencies change\n  const scales = useMemo(() => {\n    console.log("Creating scales..."); // Should only log when dependencies change\n\n    return createScales(processedData, width, height);\n  }, [processedData, width, height]); // Recalculate when data or dimensions change\n\n  // DEBOUNCE RESIZE EVENTS: Prevent excessive recalculations during window resizing\n  const debouncedDimensions = useMemo(() => {\n    // Wait 100ms after last resize before updating\n    return debounce({ width, height }, 100);\n  }, [width, height]);\n\n  // OPTIMIZED RENDER: Chart only re-renders when memoized values change\n  return (\n    <LineChart data={processedData} {...debouncedDimensions}>\n      <Line dataKey="value" />\n    </LineChart>\n  );\n}); // React.memo prevents re-render if props are the same\n\n// VIRTUAL SCROLLING: Handle large datasets by only rendering visible portion\nconst VirtualizedChart = ({ data, itemHeight = 50 }) => {\n  // Track which data points are currently visible\n  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 100 });\n\n  // MEMOIZE VISIBLE DATA SLICE: Only include data points that should be rendered\n  const visibleData = useMemo(() => {\n    console.log(`Showing items ${visibleRange.start} to ${visibleRange.end}`);\n\n    // Only render data points in the visible range\n    return data.slice(visibleRange.start, visibleRange.end);\n  }, [data, visibleRange]); // Recalculate when data or visible range changes\n\n  // SCROLL HANDLER: Update visible range as user scrolls\n  const handleScroll = useCallback(\n    (e) => {\n      const scrollTop = e.target.scrollTop; // Current scroll position\n      const start = Math.floor(scrollTop / itemHeight); // First visible item\n      const end = start + Math.ceil(window.innerHeight / itemHeight); // Last visible item\n\n      // Only update if range actually changed (prevents unnecessary re-renders)\n      setVisibleRange((prevRange) => {\n        if (prevRange.start !== start || prevRange.end !== end) {\n          return { start, end };\n        }\n        return prevRange;\n      });\n    },\n    [itemHeight]\n  );\n\n  return (\n    <div\n      onScroll={handleScroll}\n      style={{ height: "400px", overflow: "auto" }} // Scrollable container\n    >\n      {/* Spacer to maintain scroll height for items above visible range */}\n      <div style={{ height: visibleRange.start * itemHeight }} />\n\n      {/* Chart showing only visible data */}\n      <LineChart data={visibleData} height={visibleData.length * itemHeight}>\n        <Line dataKey="value" />\n      </LineChart>\n\n      {/* Spacer to maintain scroll height for items below visible range */}\n      <div style={{ height: (data.length - visibleRange.end) * itemHeight }} />\n    </div>\n  );\n};\n\n// DEBOUNCE UTILITY: Limits function execution frequency\nconst debounce = (value, delay) => {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    // Set up timer to update value after delay\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    // Clear timer if value changes before delay expires\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n};\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Performance Best Practices"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memoize Heavy Calculations"}),": Use useMemo for data transformations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Optimize Re-renders"}),": Use React.memo and useCallback appropriately"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Virtual Scrolling"}),": Only render visible data for large datasets"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Debounce Events"}),": Limit frequency of resize/scroll handlers"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Data Structure"}),": Keep data flat and avoid deep object comparisons"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(e.h3,{id:"component-organization",children:"Component Organization"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// Reusable chart components\nconst BaseChart = ({ children, ...props }) => (\n  <ResponsiveContainer width="100%" height={400}>\n    <LineChart {...props}>\n      <CartesianGrid strokeDasharray="3 3" />\n      <XAxis dataKey="name" />\n      <YAxis />\n      <Tooltip />\n      <Legend />\n      {children}\n    </LineChart>\n  </ResponsiveContainer>\n);\n\n// Specialized chart variants\nconst SalesChart = ({ data }) => (\n  <BaseChart data={data}>\n    <Line dataKey="sales" stroke="#8884d8" name="Sales" />\n    <Line dataKey="profit" stroke="#82ca9d" name="Profit" />\n  </BaseChart>\n);\n\nconst PerformanceChart = ({ data }) => (\n  <BaseChart data={data}>\n    <Line dataKey="cpu" stroke="#ff7300" name="CPU Usage" />\n    <Line dataKey="memory" stroke="#387908" name="Memory Usage" />\n  </BaseChart>\n);\n'})}),"\n",(0,i.jsx)(e.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'// Error boundary for charts\nclass ChartErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className="chart-error">\n          <p>Unable to render chart</p>\n          <button\n            onClick={() => this.setState({ hasError: false, error: null })}\n          >\n            Retry\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Safe chart wrapper\nconst SafeChart = ({ data, ...props }) => {\n  if (!data || data.length === 0) {\n    return <div className="no-data">No data available</div>;\n  }\n\n  return (\n    <ChartErrorBoundary>\n      <LineChart data={data} {...props}>\n        <Line dataKey="value" />\n      </LineChart>\n    </ChartErrorBoundary>\n  );\n};\n'})}),"\n",(0,i.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(e.p,{children:"Recharts provides a powerful and flexible solution for creating data visualizations in React applications. By leveraging React's component model and D3's mathematical utilities, it offers a declarative approach to building charts while maintaining the performance and capabilities needed for complex visualizations."}),"\n",(0,i.jsx)(e.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Component Composition"}),": Recharts' modular architecture enables flexible chart creation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"D3 Integration"}),": Leverages D3 for calculations while React handles rendering"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"SVG-Based"}),": Native SVG support ensures crisp rendering and accessibility"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Performance"}),": Proper memoization and optimization strategies ensure smooth interactions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Customization"}),": Extensive customization options through props and custom components"]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["As referenced in the ",(0,i.jsx)(e.a,{href:"https://github.com/recharts/recharts",children:"Recharts GitHub repository"}),", the library continues to evolve with strong community support and comprehensive documentation for modern data visualization needs."]}),"\n",(0,i.jsx)(e.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://recharts.org/",children:"Recharts Documentation"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://github.com/recharts/recharts",children:"Recharts GitHub Repository"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://recharts.org/en-US/examples",children:"Recharts Examples"})}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>o});var a=t(6540);const i={},s=a.createContext(i);function r(n){const e=a.useContext(s);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),a.createElement(s.Provider,{value:e},n.children)}}}]);