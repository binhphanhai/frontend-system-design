"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5891],{7985:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"project-detail/service-worker","title":"Service Workers: The Gateway to Progressive Web Apps","description":"Table of Contents","source":"@site/docs/project-detail/service-worker.md","sourceDirName":"project-detail","slug":"/project-detail/service-worker","permalink":"/frontend-system-design/docs/project-detail/service-worker","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/service-worker.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Web Workers: Background Threading in the Browser","permalink":"/frontend-system-design/docs/project-detail/web-worker"},"next":{"title":"Styled Components: CSS-in-JS Simplified","permalink":"/frontend-system-design/docs/project-detail/styled-component"}}');var s=r(4848),i=r(8453);const a={},o="Service Workers: The Gateway to Progressive Web Apps",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Capabilities",id:"key-capabilities",level:3},{value:"Service Worker vs Web Worker",id:"service-worker-vs-web-worker",level:3},{value:"Getting Started with Service Workers",id:"getting-started-with-service-workers",level:2},{value:"Feature Detection and Registration",id:"feature-detection-and-registration",level:3},{value:"Basic Service Worker Structure",id:"basic-service-worker-structure",level:3},{value:"Service Worker Lifecycle",id:"service-worker-lifecycle",level:2},{value:"Lifecycle States and Transitions",id:"lifecycle-states-and-transitions",level:3},{value:"Under the Hood: How Service Workers Work",id:"under-the-hood-how-service-workers-work",level:2},{value:"Browser Architecture with Service Workers",id:"browser-architecture-with-service-workers",level:3},{value:"Service Worker Global Scope",id:"service-worker-global-scope",level:3},{value:"Caching Strategies",id:"caching-strategies",level:2},{value:"Cache-First Strategy",id:"cache-first-strategy",level:3},{value:"Network-First Strategy",id:"network-first-strategy",level:3},{value:"Stale-While-Revalidate Strategy",id:"stale-while-revalidate-strategy",level:3},{value:"Advanced Caching with Expiration",id:"advanced-caching-with-expiration",level:3},{value:"Offline Functionality",id:"offline-functionality",level:2},{value:"Comprehensive Offline Strategy",id:"comprehensive-offline-strategy",level:3},{value:"Push Notifications and Background Sync",id:"push-notifications-and-background-sync",level:2},{value:"Push Notification Implementation",id:"push-notification-implementation",level:3},{value:"Background Sync",id:"background-sync",level:3},{value:"Advanced Patterns and Best Practices",id:"advanced-patterns-and-best-practices",level:2},{value:"Service Worker Update Pattern",id:"service-worker-update-pattern",level:3},{value:"Resource Versioning Strategy",id:"resource-versioning-strategy",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Secure Service Worker Implementation",id:"secure-service-worker-implementation",level:3},{value:"Debugging and Development",id:"debugging-and-development",level:2},{value:"Service Worker Debugging Tools",id:"service-worker-debugging-tools",level:3},{value:"Real-World Implementation",id:"real-world-implementation",level:2},{value:"Complete PWA Service Worker",id:"complete-pwa-service-worker",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Cache Management Best Practices",id:"cache-management-best-practices",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"When to Use Service Workers",id:"when-to-use-service-workers",level:3},{value:"Further Resources",id:"further-resources",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"service-workers-the-gateway-to-progressive-web-apps",children:"Service Workers: The Gateway to Progressive Web Apps"})}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getting-started-with-service-workers",children:"Getting Started with Service Workers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#service-worker-lifecycle",children:"Service Worker Lifecycle"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#under-the-hood-how-service-workers-work",children:"Under the Hood: How Service Workers Work"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#caching-strategies",children:"Caching Strategies"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#offline-functionality",children:"Offline Functionality"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#push-notifications-and-background-sync",children:"Push Notifications and Background Sync"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#advanced-patterns-and-best-practices",children:"Advanced Patterns and Best Practices"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#security-considerations",children:"Security Considerations"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#debugging-and-development",children:"Debugging and Development"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#real-world-implementation",children:"Real-World Implementation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["Service Workers are a cornerstone technology of Progressive Web Apps (PWAs), acting as programmable proxy servers between web applications and the network. As outlined in the ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API",children:"MDN Service Worker API documentation"}),", they enable powerful features like offline functionality, push notifications, and background synchronization."]}),"\n",(0,s.jsx)(n.p,{children:"Unlike regular Web Workers, Service Workers can intercept network requests, cache resources, and serve content even when the network is unavailable. They run in a separate thread from the main application, ensuring that intensive operations don't block the user interface."}),"\n",(0,s.jsx)(n.h3,{id:"key-capabilities",children:"Key Capabilities"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network Interception"}),": Intercept and modify network requests"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Caching"}),": Store resources for offline access"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Background Processing"}),": Handle tasks when the app isn't active"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Push Notifications"}),": Receive and display notifications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Background Sync"}),": Sync data when connectivity is restored"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"service-worker-vs-web-worker",children:"Service Worker vs Web Worker"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this comparison demonstrates:"})," The fundamental difference between Service Workers and Web Workers in terms of network access capabilities."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key differences:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service Workers:"})," Run in a separate context and can intercept all network requests from your web app"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Web Workers:"})," Execute JavaScript in background threads but cannot access the network layer directly"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use cases:"})," Service Workers for PWA features (offline, caching, push notifications), Web Workers for heavy computations"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Service Worker - Can intercept network requests\r\n// This code runs in the Service Worker context and demonstrates network interception\r\nself.addEventListener("fetch", (event) => {\r\n  // Intercept any fetch request made by the web app\r\n  // event.request contains the full request object (URL, method, headers, etc.)\r\n  event.respondWith(\r\n    // Check if we have a cached version of this request\r\n    caches.match(event.request)\r\n    // If found in cache, return it; if not, this will return undefined\r\n    // and the browser will proceed with the original network request\r\n  );\r\n});\r\n\r\n// Web Worker - Cannot access network layer\r\n// Regular Web Workers run in a different context without network interception capabilities\r\n// They can use fetch() to make requests, but cannot intercept requests from the main thread\r\n// Network interception is not possible in regular Web Workers\n'})}),"\n",(0,s.jsx)(n.h2,{id:"getting-started-with-service-workers",children:"Getting Started with Service Workers"}),"\n",(0,s.jsx)(n.h3,{id:"feature-detection-and-registration",children:"Feature Detection and Registration"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this code does:"})," Safely registers a Service Worker with proper feature detection and update handling."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Step-by-step process:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Feature Detection:"})," Check if the browser supports Service Workers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Registration:"})," Register the Service Worker file (",(0,s.jsx)(n.code,{children:"/sw.js"}),") with a specific scope"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Update Detection:"})," Listen for new Service Worker versions and notify users"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling:"})," Gracefully handle registration failures"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," Service Worker file path (",(0,s.jsx)(n.code,{children:"/sw.js"}),") and configuration options\r\n",(0,s.jsx)(n.strong,{children:"Output:"})," Registered Service Worker with update notifications"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"When to use:"})," This should be your standard Service Worker registration pattern in production apps."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Check for Service Worker support before attempting registration\r\n// This prevents errors in older browsers that don\'t support Service Workers\r\nif ("serviceWorker" in navigator) {\r\n  // Wait for the page to fully load before registering\r\n  // This ensures the main thread isn\'t blocked during initial page render\r\n  window.addEventListener("load", async () => {\r\n    try {\r\n      // Register the Service Worker file\r\n      const registration = await navigator.serviceWorker.register("/sw.js", {\r\n        scope: "/", // Controls which pages the SW manages (all pages in this case)\r\n        // Other options: updateViaCache: \'none\' | \'imports\' | \'all\'\r\n      });\r\n\r\n      console.log("SW registered:", registration.scope);\r\n\r\n      // Handle registration updates - crucial for deploying new versions\r\n      registration.addEventListener("updatefound", () => {\r\n        // A new Service Worker is being installed\r\n        const newWorker = registration.installing;\r\n        console.log("New service worker installing");\r\n\r\n        // Monitor the installation progress\r\n        newWorker.addEventListener("statechange", () => {\r\n          if (newWorker.state === "installed") {\r\n            // Check if there\'s already an active Service Worker\r\n            if (navigator.serviceWorker.controller) {\r\n              // There\'s an update available\r\n              console.log("New content available, please refresh");\r\n              showUpdateNotification();\r\n            } else {\r\n              // First time installation - everything is cached\r\n              console.log("Content cached for offline use");\r\n            }\r\n          }\r\n        });\r\n      });\r\n    } catch (error) {\r\n      // Registration failed - could be network issues, invalid SW file, etc.\r\n      console.error("SW registration failed:", error);\r\n    }\r\n  });\r\n} else {\r\n  // Graceful degradation for unsupported browsers\r\n  console.log("Service Workers not supported");\r\n}\r\n\r\n// User-friendly update notification\r\n// This creates a simple UI element to inform users about available updates\r\nfunction showUpdateNotification() {\r\n  const notification = document.createElement("div");\r\n  notification.innerHTML = `\r\n    <div class="update-notification" style="\r\n      position: fixed; \r\n      top: 20px; \r\n      right: 20px; \r\n      background: #4CAF50; \r\n      color: white; \r\n      padding: 12px; \r\n      border-radius: 4px;\r\n      z-index: 9999;\r\n    ">\r\n      New version available! \r\n      <button onclick="window.location.reload()" style="\r\n        background: white; \r\n        color: #4CAF50; \r\n        border: none; \r\n        padding: 4px 8px; \r\n        border-radius: 2px;\r\n        cursor: pointer;\r\n      ">Refresh</button>\r\n    </div>\r\n  `;\r\n  document.body.appendChild(notification);\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"basic-service-worker-structure",children:"Basic Service Worker Structure"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this Service Worker does:"})," Implements a complete caching strategy with installation, activation, and fetch handling."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"The three main lifecycle events:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Install:"})," Downloads and caches essential resources (app shell)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Activate:"})," Cleans up old caches and takes control of all pages"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fetch:"})," Intercepts network requests and serves cached content when available"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," Network requests from the web application\r\n",(0,s.jsx)(n.strong,{children:"Output:"})," Cached responses or fresh network responses, with offline fallback"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cache strategy:"})," Cache-first with network fallback and offline page support"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// sw.js - Service Worker file\r\n// This file must be served from your domain\'s root or a directory you want to control\r\n\r\n// Cache configuration\r\nconst CACHE_NAME = "my-app-v1"; // Version your cache names for easy updates\r\nconst urlsToCache = [\r\n  "/", // Home page\r\n  "/styles/main.css", // Critical CSS\r\n  "/scripts/main.js", // Core JavaScript\r\n  "/offline.html", // Offline fallback page\r\n  // Add other essential resources your app needs to work offline\r\n];\r\n\r\n// INSTALL EVENT - Triggered when the Service Worker is first installed\r\n// This is where you cache your app\'s essential resources ("app shell")\r\nself.addEventListener("install", (event) => {\r\n  console.log("Service Worker installing");\r\n\r\n  // event.waitUntil() ensures the Service Worker doesn\'t finish installing\r\n  // until the promise resolves (all caching is complete)\r\n  event.waitUntil(\r\n    caches\r\n      .open(CACHE_NAME) // Create/open the cache with our version name\r\n      .then((cache) => {\r\n        console.log("Caching app shell");\r\n        // cache.addAll() downloads and stores all URLs in the array\r\n        // If any URL fails to cache, the entire installation fails\r\n        return cache.addAll(urlsToCache);\r\n      })\r\n      .then(() => {\r\n        // Skip waiting phase to activate immediately\r\n        // Without this, the new SW waits until all tabs are closed\r\n        return self.skipWaiting();\r\n      })\r\n  );\r\n});\r\n\r\n// ACTIVATE EVENT - Triggered when the Service Worker becomes active\r\n// This is where you clean up old caches and prepare for new functionality\r\nself.addEventListener("activate", (event) => {\r\n  console.log("Service Worker activating");\r\n\r\n  event.waitUntil(\r\n    // Get all existing cache names\r\n    caches\r\n      .keys()\r\n      .then((cacheNames) => {\r\n        // Delete old caches that don\'t match the current version\r\n        return Promise.all(\r\n          cacheNames.map((cacheName) => {\r\n            // Keep only the current cache, delete everything else\r\n            if (cacheName !== CACHE_NAME) {\r\n              console.log("Deleting old cache:", cacheName);\r\n              return caches.delete(cacheName);\r\n            }\r\n            // Return undefined for caches we want to keep\r\n          })\r\n        );\r\n      })\r\n      .then(() => {\r\n        // Take control of all clients (open tabs/windows)\r\n        // Without this, the SW only controls pages opened after activation\r\n        return self.clients.claim();\r\n      })\r\n  );\r\n});\r\n\r\n// FETCH EVENT - Triggered for every network request made by the app\r\n// This is where you implement your caching strategy\r\nself.addEventListener("fetch", (event) => {\r\n  // Intercept the request and provide a custom response\r\n  event.respondWith(\r\n    // First, check if we have this request in our cache\r\n    caches\r\n      .match(event.request)\r\n      .then((response) => {\r\n        // If found in cache, return it; otherwise fetch from network\r\n        // This implements a "cache-first" strategy\r\n        return response || fetch(event.request);\r\n      })\r\n      .catch(() => {\r\n        // If both cache and network fail (offline + not cached)\r\n        // Show the offline page for HTML document requests\r\n        if (event.request.destination === "document") {\r\n          return caches.match("/offline.html");\r\n        }\r\n        // For other resources (images, CSS, JS), just let the request fail\r\n        // The browser will handle this gracefully\r\n      })\r\n  );\r\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"service-worker-lifecycle",children:"Service Worker Lifecycle"}),"\n",(0,s.jsx)(n.h3,{id:"lifecycle-states-and-transitions",children:"Lifecycle States and Transitions"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this ServiceWorkerManager does:"})," Provides a comprehensive system for managing Service Worker lifecycle events, updates, and user notifications."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key lifecycle states:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Installing:"})," Service Worker is downloading and setting up"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Installed:"})," Installation complete, waiting to activate"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Activating:"})," Taking control of the application"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Activated:"})," Fully operational and controlling network requests"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Redundant:"})," Replaced by a newer version"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Features implemented:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Automatic update detection"}),"\n",(0,s.jsx)(n.li,{children:"User-friendly update notifications"}),"\n",(0,s.jsx)(n.li,{children:"Periodic update checks"}),"\n",(0,s.jsx)(n.li,{children:"Graceful handling of Service Worker state transitions"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," Service Worker registration and lifecycle events\r\n",(0,s.jsx)(n.strong,{children:"Output:"})," Managed Service Worker with user-controlled updates"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Monitor service worker lifecycle with a comprehensive management class\r\nclass ServiceWorkerManager {\r\n  constructor() {\r\n    this.registration = null; // Stores the SW registration object\r\n    this.isUpdateAvailable = false; // Flag to track update availability\r\n    this.setupServiceWorker(); // Initialize immediately\r\n  }\r\n\r\n  // Main setup method - handles feature detection and registration\r\n  async setupServiceWorker() {\r\n    // Feature detection - graceful degradation for unsupported browsers\r\n    if (!("serviceWorker" in navigator)) {\r\n      console.log("Service Workers not supported");\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Register the Service Worker and store the registration\r\n      this.registration = await navigator.serviceWorker.register("/sw.js");\r\n      console.log("Service Worker registered successfully");\r\n\r\n      // Start monitoring lifecycle events\r\n      this.monitorLifecycle();\r\n    } catch (error) {\r\n      // Handle registration failures (network issues, invalid SW file, etc.)\r\n      console.error("SW registration failed:", error);\r\n    }\r\n  }\r\n\r\n  // Set up all lifecycle event listeners\r\n  monitorLifecycle() {\r\n    // Monitor for new Service Worker installations (updates)\r\n    this.registration.addEventListener("updatefound", () => {\r\n      console.log("New Service Worker version detected");\r\n      const newWorker = this.registration.installing;\r\n      this.trackWorkerState(newWorker, "Installing");\r\n    });\r\n\r\n    // Monitor when the active Service Worker changes\r\n    navigator.serviceWorker.addEventListener("controllerchange", () => {\r\n      console.log("Controller changed - page refresh recommended");\r\n      this.handleControllerChange();\r\n    });\r\n\r\n    // Periodically check for updates (production apps might do this less frequently)\r\n    setInterval(() => {\r\n      console.log("Checking for Service Worker updates...");\r\n      this.registration.update();\r\n    }, 60000); // Check every minute (adjust based on your update frequency needs)\r\n  }\r\n\r\n  // Track state changes for a specific Service Worker instance\r\n  trackWorkerState(worker, phase) {\r\n    worker.addEventListener("statechange", () => {\r\n      console.log(`${phase} worker state:`, worker.state);\r\n\r\n      switch (worker.state) {\r\n        case "installed":\r\n          // Service Worker is installed and ready\r\n          if (navigator.serviceWorker.controller) {\r\n            // There\'s already an active SW, so this is an update\r\n            this.isUpdateAvailable = true;\r\n            this.notifyUpdateAvailable();\r\n          } else {\r\n            // First installation - no previous SW\r\n            console.log("Content cached for offline use");\r\n          }\r\n          break;\r\n\r\n        case "activated":\r\n          // Service Worker is now controlling the page\r\n          console.log("Service Worker activated and controlling pages");\r\n          this.isUpdateAvailable = false;\r\n          break;\r\n\r\n        case "redundant":\r\n          // Service Worker has been replaced or failed\r\n          console.log("Service Worker became redundant");\r\n          break;\r\n      }\r\n    });\r\n  }\r\n\r\n  // Notify the application that an update is available\r\n  notifyUpdateAvailable() {\r\n    console.log("Dispatching update available event");\r\n    const event = new CustomEvent("sw-update-available", {\r\n      detail: {\r\n        registration: this.registration,\r\n        hasWaitingWorker: !!this.registration.waiting,\r\n      },\r\n    });\r\n    window.dispatchEvent(event);\r\n  }\r\n\r\n  // Handle when the Service Worker controller changes\r\n  handleControllerChange() {\r\n    // Reload the page to ensure users get the latest version\r\n    // In production, you might want to show a notification instead\r\n    console.log("Reloading page due to Service Worker update");\r\n    window.location.reload();\r\n  }\r\n\r\n  // Force the waiting Service Worker to become active\r\n  async forceUpdate() {\r\n    if (this.registration.waiting) {\r\n      console.log("Forcing Service Worker update");\r\n      // Send message to the waiting SW to skip waiting phase\r\n      this.registration.waiting.postMessage({ type: "SKIP_WAITING" });\r\n    } else {\r\n      console.log("No waiting Service Worker found");\r\n    }\r\n  }\r\n}\r\n\r\n// Initialize the Service Worker manager\r\n// This should be done early in your application startup\r\nconst swManager = new ServiceWorkerManager();\r\n\r\n// Listen for update notifications and prompt user\r\nwindow.addEventListener("sw-update-available", (event) => {\r\n  console.log("Update available event received", event.detail);\r\n\r\n  // Show user-friendly update prompt\r\n  const userConfirmed = confirm(\r\n    "A new version of the application is available. " +\r\n      "Would you like to update now? (Recommended for the best experience)"\r\n  );\r\n\r\n  if (userConfirmed) {\r\n    // User wants to update - force the new Service Worker to activate\r\n    swManager.forceUpdate();\r\n  } else {\r\n    // User declined - they\'ll get the update next time they visit\r\n    console.log("User declined update - will apply on next visit");\r\n  }\r\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"under-the-hood-how-service-workers-work",children:"Under the Hood: How Service Workers Work"}),"\n",(0,s.jsx)(n.h3,{id:"browser-architecture-with-service-workers",children:"Browser Architecture with Service Workers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                    Browser Process                      \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502  Main Thread              \u2502      Service Worker Thread  \u2502\r\n\u2502  \u251c\u2500\u2500\u2500 DOM/Rendering       \u2502      \u251c\u2500\u2500\u2500 Network Proxy     \u2502\r\n\u2502  \u251c\u2500\u2500\u2500 JavaScript Engine   \u2502      \u251c\u2500\u2500\u2500 Cache Management  \u2502\r\n\u2502  \u251c\u2500\u2500\u2500 Event Loop         \u2502      \u251c\u2500\u2500\u2500 Push Notifications \u2502\r\n\u2502  \u2514\u2500\u2500\u2500 User Interactions   \u2502      \u2514\u2500\u2500\u2500 Background Tasks  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502              Network Layer                              \u2502\r\n\u2502         (All requests pass through SW)                  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h3,{id:"service-worker-global-scope",children:"Service Worker Global Scope"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Service Worker runs in ServiceWorkerGlobalScope\r\nconsole.log(self); // ServiceWorkerGlobalScope\r\nconsole.log(self.caches); // CacheStorage interface\r\nconsole.log(self.clients); // Clients interface\r\n\r\n// Available APIs in Service Worker context\r\nconst availableAPIs = {\r\n  // Network APIs\r\n  fetch: typeof fetch !== "undefined",\r\n  XMLHttpRequest: typeof XMLHttpRequest !== "undefined",\r\n\r\n  // Storage APIs\r\n  caches: typeof caches !== "undefined",\r\n  indexedDB: typeof indexedDB !== "undefined",\r\n\r\n  // Messaging APIs\r\n  postMessage: typeof self.postMessage !== "undefined",\r\n  BroadcastChannel: typeof BroadcastChannel !== "undefined",\r\n\r\n  // Notification APIs\r\n  Notification: typeof Notification !== "undefined",\r\n  showNotification: typeof self.registration?.showNotification !== "undefined",\r\n\r\n  // Not available in Service Workers\r\n  localStorage: typeof localStorage !== "undefined", // false\r\n  sessionStorage: typeof sessionStorage !== "undefined", // false\r\n  document: typeof document !== "undefined", // false\r\n  window: typeof window !== "undefined", // false\r\n};\r\n\r\nconsole.log("Available APIs:", availableAPIs);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"caching-strategies",children:"Caching Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"cache-first-strategy",children:"Cache-First Strategy"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this strategy does:"})," Prioritizes cached content for fast loading, falling back to network only when necessary."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Best use cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Static assets (images, fonts, CSS, JavaScript)"}),"\n",(0,s.jsx)(n.li,{children:"Resources that don't change frequently"}),"\n",(0,s.jsx)(n.li,{children:"When performance and speed are more important than freshness"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Flow:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Check cache first"}),"\n",(0,s.jsx)(n.li,{children:"If found, return immediately (fastest response)"}),"\n",(0,s.jsx)(n.li,{children:"If not found, fetch from network"}),"\n",(0,s.jsx)(n.li,{children:"Cache the network response for future use"}),"\n",(0,s.jsx)(n.li,{children:"Return the network response"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pros:"})," Very fast for cached resources, works offline\r\n",(0,s.jsx)(n.strong,{children:"Cons:"})," May serve stale content"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Cache-First Strategy Implementation\r\n// Best for static assets like images, fonts, and CSS files\r\nself.addEventListener("fetch", (event) => {\r\n  // Apply cache-first strategy specifically to image requests\r\n  if (event.request.destination === "image") {\r\n    event.respondWith(\r\n      // Step 1: Check if the request is already in cache\r\n      caches.match(event.request).then((cachedResponse) => {\r\n        // Step 2: If found in cache, return immediately (fastest path)\r\n        if (cachedResponse) {\r\n          console.log("Serving from cache:", event.request.url);\r\n          return cachedResponse;\r\n        }\r\n\r\n        // Step 3: Not in cache, fetch from network\r\n        console.log("Not in cache, fetching from network:", event.request.url);\r\n        return fetch(event.request).then((networkResponse) => {\r\n          // Step 4: Cache the new response for future requests\r\n          // Important: Clone the response because it can only be consumed once\r\n          const responseClone = networkResponse.clone();\r\n\r\n          // Cache asynchronously (don\'t block the response)\r\n          caches.open(CACHE_NAME).then((cache) => {\r\n            console.log("Caching new resource:", event.request.url);\r\n            cache.put(event.request, responseClone);\r\n          });\r\n\r\n          // Step 5: Return the fresh network response\r\n          return networkResponse;\r\n        });\r\n      })\r\n    );\r\n  }\r\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"network-first-strategy",children:"Network-First Strategy"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this strategy does:"})," Always tries to fetch fresh content from the network first, using cache as a fallback when offline."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Best use cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"API calls and dynamic data"}),"\n",(0,s.jsx)(n.li,{children:"Content that changes frequently"}),"\n",(0,s.jsx)(n.li,{children:"When data freshness is critical"}),"\n",(0,s.jsx)(n.li,{children:"Social media feeds, news articles, user-generated content"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Flow:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Try network request first"}),"\n",(0,s.jsx)(n.li,{children:"If successful, update cache with fresh data"}),"\n",(0,s.jsx)(n.li,{children:"Return the fresh network response"}),"\n",(0,s.jsx)(n.li,{children:"If network fails, fall back to cached version"}),"\n",(0,s.jsx)(n.li,{children:"If no cache either, request fails gracefully"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pros:"})," Always tries to serve fresh content\r\n",(0,s.jsx)(n.strong,{children:"Cons:"})," Slower when network is slow, requires network for first load"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Network-First Strategy Implementation\r\n// Best for API calls and dynamic content that changes frequently\r\nself.addEventListener("fetch", (event) => {\r\n  // Apply network-first strategy to API calls\r\n  if (event.request.url.includes("/api/")) {\r\n    event.respondWith(\r\n      // Step 1: Always try network first for fresh data\r\n      fetch(event.request)\r\n        .then((networkResponse) => {\r\n          console.log("Network request successful:", event.request.url);\r\n\r\n          // Step 2: Update cache with the fresh response\r\n          // Clone because response body can only be read once\r\n          const responseClone = networkResponse.clone();\r\n\r\n          // Update cache asynchronously (don\'t block the response)\r\n          caches\r\n            .open(CACHE_NAME)\r\n            .then((cache) => {\r\n              console.log("Updating cache with fresh data:", event.request.url);\r\n              cache.put(event.request, responseClone);\r\n            })\r\n            .catch((cacheError) => {\r\n              // Handle cache update failures gracefully\r\n              console.warn("Failed to update cache:", cacheError);\r\n            });\r\n\r\n          // Step 3: Return the fresh network response\r\n          return networkResponse;\r\n        })\r\n        .catch((networkError) => {\r\n          // Step 4: Network failed (offline, server error, etc.)\r\n          console.log(\r\n            "Network failed, trying cache:",\r\n            event.request.url,\r\n            networkError\r\n          );\r\n\r\n          // Step 5: Try to serve from cache as fallback\r\n          return caches.match(event.request).then((cachedResponse) => {\r\n            if (cachedResponse) {\r\n              console.log("Serving stale data from cache:", event.request.url);\r\n              return cachedResponse;\r\n            } else {\r\n              // No cache available either - let the request fail\r\n              console.error("No cache available for:", event.request.url);\r\n              throw networkError;\r\n            }\r\n          });\r\n        })\r\n    );\r\n  }\r\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"stale-while-revalidate-strategy",children:"Stale-While-Revalidate Strategy"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this strategy does:"})," Serves cached content immediately for speed, while updating the cache in the background for next time."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Best use cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"HTML pages and documents"}),"\n",(0,s.jsx)(n.li,{children:"Content where slight staleness is acceptable"}),"\n",(0,s.jsx)(n.li,{children:"When you want both speed AND freshness"}),"\n",(0,s.jsx)(n.li,{children:"News sites, blogs, product catalogs"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Flow:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Check cache first"}),"\n",(0,s.jsx)(n.li,{children:"If found, return cached version immediately (fast response)"}),"\n",(0,s.jsx)(n.li,{children:"Simultaneously fetch from network in background"}),"\n",(0,s.jsx)(n.li,{children:"Update cache with fresh content for next visit"}),"\n",(0,s.jsx)(n.li,{children:"If no cache, wait for network response"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pros:"})," Fast responses + fresh content on next visit\r\n",(0,s.jsx)(n.strong,{children:"Cons:"})," Users might see outdated content briefly"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Stale-While-Revalidate Strategy Implementation\r\n// Best for HTML documents where slight staleness is acceptable\r\nself.addEventListener("fetch", (event) => {\r\n  // Apply stale-while-revalidate strategy to HTML documents\r\n  if (event.request.destination === "document") {\r\n    event.respondWith(\r\n      // Step 1: Check cache for existing content\r\n      caches.match(event.request).then((cachedResponse) => {\r\n        // Step 2: Start network request in parallel (don\'t wait for it)\r\n        const fetchPromise = fetch(event.request)\r\n          .then((networkResponse) => {\r\n            // Step 3: Update cache in background with fresh content\r\n            const responseClone = networkResponse.clone();\r\n\r\n            caches\r\n              .open(CACHE_NAME)\r\n              .then((cache) => {\r\n                console.log("Background cache update:", event.request.url);\r\n                cache.put(event.request, responseClone);\r\n              })\r\n              .catch((cacheError) => {\r\n                console.warn("Background cache update failed:", cacheError);\r\n              });\r\n\r\n            return networkResponse;\r\n          })\r\n          .catch((networkError) => {\r\n            console.log("Background network update failed:", networkError);\r\n            // Don\'t throw - this is a background update\r\n            return null;\r\n          });\r\n\r\n        // Step 4: Return cached response immediately if available\r\n        if (cachedResponse) {\r\n          console.log(\r\n            "Serving from cache (updating in background):",\r\n            event.request.url\r\n          );\r\n          return cachedResponse;\r\n        }\r\n\r\n        // Step 5: No cache available, wait for network response\r\n        console.log("No cache, waiting for network:", event.request.url);\r\n        return fetchPromise;\r\n      })\r\n    );\r\n  }\r\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-caching-with-expiration",children:"Advanced Caching with Expiration"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this CacheManager does:"})," Implements intelligent cache expiration and management to prevent stale data and storage bloat."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key features:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Time-based expiration:"})," Automatically expire cached content after a specified time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Custom cache headers:"})," Add metadata to track when content was cached"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic cleanup:"})," Remove expired entries to free up storage space"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configurable TTL:"})," Different cache lifetimes for different types of content"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"API responses with time-sensitive data"}),"\n",(0,s.jsx)(n.li,{children:"Dynamic content that needs periodic refresh"}),"\n",(0,s.jsx)(n.li,{children:"Storage-constrained environments"}),"\n",(0,s.jsx)(n.li,{children:"Applications with strict data freshness requirements"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," HTTP requests and responses with custom expiration logic\r\n",(0,s.jsx)(n.strong,{children:"Output:"})," Managed cache with automatic expiration and cleanup"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Advanced Cache Manager with time-based expiration\r\nclass CacheManager {\r\n  constructor(cacheName, maxAge = 24 * 60 * 60 * 1000) {\r\n    // Default to 24 hours cache lifetime\r\n    this.cacheName = cacheName;\r\n    this.maxAge = maxAge; // Maximum age in milliseconds\r\n    console.log(\r\n      `CacheManager initialized: ${cacheName}, TTL: ${maxAge / 1000}s`\r\n    );\r\n  }\r\n\r\n  // Retrieve from cache with expiration check\r\n  async get(request) {\r\n    try {\r\n      const cache = await caches.open(this.cacheName);\r\n      const response = await cache.match(request);\r\n\r\n      // No cached response found\r\n      if (!response) {\r\n        console.log("Cache miss:", request.url);\r\n        return null;\r\n      }\r\n\r\n      // Check if the cached response has expired\r\n      const cachedTime = response.headers.get("sw-cache-time");\r\n      if (cachedTime) {\r\n        const age = Date.now() - parseInt(cachedTime);\r\n\r\n        if (age > this.maxAge) {\r\n          console.log(\r\n            "Cache expired, removing:",\r\n            request.url,\r\n            `(age: ${age / 1000}s)`\r\n          );\r\n          // Cache expired - remove it and return null\r\n          await cache.delete(request);\r\n          return null;\r\n        }\r\n\r\n        console.log("Cache hit (valid):", request.url, `(age: ${age / 1000}s)`);\r\n      }\r\n\r\n      return response;\r\n    } catch (error) {\r\n      console.error("Cache get error:", error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Store in cache with timestamp header\r\n  async put(request, response) {\r\n    try {\r\n      const cache = await caches.open(this.cacheName);\r\n\r\n      // Clone the response because it can only be consumed once\r\n      const responseClone = response.clone();\r\n\r\n      // Add custom timestamp header to track when this was cached\r\n      const headers = new Headers(responseClone.headers);\r\n      headers.set("sw-cache-time", Date.now().toString());\r\n      headers.set("sw-cache-ttl", this.maxAge.toString());\r\n\r\n      // Create new response with timestamp headers\r\n      const responseWithTimestamp = new Response(responseClone.body, {\r\n        status: responseClone.status,\r\n        statusText: responseClone.statusText,\r\n        headers: headers,\r\n      });\r\n\r\n      // Store in cache\r\n      await cache.put(request, responseWithTimestamp);\r\n      console.log("Cached with timestamp:", request.url);\r\n\r\n      // Return the original response to the caller\r\n      return response;\r\n    } catch (error) {\r\n      console.error("Cache put error:", error);\r\n      // Return original response even if caching fails\r\n      return response;\r\n    }\r\n  }\r\n\r\n  // Clean up expired cache entries\r\n  async cleanup() {\r\n    try {\r\n      console.log("Starting cache cleanup for:", this.cacheName);\r\n      const cache = await caches.open(this.cacheName);\r\n      const requests = await cache.keys();\r\n\r\n      let deletedCount = 0;\r\n\r\n      // Check each cached item for expiration\r\n      const deletePromises = requests.map(async (request) => {\r\n        try {\r\n          const response = await cache.match(request);\r\n          const cachedTime = response.headers.get("sw-cache-time");\r\n\r\n          if (cachedTime) {\r\n            const age = Date.now() - parseInt(cachedTime);\r\n\r\n            if (age > this.maxAge) {\r\n              console.log("Deleting expired cache entry:", request.url);\r\n              await cache.delete(request);\r\n              deletedCount++;\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        } catch (error) {\r\n          console.error("Error checking cache entry:", request.url, error);\r\n          return false;\r\n        }\r\n      });\r\n\r\n      await Promise.all(deletePromises);\r\n      console.log(\r\n        `Cache cleanup complete. Deleted ${deletedCount} expired entries.`\r\n      );\r\n    } catch (error) {\r\n      console.error("Cache cleanup error:", error);\r\n    }\r\n  }\r\n\r\n  // Get cache statistics\r\n  async getStats() {\r\n    try {\r\n      const cache = await caches.open(this.cacheName);\r\n      const requests = await cache.keys();\r\n\r\n      let totalSize = 0;\r\n      let expiredCount = 0;\r\n\r\n      for (const request of requests) {\r\n        const response = await cache.match(request);\r\n        const blob = await response.blob();\r\n        totalSize += blob.size;\r\n\r\n        const cachedTime = response.headers.get("sw-cache-time");\r\n        if (cachedTime && Date.now() - parseInt(cachedTime) > this.maxAge) {\r\n          expiredCount++;\r\n        }\r\n      }\r\n\r\n      return {\r\n        name: this.cacheName,\r\n        entryCount: requests.length,\r\n        expiredCount,\r\n        totalSizeBytes: totalSize,\r\n        totalSizeMB: (totalSize / (1024 * 1024)).toFixed(2),\r\n      };\r\n    } catch (error) {\r\n      console.error("Error getting cache stats:", error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\n// Usage in service worker with different TTLs for different content types\r\nconst apiCacheManager = new CacheManager("api-cache-v1", 30 * 60 * 1000); // 30 minutes for API\r\nconst imageCacheManager = new CacheManager(\r\n  "image-cache-v1",\r\n  7 * 24 * 60 * 60 * 1000\r\n); // 7 days for images\r\n\r\nself.addEventListener("fetch", (event) => {\r\n  const { request } = event;\r\n\r\n  // Handle API requests with short cache TTL\r\n  if (request.url.includes("/api/")) {\r\n    event.respondWith(\r\n      apiCacheManager.get(request).then((cachedResponse) => {\r\n        if (cachedResponse) {\r\n          console.log("Serving API response from cache");\r\n          return cachedResponse;\r\n        }\r\n\r\n        // Not in cache or expired, fetch from network\r\n        console.log("Fetching API response from network");\r\n        return fetch(request).then((networkResponse) => {\r\n          // Cache the response and return it\r\n          return apiCacheManager.put(request, networkResponse);\r\n        });\r\n      })\r\n    );\r\n  }\r\n\r\n  // Handle image requests with long cache TTL\r\n  else if (request.destination === "image") {\r\n    event.respondWith(\r\n      imageCacheManager.get(request).then((cachedResponse) => {\r\n        if (cachedResponse) {\r\n          return cachedResponse;\r\n        }\r\n\r\n        return fetch(request).then((networkResponse) => {\r\n          return imageCacheManager.put(request, networkResponse);\r\n        });\r\n      })\r\n    );\r\n  }\r\n});\r\n\r\n// Handle cleanup messages from the main thread\r\nself.addEventListener("message", (event) => {\r\n  const { data } = event;\r\n\r\n  switch (data.type) {\r\n    case "CLEANUP_CACHE":\r\n      console.log("Manual cache cleanup requested");\r\n      Promise.all([apiCacheManager.cleanup(), imageCacheManager.cleanup()]);\r\n      break;\r\n\r\n    case "GET_CACHE_STATS":\r\n      Promise.all([\r\n        apiCacheManager.getStats(),\r\n        imageCacheManager.getStats(),\r\n      ]).then((stats) => {\r\n        // Send stats back to main thread\r\n        event.ports[0].postMessage({ type: "CACHE_STATS", stats });\r\n      });\r\n      break;\r\n  }\r\n});\r\n\r\n// Automatic cleanup every hour\r\nsetInterval(() => {\r\n  console.log("Running scheduled cache cleanup");\r\n  apiCacheManager.cleanup();\r\n  imageCacheManager.cleanup();\r\n}, 60 * 60 * 1000); // Every hour\n'})}),"\n",(0,s.jsx)(n.h2,{id:"offline-functionality",children:"Offline Functionality"}),"\n",(0,s.jsx)(n.h3,{id:"comprehensive-offline-strategy",children:"Comprehensive Offline Strategy"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this offline strategy does:"})," Provides a robust offline experience by handling different resource types with appropriate fallback mechanisms."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Resource-specific strategies:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Documents (HTML):"})," Network-first with offline page fallback"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Images:"})," Cache-first with placeholder image fallback"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Other resources:"})," Network-first with cache fallback"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Offline experience features:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Custom offline page for when users lose connectivity"}),"\n",(0,s.jsx)(n.li,{children:"Placeholder images for missing resources"}),"\n",(0,s.jsx)(n.li,{children:"Graceful degradation for different content types"}),"\n",(0,s.jsx)(n.li,{children:"Intelligent caching based on resource characteristics"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," Various types of network requests (documents, images, API calls, etc.)\r\n",(0,s.jsx)(n.strong,{children:"Output:"})," Appropriate responses with offline fallbacks for each resource type"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Define fallback resources for offline scenarios\r\nconst OFFLINE_PAGE = "/offline.html"; // Custom offline page\r\nconst FALLBACK_IMAGE = "/images/offline-image.png"; // Placeholder for missing images\r\nconst CACHE_NAME = "offline-cache-v1";\r\n\r\n// Main fetch event handler with resource-type routing\r\nself.addEventListener("fetch", (event) => {\r\n  const { request } = event;\r\n\r\n  console.log("Handling request:", request.url, "Type:", request.destination);\r\n\r\n  // Route different resource types to appropriate handlers\r\n  if (request.destination === "document") {\r\n    // HTML pages - prioritize fresh content but provide offline fallback\r\n    event.respondWith(handleDocumentRequest(request));\r\n  } else if (request.destination === "image") {\r\n    // Images - prioritize cache for performance, provide placeholder fallback\r\n    event.respondWith(handleImageRequest(request));\r\n  } else {\r\n    // CSS, JS, fonts, and other resources\r\n    event.respondWith(handleOtherRequests(request));\r\n  }\r\n});\r\n\r\n// Handle HTML document requests with network-first strategy\r\nasync function handleDocumentRequest(request) {\r\n  console.log("Handling document request:", request.url);\r\n\r\n  try {\r\n    // Step 1: Try network first for fresh content\r\n    console.log("Attempting network request for document");\r\n    const networkResponse = await fetch(request);\r\n\r\n    // Step 2: Cache successful responses for offline access\r\n    if (networkResponse.ok) {\r\n      console.log("Caching successful document response");\r\n      const cache = await caches.open(CACHE_NAME);\r\n      // Clone because response can only be consumed once\r\n      cache.put(request, networkResponse.clone());\r\n    }\r\n\r\n    return networkResponse;\r\n  } catch (error) {\r\n    console.log("Network failed for document, trying cache:", error.message);\r\n\r\n    // Step 3: Network failed, try cache\r\n    const cachedResponse = await caches.match(request);\r\n    if (cachedResponse) {\r\n      console.log("Serving cached document");\r\n      return cachedResponse;\r\n    }\r\n\r\n    // Step 4: No cache available, show offline page\r\n    console.log("No cache available, serving offline page");\r\n    const offlinePage = await caches.match(OFFLINE_PAGE);\r\n\r\n    if (offlinePage) {\r\n      return offlinePage;\r\n    } else {\r\n      // Fallback if offline page isn\'t cached\r\n      return new Response(\r\n        `<html><body><h1>Offline</h1><p>You are offline and this page is not cached.</p></body></html>`,\r\n        {\r\n          headers: { "Content-Type": "text/html" },\r\n          status: 503,\r\n          statusText: "Service Unavailable",\r\n        }\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n// Handle image requests with cache-first strategy\r\nasync function handleImageRequest(request) {\r\n  console.log("Handling image request:", request.url);\r\n\r\n  try {\r\n    // Step 1: Try cache first for images (performance optimization)\r\n    console.log("Checking cache for image");\r\n    const cachedResponse = await caches.match(request);\r\n    if (cachedResponse) {\r\n      console.log("Serving cached image");\r\n      return cachedResponse;\r\n    }\r\n\r\n    // Step 2: Not in cache, try network\r\n    console.log("Image not cached, fetching from network");\r\n    const networkResponse = await fetch(request);\r\n\r\n    // Step 3: Cache the image for future use\r\n    if (networkResponse.ok) {\r\n      console.log("Caching new image");\r\n      const cache = await caches.open(CACHE_NAME);\r\n      cache.put(request, networkResponse.clone());\r\n    }\r\n\r\n    return networkResponse;\r\n  } catch (error) {\r\n    console.log("Image request failed, serving fallback:", error.message);\r\n\r\n    // Step 4: Both cache and network failed, return fallback image\r\n    const fallbackImage = await caches.match(FALLBACK_IMAGE);\r\n\r\n    if (fallbackImage) {\r\n      return fallbackImage;\r\n    } else {\r\n      // Create a simple SVG placeholder if fallback image isn\'t available\r\n      const svgFallback = `\r\n        <svg width="300" height="200" xmlns="http://www.w3.org/2000/svg">\r\n          <rect width="100%" height="100%" fill="#f0f0f0"/>\r\n          <text x="50%" y="50%" font-family="Arial, sans-serif" font-size="14" \r\n                fill="#666" text-anchor="middle" dy=".3em">\r\n            Image not available offline\r\n          </text>\r\n        </svg>`;\r\n\r\n      return new Response(svgFallback, {\r\n        headers: {\r\n          "Content-Type": "image/svg+xml",\r\n          "Cache-Control": "no-cache",\r\n        },\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\n// Handle other resource requests (CSS, JS, fonts, etc.)\r\nasync function handleOtherRequests(request) {\r\n  console.log(\r\n    "Handling other resource:",\r\n    request.url,\r\n    "Type:",\r\n    request.destination\r\n  );\r\n\r\n  try {\r\n    // Step 1: Try network first for most resources\r\n    console.log("Attempting network request");\r\n    const networkResponse = await fetch(request);\r\n\r\n    // Step 2: Cache successful responses\r\n    if (networkResponse.ok) {\r\n      const cache = await caches.open(CACHE_NAME);\r\n      cache.put(request, networkResponse.clone());\r\n    }\r\n\r\n    return networkResponse;\r\n  } catch (error) {\r\n    console.log("Network failed for resource, trying cache:", error.message);\r\n\r\n    // Step 3: Network failed, try cache\r\n    const cachedResponse = await caches.match(request);\r\n\r\n    if (cachedResponse) {\r\n      console.log("Serving cached resource");\r\n      return cachedResponse;\r\n    } else {\r\n      console.log("Resource not available offline:", request.url);\r\n\r\n      // For CSS files, return empty stylesheet to prevent broken styles\r\n      if (request.destination === "style" || request.url.includes(".css")) {\r\n        return new Response("/* Stylesheet not available offline */", {\r\n          headers: { "Content-Type": "text/css" },\r\n        });\r\n      }\r\n\r\n      // For JavaScript files, return empty script\r\n      if (request.destination === "script" || request.url.includes(".js")) {\r\n        return new Response("// Script not available offline", {\r\n          headers: { "Content-Type": "application/javascript" },\r\n        });\r\n      }\r\n\r\n      // For other resources, let the request fail\r\n      throw error;\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"push-notifications-and-background-sync",children:"Push Notifications and Background Sync"}),"\n",(0,s.jsx)(n.h3,{id:"push-notification-implementation",children:"Push Notification Implementation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this push notification system does:"})," Handles incoming push messages from a server and displays rich, interactive notifications to users."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key components:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Push event handler:"})," Receives messages from push service and creates notifications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Notification click handler:"})," Manages user interactions with notifications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rich notification options:"})," Icons, images, action buttons, and custom data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Window management:"})," Intelligently handles app focus and window opening"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notification flow:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Server sends push message to browser's push service"}),"\n",(0,s.jsx)(n.li,{children:"Browser delivers message to Service Worker"}),"\n",(0,s.jsx)(n.li,{children:"Service Worker creates and displays notification"}),"\n",(0,s.jsx)(n.li,{children:"User interacts with notification"}),"\n",(0,s.jsx)(n.li,{children:"Service Worker handles the interaction (open app, perform action, etc.)"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," Push messages from server with notification payload\r\n",(0,s.jsx)(n.strong,{children:"Output:"})," Rich, interactive notifications with proper click handling"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// PUSH EVENT HANDLER - Receives push messages and displays notifications\r\nself.addEventListener("push", (event) => {\r\n  console.log("Push message received", event);\r\n\r\n  // Extract notification data from push message\r\n  let notificationData = {};\r\n\r\n  if (event.data) {\r\n    try {\r\n      // Parse JSON payload from push service\r\n      notificationData = event.data.json();\r\n      console.log("Push data:", notificationData);\r\n    } catch (error) {\r\n      console.error("Failed to parse push data:", error);\r\n      // Use text data as fallback\r\n      notificationData = { body: event.data.text() };\r\n    }\r\n  } else {\r\n    console.log("Push message has no data");\r\n  }\r\n\r\n  // Configure notification options with fallbacks\r\n  const options = {\r\n    // Basic notification content\r\n    title: notificationData.title || "New Notification",\r\n    body: notificationData.body || "You have a new message",\r\n\r\n    // Visual elements\r\n    icon: notificationData.icon || "/images/icon-192x192.png", // App icon\r\n    badge: notificationData.badge || "/images/badge-72x72.png", // Small monochrome icon\r\n    image: notificationData.image, // Large image (optional)\r\n\r\n    // Custom data to pass to click handler\r\n    data: {\r\n      url: notificationData.url || "/", // URL to open when clicked\r\n      timestamp: Date.now(),\r\n      ...notificationData.data, // Additional custom data\r\n    },\r\n\r\n    // Action buttons (max 2 on most platforms)\r\n    actions: notificationData.actions || [\r\n      {\r\n        action: "view", // Unique identifier\r\n        title: "View", // Button text\r\n        icon: "/images/view-icon.png", // Button icon (optional)\r\n      },\r\n      {\r\n        action: "dismiss",\r\n        title: "Dismiss",\r\n        icon: "/images/dismiss-icon.png",\r\n      },\r\n    ],\r\n\r\n    // Behavior options\r\n    requireInteraction: notificationData.requireInteraction || false, // Stay visible until interaction\r\n    silent: notificationData.silent || false, // No sound/vibration\r\n    renotify: false, // Don\'t replace existing notifications with same tag\r\n    tag: notificationData.tag || "default", // Group related notifications\r\n\r\n    // Additional options\r\n    dir: "auto", // Text direction\r\n    lang: "en-US", // Language\r\n    vibrate: notificationData.vibrate || [200, 100, 200], // Vibration pattern\r\n  };\r\n\r\n  // Display the notification\r\n  // event.waitUntil ensures the Service Worker stays alive until notification is shown\r\n  event.waitUntil(\r\n    self.registration\r\n      .showNotification(options.title, options)\r\n      .then(() => {\r\n        console.log("Notification displayed successfully");\r\n      })\r\n      .catch((error) => {\r\n        console.error("Failed to show notification:", error);\r\n      })\r\n  );\r\n});\r\n\r\n// NOTIFICATION CLICK HANDLER - Manages user interactions with notifications\r\nself.addEventListener("notificationclick", (event) => {\r\n  console.log(\r\n    "Notification clicked:",\r\n    event.notification.title,\r\n    "Action:",\r\n    event.action\r\n  );\r\n\r\n  // Close the notification\r\n  event.notification.close();\r\n\r\n  // Handle different actions\r\n  if (event.action === "view") {\r\n    // User clicked "View" action button\r\n    console.log("Opening specific URL from notification data");\r\n    const targetUrl = event.notification.data?.url || "/";\r\n\r\n    event.waitUntil(\r\n      clients\r\n        .openWindow(targetUrl)\r\n        .then((windowClient) => {\r\n          if (windowClient) {\r\n            console.log("Opened new window:", targetUrl);\r\n          } else {\r\n            console.log("Failed to open window (popup blocked?)");\r\n          }\r\n        })\r\n        .catch((error) => {\r\n          console.error("Error opening window:", error);\r\n        })\r\n    );\r\n  } else if (event.action === "dismiss") {\r\n    // User clicked "Dismiss" action button\r\n    console.log("Notification dismissed by user");\r\n\r\n    // Optional: Send analytics or perform cleanup\r\n    // Example: track dismissal event\r\n    // sendAnalytics(\'notification_dismissed\', event.notification.data);\r\n\r\n    return; // Just close notification, no other action needed\r\n  } else {\r\n    // Default action - user clicked notification body (not an action button)\r\n    console.log("Default notification click - finding or opening app window");\r\n\r\n    event.waitUntil(\r\n      // First, try to find an existing window to focus\r\n      clients\r\n        .matchAll({\r\n          type: "window",\r\n          includeUncontrolled: true, // Include windows not controlled by this SW\r\n        })\r\n        .then((clientList) => {\r\n          console.log(`Found ${clientList.length} existing windows`);\r\n\r\n          // Look for an existing window from our app\r\n          for (const client of clientList) {\r\n            if (\r\n              client.url.includes(self.location.origin) &&\r\n              "focus" in client\r\n            ) {\r\n              console.log("Focusing existing window:", client.url);\r\n              return client.focus();\r\n            }\r\n          }\r\n\r\n          // No existing window found, open new one\r\n          console.log("No existing window found, opening new one");\r\n          const targetUrl = event.notification.data?.url || "/";\r\n          return clients.openWindow(targetUrl);\r\n        })\r\n        .then((windowClient) => {\r\n          if (windowClient) {\r\n            console.log("Successfully handled notification click");\r\n\r\n            // Optional: Send message to the opened/focused window\r\n            windowClient.postMessage({\r\n              type: "NOTIFICATION_CLICKED",\r\n              data: event.notification.data,\r\n            });\r\n          }\r\n        })\r\n        .catch((error) => {\r\n          console.error("Error handling notification click:", error);\r\n        })\r\n    );\r\n  }\r\n});\r\n\r\n// NOTIFICATION CLOSE HANDLER - Track when notifications are closed\r\nself.addEventListener("notificationclose", (event) => {\r\n  console.log("Notification closed:", event.notification.title);\r\n\r\n  // Optional: Track notification close events for analytics\r\n  // This helps understand user engagement with notifications\r\n  const notificationData = {\r\n    title: event.notification.title,\r\n    tag: event.notification.tag,\r\n    timestamp: Date.now(),\r\n  };\r\n\r\n  // Example: Send to analytics service\r\n  // sendAnalytics(\'notification_closed\', notificationData);\r\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"background-sync",children:"Background Sync"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What Background Sync does:"})," Ensures reliable data synchronization by retrying failed network requests when connectivity is restored."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reliable data delivery:"})," Guarantees important data reaches the server eventually"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Offline resilience:"})," Handles network failures gracefully"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Battery efficient:"})," Browser optimizes sync timing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"User-friendly:"})," No manual retry needed"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Form submissions"}),"\n",(0,s.jsx)(n.li,{children:"Chat messages"}),"\n",(0,s.jsx)(n.li,{children:"Analytics events"}),"\n",(0,s.jsx)(n.li,{children:"User-generated content"}),"\n",(0,s.jsx)(n.li,{children:"Critical API calls"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Background Sync flow:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"App attempts network request while offline"}),"\n",(0,s.jsx)(n.li,{children:"Request fails, data is stored locally (IndexedDB)"}),"\n",(0,s.jsx)(n.li,{children:"Service Worker registers a sync event"}),"\n",(0,s.jsx)(n.li,{children:"When connectivity returns, browser triggers sync event"}),"\n",(0,s.jsx)(n.li,{children:"Service Worker processes pending data"}),"\n",(0,s.jsx)(n.li,{children:"Successfully synced data is removed from local storage"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," Failed network requests and their data\r\n",(0,s.jsx)(n.strong,{children:"Output:"})," Reliable delivery of data when connectivity is available"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// BACKGROUND SYNC EVENT HANDLER\r\n// Triggered by the browser when connectivity is restored\r\nself.addEventListener("sync", (event) => {\r\n  console.log("Sync event triggered, tag:", event.tag);\r\n\r\n  // Handle different types of sync operations\r\n  switch (event.tag) {\r\n    case "background-sync":\r\n      // General purpose background sync\r\n      event.waitUntil(doBackgroundSync());\r\n      break;\r\n\r\n    case "chat-messages":\r\n      // Specific sync for chat messages\r\n      event.waitUntil(syncChatMessages());\r\n      break;\r\n\r\n    case "user-actions":\r\n      // Sync user interactions (likes, shares, etc.)\r\n      event.waitUntil(syncUserActions());\r\n      break;\r\n\r\n    default:\r\n      console.log("Unknown sync tag:", event.tag);\r\n  }\r\n});\r\n\r\n// Main background sync function\r\nasync function doBackgroundSync() {\r\n  console.log("Starting background sync process");\r\n\r\n  try {\r\n    // Step 1: Get all pending data from local storage (IndexedDB)\r\n    const pendingData = await getPendingData();\r\n    console.log(`Found ${pendingData.length} pending sync items`);\r\n\r\n    if (pendingData.length === 0) {\r\n      console.log("No pending data to sync");\r\n      return;\r\n    }\r\n\r\n    // Step 2: Process each pending item\r\n    let successCount = 0;\r\n    let failureCount = 0;\r\n\r\n    for (const item of pendingData) {\r\n      try {\r\n        console.log(`Syncing item ${item.id}:`, item.type);\r\n\r\n        // Step 3: Attempt to send data to server\r\n        const response = await fetch(item.endpoint || "/api/sync", {\r\n          method: item.method || "POST",\r\n          body: JSON.stringify(item.data),\r\n          headers: {\r\n            "Content-Type": "application/json",\r\n            "X-Sync-Item-ID": item.id,\r\n            "X-Sync-Timestamp": item.timestamp.toString(),\r\n            ...item.headers, // Additional headers from original request\r\n          },\r\n        });\r\n\r\n        if (response.ok) {\r\n          // Step 4: Success - remove from pending queue\r\n          console.log(`Successfully synced item ${item.id}`);\r\n          await removePendingData(item.id);\r\n          successCount++;\r\n\r\n          // Optional: Store sync result for app to use\r\n          await storeSyncResult(item.id, {\r\n            success: true,\r\n            timestamp: Date.now(),\r\n            response: await response.json(),\r\n          });\r\n        } else {\r\n          // Server error - keep in queue for retry\r\n          console.log(\r\n            `Server error for item ${item.id}:`,\r\n            response.status,\r\n            response.statusText\r\n          );\r\n          failureCount++;\r\n\r\n          // Update retry count and timestamp\r\n          await updatePendingItem(item.id, {\r\n            retryCount: (item.retryCount || 0) + 1,\r\n            lastAttempt: Date.now(),\r\n            lastError: `HTTP ${response.status}: ${response.statusText}`,\r\n          });\r\n        }\r\n      } catch (networkError) {\r\n        // Network error - keep in queue for retry\r\n        console.log(`Network error for item ${item.id}:`, networkError.message);\r\n        failureCount++;\r\n\r\n        await updatePendingItem(item.id, {\r\n          retryCount: (item.retryCount || 0) + 1,\r\n          lastAttempt: Date.now(),\r\n          lastError: networkError.message,\r\n        });\r\n      }\r\n    }\r\n\r\n    console.log(\r\n      `Background sync complete. Success: ${successCount}, Failed: ${failureCount}`\r\n    );\r\n\r\n    // Step 5: Notify the app about sync results\r\n    await notifyAppOfSyncResults({\r\n      totalItems: pendingData.length,\r\n      successCount,\r\n      failureCount,\r\n      timestamp: Date.now(),\r\n    });\r\n  } catch (error) {\r\n    console.error("Background sync process failed:", error);\r\n\r\n    // Re-register sync for retry if the entire process failed\r\n    await self.registration.sync.register("background-sync");\r\n  }\r\n}\r\n\r\n// Specialized sync function for chat messages\r\nasync function syncChatMessages() {\r\n  console.log("Syncing chat messages");\r\n\r\n  try {\r\n    const pendingMessages = await getPendingDataByType("chat-message");\r\n\r\n    for (const message of pendingMessages) {\r\n      const response = await fetch("/api/chat/send", {\r\n        method: "POST",\r\n        body: JSON.stringify({\r\n          text: message.text,\r\n          timestamp: message.timestamp,\r\n          roomId: message.roomId,\r\n        }),\r\n        headers: {\r\n          "Content-Type": "application/json",\r\n          Authorization: `Bearer ${message.token}`,\r\n        },\r\n      });\r\n\r\n      if (response.ok) {\r\n        await removePendingData(message.id);\r\n        console.log("Chat message synced:", message.id);\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error("Chat message sync failed:", error);\r\n  }\r\n}\r\n\r\n// Notify the application about sync results\r\nasync function notifyAppOfSyncResults(results) {\r\n  try {\r\n    // Send message to all open windows/tabs\r\n    const clients = await self.clients.matchAll({\r\n      includeUncontrolled: true,\r\n      type: "window",\r\n    });\r\n\r\n    clients.forEach((client) => {\r\n      client.postMessage({\r\n        type: "BACKGROUND_SYNC_COMPLETE",\r\n        results: results,\r\n      });\r\n    });\r\n\r\n    console.log("Notified", clients.length, "clients about sync results");\r\n  } catch (error) {\r\n    console.error("Failed to notify app of sync results:", error);\r\n  }\r\n}\r\n\r\n// Helper functions for IndexedDB operations\r\n// Note: These would typically be imported from a separate module\r\n\r\nasync function getPendingData() {\r\n  // Implementation would use IndexedDB to retrieve all pending sync items\r\n  // Example structure:\r\n  return [\r\n    {\r\n      id: "sync-item-1",\r\n      type: "user-action",\r\n      endpoint: "/api/users/action",\r\n      method: "POST",\r\n      data: { action: "like", postId: "123" },\r\n      timestamp: Date.now() - 60000,\r\n      retryCount: 0,\r\n    },\r\n    // ... more items\r\n  ];\r\n}\r\n\r\nasync function removePendingData(itemId) {\r\n  // Remove successfully synced item from IndexedDB\r\n  console.log("Removing synced item from storage:", itemId);\r\n}\r\n\r\nasync function updatePendingItem(itemId, updates) {\r\n  // Update retry count and error info for failed items\r\n  console.log("Updating pending item:", itemId, updates);\r\n}\r\n\r\nasync function storeSyncResult(itemId, result) {\r\n  // Store sync results for the app to access\r\n  console.log("Storing sync result:", itemId, result);\r\n}\r\n\r\nasync function getPendingDataByType(type) {\r\n  // Get pending items of a specific type\r\n  const allPending = await getPendingData();\r\n  return allPending.filter((item) => item.type === type);\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-patterns-and-best-practices",children:"Advanced Patterns and Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"service-worker-update-pattern",children:"Service Worker Update Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Handle service worker updates gracefully\r\nself.addEventListener("message", (event) => {\r\n  if (event.data.type === "SKIP_WAITING") {\r\n    self.skipWaiting();\r\n  }\r\n});\r\n\r\n// In main application\r\nclass ServiceWorkerUpdateManager {\r\n  constructor() {\r\n    this.refreshing = false;\r\n    this.setupUpdateHandling();\r\n  }\r\n\r\n  setupUpdateHandling() {\r\n    navigator.serviceWorker.addEventListener("controllerchange", () => {\r\n      if (this.refreshing) return;\r\n      this.refreshing = true;\r\n      window.location.reload();\r\n    });\r\n  }\r\n\r\n  async checkForUpdates() {\r\n    const registration = await navigator.serviceWorker.ready;\r\n    registration.update();\r\n  }\r\n\r\n  async promptUpdate() {\r\n    const registration = await navigator.serviceWorker.ready;\r\n\r\n    if (registration.waiting) {\r\n      const userWantsUpdate = confirm(\r\n        "A new version is available. Would you like to update?"\r\n      );\r\n\r\n      if (userWantsUpdate) {\r\n        registration.waiting.postMessage({ type: "SKIP_WAITING" });\r\n      }\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"resource-versioning-strategy",children:"Resource Versioning Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const CACHE_VERSION = "v2.1.0";\r\nconst STATIC_CACHE = `static-${CACHE_VERSION}`;\r\nconst DYNAMIC_CACHE = `dynamic-${CACHE_VERSION}`;\r\n\r\nconst STATIC_FILES = [\r\n  "/",\r\n  "/styles/main.css",\r\n  "/scripts/main.js",\r\n  "/images/logo.png",\r\n  "/manifest.json",\r\n];\r\n\r\nself.addEventListener("install", (event) => {\r\n  event.waitUntil(\r\n    Promise.all([\r\n      caches.open(STATIC_CACHE).then((cache) => cache.addAll(STATIC_FILES)),\r\n      caches.open(DYNAMIC_CACHE), // Create dynamic cache\r\n    ])\r\n  );\r\n});\r\n\r\nself.addEventListener("activate", (event) => {\r\n  event.waitUntil(\r\n    caches.keys().then((cacheNames) => {\r\n      return Promise.all(\r\n        cacheNames.map((cacheName) => {\r\n          if (\r\n            !cacheName.includes(CACHE_VERSION) &&\r\n            (cacheName.startsWith("static-") ||\r\n              cacheName.startsWith("dynamic-"))\r\n          ) {\r\n            console.log("Deleting old cache:", cacheName);\r\n            return caches.delete(cacheName);\r\n          }\r\n        })\r\n      );\r\n    })\r\n  );\r\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"secure-service-worker-implementation",children:"Secure Service Worker Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Validate requests in service worker\r\nself.addEventListener("fetch", (event) => {\r\n  // Only handle same-origin requests\r\n  if (!event.request.url.startsWith(self.location.origin)) {\r\n    return;\r\n  }\r\n\r\n  // Validate request method\r\n  if (!["GET", "POST", "PUT", "DELETE"].includes(event.request.method)) {\r\n    return;\r\n  }\r\n\r\n  // Handle different request types securely\r\n  if (event.request.url.includes("/api/")) {\r\n    event.respondWith(handleAPIRequest(event.request));\r\n  } else {\r\n    event.respondWith(handleStaticRequest(event.request));\r\n  }\r\n});\r\n\r\nasync function handleAPIRequest(request) {\r\n  // Don\'t cache sensitive API requests\r\n  if (request.url.includes("/auth/") || request.url.includes("/user/")) {\r\n    return fetch(request);\r\n  }\r\n\r\n  // Use network-first for API requests\r\n  try {\r\n    const response = await fetch(request);\r\n\r\n    // Only cache successful responses\r\n    if (response.ok) {\r\n      const cache = await caches.open(DYNAMIC_CACHE);\r\n      cache.put(request, response.clone());\r\n    }\r\n\r\n    return response;\r\n  } catch (error) {\r\n    return caches.match(request);\r\n  }\r\n}\r\n\r\n// Content Security Policy headers\r\nself.addEventListener("fetch", (event) => {\r\n  if (event.request.destination === "document") {\r\n    event.respondWith(\r\n      fetch(event.request).then((response) => {\r\n        // Add security headers\r\n        const headers = new Headers(response.headers);\r\n        headers.set(\r\n          "Content-Security-Policy",\r\n          "default-src \'self\'; script-src \'self\' \'unsafe-eval\'; style-src \'self\' \'unsafe-inline\'"\r\n        );\r\n        headers.set("X-Frame-Options", "DENY");\r\n        headers.set("X-Content-Type-Options", "nosniff");\r\n\r\n        return new Response(response.body, {\r\n          status: response.status,\r\n          statusText: response.statusText,\r\n          headers: headers,\r\n        });\r\n      })\r\n    );\r\n  }\r\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"debugging-and-development",children:"Debugging and Development"}),"\n",(0,s.jsx)(n.h3,{id:"service-worker-debugging-tools",children:"Service Worker Debugging Tools"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Development utilities\r\nclass ServiceWorkerDebugger {\r\n  static logCacheContents() {\r\n    caches.keys().then((cacheNames) => {\r\n      console.group("Cache Contents");\r\n\r\n      cacheNames.forEach((cacheName) => {\r\n        caches.open(cacheName).then((cache) => {\r\n          cache.keys().then((requests) => {\r\n            console.group(cacheName);\r\n            requests.forEach((request) => {\r\n              console.log(request.url);\r\n            });\r\n            console.groupEnd();\r\n          });\r\n        });\r\n      });\r\n\r\n      console.groupEnd();\r\n    });\r\n  }\r\n\r\n  static clearAllCaches() {\r\n    return caches.keys().then((cacheNames) => {\r\n      return Promise.all(\r\n        cacheNames.map((cacheName) => {\r\n          console.log("Deleting cache:", cacheName);\r\n          return caches.delete(cacheName);\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  static async getCacheSize() {\r\n    const cacheNames = await caches.keys();\r\n    let totalSize = 0;\r\n\r\n    for (const cacheName of cacheNames) {\r\n      const cache = await caches.open(cacheName);\r\n      const requests = await cache.keys();\r\n\r\n      for (const request of requests) {\r\n        const response = await cache.match(request);\r\n        const blob = await response.blob();\r\n        totalSize += blob.size;\r\n      }\r\n    }\r\n\r\n    return totalSize;\r\n  }\r\n}\r\n\r\n// Expose debugging tools in development\r\nif (self.location.hostname === "localhost") {\r\n  self.debug = ServiceWorkerDebugger;\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-implementation",children:"Real-World Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"complete-pwa-service-worker",children:"Complete PWA Service Worker"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What this production-ready Service Worker does:"})," Implements a comprehensive caching strategy suitable for real-world Progressive Web Apps."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Production features implemented:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Version-based cache management:"})," Automatic cleanup of old cache versions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource-specific strategies:"})," Different caching approaches for different content types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Offline resilience:"})," Graceful handling of network failures"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance optimization:"})," Strategic precaching of critical resources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error handling:"})," Robust error recovery and fallback mechanisms"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Architecture overview:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"App Shell Pattern:"})," Critical resources cached during installation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Runtime Caching:"})," Dynamic content cached as needed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Offline First:"})," Local content served first when available"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network Resilience:"})," Fallbacks for every type of failure"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," All application network requests\r\n",(0,s.jsx)(n.strong,{children:"Output:"})," Fast, reliable responses with offline capability"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// CONFIGURATION - Update version to trigger cache updates\r\nconst APP_VERSION = "1.0.0";\r\nconst CACHE_NAME = `pwa-cache-${APP_VERSION}`; // Static resources cache\r\nconst API_CACHE = `api-cache-${APP_VERSION}`; // API responses cache\r\nconst RUNTIME_CACHE = `runtime-cache-${APP_VERSION}`; // Dynamic resources cache\r\n\r\n// PRECACHE URLS - Critical resources for offline functionality (App Shell)\r\nconst PRECACHE_URLS = [\r\n  "/", // Home page\r\n  "/index.html", // Main HTML file\r\n  "/styles/app.css", // Critical CSS\r\n  "/scripts/app.js", // Core JavaScript\r\n  "/images/icon-192.png", // App icon\r\n  "/manifest.json", // PWA manifest\r\n  "/offline.html", // Offline fallback page\r\n  // Add other critical resources your app needs to work offline\r\n];\r\n\r\n// INSTALL EVENT - Cache critical resources (App Shell)\r\nself.addEventListener("install", (event) => {\r\n  console.log(`Service Worker ${APP_VERSION} installing...`);\r\n\r\n  event.waitUntil(\r\n    // Open the static cache and precache all critical resources\r\n    caches\r\n      .open(CACHE_NAME)\r\n      .then((cache) => {\r\n        console.log("Precaching app shell resources");\r\n        return cache.addAll(PRECACHE_URLS);\r\n      })\r\n      .then(() => {\r\n        console.log("App shell cached successfully");\r\n        // Skip waiting to activate immediately (optional - be careful in production)\r\n        return self.skipWaiting();\r\n      })\r\n      .catch((error) => {\r\n        console.error("Failed to precache app shell:", error);\r\n        throw error;\r\n      })\r\n  );\r\n});\r\n\r\n// ACTIVATE EVENT - Clean up old caches and take control\r\nself.addEventListener("activate", (event) => {\r\n  console.log(`Service Worker ${APP_VERSION} activating...`);\r\n\r\n  event.waitUntil(\r\n    Promise.all([\r\n      // Step 1: Clean up old cache versions\r\n      caches.keys().then((cacheNames) => {\r\n        console.log("Existing caches:", cacheNames);\r\n\r\n        return Promise.all(\r\n          cacheNames.map((cacheName) => {\r\n            // Delete caches that don\'t match current version\r\n            if (\r\n              cacheName !== CACHE_NAME &&\r\n              cacheName !== API_CACHE &&\r\n              cacheName !== RUNTIME_CACHE\r\n            ) {\r\n              console.log("Deleting old cache:", cacheName);\r\n              return caches.delete(cacheName);\r\n            }\r\n          })\r\n        );\r\n      }),\r\n\r\n      // Step 2: Take control of all clients immediately\r\n      self.clients.claim().then(() => {\r\n        console.log("Service Worker now controlling all pages");\r\n      }),\r\n    ])\r\n  );\r\n});\r\n\r\n// FETCH EVENT - Main request handler with intelligent routing\r\nself.addEventListener("fetch", (event) => {\r\n  const { request } = event;\r\n  const url = new URL(request.url);\r\n\r\n  // Skip non-GET requests for caching\r\n  if (request.method !== "GET") {\r\n    return;\r\n  }\r\n\r\n  // Skip cross-origin requests (unless specifically configured)\r\n  if (url.origin !== self.location.origin) {\r\n    return;\r\n  }\r\n\r\n  console.log("Handling request:", url.pathname, "Type:", request.destination);\r\n\r\n  // Route to appropriate handler based on request type\r\n  if (url.pathname.startsWith("/api/")) {\r\n    // API requests - network-first with cache fallback\r\n    event.respondWith(handleAPIRequest(request));\r\n  } else if (request.destination === "document") {\r\n    // HTML pages - network-first with offline fallback\r\n    event.respondWith(handleDocumentRequest(request));\r\n  } else {\r\n    // Static resources - cache-first with network fallback\r\n    event.respondWith(handleResourceRequest(request));\r\n  }\r\n});\r\n\r\n// API REQUEST HANDLER - Network-first strategy for dynamic data\r\nasync function handleAPIRequest(request) {\r\n  console.log("Handling API request:", request.url);\r\n  const cache = await caches.open(API_CACHE);\r\n\r\n  try {\r\n    // Step 1: Try network first for fresh data\r\n    const response = await fetch(request);\r\n    console.log("API network response:", response.status);\r\n\r\n    // Step 2: Cache successful responses\r\n    if (response.ok) {\r\n      // Clone response for caching (response can only be consumed once)\r\n      const responseClone = response.clone();\r\n\r\n      // Add timestamp header for cache management\r\n      const headers = new Headers(responseClone.headers);\r\n      headers.set("sw-cached-at", Date.now().toString());\r\n\r\n      const timestampedResponse = new Response(responseClone.body, {\r\n        status: responseClone.status,\r\n        statusText: responseClone.statusText,\r\n        headers: headers,\r\n      });\r\n\r\n      cache.put(request, timestampedResponse);\r\n      console.log("API response cached");\r\n    }\r\n\r\n    return response;\r\n  } catch (error) {\r\n    // Step 3: Network failed, try cache\r\n    console.log("API network failed, trying cache:", error.message);\r\n    const cachedResponse = await cache.match(request);\r\n\r\n    if (cachedResponse) {\r\n      console.log("Serving stale API data from cache");\r\n      return cachedResponse;\r\n    } else {\r\n      // No cache available, return error response\r\n      console.log("No API cache available");\r\n      return new Response(\r\n        JSON.stringify({\r\n          error: "Offline",\r\n          message: "This feature requires an internet connection",\r\n        }),\r\n        {\r\n          status: 503,\r\n          statusText: "Service Unavailable",\r\n          headers: { "Content-Type": "application/json" },\r\n        }\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n// DOCUMENT REQUEST HANDLER - Network-first for HTML pages\r\nasync function handleDocumentRequest(request) {\r\n  console.log("Handling document request:", request.url);\r\n\r\n  try {\r\n    // Step 1: Try network first for fresh content\r\n    const response = await fetch(request);\r\n    console.log("Document network response:", response.status);\r\n\r\n    // Step 2: Cache successful HTML responses\r\n    if (response.ok) {\r\n      const cache = await caches.open(RUNTIME_CACHE);\r\n      cache.put(request, response.clone());\r\n      console.log("Document cached");\r\n    }\r\n\r\n    return response;\r\n  } catch (error) {\r\n    // Step 3: Network failed, try cache\r\n    console.log("Document network failed, trying cache:", error.message);\r\n\r\n    const cachedResponse = await caches.match(request);\r\n    if (cachedResponse) {\r\n      console.log("Serving cached document");\r\n      return cachedResponse;\r\n    }\r\n\r\n    // Step 4: No cache, serve offline page\r\n    console.log("No document cache, serving offline page");\r\n    return caches.match("/offline.html");\r\n  }\r\n}\r\n\r\n// RESOURCE REQUEST HANDLER - Cache-first for static assets\r\nasync function handleResourceRequest(request) {\r\n  console.log(\r\n    "Handling resource request:",\r\n    request.url,\r\n    "Type:",\r\n    request.destination\r\n  );\r\n\r\n  // Step 1: Try cache first for performance\r\n  const cachedResponse = await caches.match(request);\r\n\r\n  if (cachedResponse) {\r\n    console.log("Serving resource from cache:", request.url);\r\n    return cachedResponse;\r\n  }\r\n\r\n  try {\r\n    // Step 2: Not in cache, fetch from network\r\n    console.log("Resource not cached, fetching from network");\r\n    const response = await fetch(request);\r\n\r\n    // Step 3: Cache successful responses\r\n    if (response.ok) {\r\n      const cache = await caches.open(RUNTIME_CACHE);\r\n      console.log("Caching new resource:", request.url);\r\n      cache.put(request, response.clone());\r\n    }\r\n\r\n    return response;\r\n  } catch (error) {\r\n    console.log("Resource network failed:", error.message);\r\n\r\n    // Step 4: Provide appropriate fallbacks\r\n    if (request.destination === "image") {\r\n      // Return fallback image\r\n      const fallbackImage = await caches.match("/images/fallback.png");\r\n      if (fallbackImage) {\r\n        return fallbackImage;\r\n      }\r\n    }\r\n\r\n    // For other resources, let the request fail\r\n    throw error;\r\n  }\r\n}\r\n\r\n// ERROR HANDLING - Global error handler\r\nself.addEventListener("error", (event) => {\r\n  console.error("Service Worker error:", event.error);\r\n});\r\n\r\nself.addEventListener("unhandledrejection", (event) => {\r\n  console.error("Service Worker unhandled promise rejection:", event.reason);\r\n});\r\n\r\n// MESSAGING - Handle messages from main thread\r\nself.addEventListener("message", (event) => {\r\n  const { data } = event;\r\n\r\n  switch (data.type) {\r\n    case "GET_VERSION":\r\n      event.ports[0].postMessage({ version: APP_VERSION });\r\n      break;\r\n\r\n    case "CLEAR_CACHE":\r\n      caches\r\n        .keys()\r\n        .then((cacheNames) => {\r\n          return Promise.all(\r\n            cacheNames.map((cacheName) => caches.delete(cacheName))\r\n          );\r\n        })\r\n        .then(() => {\r\n          event.ports[0].postMessage({ success: true });\r\n        });\r\n      break;\r\n\r\n    case "SKIP_WAITING":\r\n      self.skipWaiting();\r\n      break;\r\n  }\r\n});\r\n\r\nconsole.log(`Service Worker ${APP_VERSION} loaded and ready`);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"cache-management-best-practices",children:"Cache Management Best Practices"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Efficient cache management\r\nclass OptimizedCacheManager {\r\n  constructor() {\r\n    this.maxCacheSize = 50 * 1024 * 1024; // 50MB\r\n    this.maxCacheAge = 7 * 24 * 60 * 60 * 1000; // 7 days\r\n  }\r\n\r\n  async maintainCache() {\r\n    await this.removeExpiredEntries();\r\n    await this.enforcesCacheLimit();\r\n  }\r\n\r\n  async removeExpiredEntries() {\r\n    const cacheNames = await caches.keys();\r\n\r\n    for (const cacheName of cacheNames) {\r\n      const cache = await caches.open(cacheName);\r\n      const requests = await cache.keys();\r\n\r\n      for (const request of requests) {\r\n        const response = await cache.match(request);\r\n        const dateHeader = response.headers.get("date");\r\n\r\n        if (dateHeader) {\r\n          const age = Date.now() - new Date(dateHeader).getTime();\r\n          if (age > this.maxCacheAge) {\r\n            await cache.delete(request);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  async enforcesCacheLimit() {\r\n    const totalSize = await this.calculateCacheSize();\r\n\r\n    if (totalSize > this.maxCacheSize) {\r\n      await this.removeOldestEntries(totalSize - this.maxCacheSize);\r\n    }\r\n  }\r\n\r\n  async calculateCacheSize() {\r\n    // Implementation for calculating total cache size\r\n    const cacheNames = await caches.keys();\r\n    let totalSize = 0;\r\n\r\n    for (const cacheName of cacheNames) {\r\n      const cache = await caches.open(cacheName);\r\n      const requests = await cache.keys();\r\n\r\n      for (const request of requests) {\r\n        const response = await cache.match(request);\r\n        const blob = await response.blob();\r\n        totalSize += blob.size;\r\n      }\r\n    }\r\n\r\n    return totalSize;\r\n  }\r\n}\r\n\r\n// Run cache maintenance periodically\r\nconst cacheManager = new OptimizedCacheManager();\r\nsetInterval(() => {\r\n  cacheManager.maintainCache();\r\n}, 24 * 60 * 60 * 1000); // Daily\n'})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Service Workers are a fundamental technology for building modern web applications that provide native-like experiences. They enable powerful features like offline functionality, push notifications, and background synchronization while maintaining security and performance."}),"\n",(0,s.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Lifecycle Management"}),": Understanding the install, activate, and fetch phases is crucial for effective Service Worker implementation."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Caching Strategies"}),": Different caching strategies (cache-first, network-first, stale-while-revalidate) serve different use cases and performance requirements."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Security First"}),": Service Workers require HTTPS and careful consideration of security implications, including proper scope management and input validation."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Progressive Enhancement"}),": Service Workers should enhance the user experience without breaking functionality for unsupported browsers."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance Impact"}),": While Service Workers can significantly improve performance through caching, they require careful management to avoid bloating storage and degrading performance."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"when-to-use-service-workers",children:"When to Use Service Workers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Building Progressive Web Apps (PWAs)"}),"\n",(0,s.jsx)(n.li,{children:"Implementing offline functionality"}),"\n",(0,s.jsx)(n.li,{children:"Optimizing resource loading and caching"}),"\n",(0,s.jsx)(n.li,{children:"Adding push notification capabilities"}),"\n",(0,s.jsx)(n.li,{children:"Performing background data synchronization"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["As detailed in the ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API",children:"MDN Service Worker API documentation"}),", Service Workers represent a paradigm shift toward more resilient, performant web applications that can compete with native mobile apps in terms of user experience and reliability."]}),"\n",(0,s.jsx)(n.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API",children:"MDN Service Worker API Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developers.google.com/web/fundamentals/primers/service-workers",children:"Google Developers - Service Worker Guide"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://w3c.github.io/ServiceWorker/",children:"Service Worker Specification"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developers.google.com/web/tools/workbox",children:"Workbox - Production-ready Service Worker Libraries"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(6540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);