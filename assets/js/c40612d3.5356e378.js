"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5942],{3669:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"project-detail/dexie-and-indexed-db","title":"Dexie.js and IndexedDB: Under the Hood","description":"Table of Contents","source":"@site/docs/project-detail/dexie-and-indexed-db.md","sourceDirName":"project-detail","slug":"/project-detail/dexie-and-indexed-db","permalink":"/frontend-system-design/docs/project-detail/dexie-and-indexed-db","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/dexie-and-indexed-db.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"React Native: Under the Hood","permalink":"/frontend-system-design/docs/project-detail/react-native"},"next":{"title":"WebSockets: Real-Time Communication Under the Hood","permalink":"/frontend-system-design/docs/project-detail/web-socket"}}');var a=n(4848),s=n(8453);const i={},o="Dexie.js and IndexedDB: Under the Hood",c={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"IndexedDB Fundamentals",id:"indexeddb-fundamentals",level:2},{value:"What is IndexedDB?",id:"what-is-indexeddb",level:3},{value:"Core Concepts",id:"core-concepts",level:3},{value:"Database Hierarchy",id:"database-hierarchy",level:4},{value:"Data Storage Model",id:"data-storage-model",level:4},{value:"How IndexedDB Works Under the Hood",id:"how-indexeddb-works-under-the-hood",level:2},{value:"Browser Implementation Architecture",id:"browser-implementation-architecture",level:3},{value:"Chromium/Blink (Chrome, Edge)",id:"chromiumblink-chrome-edge",level:4},{value:"Firefox/Gecko",id:"firefoxgecko",level:4},{value:"Safari/WebKit",id:"safariwebkit",level:4},{value:"Data Storage Mechanisms",id:"data-storage-mechanisms",level:3},{value:"B+ Tree Indexing",id:"b-tree-indexing",level:4},{value:"Transaction Processing",id:"transaction-processing",level:4},{value:"Memory Management",id:"memory-management",level:3},{value:"Page-based Storage",id:"page-based-storage",level:4},{value:"Cache Management",id:"cache-management",level:4},{value:"Browser Storage Architecture",id:"browser-storage-architecture",level:2},{value:"Storage Partitioning",id:"storage-partitioning",level:3},{value:"Persistence Models",id:"persistence-models",level:3},{value:"Temporary Storage",id:"temporary-storage",level:4},{value:"Persistent Storage",id:"persistent-storage",level:4},{value:"Storage Limits and Quota Management",id:"storage-limits-and-quota-management",level:2},{value:"Browser-Specific Limits",id:"browser-specific-limits",level:3},{value:"Chrome/Chromium",id:"chromechromium",level:4},{value:"Firefox",id:"firefox",level:4},{value:"Safari",id:"safari",level:4},{value:"Quota API Usage",id:"quota-api-usage",level:3},{value:"Native IndexedDB API Deep Dive",id:"native-indexeddb-api-deep-dive",level:2},{value:"Database Connection Management",id:"database-connection-management",level:3},{value:"Transaction Management",id:"transaction-management",level:3},{value:"Cursor Operations",id:"cursor-operations",level:3},{value:"Dexie.js: The Wrapper Library",id:"dexiejs-the-wrapper-library",level:2},{value:"Architecture Overview",id:"architecture-overview",level:3},{value:"Core Design Principles",id:"core-design-principles",level:3},{value:"1. Promise-First API",id:"1-promise-first-api",level:4},{value:"2. Fluent Query Interface",id:"2-fluent-query-interface",level:4},{value:"3. Automatic Transaction Management",id:"3-automatic-transaction-management",level:4},{value:"How Dexie Wraps IndexedDB",id:"how-dexie-wraps-indexeddb",level:2},{value:"Promise Wrapper Implementation",id:"promise-wrapper-implementation",level:3},{value:"Query Engine Implementation",id:"query-engine-implementation",level:3},{value:"Transaction Context Management",id:"transaction-context-management",level:3},{value:"Dexie Source Code Analysis",id:"dexie-source-code-analysis",level:2},{value:"Schema Definition and Versioning",id:"schema-definition-and-versioning",level:3},{value:"Bulk Operations Optimization",id:"bulk-operations-optimization",level:3},{value:"Error Handling and Recovery",id:"error-handling-and-recovery",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Indexing Strategies",id:"indexing-strategies",level:3},{value:"Memory Management",id:"memory-management-1",level:3},{value:"Advanced Features and Patterns",id:"advanced-features-and-patterns",level:2},{value:"Live Queries with dexie-react-hooks",id:"live-queries-with-dexie-react-hooks",level:3},{value:"Database Synchronization Patterns",id:"database-synchronization-patterns",level:3},{value:"Custom Middleware and Hooks",id:"custom-middleware-and-hooks",level:3},{value:"Real-World Implementation Examples",id:"real-world-implementation-examples",level:2},{value:"E-commerce Application",id:"e-commerce-application",level:3},{value:"Collaborative Document Editor",id:"collaborative-document-editor",level:3},{value:"Debugging and Development Tools",id:"debugging-and-development-tools",level:2},{value:"Database Inspection Tools",id:"database-inspection-tools",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3},{value:"Best Practices and Gotchas",id:"best-practices-and-gotchas",level:2},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:3},{value:"1. Transaction Scope Issues",id:"1-transaction-scope-issues",level:4},{value:"2. Memory Leaks with Large Queries",id:"2-memory-leaks-with-large-queries",level:4},{value:"3. Index Design Mistakes",id:"3-index-design-mistakes",level:4},{value:"Production Deployment Checklist",id:"production-deployment-checklist",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Further Reading",id:"further-reading",level:3}];function l(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.header,{children:(0,a.jsx)(r.h1,{id:"dexiejs-and-indexeddb-under-the-hood",children:"Dexie.js and IndexedDB: Under the Hood"})}),"\n",(0,a.jsx)(r.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#indexeddb-fundamentals",children:"IndexedDB Fundamentals"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#how-indexeddb-works-under-the-hood",children:"How IndexedDB Works Under the Hood"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#browser-storage-architecture",children:"Browser Storage Architecture"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#storage-limits-and-quota-management",children:"Storage Limits and Quota Management"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#native-indexeddb-api-deep-dive",children:"Native IndexedDB API Deep Dive"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#dexiejs-the-wrapper-library",children:"Dexie.js: The Wrapper Library"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#how-dexie-wraps-indexeddb",children:"How Dexie Wraps IndexedDB"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#dexie-source-code-analysis",children:"Dexie Source Code Analysis"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#performance-considerations",children:"Performance Considerations"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#advanced-features-and-patterns",children:"Advanced Features and Patterns"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#real-world-implementation-examples",children:"Real-World Implementation Examples"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#debugging-and-development-tools",children:"Debugging and Development Tools"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#best-practices-and-gotchas",children:"Best Practices and Gotchas"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(r.p,{children:"IndexedDB is the cornerstone of client-side storage in modern web browsers, providing a robust, transactional database system that can handle large amounts of structured data. While powerful, its native API can be complex and verbose. Dexie.js emerges as a sophisticated wrapper that simplifies IndexedDB interactions while preserving its full capabilities."}),"\n",(0,a.jsx)(r.p,{children:"This comprehensive guide explores both technologies from the ground up, examining their internal mechanisms, architectural decisions, and practical implementations."}),"\n",(0,a.jsx)(r.h2,{id:"indexeddb-fundamentals",children:"IndexedDB Fundamentals"}),"\n",(0,a.jsx)(r.h3,{id:"what-is-indexeddb",children:"What is IndexedDB?"}),"\n",(0,a.jsx)(r.p,{children:"IndexedDB is a low-level web API for client-side storage of significant amounts of structured data. Unlike simple key-value stores like localStorage, IndexedDB is a full-featured database system that supports:"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Object-oriented storage"}),": Stores JavaScript objects directly"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Indexing"}),": Enables efficient queries on object properties"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Transactions"}),": Ensures data integrity through ACID properties"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Asynchronous operations"}),": Non-blocking database operations"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Large storage capacity"}),": Much larger limits than localStorage"]}),"\n"]}),"\n",(0,a.jsx)(r.h3,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,a.jsx)(r.h4,{id:"database-hierarchy",children:"Database Hierarchy"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"Database\r\n\u2514\u2500\u2500 Object Stores (like tables)\r\n    \u251c\u2500\u2500 Records (key-value pairs)\r\n    \u2514\u2500\u2500 Indexes (for efficient querying)\n"})}),"\n",(0,a.jsx)(r.h4,{id:"data-storage-model",children:"Data Storage Model"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Example object structure in IndexedDB\r\nconst userRecord = {\r\n  id: 1, // Primary key\r\n  name: "John Doe", // Indexed property\r\n  email: "john@example.com", // Unique indexed property\r\n  preferences: {\r\n    // Nested object (fully supported)\r\n    theme: "dark",\r\n    notifications: true,\r\n  },\r\n  lastLogin: new Date(), // Complex data types supported\r\n  avatar: blob, // Binary data supported\r\n};\n'})}),"\n",(0,a.jsx)(r.h2,{id:"how-indexeddb-works-under-the-hood",children:"How IndexedDB Works Under the Hood"}),"\n",(0,a.jsx)(r.h3,{id:"browser-implementation-architecture",children:"Browser Implementation Architecture"}),"\n",(0,a.jsx)(r.p,{children:"IndexedDB is implemented differently across browser engines, but they share common architectural patterns:"}),"\n",(0,a.jsx)(r.h4,{id:"chromiumblink-chrome-edge",children:"Chromium/Blink (Chrome, Edge)"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Storage Engine"}),": LevelDB (Google's key-value store)"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"File Location"}),": ",(0,a.jsx)(r.code,{children:"{Profile}/IndexedDB/"})]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Internal Format"}),": Binary format with metadata"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Transaction Isolation"}),": Snapshot isolation"]}),"\n"]}),"\n",(0,a.jsx)(r.h4,{id:"firefoxgecko",children:"Firefox/Gecko"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Storage Engine"}),": SQLite with custom schema"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"File Location"}),": ",(0,a.jsx)(r.code,{children:"{Profile}/storage/default/{origin}/idb/"})]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Internal Format"}),": SQLite database files"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Transaction Isolation"}),": Read committed with locks"]}),"\n"]}),"\n",(0,a.jsx)(r.h4,{id:"safariwebkit",children:"Safari/WebKit"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Storage Engine"}),": SQLite-based implementation"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"File Location"}),": ",(0,a.jsx)(r.code,{children:"~/Library/Safari/Databases/"})]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Internal Format"}),": SQLite with IndexedDB-specific schema"]}),"\n"]}),"\n",(0,a.jsx)(r.h3,{id:"data-storage-mechanisms",children:"Data Storage Mechanisms"}),"\n",(0,a.jsx)(r.h4,{id:"b-tree-indexing",children:"B+ Tree Indexing"}),"\n",(0,a.jsx)(r.p,{children:"IndexedDB implementations typically use B+ tree structures for indexing:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"B+ Tree Example for User Index by Age:\r\n                [25, 50]\r\n               /    |    \\\r\n        [18,21,24] [30,35,40] [55,60,65]\r\n         |  |  |    |  |  |     |  |  |\r\n       data data data ...    data data data\n"})}),"\n",(0,a.jsx)(r.h4,{id:"transaction-processing",children:"Transaction Processing"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Transaction lifecycle in IndexedDB\r\nconst transaction = db.transaction(["users"], "readwrite");\r\n\r\n// 1. Transaction creation - browser allocates resources\r\n// 2. Operation queueing - operations are queued, not executed immediately\r\ntransaction.objectStore("users").add(userData);\r\ntransaction.objectStore("users").get(1);\r\n\r\n// 3. Execution phase - browser processes queued operations\r\n// 4. Commit/Rollback - transaction completes atomically\r\ntransaction.oncomplete = () => console.log("Transaction committed");\r\ntransaction.onerror = () => console.log("Transaction rolled back");\n'})}),"\n",(0,a.jsx)(r.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,a.jsx)(r.h4,{id:"page-based-storage",children:"Page-based Storage"}),"\n",(0,a.jsx)(r.p,{children:"IndexedDB stores data in pages (typically 4KB or 8KB), similar to traditional databases:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"Page Structure:\r\n[Header][Record1][Record2][...][FreeSpace][PageFooter]\n"})}),"\n",(0,a.jsx)(r.h4,{id:"cache-management",children:"Cache Management"}),"\n",(0,a.jsx)(r.p,{children:"Browsers implement sophisticated caching strategies:"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Buffer Pool"}),": In-memory cache of frequently accessed pages"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Write-Ahead Logging"}),": Ensures durability before commit"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Checkpoint Processing"}),": Periodic flushing of dirty pages to disk"]}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"browser-storage-architecture",children:"Browser Storage Architecture"}),"\n",(0,a.jsx)(r.h3,{id:"storage-partitioning",children:"Storage Partitioning"}),"\n",(0,a.jsx)(r.p,{children:"Modern browsers implement storage partitioning to enhance security and performance:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Storage is partitioned by origin\r\nconst origin1 = "https://example.com"; // Separate storage\r\nconst origin2 = "https://subdomain.example.com"; // Separate storage\r\nconst origin3 = "http://example.com"; // Separate storage (different protocol)\n'})}),"\n",(0,a.jsx)(r.h3,{id:"persistence-models",children:"Persistence Models"}),"\n",(0,a.jsx)(r.h4,{id:"temporary-storage",children:"Temporary Storage"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Default behavior - subject to browser eviction\r\nnavigator.storage.estimate().then((estimate) => {\r\n  console.log("Available:", estimate.quota);\r\n  console.log("Used:", estimate.usage);\r\n});\n'})}),"\n",(0,a.jsx)(r.h4,{id:"persistent-storage",children:"Persistent Storage"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Request persistent storage (won\'t be evicted)\r\nnavigator.storage.persist().then((persistent) => {\r\n  if (persistent) {\r\n    console.log("Storage will persist across browser sessions");\r\n  } else {\r\n    console.log("Storage may be evicted by the browser");\r\n  }\r\n});\n'})}),"\n",(0,a.jsx)(r.h2,{id:"storage-limits-and-quota-management",children:"Storage Limits and Quota Management"}),"\n",(0,a.jsx)(r.h3,{id:"browser-specific-limits",children:"Browser-Specific Limits"}),"\n",(0,a.jsx)(r.h4,{id:"chromechromium",children:"Chrome/Chromium"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Default Quota"}),": 60% of available disk space (shared across all origins)"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Per-Origin Limit"}),": 20% of total quota"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Minimum Guarantee"}),": 1GB if available"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Eviction Policy"}),": LRU (Least Recently Used)"]}),"\n"]}),"\n",(0,a.jsx)(r.h4,{id:"firefox",children:"Firefox"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Default Quota"}),": 50% of available disk space"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Per-Origin Limit"}),": 2GB initially, can grow"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Group Limit"}),": 20% of global quota per origin group"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Eviction Policy"}),": LRU with usage-based weighting"]}),"\n"]}),"\n",(0,a.jsx)(r.h4,{id:"safari",children:"Safari"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Default Quota"}),": More conservative, around 1GB"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Per-Origin Limit"}),": Varies, typically 1GB"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"User Prompts"}),": May prompt user for additional storage"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Eviction Policy"}),": Strict LRU"]}),"\n"]}),"\n",(0,a.jsx)(r.h3,{id:"quota-api-usage",children:"Quota API Usage"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Check current storage usage and quota\r\nasync function checkStorageQuota() {\r\n  if ("storage" in navigator && "estimate" in navigator.storage) {\r\n    const estimate = await navigator.storage.estimate();\r\n\r\n    const usageInMB = (estimate.usage / (1024 * 1024)).toFixed(2);\r\n    const quotaInMB = (estimate.quota / (1024 * 1024)).toFixed(2);\r\n    const percentUsed = ((estimate.usage / estimate.quota) * 100).toFixed(2);\r\n\r\n    console.log(`Storage used: ${usageInMB} MB`);\r\n    console.log(`Storage quota: ${quotaInMB} MB`);\r\n    console.log(`Percentage used: ${percentUsed}%`);\r\n\r\n    // Check if we\'re approaching the limit\r\n    if (estimate.usage / estimate.quota > 0.8) {\r\n      console.warn("Storage usage is above 80% - consider cleanup");\r\n    }\r\n  }\r\n}\r\n\r\n// Handle quota exceeded errors\r\nfunction handleQuotaError(error) {\r\n  if (error.name === "QuotaExceededError") {\r\n    console.error("Storage quota exceeded");\r\n    // Implement cleanup logic\r\n    cleanupOldData();\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(r.h2,{id:"native-indexeddb-api-deep-dive",children:"Native IndexedDB API Deep Dive"}),"\n",(0,a.jsx)(r.h3,{id:"database-connection-management",children:"Database Connection Management"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Advanced database opening with version control\r\nfunction openDatabase(name, version, upgradeCallback) {\r\n  return new Promise((resolve, reject) => {\r\n    const request = indexedDB.open(name, version);\r\n\r\n    request.onerror = () => {\r\n      reject(new Error(`Failed to open database: ${request.error}`));\r\n    };\r\n\r\n    request.onsuccess = () => {\r\n      const db = request.result;\r\n\r\n      // Set up global error handler\r\n      db.onerror = (event) => {\r\n        console.error("Database error:", event.target.error);\r\n      };\r\n\r\n      // Handle version change (another tab upgraded the database)\r\n      db.onversionchange = () => {\r\n        db.close();\r\n        console.warn("Database version changed by another tab");\r\n      };\r\n\r\n      resolve(db);\r\n    };\r\n\r\n    request.onupgradeneeded = (event) => {\r\n      const db = event.target.result;\r\n      const transaction = event.target.transaction;\r\n\r\n      // Call user-provided upgrade callback\r\n      if (upgradeCallback) {\r\n        upgradeCallback(db, transaction, event.oldVersion, event.newVersion);\r\n      }\r\n    };\r\n\r\n    request.onblocked = () => {\r\n      console.warn("Database upgrade blocked by other connections");\r\n    };\r\n  });\r\n}\n'})}),"\n",(0,a.jsx)(r.h3,{id:"transaction-management",children:"Transaction Management"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Advanced transaction handling with retry logic\r\nclass TransactionManager {\r\n  constructor(db) {\r\n    this.db = db;\r\n  }\r\n\r\n  async executeWithRetry(storeNames, mode, operations, maxRetries = 3) {\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        return await this.executeTransaction(storeNames, mode, operations);\r\n      } catch (error) {\r\n        if (attempt === maxRetries || !this.isRetryableError(error)) {\r\n          throw error;\r\n        }\r\n\r\n        // Exponential backoff\r\n        await this.delay(Math.pow(2, attempt) * 100);\r\n      }\r\n    }\r\n  }\r\n\r\n  executeTransaction(storeNames, mode, operations) {\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db.transaction(storeNames, mode);\r\n      const results = {};\r\n\r\n      transaction.oncomplete = () => resolve(results);\r\n      transaction.onerror = () => reject(transaction.error);\r\n      transaction.onabort = () => reject(new Error("Transaction aborted"));\r\n\r\n      // Execute operations within transaction\r\n      operations(transaction, results);\r\n    });\r\n  }\r\n\r\n  isRetryableError(error) {\r\n    return (\r\n      error.name === "TransactionInactiveError" ||\r\n      error.name === "InvalidStateError"\r\n    );\r\n  }\r\n\r\n  delay(ms) {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(r.h3,{id:"cursor-operations",children:"Cursor Operations"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"// Advanced cursor usage for range queries and pagination\r\nclass CursorQuery {\r\n  constructor(objectStore) {\r\n    this.objectStore = objectStore;\r\n  }\r\n\r\n  // Paginated query with cursor\r\n  async paginate(pageSize = 20, startKey = null) {\r\n    return new Promise((resolve, reject) => {\r\n      const results = [];\r\n      let cursor;\r\n\r\n      // Create appropriate cursor based on start key\r\n      if (startKey) {\r\n        const range = IDBKeyRange.lowerBound(startKey, true); // exclusive\r\n        cursor = this.objectStore.openCursor(range);\r\n      } else {\r\n        cursor = this.objectStore.openCursor();\r\n      }\r\n\r\n      cursor.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor && results.length < pageSize) {\r\n          results.push({\r\n            key: cursor.key,\r\n            value: cursor.value,\r\n          });\r\n          cursor.continue();\r\n        } else {\r\n          resolve({\r\n            results,\r\n            nextKey: cursor ? cursor.key : null,\r\n            hasMore: cursor !== null,\r\n          });\r\n        }\r\n      };\r\n\r\n      cursor.onerror = () => reject(cursor.error);\r\n    });\r\n  }\r\n\r\n  // Range query with filtering\r\n  async rangeQuery(lowerBound, upperBound, filter = null) {\r\n    return new Promise((resolve, reject) => {\r\n      const results = [];\r\n      const range = IDBKeyRange.bound(lowerBound, upperBound);\r\n      const cursor = this.objectStore.openCursor(range);\r\n\r\n      cursor.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor) {\r\n          if (!filter || filter(cursor.value)) {\r\n            results.push(cursor.value);\r\n          }\r\n          cursor.continue();\r\n        } else {\r\n          resolve(results);\r\n        }\r\n      };\r\n\r\n      cursor.onerror = () => reject(cursor.error);\r\n    });\r\n  }\r\n}\n"})}),"\n",(0,a.jsx)(r.h2,{id:"dexiejs-the-wrapper-library",children:"Dexie.js: The Wrapper Library"}),"\n",(0,a.jsx)(r.h3,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,a.jsx)(r.p,{children:"Dexie.js provides a sophisticated abstraction layer over IndexedDB while maintaining high performance and full feature access. Its architecture consists of several key components:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"Dexie Architecture:\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502           User API Layer            \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         Promise Wrapper             \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502       Transaction Manager           \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         Query Engine                \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502       Schema Management             \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         IndexedDB Core              \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(r.h3,{id:"core-design-principles",children:"Core Design Principles"}),"\n",(0,a.jsx)(r.h4,{id:"1-promise-first-api",children:"1. Promise-First API"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"// Native IndexedDB (callback-based)\r\nconst request = objectStore.get(key);\r\nrequest.onsuccess = (event) => {\r\n  const result = event.target.result;\r\n  // Handle result\r\n};\r\nrequest.onerror = (event) => {\r\n  // Handle error\r\n};\r\n\r\n// Dexie (Promise-based)\r\nconst result = await db.table.get(key);\n"})}),"\n",(0,a.jsx)(r.h4,{id:"2-fluent-query-interface",children:"2. Fluent Query Interface"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Complex query in Dexie\r\nconst results = await db.users\r\n  .where("age")\r\n  .between(18, 65)\r\n  .and((user) => user.isActive)\r\n  .orderBy("name")\r\n  .limit(50)\r\n  .toArray();\n'})}),"\n",(0,a.jsx)(r.h4,{id:"3-automatic-transaction-management",children:"3. Automatic Transaction Management"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Dexie automatically manages transactions\r\nawait db.transaction("rw", db.users, db.orders, async () => {\r\n  const user = await db.users.add({ name: "John" });\r\n  await db.orders.add({ userId: user, total: 100 });\r\n  // Transaction commits automatically on success\r\n  // Rolls back automatically on error\r\n});\n'})}),"\n",(0,a.jsx)(r.h2,{id:"how-dexie-wraps-indexeddb",children:"How Dexie Wraps IndexedDB"}),"\n",(0,a.jsx)(r.h3,{id:"promise-wrapper-implementation",children:"Promise Wrapper Implementation"}),"\n",(0,a.jsx)(r.p,{children:"Dexie's promise wrapper is one of its most sophisticated features. Here's a simplified version of how it works:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"// Simplified Promise wrapper (based on Dexie source concepts)\r\nclass DexiePromise extends Promise {\r\n  constructor(executor) {\r\n    super(executor);\r\n    this._zone = getCurrentZone(); // Transaction context\r\n  }\r\n\r\n  then(onFulfilled, onRejected) {\r\n    return this._zone.run(() => {\r\n      return super.then(onFulfilled, onRejected);\r\n    });\r\n  }\r\n\r\n  catch(onRejected) {\r\n    return this._zone.run(() => {\r\n      return super.catch(onRejected);\r\n    });\r\n  }\r\n}\r\n\r\n// Zone implementation for transaction context\r\nclass Zone {\r\n  constructor(parent = null) {\r\n    this.parent = parent;\r\n    this.transaction = null;\r\n    this.props = {};\r\n  }\r\n\r\n  run(fn) {\r\n    const previousZone = currentZone;\r\n    currentZone = this;\r\n    try {\r\n      return fn();\r\n    } finally {\r\n      currentZone = previousZone;\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,a.jsx)(r.h3,{id:"query-engine-implementation",children:"Query Engine Implementation"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"// Dexie's Collection class (simplified)\r\nclass Collection {\r\n  constructor(table, where) {\r\n    this.table = table;\r\n    this.where = where;\r\n    this.filters = [];\r\n    this.ordering = null;\r\n    this.limitValue = null;\r\n  }\r\n\r\n  // Fluent query methods\r\n  and(filterFunction) {\r\n    return new Collection(this.table, this.where).addFilter(filterFunction);\r\n  }\r\n\r\n  orderBy(keyPath) {\r\n    const collection = this.clone();\r\n    collection.ordering = keyPath;\r\n    return collection;\r\n  }\r\n\r\n  limit(count) {\r\n    const collection = this.clone();\r\n    collection.limitValue = count;\r\n    return collection;\r\n  }\r\n\r\n  // Execute query\r\n  async toArray() {\r\n    const strategy = this.optimizeQuery();\r\n    return await strategy.execute();\r\n  }\r\n\r\n  // Query optimization\r\n  optimizeQuery() {\r\n    if (this.where && this.table.schema.hasIndex(this.where.keyPath)) {\r\n      return new IndexStrategy(this);\r\n    } else {\r\n      return new ScanStrategy(this);\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,a.jsx)(r.h3,{id:"transaction-context-management",children:"Transaction Context Management"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"// Dexie's transaction management (conceptual)\r\nclass Transaction {\r\n  constructor(mode, tables, db) {\r\n    this.mode = mode;\r\n    this.tables = tables;\r\n    this.db = db;\r\n    this.idbtrans = null;\r\n    this.active = false;\r\n  }\r\n\r\n  async execute(fn) {\r\n    this.idbtrans = this.db.idbdb.transaction(this.tables, this.mode);\r\n    this.active = true;\r\n\r\n    // Set up transaction event handlers\r\n    this.idbtrans.oncomplete = () => this.complete();\r\n    this.idbtrans.onerror = (event) => this.error(event);\r\n    this.idbtrans.onabort = () => this.abort();\r\n\r\n    try {\r\n      // Execute user function in transaction context\r\n      const result = await this.runInContext(fn);\r\n      return result;\r\n    } catch (error) {\r\n      this.idbtrans.abort();\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  runInContext(fn) {\r\n    return new Zone(currentZone).run(() => {\r\n      currentZone.transaction = this;\r\n      return fn();\r\n    });\r\n  }\r\n}\n"})}),"\n",(0,a.jsx)(r.h2,{id:"dexie-source-code-analysis",children:"Dexie Source Code Analysis"}),"\n",(0,a.jsx)(r.h3,{id:"schema-definition-and-versioning",children:"Schema Definition and Versioning"}),"\n",(0,a.jsx)(r.p,{children:"Looking at Dexie's source code, schema management is handled through a sophisticated versioning system:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// From Dexie source: Version class\r\nclass Version {\r\n  constructor(versionNumber) {\r\n    this._cfg = {\r\n      version: versionNumber,\r\n      storeNames: [],\r\n      dbschema: {},\r\n      tables: {},\r\n    };\r\n  }\r\n\r\n  stores(stores) {\r\n    Object.keys(stores).forEach((tableName) => {\r\n      const schema = stores[tableName];\r\n      this.parseStoreSchema(tableName, schema);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  parseStoreSchema(tableName, schema) {\r\n    // Parse schema string like "++id,name,*tags"\r\n    const parts = schema.split(",").map((s) => s.trim());\r\n    const primKey = this.parsePrimaryKey(parts[0]);\r\n    const indexes = this.parseIndexes(parts.slice(1));\r\n\r\n    this._cfg.dbschema[tableName] = {\r\n      primKey,\r\n      indexes,\r\n      mappedClass: null,\r\n    };\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(r.h3,{id:"bulk-operations-optimization",children:"Bulk Operations Optimization"}),"\n",(0,a.jsx)(r.p,{children:"Dexie implements sophisticated bulk operations that significantly outperform individual operations:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"// Dexie's bulk add implementation (conceptual)\r\nclass Table {\r\n  async bulkAdd(objects, keys) {\r\n    const trans = getCurrentTransaction();\r\n    const store = trans.objectStore(this.name);\r\n\r\n    // Use browser's native bulk capabilities when available\r\n    if (store.addAll) {\r\n      return await this.nativeBulkAdd(store, objects, keys);\r\n    }\r\n\r\n    // Fallback to optimized batch processing\r\n    return await this.batchAdd(store, objects, keys);\r\n  }\r\n\r\n  async batchAdd(store, objects, keys) {\r\n    const batchSize = 100; // Optimal batch size\r\n    const results = [];\r\n\r\n    for (let i = 0; i < objects.length; i += batchSize) {\r\n      const batch = objects.slice(i, i + batchSize);\r\n      const batchKeys = keys ? keys.slice(i, i + batchSize) : undefined;\r\n\r\n      const batchResults = await Promise.all(\r\n        batch.map((obj, idx) => {\r\n          const key = batchKeys ? batchKeys[idx] : undefined;\r\n          return this.promisifyRequest(store.add(obj, key));\r\n        })\r\n      );\r\n\r\n      results.push(...batchResults);\r\n    }\r\n\r\n    return results;\r\n  }\r\n}\n"})}),"\n",(0,a.jsx)(r.h3,{id:"error-handling-and-recovery",children:"Error Handling and Recovery"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Dexie\'s error handling system\r\nclass DexieError extends Error {\r\n  constructor(name, message) {\r\n    super(message);\r\n    this.name = name;\r\n  }\r\n}\r\n\r\n// Specific error types\r\nclass QuotaExceededError extends DexieError {\r\n  constructor() {\r\n    super("QuotaExceededError", "Storage quota exceeded");\r\n  }\r\n}\r\n\r\nclass TransactionInactiveError extends DexieError {\r\n  constructor() {\r\n    super("TransactionInactiveError", "Transaction is no longer active");\r\n  }\r\n}\r\n\r\n// Error recovery mechanisms\r\nclass ErrorRecovery {\r\n  static async handleQuotaExceeded(operation) {\r\n    // Attempt to free up space\r\n    await this.cleanupExpiredData();\r\n\r\n    // Retry operation\r\n    try {\r\n      return await operation();\r\n    } catch (error) {\r\n      if (error.name === "QuotaExceededError") {\r\n        throw new Error("Storage quota exceeded even after cleanup");\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(r.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(r.h3,{id:"indexing-strategies",children:"Indexing Strategies"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Optimal indexing for different query patterns\r\nconst db = new Dexie("PerformanceDB");\r\ndb.version(1).stores({\r\n  // Compound index for multi-column queries\r\n  orders:\r\n    "++id, [customerId+status], [createdAt+status], customerId, status, createdAt",\r\n\r\n  // Multientry index for array properties\r\n  products: "++id, name, *tags, categoryId",\r\n\r\n  // Case-insensitive search preparation\r\n  users: "++id, name, email, [lastName+firstName]",\r\n});\r\n\r\n// Query optimization examples\r\nasync function optimizedQueries() {\r\n  // Uses compound index [customerId+status]\r\n  const activeOrders = await db.orders\r\n    .where(["customerId", "status"])\r\n    .equals([123, "active"])\r\n    .toArray();\r\n\r\n  // Uses multientry index on tags\r\n  const taggedProducts = await db.products\r\n    .where("tags")\r\n    .anyOf(["electronics", "gadgets"])\r\n    .toArray();\r\n\r\n  // Range query with index\r\n  const recentOrders = await db.orders\r\n    .where("createdAt")\r\n    .above(Date.now() - 86400000) // Last 24 hours\r\n    .toArray();\r\n}\n'})}),"\n",(0,a.jsx)(r.h3,{id:"memory-management-1",children:"Memory Management"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Efficient large dataset processing\r\nasync function processLargeDataset() {\r\n  let processed = 0;\r\n\r\n  await db.largeTable.each((record) => {\r\n    // Process each record individually\r\n    processRecord(record);\r\n    processed++;\r\n\r\n    if (processed % 1000 === 0) {\r\n      console.log(`Processed ${processed} records`);\r\n    }\r\n  });\r\n}\r\n\r\n// Pagination for large result sets\r\nasync function paginatedQuery(pageSize = 100) {\r\n  let lastKey = null;\r\n  let hasMore = true;\r\n\r\n  while (hasMore) {\r\n    const query = db.table.orderBy("id");\r\n\r\n    if (lastKey) {\r\n      query.where("id").above(lastKey);\r\n    }\r\n\r\n    const results = await query.limit(pageSize).toArray();\r\n\r\n    if (results.length < pageSize) {\r\n      hasMore = false;\r\n    } else {\r\n      lastKey = results[results.length - 1].id;\r\n    }\r\n\r\n    // Process current page\r\n    processBatch(results);\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(r.h2,{id:"advanced-features-and-patterns",children:"Advanced Features and Patterns"}),"\n",(0,a.jsx)(r.h3,{id:"live-queries-with-dexie-react-hooks",children:"Live Queries with dexie-react-hooks"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Real-time data synchronization\r\nimport { useLiveQuery } from "dexie-react-hooks";\r\n\r\nfunction UserList() {\r\n  // Automatically re-runs when data changes\r\n  const users = useLiveQuery(() =>\r\n    db.users.where("isActive").equals(true).sortBy("name")\r\n  );\r\n\r\n  if (!users) return <div>Loading...</div>;\r\n\r\n  return (\r\n    <ul>\r\n      {users.map((user) => (\r\n        <li key={user.id}>{user.name}</li>\r\n      ))}\r\n    </ul>\r\n  );\r\n}\n'})}),"\n",(0,a.jsx)(r.h3,{id:"database-synchronization-patterns",children:"Database Synchronization Patterns"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Offline-first sync pattern\r\nclass SyncManager {\r\n  constructor(db, apiClient) {\r\n    this.db = db;\r\n    this.api = apiClient;\r\n    this.syncQueue = [];\r\n  }\r\n\r\n  async syncToServer() {\r\n    // Get pending changes\r\n    const pendingChanges = await this.db.syncLog\r\n      .where("synced")\r\n      .equals(false)\r\n      .toArray();\r\n\r\n    for (const change of pendingChanges) {\r\n      try {\r\n        await this.applySyncChange(change);\r\n        await this.db.syncLog.update(change.id, { synced: true });\r\n      } catch (error) {\r\n        console.error("Sync failed for change:", change.id, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  async applySyncChange(change) {\r\n    switch (change.operation) {\r\n      case "create":\r\n        await this.api.create(change.table, change.data);\r\n        break;\r\n      case "update":\r\n        await this.api.update(change.table, change.id, change.data);\r\n        break;\r\n      case "delete":\r\n        await this.api.delete(change.table, change.id);\r\n        break;\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(r.h3,{id:"custom-middleware-and-hooks",children:"Custom Middleware and Hooks"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Dexie middleware for logging and validation\r\ndb.use({\r\n  name: "LoggingMiddleware",\r\n  create: function (down, ctx, table) {\r\n    return function (data) {\r\n      console.log(`Creating record in ${table}:`, data);\r\n      return down.create.call(this, data);\r\n    };\r\n  },\r\n  read: function (down, ctx, table) {\r\n    return function (key) {\r\n      console.log(`Reading from ${table} with key:`, key);\r\n      return down.read.call(this, key);\r\n    };\r\n  },\r\n  update: function (down, ctx, table) {\r\n    return function (data) {\r\n      console.log(`Updating record in ${table}:`, data);\r\n      return down.update.call(this, data);\r\n    };\r\n  },\r\n  delete: function (down, ctx, table) {\r\n    return function (key) {\r\n      console.log(`Deleting from ${table} with key:`, key);\r\n      return down.delete.call(this, key);\r\n    };\r\n  },\r\n});\n'})}),"\n",(0,a.jsx)(r.h2,{id:"real-world-implementation-examples",children:"Real-World Implementation Examples"}),"\n",(0,a.jsx)(r.h3,{id:"e-commerce-application",children:"E-commerce Application"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// E-commerce database schema\r\nconst ecommerceDB = new Dexie("EcommerceApp");\r\necommerceDB.version(1).stores({\r\n  products: "++id, name, price, categoryId, *tags, inStock",\r\n  categories: "++id, name, parentId",\r\n  cart: "++id, productId, quantity, addedAt",\r\n  orders: "++id, customerId, status, total, createdAt",\r\n  orderItems: "++id, orderId, productId, quantity, price",\r\n});\r\n\r\n// Shopping cart implementation\r\nclass ShoppingCart {\r\n  async addItem(productId, quantity = 1) {\r\n    const existingItem = await ecommerceDB.cart\r\n      .where("productId")\r\n      .equals(productId)\r\n      .first();\r\n\r\n    if (existingItem) {\r\n      await ecommerceDB.cart.update(existingItem.id, {\r\n        quantity: existingItem.quantity + quantity,\r\n      });\r\n    } else {\r\n      await ecommerceDB.cart.add({\r\n        productId,\r\n        quantity,\r\n        addedAt: new Date(),\r\n      });\r\n    }\r\n  }\r\n\r\n  async getCartTotal() {\r\n    const cartItems = await ecommerceDB.cart.toArray();\r\n    let total = 0;\r\n\r\n    for (const item of cartItems) {\r\n      const product = await ecommerceDB.products.get(item.productId);\r\n      total += product.price * item.quantity;\r\n    }\r\n\r\n    return total;\r\n  }\r\n\r\n  async checkout(customerId) {\r\n    return await ecommerceDB.transaction(\r\n      "rw",\r\n      ecommerceDB.cart,\r\n      ecommerceDB.orders,\r\n      ecommerceDB.orderItems,\r\n      async () => {\r\n        const cartItems = await ecommerceDB.cart.toArray();\r\n        const total = await this.getCartTotal();\r\n\r\n        // Create order\r\n        const orderId = await ecommerceDB.orders.add({\r\n          customerId,\r\n          status: "pending",\r\n          total,\r\n          createdAt: new Date(),\r\n        });\r\n\r\n        // Add order items\r\n        for (const item of cartItems) {\r\n          const product = await ecommerceDB.products.get(item.productId);\r\n          await ecommerceDB.orderItems.add({\r\n            orderId,\r\n            productId: item.productId,\r\n            quantity: item.quantity,\r\n            price: product.price,\r\n          });\r\n        }\r\n\r\n        // Clear cart\r\n        await ecommerceDB.cart.clear();\r\n\r\n        return orderId;\r\n      }\r\n    );\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(r.h3,{id:"collaborative-document-editor",children:"Collaborative Document Editor"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Document editor with operational transformation\r\nconst docDB = new Dexie("DocumentEditor");\r\ndocDB.version(1).stores({\r\n  documents: "++id, title, content, lastModified, version",\r\n  operations: "++id, documentId, type, position, content, timestamp, userId",\r\n  conflicts: "++id, documentId, operationId, resolvedAt",\r\n});\r\n\r\nclass OperationalTransform {\r\n  async applyOperation(docId, operation) {\r\n    return await docDB.transaction(\r\n      "rw",\r\n      docDB.documents,\r\n      docDB.operations,\r\n      async () => {\r\n        // Get current document state\r\n        const doc = await docDB.documents.get(docId);\r\n\r\n        // Get all operations after this operation\'s base version\r\n        const laterOps = await docDB.operations\r\n          .where("documentId")\r\n          .equals(docId)\r\n          .and((op) => op.timestamp > operation.baseTimestamp)\r\n          .sortBy("timestamp");\r\n\r\n        // Transform operation against later operations\r\n        const transformedOp = this.transform(operation, laterOps);\r\n\r\n        // Apply transformed operation to document\r\n        const newContent = this.applyToContent(doc.content, transformedOp);\r\n\r\n        // Update document\r\n        await docDB.documents.update(docId, {\r\n          content: newContent,\r\n          lastModified: new Date(),\r\n          version: doc.version + 1,\r\n        });\r\n\r\n        // Store operation in log\r\n        await docDB.operations.add({\r\n          ...transformedOp,\r\n          documentId: docId,\r\n          timestamp: new Date(),\r\n        });\r\n      }\r\n    );\r\n  }\r\n\r\n  transform(operation, laterOperations) {\r\n    let transformedOp = { ...operation };\r\n\r\n    for (const laterOp of laterOperations) {\r\n      transformedOp = this.transformPair(transformedOp, laterOp);\r\n    }\r\n\r\n    return transformedOp;\r\n  }\r\n\r\n  transformPair(op1, op2) {\r\n    // Implement operational transformation logic\r\n    // This is a simplified version\r\n    if (op1.type === "insert" && op2.type === "insert") {\r\n      if (op2.position <= op1.position) {\r\n        return { ...op1, position: op1.position + op2.content.length };\r\n      }\r\n    }\r\n\r\n    return op1;\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(r.h2,{id:"debugging-and-development-tools",children:"Debugging and Development Tools"}),"\n",(0,a.jsx)(r.h3,{id:"database-inspection-tools",children:"Database Inspection Tools"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Development utilities for debugging\r\nclass DexieDebugger {\r\n  static async inspectDatabase(db) {\r\n    console.group("Database Inspection");\r\n\r\n    // List all tables\r\n    const tables = db.tables.map((table) => table.name);\r\n    console.log("Tables:", tables);\r\n\r\n    // Count records in each table\r\n    for (const tableName of tables) {\r\n      const count = await db.table(tableName).count();\r\n      console.log(`${tableName}: ${count} records`);\r\n    }\r\n\r\n    // Check storage usage\r\n    if (navigator.storage && navigator.storage.estimate) {\r\n      const estimate = await navigator.storage.estimate();\r\n      console.log("Storage estimate:", estimate);\r\n    }\r\n\r\n    console.groupEnd();\r\n  }\r\n\r\n  static async exportData(db) {\r\n    const data = {};\r\n\r\n    for (const table of db.tables) {\r\n      data[table.name] = await table.toArray();\r\n    }\r\n\r\n    return JSON.stringify(data, null, 2);\r\n  }\r\n\r\n  static async importData(db, jsonData) {\r\n    const data = JSON.parse(jsonData);\r\n\r\n    await db.transaction("rw", db.tables, async () => {\r\n      // Clear all tables first\r\n      for (const table of db.tables) {\r\n        await table.clear();\r\n      }\r\n\r\n      // Import data\r\n      for (const [tableName, records] of Object.entries(data)) {\r\n        if (db[tableName]) {\r\n          await db[tableName].bulkAdd(records);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  static enableQueryLogging(db) {\r\n    db.use({\r\n      name: "QueryLogger",\r\n      read: function (down, ctx, table) {\r\n        return function (...args) {\r\n          console.time(`Read from ${table}`);\r\n          return down.read.apply(this, args).finally(() => {\r\n            console.timeEnd(`Read from ${table}`);\r\n          });\r\n        };\r\n      },\r\n    });\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(r.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Performance monitoring utilities\r\nclass PerformanceMonitor {\r\n  constructor(db) {\r\n    this.db = db;\r\n    this.metrics = new Map();\r\n  }\r\n\r\n  startMonitoring() {\r\n    this.db.use({\r\n      name: "PerformanceMonitor",\r\n      create: this.wrapOperation("create"),\r\n      read: this.wrapOperation("read"),\r\n      update: this.wrapOperation("update"),\r\n      delete: this.wrapOperation("delete"),\r\n    });\r\n  }\r\n\r\n  wrapOperation(operation) {\r\n    return (down, ctx, table) => {\r\n      return function (...args) {\r\n        const start = performance.now();\r\n        const key = `${table}.${operation}`;\r\n\r\n        return down[operation].apply(this, args).finally(() => {\r\n          const duration = performance.now() - start;\r\n          this.recordMetric(key, duration);\r\n        });\r\n      }.bind(this);\r\n    };\r\n  }\r\n\r\n  recordMetric(operation, duration) {\r\n    if (!this.metrics.has(operation)) {\r\n      this.metrics.set(operation, []);\r\n    }\r\n\r\n    this.metrics.get(operation).push(duration);\r\n\r\n    // Keep only last 100 measurements\r\n    const measurements = this.metrics.get(operation);\r\n    if (measurements.length > 100) {\r\n      measurements.shift();\r\n    }\r\n  }\r\n\r\n  getStats() {\r\n    const stats = {};\r\n\r\n    for (const [operation, measurements] of this.metrics) {\r\n      const avg = measurements.reduce((a, b) => a + b, 0) / measurements.length;\r\n      const max = Math.max(...measurements);\r\n      const min = Math.min(...measurements);\r\n\r\n      stats[operation] = { avg, max, min, count: measurements.length };\r\n    }\r\n\r\n    return stats;\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(r.h2,{id:"best-practices-and-gotchas",children:"Best Practices and Gotchas"}),"\n",(0,a.jsx)(r.h3,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,a.jsx)(r.h4,{id:"1-transaction-scope-issues",children:"1. Transaction Scope Issues"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// \u274c Wrong: Operations outside transaction scope\r\nasync function badExample() {\r\n  const transaction = db.transaction("rw", db.users, db.orders);\r\n\r\n  setTimeout(async () => {\r\n    // This will fail - transaction may already be committed\r\n    await db.users.add({ name: "John" });\r\n  }, 100);\r\n}\r\n\r\n// \u2705 Correct: Keep all operations synchronous within transaction\r\nasync function goodExample() {\r\n  await db.transaction("rw", db.users, db.orders, async () => {\r\n    await db.users.add({ name: "John" });\r\n    await db.orders.add({ userId: 1, total: 100 });\r\n    // All operations complete before transaction ends\r\n  });\r\n}\n'})}),"\n",(0,a.jsx)(r.h4,{id:"2-memory-leaks-with-large-queries",children:"2. Memory Leaks with Large Queries"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// \u274c Wrong: Loading entire large dataset\r\nasync function memoryHog() {\r\n  const allRecords = await db.largeTable.toArray(); // Could be millions\r\n  return allRecords.filter((record) => record.isActive);\r\n}\r\n\r\n// \u2705 Correct: Use streaming or pagination\r\nasync function memoryEfficient() {\r\n  const activeRecords = [];\r\n\r\n  await db.largeTable\r\n    .where("isActive")\r\n    .equals(true)\r\n    .each((record) => {\r\n      activeRecords.push(record);\r\n    });\r\n\r\n  return activeRecords;\r\n}\n'})}),"\n",(0,a.jsx)(r.h4,{id:"3-index-design-mistakes",children:"3. Index Design Mistakes"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// \u274c Wrong: Missing compound indexes for multi-column queries\r\ndb.version(1).stores({\r\n  orders: "++id, customerId, status, createdAt",\r\n});\r\n\r\n// This query will be slow\r\nawait db.orders\r\n  .where("customerId")\r\n  .equals(123)\r\n  .and((order) => order.status === "active")\r\n  .toArray();\r\n\r\n// \u2705 Correct: Add compound index\r\ndb.version(1).stores({\r\n  orders: "++id, [customerId+status], customerId, status, createdAt",\r\n});\r\n\r\n// This query will be fast\r\nawait db.orders\r\n  .where(["customerId", "status"])\r\n  .equals([123, "active"])\r\n  .toArray();\n'})}),"\n",(0,a.jsx)(r.h3,{id:"production-deployment-checklist",children:"Production Deployment Checklist"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:'// Production-ready Dexie setup\r\nclass ProductionDB {\r\n  constructor() {\r\n    this.db = new Dexie("ProductionApp");\r\n    this.setupSchema();\r\n    this.setupErrorHandling();\r\n    this.setupPerformanceMonitoring();\r\n  }\r\n\r\n  setupSchema() {\r\n    this.db.version(1).stores({\r\n      // Carefully designed schema with proper indexes\r\n      users: "++id, email, [lastName+firstName], lastActiveAt",\r\n      sessions: "++id, userId, token, expiresAt",\r\n      cache: "key, data, expiresAt",\r\n    });\r\n\r\n    // Handle schema upgrades gracefully\r\n    this.db\r\n      .version(2)\r\n      .stores({\r\n        users: "++id, email, [lastName+firstName], lastActiveAt, preferences",\r\n      })\r\n      .upgrade((trans) => {\r\n        return trans.users.toCollection().modify((user) => {\r\n          user.preferences = {};\r\n        });\r\n      });\r\n  }\r\n\r\n  setupErrorHandling() {\r\n    this.db.use({\r\n      name: "ErrorHandler",\r\n      stack: "dbcore",\r\n      create: this.handleOperation("create"),\r\n      read: this.handleOperation("read"),\r\n      update: this.handleOperation("update"),\r\n      delete: this.handleOperation("delete"),\r\n    });\r\n  }\r\n\r\n  handleOperation(operationType) {\r\n    return (req) => {\r\n      return new Promise((resolve, reject) => {\r\n        try {\r\n          const result = req.operation.apply(req, req.args);\r\n\r\n          if (result && typeof result.then === "function") {\r\n            result.then(resolve).catch((error) => {\r\n              this.logError(operationType, error, req);\r\n              reject(error);\r\n            });\r\n          } else {\r\n            resolve(result);\r\n          }\r\n        } catch (error) {\r\n          this.logError(operationType, error, req);\r\n          reject(error);\r\n        }\r\n      });\r\n    };\r\n  }\r\n\r\n  logError(operation, error, request) {\r\n    console.error("Database operation failed:", {\r\n      operation,\r\n      error: error.message,\r\n      table: request.objectStoreName,\r\n      stack: error.stack,\r\n    });\r\n\r\n    // Send to error reporting service\r\n    if (window.errorReporter) {\r\n      window.errorReporter.captureException(error, {\r\n        tags: { operation, table: request.objectStoreName },\r\n      });\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(r.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(r.p,{children:"IndexedDB and Dexie.js represent a powerful combination for client-side data storage in modern web applications. IndexedDB provides the robust, transactional foundation with its sophisticated storage engine, while Dexie.js offers an elegant, developer-friendly interface that doesn't sacrifice performance or capabilities."}),"\n",(0,a.jsx)(r.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"IndexedDB Architecture"}),": Understanding the underlying B+ tree structures, transaction management, and browser storage mechanisms helps in making informed design decisions."]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Dexie's Value Proposition"}),": The wrapper doesn't just simplify the API\u2014it provides transaction management, query optimization, and error handling that would be complex to implement correctly with raw IndexedDB."]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Performance Considerations"}),": Proper indexing strategies, transaction scoping, and memory management are crucial for production applications."]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Browser Differences"}),": While IndexedDB is standardized, browser implementations vary in storage limits, eviction policies, and performance characteristics."]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Future-Proofing"}),": Both technologies continue to evolve, with new features like partitioned storage, improved quota management, and enhanced debugging tools."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(r.p,{children:"The combination of IndexedDB's power and Dexie's elegance provides a robust foundation for building sophisticated offline-first web applications with complex data requirements. Whether you're building a simple cache or a full-featured collaborative application, understanding both the underlying mechanisms and the abstraction layer ensures you can build performant, reliable data storage solutions."}),"\n",(0,a.jsx)(r.h3,{id:"further-reading",children:"Further Reading"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://dexie.org",children:"Dexie.js Official Documentation"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API",children:"IndexedDB API Reference"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://github.com/dexie/Dexie.js",children:"Dexie.js GitHub Repository"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API",children:"Web Storage API Documentation"})}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.a,{href:"https://web.dev/storage-for-the-web/",children:"Storage for the Web"})}),"\n"]})]})}function u(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>o});var t=n(6540);const a={},s=t.createContext(a);function i(e){const r=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);