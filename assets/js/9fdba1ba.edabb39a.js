"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2825],{7820:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"project-detail/react-virtuoso","title":"React Virtuoso: Deep Dive into Virtual Scrolling","description":"Master React Virtuoso\'s virtualization engine, covering implementation details, offset management, variable height handling, and performance optimization strategies for building high-performance lists","source":"@site/docs/project-detail/react-virtuoso.md","sourceDirName":"project-detail","slug":"/project-detail/react-virtuoso","permalink":"/frontend-system-design/docs/project-detail/react-virtuoso","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/react-virtuoso.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Tech Stack Cheatsheet: affiliate-framework-fe-bo","permalink":"/frontend-system-design/docs/project-detail/affiliate-framework-bo"},"next":{"title":"React Native: Under the Hood","permalink":"/frontend-system-design/docs/project-detail/react-native"}}');var s=t(4848),r=t(8453);const o={},a="React Virtuoso: Deep Dive into Virtual Scrolling",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Core Virtualization Concepts",id:"core-virtualization-concepts",level:2},{value:"What is Virtualization?",id:"what-is-virtualization",level:3},{value:"Key Benefits",id:"key-benefits",level:3},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Core Components",id:"core-components",level:3},{value:"State Management System",id:"state-management-system",level:3},{value:"Viewport Management",id:"viewport-management",level:2},{value:"Visible Range Calculation",id:"visible-range-calculation",level:3},{value:"Overscan (Buffer) Management",id:"overscan-buffer-management",level:3},{value:"Offset Calculation &amp; Management",id:"offset-calculation--management",level:2},{value:"Height-Based Offset System",id:"height-based-offset-system",level:3},{value:"Efficient Offset Updates",id:"efficient-offset-updates",level:3},{value:"Variable Height Item Handling",id:"variable-height-item-handling",level:2},{value:"Automatic Height Measurement",id:"automatic-height-measurement",level:3},{value:"Dynamic Height Estimation",id:"dynamic-height-estimation",level:3},{value:"Handling Content Loading",id:"handling-content-loading",level:3},{value:"Scroll Synchronization",id:"scroll-synchronization",level:2},{value:"Scroll Event Handling",id:"scroll-event-handling",level:3},{value:"Scroll Position Preservation",id:"scroll-position-preservation",level:3},{value:"Programmatic Scrolling",id:"programmatic-scrolling",level:3},{value:"Performance Optimization Strategies",id:"performance-optimization-strategies",level:2},{value:"Memoization and React.memo",id:"memoization-and-reactmemo",level:3},{value:"Overscan Tuning",id:"overscan-tuning",level:3},{value:"CSS Optimization",id:"css-optimization",level:3},{value:"Component Variants",id:"component-variants",level:2},{value:"Virtuoso (Basic List)",id:"virtuoso-basic-list",level:3},{value:"GroupedVirtuoso (Grouped Lists)",id:"groupedvirtuoso-grouped-lists",level:3},{value:"VirtuosoGrid (Grid Layout)",id:"virtuosogrid-grid-layout",level:3},{value:"TableVirtuoso (Table Virtualization)",id:"tablevirtuoso-table-virtualization",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Message List for Chat Applications",id:"message-list-for-chat-applications",level:3},{value:"Infinite Scrolling",id:"infinite-scrolling",level:3},{value:"Custom Scrollbars",id:"custom-scrollbars",level:3},{value:"Common Patterns &amp; Best Practices",id:"common-patterns--best-practices",level:2},{value:"Error Boundaries",id:"error-boundaries",level:3},{value:"Testing Strategies",id:"testing-strategies",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3},{value:"Accessibility Considerations",id:"accessibility-considerations",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"react-virtuoso-deep-dive-into-virtual-scrolling",children:"React Virtuoso: Deep Dive into Virtual Scrolling"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Master React Virtuoso's virtualization engine, covering implementation details, offset management, variable height handling, and performance optimization strategies for building high-performance lists"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"React Virtuoso is the most powerful virtual list component for React, providing efficient rendering of large datasets through sophisticated virtualization techniques. Unlike traditional approaches that render all items at once, Virtuoso renders only visible items plus a configurable buffer, dramatically improving performance and memory usage. This guide explores how React Virtuoso works under the hood, examining its core algorithms, offset management, variable height handling, and optimization strategies."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#core-virtualization-concepts",children:"Core Virtualization Concepts"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#architecture-overview",children:"Architecture Overview"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#viewport-management",children:"Viewport Management"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#offset-calculation--management",children:"Offset Calculation & Management"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#variable-height-item-handling",children:"Variable Height Item Handling"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#scroll-synchronization",children:"Scroll Synchronization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#performance-optimization-strategies",children:"Performance Optimization Strategies"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#component-variants",children:"Component Variants"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#advanced-features",children:"Advanced Features"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#common-patterns--best-practices",children:"Common Patterns & Best Practices"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"core-virtualization-concepts",children:"Core Virtualization Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-virtualization",children:"What is Virtualization?"}),"\n",(0,s.jsx)(n.p,{children:"Virtualization is a rendering optimization technique that renders only the items currently visible in the viewport, plus a small buffer of items above and below for smooth scrolling. This approach transforms O(n) rendering complexity to O(1) relative to the total dataset size."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// Traditional approach - renders ALL items (performance killer)\nfunction TraditionalList({ items }) {\n  return (\n    <div style={{ height: "400px", overflow: "auto" }}>\n      {items.map((item, index) => (\n        <div key={index}>{item.content}</div>\n      ))}\n    </div>\n  );\n}\n\n// Virtualized approach - renders ONLY visible items\nimport { Virtuoso } from "react-virtuoso";\n\nfunction VirtualizedList({ items }) {\n  return (\n    <Virtuoso\n      style={{ height: "400px" }}\n      totalCount={items.length}\n      itemContent={(index) => <div>{items[index].content}</div>}\n    />\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Efficiency"}),": DOM contains only visible items (~10-50 elements instead of thousands)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consistent Performance"}),": Rendering time remains constant regardless of dataset size"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Smooth Scrolling"}),": Optimized rendering pipeline prevents janky scroll behavior"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Variable Heights"}),": Automatic measurement and adjustment for dynamic content"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,s.jsx)(n.p,{children:"React Virtuoso's architecture consists of several interconnected systems working together to provide seamless virtualization:"}),"\n",(0,s.jsx)(n.h3,{id:"core-components",children:"Core Components"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[Virtuoso Container] --\x3e B[Viewport Manager]\n    A --\x3e C[Item Renderer]\n    A --\x3e D[Scroller System]\n\n    B --\x3e E[Visible Range Calculator]\n    B --\x3e F[Offset Manager]\n\n    C --\x3e G[Item Measurement]\n    C --\x3e H[DOM Recycling]\n\n    D --\x3e I[Scroll Event Handler]\n    D --\x3e J[Position Synchronizer]\n\n    E --\x3e K[Buffer Management]\n    F --\x3e L[Height Estimation]\n    G --\x3e M[ResizeObserver]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"state-management-system",children:"State Management System"}),"\n",(0,s.jsx)(n.p,{children:"Virtuoso uses a reactive state management system that efficiently updates only necessary parts when data changes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Simplified internal state structure\nconst virtuosoState = {\n  // Viewport dimensions\n  viewportHeight: 400,\n  scrollTop: 0,\n\n  // Item management\n  totalCount: 10000,\n  visibleRange: { start: 45, end: 65 },\n  overscan: { start: 40, end: 70 },\n\n  // Height tracking\n  itemHeights: new Map(), // Measured heights\n  estimatedItemHeight: 50,\n  totalHeight: 500000,\n\n  // Offset calculations\n  itemOffsets: new Map(), // Cached positions\n  scrollOffset: 2250,\n};\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"viewport-management",children:"Viewport Management"}),"\n",(0,s.jsx)(n.h3,{id:"visible-range-calculation",children:"Visible Range Calculation"}),"\n",(0,s.jsx)(n.p,{children:"The viewport manager determines which items should be rendered based on scroll position and container dimensions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Simplified visible range calculation algorithm\nfunction calculateVisibleRange(\n  scrollTop,\n  viewportHeight,\n  itemOffsets,\n  totalCount\n) {\n  // Find first visible item using binary search for efficiency\n  const startIndex = binarySearchFirstVisible(scrollTop, itemOffsets);\n\n  // Calculate end index based on viewport height\n  let endIndex = startIndex;\n  let accumulatedHeight = 0;\n\n  while (endIndex < totalCount && accumulatedHeight < viewportHeight) {\n    accumulatedHeight += getItemHeight(endIndex, itemOffsets);\n    endIndex++;\n  }\n\n  return { start: startIndex, end: endIndex };\n}\n\nfunction binarySearchFirstVisible(scrollTop, itemOffsets) {\n  let left = 0;\n  let right = itemOffsets.size - 1;\n\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const offset = itemOffsets.get(mid) || 0;\n\n    if (offset < scrollTop) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n\n  return left;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"overscan-buffer-management",children:"Overscan (Buffer) Management"}),"\n",(0,s.jsx)(n.p,{children:"Virtuoso renders additional items outside the visible area to ensure smooth scrolling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Overscan configuration affects performance vs smoothness trade-off\n<Virtuoso\n  totalCount={10000}\n  itemContent={(index) => <Item key={index} />}\n  // Render 5 extra items above and below visible area\n  increaseViewportBy={{ top: 200, bottom: 200 }}\n  // Alternative: specify item count\n  overscan={5}\n/>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Overscan Strategy:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Small overscan"})," (2-5 items): Better performance, potential scroll stuttering"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Large overscan"})," (10-20 items): Smoother scrolling, higher memory usage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic overscan"}),": Adjusts based on scroll velocity"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"offset-calculation--management",children:"Offset Calculation & Management"}),"\n",(0,s.jsx)(n.h3,{id:"height-based-offset-system",children:"Height-Based Offset System"}),"\n",(0,s.jsx)(n.p,{children:"React Virtuoso maintains a sophisticated offset calculation system that tracks the position of each item:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Internal offset management system\nclass OffsetManager {\n  constructor() {\n    this.itemHeights = new Map();\n    this.itemOffsets = new Map();\n    this.totalHeight = 0;\n    this.estimatedItemHeight = 50;\n  }\n\n  // Calculate offset for a specific item\n  getItemOffset(index) {\n    if (this.itemOffsets.has(index)) {\n      return this.itemOffsets.get(index);\n    }\n\n    // Calculate offset based on previous items\n    let offset = 0;\n    for (let i = 0; i < index; i++) {\n      offset += this.getItemHeight(i);\n    }\n\n    this.itemOffsets.set(index, offset);\n    return offset;\n  }\n\n  // Get item height (measured or estimated)\n  getItemHeight(index) {\n    return this.itemHeights.get(index) || this.estimatedItemHeight;\n  }\n\n  // Update height and recalculate offsets\n  setItemHeight(index, height) {\n    const oldHeight = this.getItemHeight(index);\n    this.itemHeights.set(index, height);\n\n    // Invalidate cached offsets for items after this one\n    this.invalidateOffsetsAfter(index);\n\n    // Update total height\n    this.totalHeight += height - oldHeight;\n  }\n\n  invalidateOffsetsAfter(index) {\n    for (let i = index + 1; i < this.totalCount; i++) {\n      this.itemOffsets.delete(i);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"efficient-offset-updates",children:"Efficient Offset Updates"}),"\n",(0,s.jsx)(n.p,{children:"When item heights change, Virtuoso efficiently updates only affected offsets:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Example: Item height changes from 100px to 150px at index 25\n// Before: [0, 100, 200, 300, ..., 2500, 2600, ...]\n// After:  [0, 100, 200, 300, ..., 2500, 2650, ...] (+50px offset for items after 25)\n\nfunction handleHeightChange(index, newHeight, oldHeight) {\n  const heightDelta = newHeight - oldHeight;\n\n  // Update stored height\n  this.itemHeights.set(index, newHeight);\n\n  // Efficiently update subsequent offsets\n  for (let i = index + 1; i < this.totalCount; i++) {\n    if (this.itemOffsets.has(i)) {\n      const currentOffset = this.itemOffsets.get(i);\n      this.itemOffsets.set(i, currentOffset + heightDelta);\n    }\n  }\n\n  // Update total scrollable height\n  this.totalHeight += heightDelta;\n\n  // Adjust scroll position if necessary to maintain view stability\n  this.adjustScrollPosition(index, heightDelta);\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"variable-height-item-handling",children:"Variable Height Item Handling"}),"\n",(0,s.jsx)(n.h3,{id:"automatic-height-measurement",children:"Automatic Height Measurement"}),"\n",(0,s.jsx)(n.p,{children:"React Virtuoso automatically measures item heights using the ResizeObserver API:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Simplified height measurement system\nfunction ItemRenderer({ index, style, data }) {\n  const itemRef = useRef(null);\n  const measureHeight = useCallback(() => {\n    if (itemRef.current) {\n      const height = itemRef.current.getBoundingClientRect().height;\n      // Report height back to Virtuoso's measurement system\n      reportItemHeight(index, height);\n    }\n  }, [index]);\n\n  useEffect(() => {\n    // Initial measurement\n    measureHeight();\n\n    // Set up ResizeObserver for dynamic content\n    const resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const height = entry.borderBoxSize[0].blockSize;\n        reportItemHeight(index, height);\n      }\n    });\n\n    if (itemRef.current) {\n      resizeObserver.observe(itemRef.current);\n    }\n\n    return () => resizeObserver.disconnect();\n  }, [measureHeight]);\n\n  return (\n    <div ref={itemRef} style={style}>\n      {data[index].content}\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dynamic-height-estimation",children:"Dynamic Height Estimation"}),"\n",(0,s.jsx)(n.p,{children:"For unmeasured items, Virtuoso uses intelligent height estimation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Height estimation strategies\nclass HeightEstimator {\n  constructor() {\n    this.measuredHeights = [];\n    this.estimatedHeight = 50; // Initial estimate\n  }\n\n  // Update estimation based on measured items\n  updateEstimation(newHeight) {\n    this.measuredHeights.push(newHeight);\n\n    // Use different strategies based on data availability\n    if (this.measuredHeights.length < 10) {\n      // Simple average for small samples\n      this.estimatedHeight = this.calculateSimpleAverage();\n    } else {\n      // Weighted average favoring recent measurements\n      this.estimatedHeight = this.calculateWeightedAverage();\n    }\n  }\n\n  calculateWeightedAverage() {\n    const recentHeights = this.measuredHeights.slice(-20); // Last 20 measurements\n    const weights = recentHeights.map((_, i) => i + 1); // Newer items get higher weight\n\n    const weightedSum = recentHeights.reduce(\n      (sum, height, i) => sum + height * weights[i],\n      0\n    );\n    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);\n\n    return weightedSum / totalWeight;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"handling-content-loading",children:"Handling Content Loading"}),"\n",(0,s.jsx)(n.p,{children:"React Virtuoso gracefully handles scenarios where content loads asynchronously:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// Example: Images loading in list items\nfunction ImageListItem({ index, data }) {\n  const [imageLoaded, setImageLoaded] = useState(false);\n  const itemRef = useRef(null);\n\n  // Re-measure when image loads\n  const handleImageLoad = useCallback(() => {\n    setImageLoaded(true);\n    // Trigger re-measurement\n    if (itemRef.current) {\n      const height = itemRef.current.offsetHeight;\n      // This will trigger Virtuoso\'s height update system\n      requestAnimationFrame(() => {\n        reportHeightChange(index, height);\n      });\n    }\n  }, [index]);\n\n  return (\n    <div ref={itemRef}>\n      <h3>{data[index].title}</h3>\n      <img\n        src={data[index].imageUrl}\n        onLoad={handleImageLoad}\n        style={{\n          width: "100%",\n          height: imageLoaded ? "auto" : "200px",\n          backgroundColor: imageLoaded ? "transparent" : "#f0f0f0",\n        }}\n        alt={data[index].title}\n      />\n      <p>{data[index].description}</p>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"scroll-synchronization",children:"Scroll Synchronization"}),"\n",(0,s.jsx)(n.h3,{id:"scroll-event-handling",children:"Scroll Event Handling"}),"\n",(0,s.jsx)(n.p,{children:"Virtuoso optimizes scroll event handling using requestAnimationFrame and throttling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Optimized scroll handling system\nclass ScrollManager {\n  constructor() {\n    this.isScrolling = false;\n    this.scrollRaf = null;\n    this.lastScrollTime = 0;\n  }\n\n  handleScroll = (event) => {\n    const now = performance.now();\n\n    // Throttle scroll events for performance\n    if (now - this.lastScrollTime < 16) {\n      // ~60fps\n      return;\n    }\n\n    this.lastScrollTime = now;\n\n    // Cancel previous frame if still pending\n    if (this.scrollRaf) {\n      cancelAnimationFrame(this.scrollRaf);\n    }\n\n    // Schedule update for next frame\n    this.scrollRaf = requestAnimationFrame(() => {\n      this.updateScrollPosition(event.target.scrollTop);\n      this.scrollRaf = null;\n    });\n  };\n\n  updateScrollPosition(scrollTop) {\n    // Update visible range\n    const newVisibleRange = this.calculateVisibleRange(scrollTop);\n\n    // Only update if range actually changed\n    if (!this.rangesEqual(newVisibleRange, this.currentVisibleRange)) {\n      this.currentVisibleRange = newVisibleRange;\n      this.notifyRangeChange(newVisibleRange);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scroll-position-preservation",children:"Scroll Position Preservation"}),"\n",(0,s.jsx)(n.p,{children:"When items change height, Virtuoso maintains scroll position relative to content:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Scroll position preservation during height changes\nfunction preserveScrollPosition(heightChanges) {\n  const currentScrollTop = this.scrollContainer.scrollTop;\n  const currentFirstVisibleIndex = this.findFirstVisibleIndex(currentScrollTop);\n\n  // Apply height changes and recalculate offsets\n  this.applyHeightChanges(heightChanges);\n\n  // Calculate new scroll position to maintain visual stability\n  const newScrollTop = this.getItemOffset(currentFirstVisibleIndex);\n\n  // Smoothly adjust scroll position\n  this.scrollContainer.scrollTop = newScrollTop;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"programmatic-scrolling",children:"Programmatic Scrolling"}),"\n",(0,s.jsx)(n.p,{children:"Virtuoso provides methods for programmatic scrolling with smooth animations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// Scroll to specific item with options\n<Virtuoso\n  ref={virtuosoRef}\n  totalCount={items.length}\n  itemContent={(index) => <Item data={items[index]} />}\n/>;\n\n// Usage examples\nfunction scrollToItem() {\n  // Instant scroll to item 100\n  virtuosoRef.current?.scrollToIndex({\n    index: 100,\n    align: "start", // \'start\' | \'center\' | \'end\'\n  });\n\n  // Smooth scroll to item 500\n  virtuosoRef.current?.scrollToIndex({\n    index: 500,\n    align: "center",\n    behavior: "smooth",\n  });\n\n  // Scroll to item only if not already visible\n  virtuosoRef.current?.scrollIntoView({\n    index: 250,\n    done: () => console.log("Scroll completed"),\n  });\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization-strategies",children:"Performance Optimization Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"memoization-and-reactmemo",children:"Memoization and React.memo"}),"\n",(0,s.jsx)(n.p,{children:"Optimize item rendering using React.memo and proper dependency management:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// Optimized item component with memoization\nconst ListItem = React.memo(function ListItem({\n  index,\n  data,\n  isSelected,\n  onSelect,\n}) {\n  const item = data[index];\n\n  // Memoize click handler to prevent unnecessary re-renders\n  const handleClick = useCallback(() => {\n    onSelect(item.id);\n  }, [item.id, onSelect]);\n\n  // Memoize computed styles\n  const itemStyle = useMemo(\n    () => ({\n      padding: "12px",\n      borderBottom: "1px solid #eee",\n      backgroundColor: isSelected ? "#e3f2fd" : "transparent",\n      cursor: "pointer",\n    }),\n    [isSelected]\n  );\n\n  return (\n    <div style={itemStyle} onClick={handleClick}>\n      <h4>{item.title}</h4>\n      <p>{item.description}</p>\n    </div>\n  );\n});\n\n// Usage with proper prop comparison\nfunction App() {\n  const [selectedId, setSelectedId] = useState(null);\n\n  // Memoize selection handler\n  const handleSelect = useCallback((id) => {\n    setSelectedId(id);\n  }, []);\n\n  return (\n    <Virtuoso\n      totalCount={items.length}\n      itemContent={(index) => (\n        <ListItem\n          index={index}\n          data={items}\n          isSelected={items[index].id === selectedId}\n          onSelect={handleSelect}\n        />\n      )}\n    />\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"overscan-tuning",children:"Overscan Tuning"}),"\n",(0,s.jsx)(n.p,{children:"Balance performance vs. smoothness by adjusting overscan parameters:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Performance-focused configuration (minimal overscan)\n<Virtuoso\n  totalCount={items.length}\n  itemContent={renderItem}\n  overscan={2} // Minimal buffer for better performance\n/>\n\n// Smoothness-focused configuration (larger overscan)\n<Virtuoso\n  totalCount={items.length}\n  itemContent={renderItem}\n  increaseViewportBy={{\n    top: 300,    // Render 300px worth of items above viewport\n    bottom: 300  // Render 300px worth of items below viewport\n  }}\n/>\n\n// Dynamic overscan based on scroll velocity\n<Virtuoso\n  totalCount={items.length}\n  itemContent={renderItem}\n  overscan={(velocity) => {\n    // More overscan for faster scrolling\n    return Math.min(Math.floor(Math.abs(velocity) / 100), 20);\n  }}\n/>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"css-optimization",children:"CSS Optimization"}),"\n",(0,s.jsx)(n.p,{children:"Optimize CSS to work well with virtualization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-css",children:"/* Avoid margins on items - use padding instead */\n.list-item {\n  padding: 12px; /* \u2705 Good - doesn't interfere with measurements */\n  /* margin: 12px; \u274c Bad - can cause measurement issues */\n}\n\n/* Use transform for positioning when possible */\n.item-container {\n  will-change: transform; /* Optimize for frequent changes */\n  contain: layout style paint; /* CSS containment for better performance */\n}\n\n/* Optimize for GPU acceleration */\n.smooth-item {\n  transform: translateZ(0); /* Force GPU layer */\n  backface-visibility: hidden;\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"component-variants",children:"Component Variants"}),"\n",(0,s.jsx)(n.h3,{id:"virtuoso-basic-list",children:"Virtuoso (Basic List)"}),"\n",(0,s.jsx)(n.p,{children:"The standard virtualized list component:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { Virtuoso } from "react-virtuoso";\n\nfunction BasicList({ items }) {\n  return (\n    <Virtuoso\n      style={{ height: "400px" }}\n      totalCount={items.length}\n      itemContent={(index) => (\n        <div style={{ padding: "12px", borderBottom: "1px solid #eee" }}>\n          {items[index].content}\n        </div>\n      )}\n      // Optional customizations\n      components={{\n        Header: () => <div>List Header</div>,\n        Footer: () => <div>List Footer</div>,\n        EmptyPlaceholder: () => <div>No items found</div>,\n      }}\n    />\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"groupedvirtuoso-grouped-lists",children:"GroupedVirtuoso (Grouped Lists)"}),"\n",(0,s.jsx)(n.p,{children:"For lists with group headers and categorized content:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { GroupedVirtuoso } from "react-virtuoso";\n\nfunction GroupedList({ groups }) {\n  // Group structure: [{ title: \'Group 1\', items: [...] }, ...]\n  const groupCounts = groups.map((group) => group.items.length);\n\n  return (\n    <GroupedVirtuoso\n      style={{ height: "400px" }}\n      groupCounts={groupCounts}\n      groupContent={(index) => (\n        <div\n          style={{\n            padding: "8px 12px",\n            backgroundColor: "#f5f5f5",\n            fontWeight: "bold",\n            position: "sticky",\n            top: 0,\n            zIndex: 1,\n          }}\n        >\n          {groups[index].title}\n        </div>\n      )}\n      itemContent={(index, groupIndex) => (\n        <div style={{ padding: "12px", borderBottom: "1px solid #eee" }}>\n          {groups[groupIndex].items[index].content}\n        </div>\n      )}\n    />\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"virtuosogrid-grid-layout",children:"VirtuosoGrid (Grid Layout)"}),"\n",(0,s.jsx)(n.p,{children:"For responsive grid layouts with equal-sized items:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import { VirtuosoGrid } from 'react-virtuoso';\n\nfunction ResponsiveGrid({ items }) {\n  return (\n    <VirtuosoGrid\n      style={{ height: '400px' }}\n      totalCount={items.length}\n      itemContent={index => (\n        <div style={{\n          padding: '8px',\n          border: '1px solid #ddd',\n          borderRadius: '4px',\n          height: '200px' // Fixed height for grid items\n        }}>\n          <img src={items[index].image} alt={items[index].title} />\n          <h4>{items[index].title}</h4>\n        </div>\n      )}\n      listClassName=\"grid-container\"\n    />\n  );\n}\n\n/* CSS for responsive grid */\n.grid-container {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n  gap: 16px;\n  padding: 16px;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tablevirtuoso-table-virtualization",children:"TableVirtuoso (Table Virtualization)"}),"\n",(0,s.jsx)(n.p,{children:"For large tables with virtualized rows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { TableVirtuoso } from "react-virtuoso";\n\nfunction VirtualizedTable({ data, columns }) {\n  return (\n    <TableVirtuoso\n      style={{ height: "400px" }}\n      data={data}\n      components={{\n        Table: (props) => (\n          <table {...props} style={{ borderCollapse: "collapse" }} />\n        ),\n        TableHead: React.forwardRef((props, ref) => (\n          <thead {...props} ref={ref} />\n        )),\n        TableRow: (props) => (\n          <tr {...props} style={{ borderBottom: "1px solid #ddd" }} />\n        ),\n        TableBody: React.forwardRef((props, ref) => (\n          <tbody {...props} ref={ref} />\n        )),\n      }}\n      fixedHeaderContent={() => (\n        <tr>\n          {columns.map((col) => (\n            <th\n              key={col.key}\n              style={{\n                padding: "12px",\n                backgroundColor: "#f5f5f5",\n                position: "sticky",\n                top: 0,\n              }}\n            >\n              {col.title}\n            </th>\n          ))}\n        </tr>\n      )}\n      itemContent={(index, item) => (\n        <>\n          {columns.map((col) => (\n            <td key={col.key} style={{ padding: "12px" }}>\n              {item[col.key]}\n            </td>\n          ))}\n        </>\n      )}\n    />\n  );\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,s.jsx)(n.h3,{id:"message-list-for-chat-applications",children:"Message List for Chat Applications"}),"\n",(0,s.jsx)(n.p,{children:"Specialized component for chat/message interfaces:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { VirtuosoMessageList } from "@virtuoso.dev/message-list";\n\nfunction ChatInterface() {\n  const [messages, setMessages] = useState([]);\n\n  return (\n    <VirtuosoMessageList\n      initialData={messages}\n      itemContent={(index, message) => (\n        <div\n          style={{\n            padding: "8px 12px",\n            maxWidth: "70%",\n            marginLeft: message.isOwn ? "auto" : "0",\n            marginRight: message.isOwn ? "0" : "auto",\n            backgroundColor: message.isOwn ? "#007bff" : "#e9ecef",\n            color: message.isOwn ? "white" : "black",\n            borderRadius: "12px",\n            marginBottom: "4px",\n          }}\n        >\n          {message.text}\n        </div>\n      )}\n      // Auto-scroll to bottom for new messages\n      followOutput="smooth"\n      // Handle loading older messages\n      startReached={() => loadOlderMessages()}\n    />\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"infinite-scrolling",children:"Infinite Scrolling"}),"\n",(0,s.jsx)(n.p,{children:"Implement infinite scrolling with data loading:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'function InfiniteScrollList() {\n  const [items, setItems] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [hasMore, setHasMore] = useState(true);\n\n  const loadMore = useCallback(async () => {\n    if (loading || !hasMore) return;\n\n    setLoading(true);\n    try {\n      const newItems = await fetchMoreData(items.length);\n      setItems((prev) => [...prev, ...newItems]);\n      setHasMore(newItems.length > 0);\n    } finally {\n      setLoading(false);\n    }\n  }, [items.length, loading, hasMore]);\n\n  return (\n    <Virtuoso\n      style={{ height: "400px" }}\n      totalCount={hasMore ? items.length + 1 : items.length}\n      itemContent={(index) => {\n        if (index === items.length) {\n          return (\n            <div style={{ padding: "20px", textAlign: "center" }}>\n              {loading ? "Loading..." : "Load More"}\n            </div>\n          );\n        }\n        return <Item data={items[index]} />;\n      }}\n      endReached={loadMore}\n      // Preload when user is near the end\n      overscan={5}\n    />\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"custom-scrollbars",children:"Custom Scrollbars"}),"\n",(0,s.jsx)(n.p,{children:"Implement custom scrollbar styling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<Virtuoso\n  style={{ height: '400px' }}\n  totalCount={items.length}\n  itemContent={renderItem}\n  components={{\n    Scroller: React.forwardRef((props, ref) => (\n      <div\n        {...props}\n        ref={ref}\n        style={{\n          ...props.style,\n          // Custom scrollbar styles\n          scrollbarWidth: 'thin',\n          scrollbarColor: '#888 #f1f1f1'\n        }}\n        className=\"custom-scrollbar\"\n      />\n    ))\n  }}\n/>\n\n/* CSS for webkit browsers */\n.custom-scrollbar::-webkit-scrollbar {\n  width: 8px;\n}\n\n.custom-scrollbar::-webkit-scrollbar-track {\n  background: #f1f1f1;\n  border-radius: 4px;\n}\n\n.custom-scrollbar::-webkit-scrollbar-thumb {\n  background: #888;\n  border-radius: 4px;\n}\n\n.custom-scrollbar::-webkit-scrollbar-thumb:hover {\n  background: #555;\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"common-patterns--best-practices",children:"Common Patterns & Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"error-boundaries",children:"Error Boundaries"}),"\n",(0,s.jsx)(n.p,{children:"Wrap virtualized lists with error boundaries:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'class VirtuosoErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error("Virtuoso error:", error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div style={{ padding: "20px", textAlign: "center" }}>\n          <h3>Something went wrong rendering the list</h3>\n          <button onClick={() => this.setState({ hasError: false })}>\n            Try Again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Usage\nfunction App() {\n  return (\n    <VirtuosoErrorBoundary>\n      <Virtuoso totalCount={items.length} itemContent={renderItem} />\n    </VirtuosoErrorBoundary>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,s.jsx)(n.p,{children:"Test virtualized components effectively:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { render, screen } from "@testing-library/react";\nimport { Virtuoso } from "react-virtuoso";\n\n// Mock intersection observer for tests\nbeforeAll(() => {\n  global.IntersectionObserver = jest.fn(() => ({\n    observe: jest.fn(),\n    disconnect: jest.fn(),\n    unobserve: jest.fn(),\n  }));\n});\n\ntest("renders visible items correctly", async () => {\n  const items = Array.from({ length: 1000 }, (_, i) => ({\n    id: i,\n    content: `Item ${i}`,\n  }));\n\n  render(\n    <Virtuoso\n      style={{ height: "400px" }}\n      totalCount={items.length}\n      itemContent={(index) => (\n        <div data-testid={`item-${index}`}>{items[index].content}</div>\n      )}\n    />\n  );\n\n  // Only visible items should be rendered\n  expect(screen.queryByTestId("item-0")).toBeInTheDocument();\n  expect(screen.queryByTestId("item-999")).not.toBeInTheDocument();\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,s.jsx)(n.p,{children:"Monitor virtualization performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"function useVirtuosoPerformance() {\n  const [metrics, setMetrics] = useState({});\n\n  const onScroll = useCallback((scrollTop) => {\n    const start = performance.now();\n\n    // Measure scroll handling time\n    requestAnimationFrame(() => {\n      const duration = performance.now() - start;\n      setMetrics((prev) => ({\n        ...prev,\n        scrollHandlingTime: duration,\n        lastScrollTop: scrollTop,\n      }));\n    });\n  }, []);\n\n  return { metrics, onScroll };\n}\n\n// Usage\nfunction MonitoredList() {\n  const { metrics, onScroll } = useVirtuosoPerformance();\n\n  return (\n    <>\n      <div>Scroll handling: {metrics.scrollHandlingTime?.toFixed(2)}ms</div>\n      <Virtuoso\n        totalCount={items.length}\n        itemContent={renderItem}\n        onScroll={onScroll}\n      />\n    </>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"accessibility-considerations",children:"Accessibility Considerations"}),"\n",(0,s.jsx)(n.p,{children:"Ensure virtualized lists are accessible:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'<Virtuoso\n  style={{ height: "400px" }}\n  totalCount={items.length}\n  itemContent={(index) => (\n    <div\n      role="listitem"\n      aria-setsize={items.length}\n      aria-posinset={index + 1}\n      tabIndex={0}\n      onKeyDown={(e) => {\n        if (e.key === "Enter" || e.key === " ") {\n          handleItemSelect(index);\n        }\n      }}\n    >\n      {items[index].content}\n    </div>\n  )}\n  components={{\n    List: React.forwardRef((props, ref) => (\n      <div\n        {...props}\n        ref={ref}\n        role="list"\n        aria-label="Virtualized item list"\n      />\n    )),\n  }}\n/>\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"React Virtuoso represents a sophisticated approach to handling large datasets in React applications. Its automatic height measurement, efficient offset management, and smooth scrolling capabilities make it an excellent choice for performance-critical applications. By understanding its internal mechanisms\u2014from viewport management to variable height handling\u2014developers can leverage its full potential while avoiding common pitfalls."}),"\n",(0,s.jsx)(n.p,{children:"Key takeaways:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Virtualization transforms O(n) to O(1)"})," rendering complexity"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic height measurement"})," eliminates manual configuration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Smart offset calculation"})," maintains scroll position accuracy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Proper memoization"})," is crucial for optimal performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Component variants"})," address different use cases efficiently"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Whether building chat interfaces, data tables, or image galleries, React Virtuoso provides the tools needed to create smooth, performant user experiences at any scale."}),"\n",(0,s.jsxs)(n.p,{children:["Further reading: ",(0,s.jsx)(n.a,{href:"https://virtuoso.dev/",children:"React Virtuoso Documentation"})," | ",(0,s.jsx)(n.a,{href:"https://github.com/petyosi/react-virtuoso",children:"GitHub Repository"})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);