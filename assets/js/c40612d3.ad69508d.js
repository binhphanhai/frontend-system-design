"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5942],{3669:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"project-detail/dexie-and-indexed-db","title":"Dexie.js and IndexedDB: Under the Hood","description":"Table of Contents","source":"@site/docs/project-detail/dexie-and-indexed-db.md","sourceDirName":"project-detail","slug":"/project-detail/dexie-and-indexed-db","permalink":"/frontend-system-design/docs/project-detail/dexie-and-indexed-db","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/dexie-and-indexed-db.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"React Native: Under the Hood","permalink":"/frontend-system-design/docs/project-detail/react-native"},"next":{"title":"WebSockets: Real-Time Communication Under the Hood","permalink":"/frontend-system-design/docs/project-detail/web-socket"}}');var s=n(4848),a=n(8453);const o={},i="Dexie.js and IndexedDB: Under the Hood",c={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"IndexedDB Fundamentals",id:"indexeddb-fundamentals",level:2},{value:"What is IndexedDB?",id:"what-is-indexeddb",level:3},{value:"Core Concepts",id:"core-concepts",level:3},{value:"Database Hierarchy",id:"database-hierarchy",level:4},{value:"Data Storage Model",id:"data-storage-model",level:4},{value:"How IndexedDB Works Under the Hood",id:"how-indexeddb-works-under-the-hood",level:2},{value:"Browser Implementation Architecture",id:"browser-implementation-architecture",level:3},{value:"Chromium/Blink (Chrome, Edge)",id:"chromiumblink-chrome-edge",level:4},{value:"Firefox/Gecko",id:"firefoxgecko",level:4},{value:"Safari/WebKit",id:"safariwebkit",level:4},{value:"Data Storage Mechanisms",id:"data-storage-mechanisms",level:3},{value:"B+ Tree Indexing",id:"b-tree-indexing",level:4},{value:"Transaction Processing",id:"transaction-processing",level:4},{value:"Memory Management",id:"memory-management",level:3},{value:"Page-based Storage",id:"page-based-storage",level:4},{value:"Cache Management",id:"cache-management",level:4},{value:"Browser Storage Architecture",id:"browser-storage-architecture",level:2},{value:"Storage Partitioning",id:"storage-partitioning",level:3},{value:"Persistence Models",id:"persistence-models",level:3},{value:"Temporary Storage",id:"temporary-storage",level:4},{value:"Persistent Storage",id:"persistent-storage",level:4},{value:"Storage Limits and Quota Management",id:"storage-limits-and-quota-management",level:2},{value:"Browser-Specific Limits",id:"browser-specific-limits",level:3},{value:"Chrome/Chromium",id:"chromechromium",level:4},{value:"Firefox",id:"firefox",level:4},{value:"Safari",id:"safari",level:4},{value:"Quota API Usage",id:"quota-api-usage",level:3},{value:"Native IndexedDB API Deep Dive",id:"native-indexeddb-api-deep-dive",level:2},{value:"Database Connection Management",id:"database-connection-management",level:3},{value:"Transaction Management",id:"transaction-management",level:3},{value:"Cursor Operations",id:"cursor-operations",level:3},{value:"Dexie.js: The Wrapper Library",id:"dexiejs-the-wrapper-library",level:2},{value:"Architecture Overview",id:"architecture-overview",level:3},{value:"Core Design Principles",id:"core-design-principles",level:3},{value:"1. Promise-First API",id:"1-promise-first-api",level:4},{value:"2. Fluent Query Interface",id:"2-fluent-query-interface",level:4},{value:"3. Automatic Transaction Management",id:"3-automatic-transaction-management",level:4},{value:"How Dexie Wraps IndexedDB",id:"how-dexie-wraps-indexeddb",level:2},{value:"Promise Wrapper Implementation",id:"promise-wrapper-implementation",level:3},{value:"Query Engine Implementation",id:"query-engine-implementation",level:3},{value:"Transaction Context Management",id:"transaction-context-management",level:3},{value:"Dexie Source Code Analysis",id:"dexie-source-code-analysis",level:2},{value:"Schema Definition and Versioning",id:"schema-definition-and-versioning",level:3},{value:"Bulk Operations Optimization",id:"bulk-operations-optimization",level:3},{value:"Error Handling and Recovery",id:"error-handling-and-recovery",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Indexing Strategies",id:"indexing-strategies",level:3},{value:"Memory Management",id:"memory-management-1",level:3},{value:"Advanced Features and Patterns",id:"advanced-features-and-patterns",level:2},{value:"Live Queries with dexie-react-hooks",id:"live-queries-with-dexie-react-hooks",level:3},{value:"Database Synchronization Patterns",id:"database-synchronization-patterns",level:3},{value:"Custom Middleware and Hooks",id:"custom-middleware-and-hooks",level:3},{value:"Real-World Implementation Examples",id:"real-world-implementation-examples",level:2},{value:"E-commerce Application",id:"e-commerce-application",level:3},{value:"Collaborative Document Editor",id:"collaborative-document-editor",level:3},{value:"Debugging and Development Tools",id:"debugging-and-development-tools",level:2},{value:"Database Inspection Tools",id:"database-inspection-tools",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3},{value:"Best Practices and Gotchas",id:"best-practices-and-gotchas",level:2},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:3},{value:"1. Transaction Scope Issues",id:"1-transaction-scope-issues",level:4},{value:"2. Memory Leaks with Large Queries",id:"2-memory-leaks-with-large-queries",level:4},{value:"3. Index Design Mistakes",id:"3-index-design-mistakes",level:4},{value:"Production Deployment Checklist",id:"production-deployment-checklist",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Further Reading",id:"further-reading",level:3}];function l(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"dexiejs-and-indexeddb-under-the-hood",children:"Dexie.js and IndexedDB: Under the Hood"})}),"\n",(0,s.jsx)(r.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#indexeddb-fundamentals",children:"IndexedDB Fundamentals"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#how-indexeddb-works-under-the-hood",children:"How IndexedDB Works Under the Hood"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#browser-storage-architecture",children:"Browser Storage Architecture"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#storage-limits-and-quota-management",children:"Storage Limits and Quota Management"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#native-indexeddb-api-deep-dive",children:"Native IndexedDB API Deep Dive"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#dexiejs-the-wrapper-library",children:"Dexie.js: The Wrapper Library"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#how-dexie-wraps-indexeddb",children:"How Dexie Wraps IndexedDB"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#dexie-source-code-analysis",children:"Dexie Source Code Analysis"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#performance-considerations",children:"Performance Considerations"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#advanced-features-and-patterns",children:"Advanced Features and Patterns"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#real-world-implementation-examples",children:"Real-World Implementation Examples"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#debugging-and-development-tools",children:"Debugging and Development Tools"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#best-practices-and-gotchas",children:"Best Practices and Gotchas"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(r.p,{children:"IndexedDB is the cornerstone of client-side storage in modern web browsers, providing a robust, transactional database system that can handle large amounts of structured data. While powerful, its native API can be complex and verbose. Dexie.js emerges as a sophisticated wrapper that simplifies IndexedDB interactions while preserving its full capabilities."}),"\n",(0,s.jsx)(r.p,{children:"This comprehensive guide explores both technologies from the ground up, examining their internal mechanisms, architectural decisions, and practical implementations."}),"\n",(0,s.jsx)(r.h2,{id:"indexeddb-fundamentals",children:"IndexedDB Fundamentals"}),"\n",(0,s.jsx)(r.h3,{id:"what-is-indexeddb",children:"What is IndexedDB?"}),"\n",(0,s.jsx)(r.p,{children:"IndexedDB is a low-level web API for client-side storage of significant amounts of structured data. Unlike simple key-value stores like localStorage, IndexedDB is a full-featured database system that supports:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Object-oriented storage"}),": Stores JavaScript objects directly"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Indexing"}),": Enables efficient queries on object properties"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Transactions"}),": Ensures data integrity through ACID properties"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Asynchronous operations"}),": Non-blocking database operations"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Large storage capacity"}),": Much larger limits than localStorage"]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,s.jsx)(r.h4,{id:"database-hierarchy",children:"Database Hierarchy"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"Database\r\n\u2514\u2500\u2500 Object Stores (like tables)\r\n    \u251c\u2500\u2500 Records (key-value pairs)\r\n    \u2514\u2500\u2500 Indexes (for efficient querying)\n"})}),"\n",(0,s.jsx)(r.h4,{id:"data-storage-model",children:"Data Storage Model"}),"\n",(0,s.jsx)(r.p,{children:"IndexedDB can store complex JavaScript objects directly, unlike traditional databases that require serialization. This example demonstrates the various data types and structures that IndexedDB natively supports."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What this code demonstrates:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Primary key definition (id field)"}),"\n",(0,s.jsx)(r.li,{children:"Indexed properties for efficient querying"}),"\n",(0,s.jsx)(r.li,{children:"Nested object storage capabilities"}),"\n",(0,s.jsx)(r.li,{children:"Complex data type support (Date objects, Blobs)"}),"\n",(0,s.jsx)(r.li,{children:"Unique constraints on indexed fields"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Input:"})," JavaScript object with mixed data types\r\n",(0,s.jsx)(r.strong,{children:"Output:"})," Stored record that maintains data types and structure\r\n",(0,s.jsx)(r.strong,{children:"Use case:"})," User profile storage with preferences and binary avatar data"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Example object structure in IndexedDB\r\n// This object shows all the data types IndexedDB can handle natively\r\nconst userRecord = {\r\n  id: 1, // Primary key - used for direct record access\r\n  name: "John Doe", // Indexed property - allows fast searching by name\r\n  email: "john@example.com", // Unique indexed property - ensures no duplicates\r\n  preferences: {\r\n    // Nested object (fully supported) - no need to serialize/deserialize\r\n    theme: "dark",\r\n    notifications: true,\r\n  },\r\n  lastLogin: new Date(), // Complex data types supported - Date objects preserved\r\n  avatar: blob, // Binary data supported - images, files, etc.\r\n  tags: ["developer", "manager"], // Arrays are fully supported\r\n  metadata: new Map([["role", "admin"]]), // Even Map objects can be stored\r\n};\n'})}),"\n",(0,s.jsx)(r.h2,{id:"how-indexeddb-works-under-the-hood",children:"How IndexedDB Works Under the Hood"}),"\n",(0,s.jsx)(r.h3,{id:"browser-implementation-architecture",children:"Browser Implementation Architecture"}),"\n",(0,s.jsx)(r.p,{children:"IndexedDB is implemented differently across browser engines, but they share common architectural patterns:"}),"\n",(0,s.jsx)(r.h4,{id:"chromiumblink-chrome-edge",children:"Chromium/Blink (Chrome, Edge)"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Storage Engine"}),": LevelDB (Google's key-value store)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"File Location"}),": ",(0,s.jsx)(r.code,{children:"{Profile}/IndexedDB/"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Internal Format"}),": Binary format with metadata"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Transaction Isolation"}),": Snapshot isolation"]}),"\n"]}),"\n",(0,s.jsx)(r.h4,{id:"firefoxgecko",children:"Firefox/Gecko"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Storage Engine"}),": SQLite with custom schema"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"File Location"}),": ",(0,s.jsx)(r.code,{children:"{Profile}/storage/default/{origin}/idb/"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Internal Format"}),": SQLite database files"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Transaction Isolation"}),": Read committed with locks"]}),"\n"]}),"\n",(0,s.jsx)(r.h4,{id:"safariwebkit",children:"Safari/WebKit"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Storage Engine"}),": SQLite-based implementation"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"File Location"}),": ",(0,s.jsx)(r.code,{children:"~/Library/Safari/Databases/"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Internal Format"}),": SQLite with IndexedDB-specific schema"]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"data-storage-mechanisms",children:"Data Storage Mechanisms"}),"\n",(0,s.jsx)(r.h4,{id:"b-tree-indexing",children:"B+ Tree Indexing"}),"\n",(0,s.jsx)(r.p,{children:"IndexedDB implementations typically use B+ tree structures for indexing:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"B+ Tree Example for User Index by Age:\r\n                [25, 50]\r\n               /    |    \\\r\n        [18,21,24] [30,35,40] [55,60,65]\r\n         |  |  |    |  |  |     |  |  |\r\n       data data data ...    data data data\n"})}),"\n",(0,s.jsx)(r.h4,{id:"transaction-processing",children:"Transaction Processing"}),"\n",(0,s.jsx)(r.p,{children:"IndexedDB transactions are the foundation of data integrity. Understanding the transaction lifecycle helps you write reliable database operations and avoid common pitfalls like inactive transaction errors."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What this code demonstrates:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Complete transaction lifecycle from creation to completion"}),"\n",(0,s.jsx)(r.li,{children:"Operation queueing vs. immediate execution"}),"\n",(0,s.jsx)(r.li,{children:"Atomic commit/rollback behavior"}),"\n",(0,s.jsx)(r.li,{children:"Event-driven transaction state management"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Transaction Phases:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Creation"})," - Browser allocates transaction context and locks"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Queueing"})," - Operations are queued but not executed yet"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Execution"})," - Browser processes all queued operations atomically"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Completion"})," - Transaction either commits all changes or rolls back completely"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Input:"})," Database reference and store names\r\n",(0,s.jsx)(r.strong,{children:"Output:"})," Transaction object with event handlers\r\n",(0,s.jsx)(r.strong,{children:"Use case:"})," Ensuring data consistency across multiple operations"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Transaction lifecycle in IndexedDB\r\n// This example shows how transactions work behind the scenes\r\nconst transaction = db.transaction(["users"], "readwrite");\r\n\r\n// Phase 1: Transaction creation\r\n// - Browser allocates transaction context\r\n// - Acquires necessary locks on object stores\r\n// - Sets up internal state tracking\r\n\r\n// Phase 2: Operation queueing\r\n// These operations are NOT executed immediately - they\'re queued\r\ntransaction.objectStore("users").add(userData); // Queued: add operation\r\ntransaction.objectStore("users").get(1); // Queued: get operation\r\n\r\n// Phase 3: Execution phase happens automatically\r\n// Browser processes all queued operations in order\r\n// If any operation fails, entire transaction rolls back\r\n\r\n// Phase 4: Commit/Rollback phase\r\n// All operations succeed = commit, any failure = rollback\r\ntransaction.oncomplete = () => {\r\n  console.log("Transaction committed - all operations succeeded");\r\n  // All changes are now permanent\r\n};\r\n\r\ntransaction.onerror = (event) => {\r\n  console.log("Transaction rolled back - error:", event.target.error);\r\n  // No changes were made to the database\r\n};\r\n\r\ntransaction.onabort = () => {\r\n  console.log("Transaction aborted - manually cancelled");\r\n  // Can be triggered by calling transaction.abort()\r\n};\n'})}),"\n",(0,s.jsx)(r.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,s.jsx)(r.h4,{id:"page-based-storage",children:"Page-based Storage"}),"\n",(0,s.jsx)(r.p,{children:"IndexedDB stores data in pages (typically 4KB or 8KB), similar to traditional databases:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"Page Structure:\r\n[Header][Record1][Record2][...][FreeSpace][PageFooter]\n"})}),"\n",(0,s.jsx)(r.h4,{id:"cache-management",children:"Cache Management"}),"\n",(0,s.jsx)(r.p,{children:"Browsers implement sophisticated caching strategies:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Buffer Pool"}),": In-memory cache of frequently accessed pages"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Write-Ahead Logging"}),": Ensures durability before commit"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Checkpoint Processing"}),": Periodic flushing of dirty pages to disk"]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"browser-storage-architecture",children:"Browser Storage Architecture"}),"\n",(0,s.jsx)(r.h3,{id:"storage-partitioning",children:"Storage Partitioning"}),"\n",(0,s.jsx)(r.p,{children:"Modern browsers implement storage partitioning to enhance security and performance:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Storage is partitioned by origin\r\nconst origin1 = "https://example.com"; // Separate storage\r\nconst origin2 = "https://subdomain.example.com"; // Separate storage\r\nconst origin3 = "http://example.com"; // Separate storage (different protocol)\n'})}),"\n",(0,s.jsx)(r.h3,{id:"persistence-models",children:"Persistence Models"}),"\n",(0,s.jsx)(r.h4,{id:"temporary-storage",children:"Temporary Storage"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Default behavior - subject to browser eviction\r\nnavigator.storage.estimate().then((estimate) => {\r\n  console.log("Available:", estimate.quota);\r\n  console.log("Used:", estimate.usage);\r\n});\n'})}),"\n",(0,s.jsx)(r.h4,{id:"persistent-storage",children:"Persistent Storage"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Request persistent storage (won\'t be evicted)\r\nnavigator.storage.persist().then((persistent) => {\r\n  if (persistent) {\r\n    console.log("Storage will persist across browser sessions");\r\n  } else {\r\n    console.log("Storage may be evicted by the browser");\r\n  }\r\n});\n'})}),"\n",(0,s.jsx)(r.h2,{id:"storage-limits-and-quota-management",children:"Storage Limits and Quota Management"}),"\n",(0,s.jsx)(r.h3,{id:"browser-specific-limits",children:"Browser-Specific Limits"}),"\n",(0,s.jsx)(r.h4,{id:"chromechromium",children:"Chrome/Chromium"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Default Quota"}),": 60% of available disk space (shared across all origins)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Per-Origin Limit"}),": 20% of total quota"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Minimum Guarantee"}),": 1GB if available"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Eviction Policy"}),": LRU (Least Recently Used)"]}),"\n"]}),"\n",(0,s.jsx)(r.h4,{id:"firefox",children:"Firefox"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Default Quota"}),": 50% of available disk space"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Per-Origin Limit"}),": 2GB initially, can grow"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Group Limit"}),": 20% of global quota per origin group"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Eviction Policy"}),": LRU with usage-based weighting"]}),"\n"]}),"\n",(0,s.jsx)(r.h4,{id:"safari",children:"Safari"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Default Quota"}),": More conservative, around 1GB"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Per-Origin Limit"}),": Varies, typically 1GB"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"User Prompts"}),": May prompt user for additional storage"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Eviction Policy"}),": Strict LRU"]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"quota-api-usage",children:"Quota API Usage"}),"\n",(0,s.jsx)(r.p,{children:"Modern browsers provide a Storage API to help applications monitor and manage their storage usage. This is crucial for production applications that store significant amounts of data and need to handle storage limits gracefully."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What this code demonstrates:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"How to check current storage usage and available quota"}),"\n",(0,s.jsx)(r.li,{children:"Converting bytes to human-readable megabytes"}),"\n",(0,s.jsx)(r.li,{children:"Implementing proactive storage monitoring"}),"\n",(0,s.jsx)(r.li,{children:"Handling quota exceeded errors gracefully"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Storage Monitoring Steps:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Feature Detection"})," - Check if Storage API is available"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Usage Estimation"})," - Get current usage and total quota"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Calculation"})," - Convert to readable format and percentages"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Threshold Monitoring"})," - Alert when approaching limits"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Error Handling"})," - Graceful degradation when quota exceeded"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Input:"})," None (reads browser storage state)\r\n",(0,s.jsx)(r.strong,{children:"Output:"})," Storage usage statistics and warnings\r\n",(0,s.jsx)(r.strong,{children:"Use case:"})," Proactive storage management in data-heavy applications"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Check current storage usage and quota\r\n// Essential for applications that store large amounts of data\r\nasync function checkStorageQuota() {\r\n  // Feature detection - not all browsers support Storage API\r\n  if ("storage" in navigator && "estimate" in navigator.storage) {\r\n    // Get current storage estimate from browser\r\n    const estimate = await navigator.storage.estimate();\r\n\r\n    // Convert bytes to more readable megabytes (1024 * 1024 = 1MB)\r\n    const usageInMB = (estimate.usage / (1024 * 1024)).toFixed(2);\r\n    const quotaInMB = (estimate.quota / (1024 * 1024)).toFixed(2);\r\n    const percentUsed = ((estimate.usage / estimate.quota) * 100).toFixed(2);\r\n\r\n    // Log storage statistics for monitoring\r\n    console.log(`Storage used: ${usageInMB} MB`);\r\n    console.log(`Storage quota: ${quotaInMB} MB`);\r\n    console.log(`Percentage used: ${percentUsed}%`);\r\n\r\n    // Proactive monitoring - warn when approaching 80% capacity\r\n    if (estimate.usage / estimate.quota > 0.8) {\r\n      console.warn("Storage usage is above 80% - consider cleanup");\r\n      // Could trigger background cleanup or user notification\r\n      return { status: "warning", usage: usageInMB, quota: quotaInMB };\r\n    }\r\n\r\n    return { status: "ok", usage: usageInMB, quota: quotaInMB };\r\n  } else {\r\n    console.warn("Storage API not supported in this browser");\r\n    return { status: "unsupported" };\r\n  }\r\n}\r\n\r\n// Handle quota exceeded errors\r\n// This function should be called in your error handling middleware\r\nfunction handleQuotaError(error) {\r\n  if (error.name === "QuotaExceededError") {\r\n    console.error("Storage quota exceeded - cannot store more data");\r\n\r\n    // Implement cleanup strategies:\r\n    // 1. Clear expired cache data\r\n    // 2. Remove old log entries\r\n    // 3. Compress or archive old data\r\n    // 4. Prompt user to free up space\r\n\r\n    cleanupOldData()\r\n      .then(() => {\r\n        console.log("Cleanup completed - retrying operation");\r\n        // Could retry the failed operation here\r\n      })\r\n      .catch((cleanupError) => {\r\n        console.error("Cleanup failed:", cleanupError);\r\n        // Show user notification about storage being full\r\n        showStorageFullNotification();\r\n      });\r\n  }\r\n}\r\n\r\n// Example cleanup function\r\nasync function cleanupOldData() {\r\n  // Remove cache entries older than 7 days\r\n  const weekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;\r\n\r\n  await db.cache.where("timestamp").below(weekAgo).delete();\r\n\r\n  console.log("Removed cache entries older than 7 days");\r\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"native-indexeddb-api-deep-dive",children:"Native IndexedDB API Deep Dive"}),"\n",(0,s.jsx)(r.h3,{id:"database-connection-management",children:"Database Connection Management"}),"\n",(0,s.jsx)(r.p,{children:"Opening an IndexedDB database is more complex than other storage APIs because it involves version management, schema migrations, and handling concurrent access from multiple tabs. This function demonstrates a production-ready approach to database connection management."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What this code demonstrates:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Robust database opening with comprehensive error handling"}),"\n",(0,s.jsx)(r.li,{children:"Version control and schema upgrade handling"}),"\n",(0,s.jsx)(r.li,{children:"Multi-tab coordination and conflict resolution"}),"\n",(0,s.jsx)(r.li,{children:"Promise-based API wrapper for easier async/await usage"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Connection Process Steps:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Open Request"})," - Initiate database connection with version"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Version Check"})," - Browser compares requested vs existing version"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Upgrade Handling"})," - Run migrations if version is newer"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Success/Error"})," - Resolve with database or reject with error"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Event Setup"})," - Configure ongoing error and version change handlers"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Input Parameters:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"name"}),": Database name (string)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"version"}),": Schema version number (integer)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"upgradeCallback"}),": Function to handle schema changes"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Output:"})," Promise resolving to database connection\r\n",(0,s.jsx)(r.strong,{children:"Use case:"})," Establishing reliable database connections with proper error handling"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Advanced database opening with version control\r\n// This function handles all the complexities of IndexedDB connection management\r\nfunction openDatabase(name, version, upgradeCallback) {\r\n  return new Promise((resolve, reject) => {\r\n    // Step 1: Initiate database open request\r\n    // indexedDB.open() is asynchronous and event-driven\r\n    const request = indexedDB.open(name, version);\r\n\r\n    // Step 2: Handle connection errors\r\n    // This fires if the database cannot be opened at all\r\n    request.onerror = () => {\r\n      reject(new Error(`Failed to open database: ${request.error}`));\r\n    };\r\n\r\n    // Step 3: Handle successful connection\r\n    // This fires when database is successfully opened\r\n    request.onsuccess = () => {\r\n      const db = request.result;\r\n\r\n      // Set up global error handler for ongoing operations\r\n      // This catches errors from transactions and operations\r\n      db.onerror = (event) => {\r\n        console.error("Database error:", event.target.error);\r\n        // Could implement error reporting or user notification here\r\n      };\r\n\r\n      // Handle version change from another tab/window\r\n      // Critical for multi-tab applications\r\n      db.onversionchange = () => {\r\n        console.warn("Database version changed by another tab");\r\n        db.close(); // Close this connection to allow upgrade\r\n        // Should reload the page or reconnect with new version\r\n        window.location.reload();\r\n      };\r\n\r\n      resolve(db);\r\n    };\r\n\r\n    // Step 4: Handle schema upgrades\r\n    // This fires when requested version > existing version\r\n    request.onupgradeneeded = (event) => {\r\n      const db = event.target.result;\r\n      const transaction = event.target.transaction;\r\n\r\n      console.log(\r\n        `Upgrading database from version ${event.oldVersion} to ${event.newVersion}`\r\n      );\r\n\r\n      // Call user-provided upgrade callback with context\r\n      // This is where you create/modify object stores and indexes\r\n      if (upgradeCallback) {\r\n        try {\r\n          upgradeCallback(db, transaction, event.oldVersion, event.newVersion);\r\n        } catch (error) {\r\n          console.error("Schema upgrade failed:", error);\r\n          transaction.abort(); // Abort the upgrade\r\n        }\r\n      }\r\n    };\r\n\r\n    // Step 5: Handle blocking situations\r\n    // This fires when upgrade is blocked by open connections\r\n    request.onblocked = () => {\r\n      console.warn("Database upgrade blocked by other connections");\r\n      // In production, might show user notification to close other tabs\r\n      alert("Please close other tabs to allow database upgrade");\r\n    };\r\n  });\r\n}\r\n\r\n// Example usage with schema upgrade\r\nasync function initializeDatabase() {\r\n  try {\r\n    const db = await openDatabase(\r\n      "MyApp",\r\n      2,\r\n      (db, transaction, oldVersion, newVersion) => {\r\n        // Handle different upgrade paths\r\n        if (oldVersion < 1) {\r\n          // Create initial schema\r\n          const userStore = db.createObjectStore("users", {\r\n            keyPath: "id",\r\n            autoIncrement: true,\r\n          });\r\n          userStore.createIndex("email", "email", { unique: true });\r\n        }\r\n\r\n        if (oldVersion < 2) {\r\n          // Add new features in version 2\r\n          const userStore = transaction.objectStore("users");\r\n          userStore.createIndex("lastName", "lastName");\r\n        }\r\n      }\r\n    );\r\n\r\n    console.log("Database initialized successfully");\r\n    return db;\r\n  } catch (error) {\r\n    console.error("Failed to initialize database:", error);\r\n    throw error;\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"transaction-management",children:"Transaction Management"}),"\n",(0,s.jsx)(r.p,{children:"IndexedDB transactions can fail for various reasons - network issues, quota limits, or timing problems. This TransactionManager class provides enterprise-grade transaction handling with automatic retry logic and robust error recovery."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What this code demonstrates:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Automatic retry logic for transient failures"}),"\n",(0,s.jsx)(r.li,{children:"Exponential backoff strategy to avoid overwhelming the system"}),"\n",(0,s.jsx)(r.li,{children:"Proper transaction lifecycle management"}),"\n",(0,s.jsx)(r.li,{children:"Error classification and retry decision making"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Transaction Retry Strategy:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Execute"})," - Try the transaction operation"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Classify Error"})," - Determine if error is retryable"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Backoff"})," - Wait with exponential delay between retries"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Retry"})," - Attempt operation again up to max retries"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Fail"})," - Throw error if all retries exhausted"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Input Parameters:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"storeNames"}),": Array of object store names to access"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"mode"}),': Transaction mode ("readonly" or "readwrite")']}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"operations"}),": Function containing database operations"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"maxRetries"}),": Maximum number of retry attempts"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Output:"})," Promise resolving to transaction results\r\n",(0,s.jsx)(r.strong,{children:"Use case:"})," Reliable transaction execution in unreliable network conditions"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Advanced transaction handling with retry logic\r\n// Essential for production applications dealing with network instability\r\nclass TransactionManager {\r\n  constructor(db) {\r\n    this.db = db;\r\n    this.retryStats = new Map(); // Track retry statistics\r\n  }\r\n\r\n  // Main method with automatic retry logic\r\n  async executeWithRetry(storeNames, mode, operations, maxRetries = 3) {\r\n    const operationId = this.generateOperationId();\r\n\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        console.log(\r\n          `Transaction attempt ${attempt}/${maxRetries} for operation ${operationId}`\r\n        );\r\n\r\n        // Execute the transaction\r\n        const result = await this.executeTransaction(\r\n          storeNames,\r\n          mode,\r\n          operations\r\n        );\r\n\r\n        // Success - log statistics and return result\r\n        this.recordSuccess(operationId, attempt);\r\n        return result;\r\n      } catch (error) {\r\n        console.warn(`Transaction attempt ${attempt} failed:`, error.message);\r\n\r\n        // Check if we should retry this error\r\n        if (attempt === maxRetries || !this.isRetryableError(error)) {\r\n          this.recordFailure(operationId, attempt, error);\r\n          throw error;\r\n        }\r\n\r\n        // Exponential backoff: 100ms, 400ms, 1600ms, etc.\r\n        const delayMs = Math.pow(2, attempt) * 100;\r\n        console.log(`Retrying in ${delayMs}ms...`);\r\n        await this.delay(delayMs);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Core transaction execution\r\n  executeTransaction(storeNames, mode, operations) {\r\n    return new Promise((resolve, reject) => {\r\n      // Create transaction with specified stores and mode\r\n      const transaction = this.db.transaction(storeNames, mode);\r\n      const results = {}; // Collect operation results\r\n\r\n      // Set up transaction event handlers\r\n      transaction.oncomplete = () => {\r\n        console.log("Transaction completed successfully");\r\n        resolve(results);\r\n      };\r\n\r\n      transaction.onerror = (event) => {\r\n        console.error("Transaction error:", event.target.error);\r\n        reject(transaction.error);\r\n      };\r\n\r\n      transaction.onabort = () => {\r\n        console.warn("Transaction was aborted");\r\n        reject(new Error("Transaction aborted"));\r\n      };\r\n\r\n      try {\r\n        // Execute user-provided operations within transaction context\r\n        // All operations must complete before transaction auto-commits\r\n        operations(transaction, results);\r\n      } catch (syncError) {\r\n        // Handle synchronous errors in operations\r\n        console.error(\r\n          "Synchronous error in transaction operations:",\r\n          syncError\r\n        );\r\n        transaction.abort();\r\n        reject(syncError);\r\n      }\r\n    });\r\n  }\r\n\r\n  // Determine if an error is worth retrying\r\n  isRetryableError(error) {\r\n    const retryableErrors = [\r\n      "TransactionInactiveError", // Transaction timed out\r\n      "InvalidStateError", // Database in invalid state\r\n      "AbortError", // Transaction was aborted\r\n      "UnknownError", // Generic network/system error\r\n    ];\r\n\r\n    return retryableErrors.includes(error.name);\r\n  }\r\n\r\n  // Utility methods\r\n  delay(ms) {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n\r\n  generateOperationId() {\r\n    return `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  recordSuccess(operationId, attempts) {\r\n    console.log(\r\n      `Operation ${operationId} succeeded after ${attempts} attempts`\r\n    );\r\n  }\r\n\r\n  recordFailure(operationId, attempts, error) {\r\n    console.error(\r\n      `Operation ${operationId} failed after ${attempts} attempts:`,\r\n      error\r\n    );\r\n  }\r\n}\r\n\r\n// Example usage\r\nasync function useTransactionManager() {\r\n  const tm = new TransactionManager(db);\r\n\r\n  try {\r\n    const result = await tm.executeWithRetry(\r\n      ["users", "orders"],\r\n      "readwrite",\r\n      (transaction, results) => {\r\n        // These operations execute atomically\r\n        const userStore = transaction.objectStore("users");\r\n        const orderStore = transaction.objectStore("orders");\r\n\r\n        // Add user and get the generated ID\r\n        const userRequest = userStore.add({\r\n          name: "John",\r\n          email: "john@example.com",\r\n        });\r\n        userRequest.onsuccess = () => {\r\n          const userId = userRequest.result;\r\n          results.userId = userId;\r\n\r\n          // Add order linked to the user\r\n          const orderRequest = orderStore.add({\r\n            userId: userId,\r\n            total: 99.99,\r\n            items: ["item1", "item2"],\r\n          });\r\n          orderRequest.onsuccess = () => {\r\n            results.orderId = orderRequest.result;\r\n          };\r\n        };\r\n      }\r\n    );\r\n\r\n    console.log("User and order created:", result);\r\n  } catch (error) {\r\n    console.error("Failed to create user and order:", error);\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"cursor-operations",children:"Cursor Operations"}),"\n",(0,s.jsx)(r.p,{children:"Cursors are IndexedDB's primary mechanism for iterating through large datasets efficiently. Unlike loading all records into memory, cursors allow you to process data one record at a time, making them essential for handling large datasets and implementing pagination."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What this code demonstrates:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Memory-efficient pagination using cursors"}),"\n",(0,s.jsx)(r.li,{children:"Range queries with custom filtering"}),"\n",(0,s.jsx)(r.li,{children:"Key-based navigation for next/previous functionality"}),"\n",(0,s.jsx)(r.li,{children:"Streaming data processing without memory overload"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Cursor Benefits:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Memory Efficiency"})," - Process one record at a time"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Performance"})," - No need to load entire datasets"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Flexibility"})," - Skip, filter, and transform data on-the-fly"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Pagination"})," - Implement infinite scroll and data tables"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Streaming"})," - Real-time processing of large datasets"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Input Parameters:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"pageSize"}),": Number of records per page"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"startKey"}),": Key to start pagination from (for next page)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"filter"}),": Optional function to filter records"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Output:"})," Paginated results with navigation metadata\r\n",(0,s.jsx)(r.strong,{children:"Use case:"})," Data tables, infinite scroll, large dataset processing"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Advanced cursor usage for range queries and pagination\r\n// Essential for handling large datasets without memory issues\r\nclass CursorQuery {\r\n  constructor(objectStore) {\r\n    this.objectStore = objectStore;\r\n    this.stats = { recordsProcessed: 0, queriesExecuted: 0 };\r\n  }\r\n\r\n  // Paginated query with cursor - memory efficient pagination\r\n  async paginate(pageSize = 20, startKey = null, direction = "next") {\r\n    this.stats.queriesExecuted++;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const results = [];\r\n      let cursor;\r\n\r\n      // Create appropriate cursor based on start key and direction\r\n      if (startKey) {\r\n        if (direction === "next") {\r\n          // Get records after startKey (exclusive bound)\r\n          const range = IDBKeyRange.lowerBound(startKey, true);\r\n          cursor = this.objectStore.openCursor(range);\r\n        } else {\r\n          // Get records before startKey (for previous page)\r\n          const range = IDBKeyRange.upperBound(startKey, true);\r\n          cursor = this.objectStore.openCursor(range, "prev");\r\n        }\r\n      } else {\r\n        // First page - start from beginning\r\n        cursor = this.objectStore.openCursor(\r\n          null,\r\n          direction === "next" ? "next" : "prev"\r\n        );\r\n      }\r\n\r\n      cursor.onsuccess = (event) => {\r\n        const cursorResult = event.target.result;\r\n\r\n        if (cursorResult && results.length < pageSize) {\r\n          // Add current record to results\r\n          results.push({\r\n            key: cursorResult.key,\r\n            value: cursorResult.value,\r\n          });\r\n\r\n          this.stats.recordsProcessed++;\r\n\r\n          // Move to next record\r\n          cursorResult.continue();\r\n        } else {\r\n          // Pagination complete - return results with metadata\r\n          const response = {\r\n            results: direction === "prev" ? results.reverse() : results,\r\n            nextKey: cursorResult ? cursorResult.key : null,\r\n            hasMore: cursorResult !== null,\r\n            direction: direction,\r\n            pageSize: pageSize,\r\n            totalProcessed: this.stats.recordsProcessed,\r\n          };\r\n\r\n          resolve(response);\r\n        }\r\n      };\r\n\r\n      cursor.onerror = (event) => {\r\n        console.error("Cursor error during pagination:", event.target.error);\r\n        reject(cursor.error);\r\n      };\r\n    });\r\n  }\r\n\r\n  // Range query with filtering - process data without loading everything\r\n  async rangeQuery(lowerBound, upperBound, filter = null, transform = null) {\r\n    return new Promise((resolve, reject) => {\r\n      const results = [];\r\n      let processedCount = 0;\r\n      let filteredCount = 0;\r\n\r\n      // Create bounded range for efficient querying\r\n      const range = IDBKeyRange.bound(lowerBound, upperBound);\r\n      const cursor = this.objectStore.openCursor(range);\r\n\r\n      cursor.onsuccess = (event) => {\r\n        const cursorResult = event.target.result;\r\n\r\n        if (cursorResult) {\r\n          processedCount++;\r\n          const value = cursorResult.value;\r\n\r\n          // Apply filter if provided\r\n          if (!filter || filter(value)) {\r\n            filteredCount++;\r\n\r\n            // Apply transformation if provided\r\n            const finalValue = transform ? transform(value) : value;\r\n            results.push(finalValue);\r\n          }\r\n\r\n          // Continue to next record\r\n          cursorResult.continue();\r\n        } else {\r\n          // Query complete - return results with statistics\r\n          resolve({\r\n            results: results,\r\n            statistics: {\r\n              totalProcessed: processedCount,\r\n              totalFiltered: filteredCount,\r\n              range: { lower: lowerBound, upper: upperBound },\r\n            },\r\n          });\r\n        }\r\n      };\r\n\r\n      cursor.onerror = (event) => {\r\n        console.error("Cursor error during range query:", event.target.error);\r\n        reject(cursor.error);\r\n      };\r\n    });\r\n  }\r\n\r\n  // Advanced cursor operations for complex queries\r\n  async complexQuery(options = {}) {\r\n    const {\r\n      indexName = null, // Use specific index\r\n      range = null, // Key range to query\r\n      direction = "next", // Cursor direction\r\n      limit = null, // Maximum results\r\n      offset = 0, // Skip first N records\r\n      filter = null, // Filter function\r\n      transform = null, // Transform function\r\n      onProgress = null, // Progress callback\r\n    } = options;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const results = [];\r\n      let skipped = 0;\r\n      let processed = 0;\r\n\r\n      // Choose source: index or object store\r\n      const source = indexName\r\n        ? this.objectStore.index(indexName)\r\n        : this.objectStore;\r\n\r\n      // Open cursor with range and direction\r\n      const cursor = source.openCursor(range, direction);\r\n\r\n      cursor.onsuccess = (event) => {\r\n        const cursorResult = event.target.result;\r\n\r\n        if (cursorResult) {\r\n          processed++;\r\n\r\n          // Handle offset (skip first N records)\r\n          if (skipped < offset) {\r\n            skipped++;\r\n            cursorResult.continue();\r\n            return;\r\n          }\r\n\r\n          // Check limit\r\n          if (limit && results.length >= limit) {\r\n            resolve({\r\n              results: results,\r\n              hasMore: true,\r\n              totalProcessed: processed,\r\n            });\r\n            return;\r\n          }\r\n\r\n          const value = cursorResult.value;\r\n\r\n          // Apply filter\r\n          if (!filter || filter(value, cursorResult.key)) {\r\n            // Apply transformation\r\n            const finalValue = transform\r\n              ? transform(value, cursorResult.key)\r\n              : value;\r\n\r\n            results.push(finalValue);\r\n          }\r\n\r\n          // Progress callback\r\n          if (onProgress && processed % 100 === 0) {\r\n            onProgress(processed, results.length);\r\n          }\r\n\r\n          cursorResult.continue();\r\n        } else {\r\n          // Query complete\r\n          resolve({\r\n            results: results,\r\n            hasMore: false,\r\n            totalProcessed: processed,\r\n          });\r\n        }\r\n      };\r\n\r\n      cursor.onerror = (event) => {\r\n        reject(cursor.error);\r\n      };\r\n    });\r\n  }\r\n}\r\n\r\n// Example usage patterns\r\nasync function demonstrateCursorUsage() {\r\n  const userStore = db.transaction("users", "readonly").objectStore("users");\r\n  const cursor = new CursorQuery(userStore);\r\n\r\n  // 1. Basic pagination\r\n  const page1 = await cursor.paginate(10);\r\n  console.log("First page:", page1.results.length, "records");\r\n\r\n  if (page1.hasMore) {\r\n    const page2 = await cursor.paginate(10, page1.nextKey);\r\n    console.log("Second page:", page2.results.length, "records");\r\n  }\r\n\r\n  // 2. Filtered range query\r\n  const activeUsers = await cursor.rangeQuery(\r\n    1,\r\n    1000,\r\n    (user) => user.isActive && user.lastLogin > Date.now() - 86400000,\r\n    (user) => ({ id: user.id, name: user.name }) // Transform to minimal data\r\n  );\r\n\r\n  // 3. Complex query with progress\r\n  const complexResults = await cursor.complexQuery({\r\n    indexName: "lastName",\r\n    range: IDBKeyRange.bound("A", "M"),\r\n    limit: 50,\r\n    filter: (user) => user.age >= 18,\r\n    transform: (user) => user.email,\r\n    onProgress: (processed, found) => {\r\n      console.log(`Processed ${processed}, found ${found} matches`);\r\n    },\r\n  });\r\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"dexiejs-the-wrapper-library",children:"Dexie.js: The Wrapper Library"}),"\n",(0,s.jsx)(r.h3,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,s.jsx)(r.p,{children:"Dexie.js provides a sophisticated abstraction layer over IndexedDB while maintaining high performance and full feature access. Its architecture consists of several key components:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"Dexie Architecture:\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502           User API Layer            \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         Promise Wrapper             \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502       Transaction Manager           \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         Query Engine                \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502       Schema Management             \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502         IndexedDB Core              \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(r.h3,{id:"core-design-principles",children:"Core Design Principles"}),"\n",(0,s.jsx)(r.h4,{id:"1-promise-first-api",children:"1. Promise-First API"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"// Native IndexedDB (callback-based)\r\nconst request = objectStore.get(key);\r\nrequest.onsuccess = (event) => {\r\n  const result = event.target.result;\r\n  // Handle result\r\n};\r\nrequest.onerror = (event) => {\r\n  // Handle error\r\n};\r\n\r\n// Dexie (Promise-based)\r\nconst result = await db.table.get(key);\n"})}),"\n",(0,s.jsx)(r.h4,{id:"2-fluent-query-interface",children:"2. Fluent Query Interface"}),"\n",(0,s.jsx)(r.p,{children:"Dexie's fluent query interface allows you to chain operations in a readable, SQL-like manner. This approach builds a query plan that's optimized before execution, providing both excellent performance and developer experience."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What this code demonstrates:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Chainable query operations for readable code"}),"\n",(0,s.jsx)(r.li,{children:"Automatic query optimization by Dexie"}),"\n",(0,s.jsx)(r.li,{children:"Mixed indexed and filtered operations"}),"\n",(0,s.jsx)(r.li,{children:"Seamless conversion to arrays, counting, or iteration"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Query Building Process:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Index Selection"})," - ",(0,s.jsx)(r.code,{children:'where("age")'})," chooses the age index"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Range Filtering"})," - ",(0,s.jsx)(r.code,{children:"between(18, 65)"})," uses IndexedDB key ranges"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Additional Filtering"})," - ",(0,s.jsx)(r.code,{children:"and()"})," applies JavaScript filters"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Sorting"})," - ",(0,s.jsx)(r.code,{children:"orderBy()"})," specifies result ordering"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Limiting"})," - ",(0,s.jsx)(r.code,{children:"limit()"})," controls result set size"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Execution"})," - ",(0,s.jsx)(r.code,{children:"toArray()"})," executes and returns results"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Input:"})," Query criteria and constraints\r\n",(0,s.jsx)(r.strong,{children:"Output:"})," Array of filtered and sorted records\r\n",(0,s.jsx)(r.strong,{children:"Use case:"})," Building complex queries with readable syntax"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Complex query in Dexie - demonstrates the power of fluent interface\r\nconst results = await db.users\r\n  .where("age") // Use the \'age\' index for efficient range query\r\n  .between(18, 65) // Range query: 18 <= age <= 65 (uses IndexedDB range)\r\n  .and((user) => user.isActive) // Additional filter using JavaScript (post-index)\r\n  .orderBy("name") // Sort results by name (can use index if available)\r\n  .limit(50) // Limit to first 50 results\r\n  .toArray(); // Execute query and return as array\r\n\r\n// Alternative execution methods:\r\n// .count()           - Get count without loading data\r\n// .first()           - Get first matching record\r\n// .last()            - Get last matching record\r\n// .each(callback)    - Iterate without loading all into memory\r\n// .keys()            - Get only the keys, not values\r\n// .modify({...})     - Update matching records\r\n// .delete()          - Delete matching records\r\n\r\n// More complex query examples:\r\n// Multi-column queries\r\nconst recentActiveUsers = await db.users\r\n  .where(["lastLoginDate", "isActive"])\r\n  .between([new Date("2023-01-01"), true], [new Date(), true])\r\n  .toArray();\r\n\r\n// Text search with partial matching\r\nconst searchResults = await db.users\r\n  .where("name")\r\n  .startsWithIgnoreCase("john")\r\n  .or("email")\r\n  .startsWithIgnoreCase("john")\r\n  .toArray();\r\n\r\n// Complex filtering with pagination\r\nconst paginatedQuery = await db.orders\r\n  .where("customerId")\r\n  .equals(123)\r\n  .and((order) => order.total > 100)\r\n  .offset(20) // Skip first 20 results\r\n  .limit(10) // Take next 10 results\r\n  .reverse() // Reverse order\r\n  .toArray();\n'})}),"\n",(0,s.jsx)(r.h4,{id:"3-automatic-transaction-management",children:"3. Automatic Transaction Management"}),"\n",(0,s.jsx)(r.p,{children:"One of Dexie's most powerful features is its automatic transaction management. Unlike raw IndexedDB where you must manually handle transaction lifecycles, Dexie creates transactions automatically and ensures proper commit/rollback behavior."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What this code demonstrates:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Automatic transaction creation and management"}),"\n",(0,s.jsx)(r.li,{children:"Multi-table atomic operations"}),"\n",(0,s.jsx)(r.li,{children:"Automatic commit on success / rollback on error"}),"\n",(0,s.jsx)(r.li,{children:"Clean async/await syntax within transactions"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Transaction Management Process:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Auto-Creation"})," - Dexie creates transactions as needed"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Context Preservation"})," - Maintains transaction context across await calls"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Atomic Operations"})," - Multiple operations execute atomically"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Auto-Commit"})," - Successful completion commits automatically"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Auto-Rollback"})," - Any error rolls back all changes"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Input:"})," Transaction mode, tables, and operation function\r\n",(0,s.jsx)(r.strong,{children:"Output:"})," Promise resolving to function return value\r\n",(0,s.jsx)(r.strong,{children:"Use case:"})," Ensuring data consistency across multiple operations"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Dexie automatically manages transactions\r\n// This function demonstrates ACID properties in client-side storage\r\nawait db.transaction("rw", db.users, db.orders, async () => {\r\n  // All operations within this function are atomic\r\n  // If any operation fails, entire transaction rolls back\r\n\r\n  const user = await db.users.add({\r\n    name: "John",\r\n    email: "john@example.com",\r\n    createdAt: new Date(),\r\n  });\r\n\r\n  // user variable contains the auto-generated ID\r\n  await db.orders.add({\r\n    userId: user, // Reference to the created user\r\n    total: 100,\r\n    status: "pending",\r\n    items: ["item1", "item2"],\r\n  });\r\n\r\n  // Update user\'s order count\r\n  await db.users.update(user, {\r\n    orderCount: 1,\r\n  });\r\n\r\n  // All operations succeed = automatic commit\r\n  // Any operation fails = automatic rollback\r\n  // No need to manually call commit() or rollback()\r\n});\r\n\r\n// Advanced transaction examples:\r\n\r\n// 1. Transaction with error handling\r\ntry {\r\n  const result = await db.transaction("rw", [db.users, db.orders], async () => {\r\n    const userId = await db.users.add({ name: "Jane" });\r\n\r\n    // Simulate a business logic error\r\n    if (userId > 1000) {\r\n      throw new Error("Too many users!");\r\n    }\r\n\r\n    await db.orders.add({ userId, total: 50 });\r\n    return { userId, message: "User and order created" };\r\n  });\r\n\r\n  console.log("Transaction succeeded:", result);\r\n} catch (error) {\r\n  console.log("Transaction failed and rolled back:", error.message);\r\n  // Database state is unchanged - atomic rollback occurred\r\n}\r\n\r\n// 2. Read-only transaction for consistency\r\nconst summary = await db.transaction("r", [db.users, db.orders], async () => {\r\n  // Consistent snapshot across multiple tables\r\n  const userCount = await db.users.count();\r\n  const orderCount = await db.orders.count();\r\n  const totalRevenue = await db.orders\r\n    .toCollection()\r\n    .reduce((sum, order) => sum + order.total, 0);\r\n\r\n  return { userCount, orderCount, totalRevenue };\r\n});\r\n\r\n// 3. Implicit transactions for single operations\r\n// These automatically create minimal transactions:\r\nawait db.users.add({ name: "Bob" }); // Auto-creates "rw" transaction\r\nconst user = await db.users.get(1); // Auto-creates "r" transaction\r\nawait db.users.update(1, { lastLogin: new Date() }); // Auto-creates "rw" transaction\r\n\r\n// 4. Transaction spanning multiple async operations\r\nawait db.transaction("rw", db.users, async () => {\r\n  const users = await db.users.where("isActive").equals(false).toArray();\r\n\r\n  for (const user of users) {\r\n    // Each update happens within the same transaction\r\n    await db.users.update(user.id, {\r\n      isActive: true,\r\n      reactivatedAt: new Date(),\r\n    });\r\n\r\n    // Could call external APIs here while maintaining transaction\r\n    // await notificationService.sendWelcomeBack(user.email);\r\n  }\r\n\r\n  console.log(`Reactivated ${users.length} users`);\r\n});\n'})}),"\n",(0,s.jsx)(r.h2,{id:"how-dexie-wraps-indexeddb",children:"How Dexie Wraps IndexedDB"}),"\n",(0,s.jsx)(r.h3,{id:"promise-wrapper-implementation",children:"Promise Wrapper Implementation"}),"\n",(0,s.jsx)(r.p,{children:"Dexie's promise wrapper is one of its most sophisticated features. Here's a simplified version of how it works:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"// Simplified Promise wrapper (based on Dexie source concepts)\r\nclass DexiePromise extends Promise {\r\n  constructor(executor) {\r\n    super(executor);\r\n    this._zone = getCurrentZone(); // Transaction context\r\n  }\r\n\r\n  then(onFulfilled, onRejected) {\r\n    return this._zone.run(() => {\r\n      return super.then(onFulfilled, onRejected);\r\n    });\r\n  }\r\n\r\n  catch(onRejected) {\r\n    return this._zone.run(() => {\r\n      return super.catch(onRejected);\r\n    });\r\n  }\r\n}\r\n\r\n// Zone implementation for transaction context\r\nclass Zone {\r\n  constructor(parent = null) {\r\n    this.parent = parent;\r\n    this.transaction = null;\r\n    this.props = {};\r\n  }\r\n\r\n  run(fn) {\r\n    const previousZone = currentZone;\r\n    currentZone = this;\r\n    try {\r\n      return fn();\r\n    } finally {\r\n      currentZone = previousZone;\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(r.h3,{id:"query-engine-implementation",children:"Query Engine Implementation"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"// Dexie's Collection class (simplified)\r\nclass Collection {\r\n  constructor(table, where) {\r\n    this.table = table;\r\n    this.where = where;\r\n    this.filters = [];\r\n    this.ordering = null;\r\n    this.limitValue = null;\r\n  }\r\n\r\n  // Fluent query methods\r\n  and(filterFunction) {\r\n    return new Collection(this.table, this.where).addFilter(filterFunction);\r\n  }\r\n\r\n  orderBy(keyPath) {\r\n    const collection = this.clone();\r\n    collection.ordering = keyPath;\r\n    return collection;\r\n  }\r\n\r\n  limit(count) {\r\n    const collection = this.clone();\r\n    collection.limitValue = count;\r\n    return collection;\r\n  }\r\n\r\n  // Execute query\r\n  async toArray() {\r\n    const strategy = this.optimizeQuery();\r\n    return await strategy.execute();\r\n  }\r\n\r\n  // Query optimization\r\n  optimizeQuery() {\r\n    if (this.where && this.table.schema.hasIndex(this.where.keyPath)) {\r\n      return new IndexStrategy(this);\r\n    } else {\r\n      return new ScanStrategy(this);\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(r.h3,{id:"transaction-context-management",children:"Transaction Context Management"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"// Dexie's transaction management (conceptual)\r\nclass Transaction {\r\n  constructor(mode, tables, db) {\r\n    this.mode = mode;\r\n    this.tables = tables;\r\n    this.db = db;\r\n    this.idbtrans = null;\r\n    this.active = false;\r\n  }\r\n\r\n  async execute(fn) {\r\n    this.idbtrans = this.db.idbdb.transaction(this.tables, this.mode);\r\n    this.active = true;\r\n\r\n    // Set up transaction event handlers\r\n    this.idbtrans.oncomplete = () => this.complete();\r\n    this.idbtrans.onerror = (event) => this.error(event);\r\n    this.idbtrans.onabort = () => this.abort();\r\n\r\n    try {\r\n      // Execute user function in transaction context\r\n      const result = await this.runInContext(fn);\r\n      return result;\r\n    } catch (error) {\r\n      this.idbtrans.abort();\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  runInContext(fn) {\r\n    return new Zone(currentZone).run(() => {\r\n      currentZone.transaction = this;\r\n      return fn();\r\n    });\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(r.h2,{id:"dexie-source-code-analysis",children:"Dexie Source Code Analysis"}),"\n",(0,s.jsx)(r.h3,{id:"schema-definition-and-versioning",children:"Schema Definition and Versioning"}),"\n",(0,s.jsx)(r.p,{children:"Looking at Dexie's source code, schema management is handled through a sophisticated versioning system:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// From Dexie source: Version class\r\nclass Version {\r\n  constructor(versionNumber) {\r\n    this._cfg = {\r\n      version: versionNumber,\r\n      storeNames: [],\r\n      dbschema: {},\r\n      tables: {},\r\n    };\r\n  }\r\n\r\n  stores(stores) {\r\n    Object.keys(stores).forEach((tableName) => {\r\n      const schema = stores[tableName];\r\n      this.parseStoreSchema(tableName, schema);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  parseStoreSchema(tableName, schema) {\r\n    // Parse schema string like "++id,name,*tags"\r\n    const parts = schema.split(",").map((s) => s.trim());\r\n    const primKey = this.parsePrimaryKey(parts[0]);\r\n    const indexes = this.parseIndexes(parts.slice(1));\r\n\r\n    this._cfg.dbschema[tableName] = {\r\n      primKey,\r\n      indexes,\r\n      mappedClass: null,\r\n    };\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"bulk-operations-optimization",children:"Bulk Operations Optimization"}),"\n",(0,s.jsx)(r.p,{children:"Dexie implements sophisticated bulk operations that significantly outperform individual operations:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"// Dexie's bulk add implementation (conceptual)\r\nclass Table {\r\n  async bulkAdd(objects, keys) {\r\n    const trans = getCurrentTransaction();\r\n    const store = trans.objectStore(this.name);\r\n\r\n    // Use browser's native bulk capabilities when available\r\n    if (store.addAll) {\r\n      return await this.nativeBulkAdd(store, objects, keys);\r\n    }\r\n\r\n    // Fallback to optimized batch processing\r\n    return await this.batchAdd(store, objects, keys);\r\n  }\r\n\r\n  async batchAdd(store, objects, keys) {\r\n    const batchSize = 100; // Optimal batch size\r\n    const results = [];\r\n\r\n    for (let i = 0; i < objects.length; i += batchSize) {\r\n      const batch = objects.slice(i, i + batchSize);\r\n      const batchKeys = keys ? keys.slice(i, i + batchSize) : undefined;\r\n\r\n      const batchResults = await Promise.all(\r\n        batch.map((obj, idx) => {\r\n          const key = batchKeys ? batchKeys[idx] : undefined;\r\n          return this.promisifyRequest(store.add(obj, key));\r\n        })\r\n      );\r\n\r\n      results.push(...batchResults);\r\n    }\r\n\r\n    return results;\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(r.h3,{id:"error-handling-and-recovery",children:"Error Handling and Recovery"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Dexie\'s error handling system\r\nclass DexieError extends Error {\r\n  constructor(name, message) {\r\n    super(message);\r\n    this.name = name;\r\n  }\r\n}\r\n\r\n// Specific error types\r\nclass QuotaExceededError extends DexieError {\r\n  constructor() {\r\n    super("QuotaExceededError", "Storage quota exceeded");\r\n  }\r\n}\r\n\r\nclass TransactionInactiveError extends DexieError {\r\n  constructor() {\r\n    super("TransactionInactiveError", "Transaction is no longer active");\r\n  }\r\n}\r\n\r\n// Error recovery mechanisms\r\nclass ErrorRecovery {\r\n  static async handleQuotaExceeded(operation) {\r\n    // Attempt to free up space\r\n    await this.cleanupExpiredData();\r\n\r\n    // Retry operation\r\n    try {\r\n      return await operation();\r\n    } catch (error) {\r\n      if (error.name === "QuotaExceededError") {\r\n        throw new Error("Storage quota exceeded even after cleanup");\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(r.h3,{id:"indexing-strategies",children:"Indexing Strategies"}),"\n",(0,s.jsx)(r.p,{children:"Proper indexing is the foundation of IndexedDB performance. Understanding how to design indexes for your query patterns can mean the difference between millisecond and second response times, especially with large datasets."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What this code demonstrates:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Strategic index design for different query patterns"}),"\n",(0,s.jsx)(r.li,{children:"Compound indexes for multi-column queries"}),"\n",(0,s.jsx)(r.li,{children:"Multientry indexes for array-based searches"}),"\n",(0,s.jsx)(r.li,{children:"Index reuse for optimal performance"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Index Design Principles:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Query-First Design"})," - Design indexes based on your most common queries"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Compound Indexes"})," - Combine frequently queried columns"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Selectivity"})," - More selective (unique) columns should come first"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Array Support"})," - Use multientry indexes for array properties"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Avoid Over-Indexing"})," - Each index has storage and update costs"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Performance Impact:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"With Proper Index"}),": O(log n) lookup time"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Without Index"}),": O(n) scan time"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Storage Overhead"}),": ~20-30% per index"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Write Performance"}),": Slight decrease per additional index"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Input:"})," Schema definition with strategic index placement\r\n",(0,s.jsx)(r.strong,{children:"Output:"})," Optimized query performance for common use cases\r\n",(0,s.jsx)(r.strong,{children:"Use case:"})," High-performance applications with complex query requirements"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Optimal indexing for different query patterns\r\n// Each index is designed for specific query scenarios\r\nconst db = new Dexie("PerformanceDB");\r\ndb.version(1).stores({\r\n  // Compound index for multi-column queries\r\n  // Order matters: most selective column first\r\n  orders:\r\n    "++id, " + // Primary key with auto-increment\r\n    "[customerId+status], " + // Compound: filter by customer AND status\r\n    "[createdAt+status], " + // Compound: date range AND status\r\n    "customerId, " + // Single: customer-specific queries\r\n    "status, " + // Single: status-based queries\r\n    "createdAt", // Single: date range queries\r\n\r\n  // Multientry index for array properties\r\n  // The * prefix creates a multientry index\r\n  products:\r\n    "++id, " + // Primary key\r\n    "name, " + // Text search by product name\r\n    "*tags, " + // Multientry: search within tag arrays\r\n    "categoryId, " + // Category-based filtering\r\n    "[categoryId+price], " + // Category with price range\r\n    "price", // Price-based sorting/filtering\r\n\r\n  // Indexes optimized for user search and authentication\r\n  users:\r\n    "++id, " + // Primary key\r\n    "email, " + // Unique login identifier\r\n    "[lastName+firstName], " + // Full name searches\r\n    "lastActiveAt, " + // Activity-based queries\r\n    "registrationDate", // Registration cohort analysis\r\n});\r\n\r\n// Query optimization examples demonstrating index usage\r\nasync function optimizedQueries() {\r\n  console.time("Query Performance Test");\r\n\r\n  // 1. Compound index usage: [customerId+status]\r\n  // This query uses the compound index for O(log n) performance\r\n  const activeOrders = await db.orders\r\n    .where(["customerId", "status"]) // Uses compound index\r\n    .equals([123, "active"]) // Exact match on both columns\r\n    .toArray();\r\n  console.log(`Found ${activeOrders.length} active orders for customer 123`);\r\n\r\n  // 2. Multientry index usage: *tags\r\n  // Efficiently finds products with any of the specified tags\r\n  const taggedProducts = await db.products\r\n    .where("tags") // Uses multientry index\r\n    .anyOf(["electronics", "gadgets"]) // Searches within array values\r\n    .toArray();\r\n  console.log(`Found ${taggedProducts.length} products with specified tags`);\r\n\r\n  // 3. Range query with single index: createdAt\r\n  // Uses btree index for efficient range scanning\r\n  const recentOrders = await db.orders\r\n    .where("createdAt") // Uses createdAt index\r\n    .above(Date.now() - 86400000) // Range query: last 24 hours\r\n    .toArray();\r\n  console.log(`Found ${recentOrders.length} orders in last 24 hours`);\r\n\r\n  // 4. Complex query with compound index optimization\r\n  const expensiveRecentOrders = await db.orders\r\n    .where(["createdAt", "status"]) // Uses [createdAt+status] compound index\r\n    .between(\r\n      [Date.now() - 604800000, "confirmed"], // Last week, confirmed status\r\n      [Date.now(), "delivered"] // Now, delivered status\r\n    )\r\n    .and((order) => order.total > 500) // Additional filter (post-index)\r\n    .toArray();\r\n\r\n  // 5. User search with name compound index\r\n  const usersByName = await db.users\r\n    .where(["lastName", "firstName"]) // Uses compound name index\r\n    .between(["Smith", "A"], ["Smith", "Z"]) // All Smiths with first name A-Z\r\n    .toArray();\r\n\r\n  console.timeEnd("Query Performance Test");\r\n}\r\n\r\n// Performance monitoring for index effectiveness\r\nasync function analyzeQueryPerformance() {\r\n  const startTime = performance.now();\r\n\r\n  // Query that benefits from indexing\r\n  const indexedQuery = await db.orders.where("customerId").equals(123).count();\r\n\r\n  const indexedTime = performance.now() - startTime;\r\n\r\n  // Equivalent query without index (table scan)\r\n  const scanStart = performance.now();\r\n  const scanQuery = await db.orders\r\n    .filter((order) => order.customerId === 123)\r\n    .count();\r\n\r\n  const scanTime = performance.now() - scanStart;\r\n\r\n  console.log(`Indexed query: ${indexedTime.toFixed(2)}ms`);\r\n  console.log(`Table scan: ${scanTime.toFixed(2)}ms`);\r\n  console.log(\r\n    `Performance improvement: ${(scanTime / indexedTime).toFixed(1)}x faster`\r\n  );\r\n}\r\n\r\n// Index maintenance and optimization tips\r\nconst indexOptimizationTips = {\r\n  // 1. Monitor index usage\r\n  monitorIndexUsage: async () => {\r\n    // Use browser dev tools to monitor which indexes are used\r\n    // Look for "index not found" warnings in console\r\n  },\r\n\r\n  // 2. Avoid redundant indexes\r\n  avoidRedundancy: () => {\r\n    // If you have [a, b] compound index, you don\'t need separate [a] index\r\n    // The compound index can serve single-column queries on \'a\'\r\n  },\r\n\r\n  // 3. Consider query frequency\r\n  designForFrequency: () => {\r\n    // Index the most frequently used query patterns first\r\n    // Less common queries can use table scans if necessary\r\n  },\r\n\r\n  // 4. Update performance impact\r\n  updateCosts: () => {\r\n    // Each index must be updated on every record modification\r\n    // Balance query performance vs. write performance\r\n  },\r\n};\n'})}),"\n",(0,s.jsx)(r.h3,{id:"memory-management-1",children:"Memory Management"}),"\n",(0,s.jsx)(r.p,{children:"Memory management is crucial when working with large datasets in IndexedDB. Poor memory management can lead to browser crashes, especially on mobile devices with limited RAM. These patterns help you process large amounts of data efficiently."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What this code demonstrates:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Streaming data processing to avoid memory exhaustion"}),"\n",(0,s.jsx)(r.li,{children:"Pagination techniques for handling large result sets"}),"\n",(0,s.jsx)(r.li,{children:"Memory-efficient batch processing strategies"}),"\n",(0,s.jsx)(r.li,{children:"Progress tracking for long-running operations"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Memory Management Strategies:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Stream Processing"})," - Process one record at a time using ",(0,s.jsx)(r.code,{children:".each()"})]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Pagination"})," - Break large queries into smaller chunks"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Batch Processing"})," - Process data in manageable batches"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Memory Monitoring"})," - Track and limit memory usage"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Garbage Collection"})," - Allow browser to clean up between batches"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Performance Benefits:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Prevents OOM"}),": Avoids out-of-memory crashes"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Better UX"}),": Allows progress reporting and cancellation"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Mobile Friendly"}),": Works on low-memory devices"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Responsive UI"}),": Doesn't block the main thread"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Input:"})," Large datasets that exceed available memory\r\n",(0,s.jsx)(r.strong,{children:"Output:"})," Processed data without memory issues\r\n",(0,s.jsx)(r.strong,{children:"Use case:"})," Data migration, analytics, bulk operations"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Efficient large dataset processing\r\n// Prevents memory exhaustion when handling millions of records\r\nasync function processLargeDataset() {\r\n  let processed = 0;\r\n  let startTime = Date.now();\r\n\r\n  // Use .each() for memory-efficient streaming\r\n  // Only one record is in memory at a time\r\n  await db.largeTable.each((record) => {\r\n    // Process each record individually\r\n    // This could be data transformation, validation, etc.\r\n    processRecord(record);\r\n    processed++;\r\n\r\n    // Progress reporting every 1000 records\r\n    if (processed % 1000 === 0) {\r\n      const elapsed = Date.now() - startTime;\r\n      const rate = (processed / elapsed) * 1000; // records per second\r\n      console.log(\r\n        `Processed ${processed} records (${rate.toFixed(0)} rec/sec)`\r\n      );\r\n\r\n      // Optional: Allow UI updates and garbage collection\r\n      // return new Promise(resolve => setTimeout(resolve, 0));\r\n    }\r\n  });\r\n\r\n  console.log(`Total processing completed: ${processed} records`);\r\n}\r\n\r\n// Advanced streaming with memory monitoring\r\nasync function streamWithMemoryMonitoring() {\r\n  let processed = 0;\r\n  const batchSize = 1000;\r\n\r\n  await db.largeTable.each(async (record) => {\r\n    await processRecord(record);\r\n    processed++;\r\n\r\n    // Monitor memory usage every batch\r\n    if (processed % batchSize === 0) {\r\n      // Check memory usage if available\r\n      if ("memory" in performance && performance.memory.usedJSHeapSize) {\r\n        const memoryMB = performance.memory.usedJSHeapSize / (1024 * 1024);\r\n        console.log(`Memory usage: ${memoryMB.toFixed(1)}MB`);\r\n\r\n        // Force garbage collection if memory usage is high\r\n        if (memoryMB > 100) {\r\n          // 100MB threshold\r\n          console.log("High memory usage detected, yielding to GC");\r\n          await new Promise((resolve) => setTimeout(resolve, 10));\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n// Pagination for large result sets\r\n// Handles datasets too large to load into memory at once\r\nasync function paginatedQuery(pageSize = 100) {\r\n  let lastKey = null;\r\n  let hasMore = true;\r\n  let totalProcessed = 0;\r\n\r\n  while (hasMore) {\r\n    console.log(`Processing page starting from key: ${lastKey || "beginning"}`);\r\n\r\n    // Build query with pagination\r\n    const query = db.table.orderBy("id");\r\n\r\n    if (lastKey) {\r\n      // Continue from where we left off (exclusive)\r\n      query.where("id").above(lastKey);\r\n    }\r\n\r\n    // Fetch next page\r\n    const results = await query.limit(pageSize).toArray();\r\n\r\n    // Check if we have more data\r\n    if (results.length < pageSize) {\r\n      hasMore = false;\r\n      console.log("Reached end of dataset");\r\n    } else {\r\n      // Update cursor for next iteration\r\n      lastKey = results[results.length - 1].id;\r\n    }\r\n\r\n    // Process current page\r\n    if (results.length > 0) {\r\n      await processBatch(results);\r\n      totalProcessed += results.length;\r\n\r\n      console.log(\r\n        `Processed batch: ${results.length} records, total: ${totalProcessed}`\r\n      );\r\n\r\n      // Optional: yield to event loop between batches\r\n      await new Promise((resolve) => setTimeout(resolve, 0));\r\n    }\r\n  }\r\n\r\n  return totalProcessed;\r\n}\r\n\r\n// Memory-efficient bulk operations\r\nclass BulkProcessor {\r\n  constructor(db, batchSize = 1000) {\r\n    this.db = db;\r\n    this.batchSize = batchSize;\r\n    this.stats = {\r\n      processed: 0,\r\n      errors: 0,\r\n      startTime: Date.now(),\r\n    };\r\n  }\r\n\r\n  // Process records in batches to manage memory\r\n  async processBatches(tableName, processFn, filterFn = null) {\r\n    const table = this.db[tableName];\r\n\r\n    await table.each(async (record, cursor) => {\r\n      try {\r\n        // Apply filter if provided\r\n        if (filterFn && !filterFn(record)) {\r\n          return; // Skip this record\r\n        }\r\n\r\n        // Process the record\r\n        await processFn(record);\r\n        this.stats.processed++;\r\n\r\n        // Batch boundary - check memory and yield\r\n        if (this.stats.processed % this.batchSize === 0) {\r\n          await this.handleBatchComplete();\r\n        }\r\n      } catch (error) {\r\n        this.stats.errors++;\r\n        console.error(`Error processing record ${cursor.key}:`, error);\r\n      }\r\n    });\r\n\r\n    // Final statistics\r\n    this.logFinalStats();\r\n  }\r\n\r\n  async handleBatchComplete() {\r\n    const elapsed = Date.now() - this.stats.startTime;\r\n    const rate = (this.stats.processed / elapsed) * 1000;\r\n\r\n    console.log(\r\n      `Batch complete: ${this.stats.processed} processed, ` +\r\n        `${this.stats.errors} errors, ${rate.toFixed(0)} rec/sec`\r\n    );\r\n\r\n    // Yield to allow UI updates and garbage collection\r\n    await new Promise((resolve) => setTimeout(resolve, 1));\r\n  }\r\n\r\n  logFinalStats() {\r\n    const elapsed = Date.now() - this.stats.startTime;\r\n    const rate = (this.stats.processed / elapsed) * 1000;\r\n\r\n    console.log(`Bulk processing complete:\r\n      Total processed: ${this.stats.processed}\r\n      Total errors: ${this.stats.errors}\r\n      Total time: ${(elapsed / 1000).toFixed(1)}s\r\n      Average rate: ${rate.toFixed(0)} records/second`);\r\n  }\r\n}\r\n\r\n// Example usage of bulk processor\r\nasync function runBulkDataMigration() {\r\n  const processor = new BulkProcessor(db, 500); // 500 records per batch\r\n\r\n  await processor.processBatches(\r\n    "oldTable",\r\n    async (record) => {\r\n      // Transform and migrate each record\r\n      const transformed = {\r\n        id: record.id,\r\n        newField: record.oldField?.toUpperCase(),\r\n        migrationDate: new Date(),\r\n      };\r\n\r\n      await db.newTable.put(transformed);\r\n    },\r\n    (record) => record.shouldMigrate === true // Only migrate flagged records\r\n  );\r\n}\r\n\r\n// Memory-efficient aggregation\r\nasync function calculateAggregatesEfficiently() {\r\n  let totals = {\r\n    count: 0,\r\n    sum: 0,\r\n    min: Infinity,\r\n    max: -Infinity,\r\n  };\r\n\r\n  // Stream through all records without loading into memory\r\n  await db.orders.each((order) => {\r\n    totals.count++;\r\n    totals.sum += order.total;\r\n    totals.min = Math.min(totals.min, order.total);\r\n    totals.max = Math.max(totals.max, order.total);\r\n  });\r\n\r\n  return {\r\n    count: totals.count,\r\n    sum: totals.sum,\r\n    average: totals.sum / totals.count,\r\n    min: totals.min,\r\n    max: totals.max,\r\n  };\r\n}\r\n\r\n// Helper functions\r\nfunction processRecord(record) {\r\n  // Simulate record processing\r\n  // This could be validation, transformation, or computation\r\n  return {\r\n    ...record,\r\n    processedAt: new Date(),\r\n    processed: true,\r\n  };\r\n}\r\n\r\nasync function processBatch(records) {\r\n  // Simulate batch processing\r\n  console.log(`Processing batch of ${records.length} records`);\r\n\r\n  // Could be bulk updates, external API calls, etc.\r\n  for (const record of records) {\r\n    processRecord(record);\r\n  }\r\n\r\n  // Simulate async work\r\n  await new Promise((resolve) => setTimeout(resolve, 10));\r\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"advanced-features-and-patterns",children:"Advanced Features and Patterns"}),"\n",(0,s.jsx)(r.h3,{id:"live-queries-with-dexie-react-hooks",children:"Live Queries with dexie-react-hooks"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Real-time data synchronization\r\nimport { useLiveQuery } from "dexie-react-hooks";\r\n\r\nfunction UserList() {\r\n  // Automatically re-runs when data changes\r\n  const users = useLiveQuery(() =>\r\n    db.users.where("isActive").equals(true).sortBy("name")\r\n  );\r\n\r\n  if (!users) return <div>Loading...</div>;\r\n\r\n  return (\r\n    <ul>\r\n      {users.map((user) => (\r\n        <li key={user.id}>{user.name}</li>\r\n      ))}\r\n    </ul>\r\n  );\r\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"database-synchronization-patterns",children:"Database Synchronization Patterns"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Offline-first sync pattern\r\nclass SyncManager {\r\n  constructor(db, apiClient) {\r\n    this.db = db;\r\n    this.api = apiClient;\r\n    this.syncQueue = [];\r\n  }\r\n\r\n  async syncToServer() {\r\n    // Get pending changes\r\n    const pendingChanges = await this.db.syncLog\r\n      .where("synced")\r\n      .equals(false)\r\n      .toArray();\r\n\r\n    for (const change of pendingChanges) {\r\n      try {\r\n        await this.applySyncChange(change);\r\n        await this.db.syncLog.update(change.id, { synced: true });\r\n      } catch (error) {\r\n        console.error("Sync failed for change:", change.id, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  async applySyncChange(change) {\r\n    switch (change.operation) {\r\n      case "create":\r\n        await this.api.create(change.table, change.data);\r\n        break;\r\n      case "update":\r\n        await this.api.update(change.table, change.id, change.data);\r\n        break;\r\n      case "delete":\r\n        await this.api.delete(change.table, change.id);\r\n        break;\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"custom-middleware-and-hooks",children:"Custom Middleware and Hooks"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Dexie middleware for logging and validation\r\ndb.use({\r\n  name: "LoggingMiddleware",\r\n  create: function (down, ctx, table) {\r\n    return function (data) {\r\n      console.log(`Creating record in ${table}:`, data);\r\n      return down.create.call(this, data);\r\n    };\r\n  },\r\n  read: function (down, ctx, table) {\r\n    return function (key) {\r\n      console.log(`Reading from ${table} with key:`, key);\r\n      return down.read.call(this, key);\r\n    };\r\n  },\r\n  update: function (down, ctx, table) {\r\n    return function (data) {\r\n      console.log(`Updating record in ${table}:`, data);\r\n      return down.update.call(this, data);\r\n    };\r\n  },\r\n  delete: function (down, ctx, table) {\r\n    return function (key) {\r\n      console.log(`Deleting from ${table} with key:`, key);\r\n      return down.delete.call(this, key);\r\n    };\r\n  },\r\n});\n'})}),"\n",(0,s.jsx)(r.h2,{id:"real-world-implementation-examples",children:"Real-World Implementation Examples"}),"\n",(0,s.jsx)(r.h3,{id:"e-commerce-application",children:"E-commerce Application"}),"\n",(0,s.jsx)(r.p,{children:"This comprehensive e-commerce implementation demonstrates how to build a robust offline-capable shopping system using Dexie.js. The application handles complex business logic including inventory management, cart persistence, and atomic transaction processing."}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"What this implementation demonstrates:"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Multi-table relational data modeling in IndexedDB"}),"\n",(0,s.jsx)(r.li,{children:"Complex business transactions with ACID properties"}),"\n",(0,s.jsx)(r.li,{children:"Shopping cart persistence across browser sessions"}),"\n",(0,s.jsx)(r.li,{children:"Inventory tracking and product catalog management"}),"\n",(0,s.jsx)(r.li,{children:"Order processing with referential integrity"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Application Architecture:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Product Catalog"})," - Hierarchical categories with tagging system"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Shopping Cart"})," - Persistent cart with quantity management"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Order System"})," - Multi-table transactions for order creation"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Inventory Management"})," - Stock tracking with optimistic updates"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Customer Management"})," - User sessions and order history"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Data Flow:"})}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Browse Products"})," - Query by category, tags, or search terms"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Add to Cart"})," - Update quantities or create new cart items"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Calculate Totals"})," - Join cart items with current product prices"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Checkout Process"})," - Atomic transaction across multiple tables"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Order Fulfillment"})," - Update inventory and create order records"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Input:"})," User interactions (browse, add to cart, checkout)\r\n",(0,s.jsx)(r.strong,{children:"Output:"})," Persistent shopping experience with data integrity\r\n",(0,s.jsx)(r.strong,{children:"Use case:"})," E-commerce PWAs, offline shopping applications"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// E-commerce database schema\r\n// Designed for complex queries and referential integrity\r\nconst ecommerceDB = new Dexie("EcommerceApp");\r\necommerceDB.version(1).stores({\r\n  // Products with multi-criteria search capabilities\r\n  products:\r\n    "++id, " + // Auto-increment primary key\r\n    "name, " + // Product name search\r\n    "price, " + // Price range queries\r\n    "categoryId, " + // Category filtering\r\n    "*tags, " + // Multi-entry tag search\r\n    "inStock, " + // Availability filtering\r\n    "[categoryId+price], " + // Category + price range\r\n    "[inStock+categoryId]", // Available products by category\r\n\r\n  // Hierarchical category structure\r\n  categories:\r\n    "++id, " + // Category ID\r\n    "name, " + // Category name\r\n    "parentId, " + // Parent category (for hierarchy)\r\n    "sortOrder", // Display ordering\r\n\r\n  // Persistent shopping cart\r\n  cart:\r\n    "++id, " + // Cart item ID\r\n    "productId, " + // Product reference (indexed for fast lookup)\r\n    "quantity, " + // Item quantity\r\n    "addedAt", // Timestamp for cart cleanup\r\n\r\n  // Order management\r\n  orders:\r\n    "++id, " + // Order ID\r\n    "customerId, " + // Customer reference\r\n    "status, " + // Order status (pending, confirmed, shipped, etc.)\r\n    "total, " + // Order total amount\r\n    "createdAt, " + // Order timestamp\r\n    "[customerId+status], " + // Customer orders by status\r\n    "[createdAt+status]", // Time-based status queries\r\n\r\n  // Order line items (normalized design)\r\n  orderItems:\r\n    "++id, " + // Line item ID\r\n    "orderId, " + // Order reference\r\n    "productId, " + // Product reference\r\n    "quantity, " + // Ordered quantity\r\n    "price", // Price at time of order (price history)\r\n});\r\n\r\n// Shopping cart implementation with advanced features\r\nclass ShoppingCart {\r\n  constructor() {\r\n    this.cache = new Map(); // In-memory cache for performance\r\n  }\r\n\r\n  // Add item to cart with duplicate handling\r\n  async addItem(productId, quantity = 1) {\r\n    try {\r\n      // Validate product exists and is in stock\r\n      const product = await ecommerceDB.products.get(productId);\r\n      if (!product) {\r\n        throw new Error(`Product ${productId} not found`);\r\n      }\r\n      if (!product.inStock) {\r\n        throw new Error(`Product ${product.name} is out of stock`);\r\n      }\r\n\r\n      // Check for existing cart item\r\n      const existingItem = await ecommerceDB.cart\r\n        .where("productId")\r\n        .equals(productId)\r\n        .first();\r\n\r\n      if (existingItem) {\r\n        // Update existing item quantity\r\n        const newQuantity = existingItem.quantity + quantity;\r\n        await ecommerceDB.cart.update(existingItem.id, {\r\n          quantity: newQuantity,\r\n          addedAt: new Date(), // Update timestamp for recent activity\r\n        });\r\n\r\n        console.log(\r\n          `Updated cart: Product ${productId} quantity now ${newQuantity}`\r\n        );\r\n        return existingItem.id;\r\n      } else {\r\n        // Add new cart item\r\n        const cartItemId = await ecommerceDB.cart.add({\r\n          productId,\r\n          quantity,\r\n          addedAt: new Date(),\r\n        });\r\n\r\n        console.log(`Added to cart: Product ${productId} x${quantity}`);\r\n        return cartItemId;\r\n      }\r\n    } catch (error) {\r\n      console.error("Failed to add item to cart:", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Calculate cart total with current prices\r\n  async getCartTotal() {\r\n    try {\r\n      const cartItems = await ecommerceDB.cart.toArray();\r\n      let total = 0;\r\n      let itemCount = 0;\r\n\r\n      // Use transaction for consistent price calculation\r\n      await ecommerceDB.transaction(\r\n        "r",\r\n        [ecommerceDB.cart, ecommerceDB.products],\r\n        async () => {\r\n          for (const item of cartItems) {\r\n            const product = await ecommerceDB.products.get(item.productId);\r\n\r\n            if (product) {\r\n              total += product.price * item.quantity;\r\n              itemCount += item.quantity;\r\n            } else {\r\n              // Handle deleted products\r\n              console.warn(\r\n                `Product ${item.productId} no longer exists, removing from cart`\r\n              );\r\n              await ecommerceDB.cart.delete(item.id);\r\n            }\r\n          }\r\n        }\r\n      );\r\n\r\n      return {\r\n        total: parseFloat(total.toFixed(2)),\r\n        itemCount,\r\n        items: cartItems.length,\r\n      };\r\n    } catch (error) {\r\n      console.error("Failed to calculate cart total:", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Get detailed cart contents with product information\r\n  async getCartDetails() {\r\n    const cartItems = await ecommerceDB.cart\r\n      .orderBy("addedAt")\r\n      .reverse()\r\n      .toArray();\r\n    const cartDetails = [];\r\n\r\n    for (const item of cartItems) {\r\n      const product = await ecommerceDB.products.get(item.productId);\r\n\r\n      if (product) {\r\n        cartDetails.push({\r\n          cartItemId: item.id,\r\n          productId: item.productId,\r\n          productName: product.name,\r\n          price: product.price,\r\n          quantity: item.quantity,\r\n          subtotal: product.price * item.quantity,\r\n          addedAt: item.addedAt,\r\n          inStock: product.inStock,\r\n        });\r\n      }\r\n    }\r\n\r\n    return cartDetails;\r\n  }\r\n\r\n  // Remove item from cart\r\n  async removeItem(productId) {\r\n    const deletedCount = await ecommerceDB.cart\r\n      .where("productId")\r\n      .equals(productId)\r\n      .delete();\r\n\r\n    console.log(`Removed ${deletedCount} items from cart`);\r\n    return deletedCount > 0;\r\n  }\r\n\r\n  // Update item quantity\r\n  async updateQuantity(productId, newQuantity) {\r\n    if (newQuantity <= 0) {\r\n      return await this.removeItem(productId);\r\n    }\r\n\r\n    const updateCount = await ecommerceDB.cart\r\n      .where("productId")\r\n      .equals(productId)\r\n      .modify({ quantity: newQuantity, addedAt: new Date() });\r\n\r\n    return updateCount > 0;\r\n  }\r\n\r\n  // Complete checkout process with atomic transaction\r\n  async checkout(customerId) {\r\n    try {\r\n      // Validate customer and cart\r\n      if (!customerId) {\r\n        throw new Error("Customer ID required for checkout");\r\n      }\r\n\r\n      const cartItems = await ecommerceDB.cart.toArray();\r\n      if (cartItems.length === 0) {\r\n        throw new Error("Cart is empty");\r\n      }\r\n\r\n      // Execute atomic checkout transaction\r\n      const orderId = await ecommerceDB.transaction(\r\n        "rw",\r\n        [\r\n          ecommerceDB.cart,\r\n          ecommerceDB.orders,\r\n          ecommerceDB.orderItems,\r\n          ecommerceDB.products,\r\n        ],\r\n        async () => {\r\n          // Calculate final total within transaction for consistency\r\n          const cartTotal = await this.getCartTotal();\r\n\r\n          // Validate inventory availability\r\n          for (const item of cartItems) {\r\n            const product = await ecommerceDB.products.get(item.productId);\r\n            if (!product || !product.inStock) {\r\n              throw new Error(\r\n                `Product ${item.productId} is no longer available`\r\n              );\r\n            }\r\n          }\r\n\r\n          // Create order record\r\n          const orderId = await ecommerceDB.orders.add({\r\n            customerId,\r\n            status: "pending",\r\n            total: cartTotal.total,\r\n            createdAt: new Date(),\r\n            itemCount: cartTotal.itemCount,\r\n          });\r\n\r\n          console.log(`Created order ${orderId} for customer ${customerId}`);\r\n\r\n          // Create order items with price at time of purchase\r\n          for (const item of cartItems) {\r\n            const product = await ecommerceDB.products.get(item.productId);\r\n\r\n            await ecommerceDB.orderItems.add({\r\n              orderId,\r\n              productId: item.productId,\r\n              quantity: item.quantity,\r\n              price: product.price, // Lock in current price\r\n              productName: product.name, // Denormalize for order history\r\n            });\r\n\r\n            // Optional: Update inventory (if tracking stock levels)\r\n            // await ecommerceDB.products.update(item.productId, {\r\n            //   stockLevel: product.stockLevel - item.quantity\r\n            // });\r\n          }\r\n\r\n          // Clear the cart after successful order creation\r\n          await ecommerceDB.cart.clear();\r\n\r\n          console.log(\r\n            `Checkout completed: Order ${orderId}, Total: $${cartTotal.total}`\r\n          );\r\n          return orderId;\r\n        }\r\n      );\r\n\r\n      return {\r\n        orderId,\r\n        success: true,\r\n        message: "Order placed successfully",\r\n      };\r\n    } catch (error) {\r\n      console.error("Checkout failed:", error);\r\n      return {\r\n        orderId: null,\r\n        success: false,\r\n        message: error.message,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Clear entire cart\r\n  async clearCart() {\r\n    const count = await ecommerceDB.cart.clear();\r\n    console.log(`Cleared ${count} items from cart`);\r\n    return count;\r\n  }\r\n}\r\n\r\n// Product catalog management\r\nclass ProductCatalog {\r\n  // Search products with multiple criteria\r\n  async searchProducts(criteria = {}) {\r\n    const {\r\n      categoryId,\r\n      tags = [],\r\n      priceMin,\r\n      priceMax,\r\n      inStockOnly = true,\r\n      searchTerm,\r\n      limit = 50,\r\n    } = criteria;\r\n\r\n    let query = ecommerceDB.products.toCollection();\r\n\r\n    // Apply category filter\r\n    if (categoryId) {\r\n      query = ecommerceDB.products.where("categoryId").equals(categoryId);\r\n    }\r\n\r\n    // Apply stock filter\r\n    if (inStockOnly) {\r\n      query = query.and((product) => product.inStock);\r\n    }\r\n\r\n    // Apply price range filter\r\n    if (priceMin !== undefined || priceMax !== undefined) {\r\n      query = query.and((product) => {\r\n        const price = product.price;\r\n        return (\r\n          (priceMin === undefined || price >= priceMin) &&\r\n          (priceMax === undefined || price <= priceMax)\r\n        );\r\n      });\r\n    }\r\n\r\n    // Apply tag filter\r\n    if (tags.length > 0) {\r\n      query = query.and(\r\n        (product) =>\r\n          product.tags && tags.some((tag) => product.tags.includes(tag))\r\n      );\r\n    }\r\n\r\n    // Apply text search\r\n    if (searchTerm) {\r\n      const searchLower = searchTerm.toLowerCase();\r\n      query = query.and((product) =>\r\n        product.name.toLowerCase().includes(searchLower)\r\n      );\r\n    }\r\n\r\n    // Execute query with limit\r\n    const results = await query.limit(limit).toArray();\r\n    return results;\r\n  }\r\n\r\n  // Get product hierarchy for navigation\r\n  async getCategoryHierarchy() {\r\n    const categories = await ecommerceDB.categories\r\n      .orderBy("sortOrder")\r\n      .toArray();\r\n\r\n    // Build hierarchy tree\r\n    const categoryMap = new Map();\r\n    const rootCategories = [];\r\n\r\n    // First pass: create category objects\r\n    categories.forEach((cat) => {\r\n      categoryMap.set(cat.id, { ...cat, children: [] });\r\n    });\r\n\r\n    // Second pass: build parent-child relationships\r\n    categories.forEach((cat) => {\r\n      if (cat.parentId) {\r\n        const parent = categoryMap.get(cat.parentId);\r\n        if (parent) {\r\n          parent.children.push(categoryMap.get(cat.id));\r\n        }\r\n      } else {\r\n        rootCategories.push(categoryMap.get(cat.id));\r\n      }\r\n    });\r\n\r\n    return rootCategories;\r\n  }\r\n}\r\n\r\n// Usage example\r\nasync function demonstrateEcommerce() {\r\n  const cart = new ShoppingCart();\r\n  const catalog = new ProductCatalog();\r\n\r\n  // Add products to cart\r\n  await cart.addItem(1, 2); // Product ID 1, quantity 2\r\n  await cart.addItem(3, 1); // Product ID 3, quantity 1\r\n\r\n  // Get cart details\r\n  const cartDetails = await cart.getCartDetails();\r\n  console.log("Cart contents:", cartDetails);\r\n\r\n  // Calculate total\r\n  const total = await cart.getCartTotal();\r\n  console.log(`Cart total: $${total.total} (${total.itemCount} items)`);\r\n\r\n  // Search products\r\n  const searchResults = await catalog.searchProducts({\r\n    categoryId: 1,\r\n    priceMin: 10,\r\n    priceMax: 100,\r\n    tags: ["electronics"],\r\n    inStockOnly: true,\r\n  });\r\n\r\n  // Complete checkout\r\n  const checkoutResult = await cart.checkout("customer123");\r\n  if (checkoutResult.success) {\r\n    console.log(`Order placed: ${checkoutResult.orderId}`);\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"collaborative-document-editor",children:"Collaborative Document Editor"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Document editor with operational transformation\r\nconst docDB = new Dexie("DocumentEditor");\r\ndocDB.version(1).stores({\r\n  documents: "++id, title, content, lastModified, version",\r\n  operations: "++id, documentId, type, position, content, timestamp, userId",\r\n  conflicts: "++id, documentId, operationId, resolvedAt",\r\n});\r\n\r\nclass OperationalTransform {\r\n  async applyOperation(docId, operation) {\r\n    return await docDB.transaction(\r\n      "rw",\r\n      docDB.documents,\r\n      docDB.operations,\r\n      async () => {\r\n        // Get current document state\r\n        const doc = await docDB.documents.get(docId);\r\n\r\n        // Get all operations after this operation\'s base version\r\n        const laterOps = await docDB.operations\r\n          .where("documentId")\r\n          .equals(docId)\r\n          .and((op) => op.timestamp > operation.baseTimestamp)\r\n          .sortBy("timestamp");\r\n\r\n        // Transform operation against later operations\r\n        const transformedOp = this.transform(operation, laterOps);\r\n\r\n        // Apply transformed operation to document\r\n        const newContent = this.applyToContent(doc.content, transformedOp);\r\n\r\n        // Update document\r\n        await docDB.documents.update(docId, {\r\n          content: newContent,\r\n          lastModified: new Date(),\r\n          version: doc.version + 1,\r\n        });\r\n\r\n        // Store operation in log\r\n        await docDB.operations.add({\r\n          ...transformedOp,\r\n          documentId: docId,\r\n          timestamp: new Date(),\r\n        });\r\n      }\r\n    );\r\n  }\r\n\r\n  transform(operation, laterOperations) {\r\n    let transformedOp = { ...operation };\r\n\r\n    for (const laterOp of laterOperations) {\r\n      transformedOp = this.transformPair(transformedOp, laterOp);\r\n    }\r\n\r\n    return transformedOp;\r\n  }\r\n\r\n  transformPair(op1, op2) {\r\n    // Implement operational transformation logic\r\n    // This is a simplified version\r\n    if (op1.type === "insert" && op2.type === "insert") {\r\n      if (op2.position <= op1.position) {\r\n        return { ...op1, position: op1.position + op2.content.length };\r\n      }\r\n    }\r\n\r\n    return op1;\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"debugging-and-development-tools",children:"Debugging and Development Tools"}),"\n",(0,s.jsx)(r.h3,{id:"database-inspection-tools",children:"Database Inspection Tools"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Development utilities for debugging\r\nclass DexieDebugger {\r\n  static async inspectDatabase(db) {\r\n    console.group("Database Inspection");\r\n\r\n    // List all tables\r\n    const tables = db.tables.map((table) => table.name);\r\n    console.log("Tables:", tables);\r\n\r\n    // Count records in each table\r\n    for (const tableName of tables) {\r\n      const count = await db.table(tableName).count();\r\n      console.log(`${tableName}: ${count} records`);\r\n    }\r\n\r\n    // Check storage usage\r\n    if (navigator.storage && navigator.storage.estimate) {\r\n      const estimate = await navigator.storage.estimate();\r\n      console.log("Storage estimate:", estimate);\r\n    }\r\n\r\n    console.groupEnd();\r\n  }\r\n\r\n  static async exportData(db) {\r\n    const data = {};\r\n\r\n    for (const table of db.tables) {\r\n      data[table.name] = await table.toArray();\r\n    }\r\n\r\n    return JSON.stringify(data, null, 2);\r\n  }\r\n\r\n  static async importData(db, jsonData) {\r\n    const data = JSON.parse(jsonData);\r\n\r\n    await db.transaction("rw", db.tables, async () => {\r\n      // Clear all tables first\r\n      for (const table of db.tables) {\r\n        await table.clear();\r\n      }\r\n\r\n      // Import data\r\n      for (const [tableName, records] of Object.entries(data)) {\r\n        if (db[tableName]) {\r\n          await db[tableName].bulkAdd(records);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  static enableQueryLogging(db) {\r\n    db.use({\r\n      name: "QueryLogger",\r\n      read: function (down, ctx, table) {\r\n        return function (...args) {\r\n          console.time(`Read from ${table}`);\r\n          return down.read.apply(this, args).finally(() => {\r\n            console.timeEnd(`Read from ${table}`);\r\n          });\r\n        };\r\n      },\r\n    });\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Performance monitoring utilities\r\nclass PerformanceMonitor {\r\n  constructor(db) {\r\n    this.db = db;\r\n    this.metrics = new Map();\r\n  }\r\n\r\n  startMonitoring() {\r\n    this.db.use({\r\n      name: "PerformanceMonitor",\r\n      create: this.wrapOperation("create"),\r\n      read: this.wrapOperation("read"),\r\n      update: this.wrapOperation("update"),\r\n      delete: this.wrapOperation("delete"),\r\n    });\r\n  }\r\n\r\n  wrapOperation(operation) {\r\n    return (down, ctx, table) => {\r\n      return function (...args) {\r\n        const start = performance.now();\r\n        const key = `${table}.${operation}`;\r\n\r\n        return down[operation].apply(this, args).finally(() => {\r\n          const duration = performance.now() - start;\r\n          this.recordMetric(key, duration);\r\n        });\r\n      }.bind(this);\r\n    };\r\n  }\r\n\r\n  recordMetric(operation, duration) {\r\n    if (!this.metrics.has(operation)) {\r\n      this.metrics.set(operation, []);\r\n    }\r\n\r\n    this.metrics.get(operation).push(duration);\r\n\r\n    // Keep only last 100 measurements\r\n    const measurements = this.metrics.get(operation);\r\n    if (measurements.length > 100) {\r\n      measurements.shift();\r\n    }\r\n  }\r\n\r\n  getStats() {\r\n    const stats = {};\r\n\r\n    for (const [operation, measurements] of this.metrics) {\r\n      const avg = measurements.reduce((a, b) => a + b, 0) / measurements.length;\r\n      const max = Math.max(...measurements);\r\n      const min = Math.min(...measurements);\r\n\r\n      stats[operation] = { avg, max, min, count: measurements.length };\r\n    }\r\n\r\n    return stats;\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"best-practices-and-gotchas",children:"Best Practices and Gotchas"}),"\n",(0,s.jsx)(r.h3,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,s.jsx)(r.h4,{id:"1-transaction-scope-issues",children:"1. Transaction Scope Issues"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// \u274c Wrong: Operations outside transaction scope\r\nasync function badExample() {\r\n  const transaction = db.transaction("rw", db.users, db.orders);\r\n\r\n  setTimeout(async () => {\r\n    // This will fail - transaction may already be committed\r\n    await db.users.add({ name: "John" });\r\n  }, 100);\r\n}\r\n\r\n// \u2705 Correct: Keep all operations synchronous within transaction\r\nasync function goodExample() {\r\n  await db.transaction("rw", db.users, db.orders, async () => {\r\n    await db.users.add({ name: "John" });\r\n    await db.orders.add({ userId: 1, total: 100 });\r\n    // All operations complete before transaction ends\r\n  });\r\n}\n'})}),"\n",(0,s.jsx)(r.h4,{id:"2-memory-leaks-with-large-queries",children:"2. Memory Leaks with Large Queries"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// \u274c Wrong: Loading entire large dataset\r\nasync function memoryHog() {\r\n  const allRecords = await db.largeTable.toArray(); // Could be millions\r\n  return allRecords.filter((record) => record.isActive);\r\n}\r\n\r\n// \u2705 Correct: Use streaming or pagination\r\nasync function memoryEfficient() {\r\n  const activeRecords = [];\r\n\r\n  await db.largeTable\r\n    .where("isActive")\r\n    .equals(true)\r\n    .each((record) => {\r\n      activeRecords.push(record);\r\n    });\r\n\r\n  return activeRecords;\r\n}\n'})}),"\n",(0,s.jsx)(r.h4,{id:"3-index-design-mistakes",children:"3. Index Design Mistakes"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// \u274c Wrong: Missing compound indexes for multi-column queries\r\ndb.version(1).stores({\r\n  orders: "++id, customerId, status, createdAt",\r\n});\r\n\r\n// This query will be slow\r\nawait db.orders\r\n  .where("customerId")\r\n  .equals(123)\r\n  .and((order) => order.status === "active")\r\n  .toArray();\r\n\r\n// \u2705 Correct: Add compound index\r\ndb.version(1).stores({\r\n  orders: "++id, [customerId+status], customerId, status, createdAt",\r\n});\r\n\r\n// This query will be fast\r\nawait db.orders\r\n  .where(["customerId", "status"])\r\n  .equals([123, "active"])\r\n  .toArray();\n'})}),"\n",(0,s.jsx)(r.h3,{id:"production-deployment-checklist",children:"Production Deployment Checklist"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'// Production-ready Dexie setup\r\nclass ProductionDB {\r\n  constructor() {\r\n    this.db = new Dexie("ProductionApp");\r\n    this.setupSchema();\r\n    this.setupErrorHandling();\r\n    this.setupPerformanceMonitoring();\r\n  }\r\n\r\n  setupSchema() {\r\n    this.db.version(1).stores({\r\n      // Carefully designed schema with proper indexes\r\n      users: "++id, email, [lastName+firstName], lastActiveAt",\r\n      sessions: "++id, userId, token, expiresAt",\r\n      cache: "key, data, expiresAt",\r\n    });\r\n\r\n    // Handle schema upgrades gracefully\r\n    this.db\r\n      .version(2)\r\n      .stores({\r\n        users: "++id, email, [lastName+firstName], lastActiveAt, preferences",\r\n      })\r\n      .upgrade((trans) => {\r\n        return trans.users.toCollection().modify((user) => {\r\n          user.preferences = {};\r\n        });\r\n      });\r\n  }\r\n\r\n  setupErrorHandling() {\r\n    this.db.use({\r\n      name: "ErrorHandler",\r\n      stack: "dbcore",\r\n      create: this.handleOperation("create"),\r\n      read: this.handleOperation("read"),\r\n      update: this.handleOperation("update"),\r\n      delete: this.handleOperation("delete"),\r\n    });\r\n  }\r\n\r\n  handleOperation(operationType) {\r\n    return (req) => {\r\n      return new Promise((resolve, reject) => {\r\n        try {\r\n          const result = req.operation.apply(req, req.args);\r\n\r\n          if (result && typeof result.then === "function") {\r\n            result.then(resolve).catch((error) => {\r\n              this.logError(operationType, error, req);\r\n              reject(error);\r\n            });\r\n          } else {\r\n            resolve(result);\r\n          }\r\n        } catch (error) {\r\n          this.logError(operationType, error, req);\r\n          reject(error);\r\n        }\r\n      });\r\n    };\r\n  }\r\n\r\n  logError(operation, error, request) {\r\n    console.error("Database operation failed:", {\r\n      operation,\r\n      error: error.message,\r\n      table: request.objectStoreName,\r\n      stack: error.stack,\r\n    });\r\n\r\n    // Send to error reporting service\r\n    if (window.errorReporter) {\r\n      window.errorReporter.captureException(error, {\r\n        tags: { operation, table: request.objectStoreName },\r\n      });\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(r.p,{children:"IndexedDB and Dexie.js represent a powerful combination for client-side data storage in modern web applications. IndexedDB provides the robust, transactional foundation with its sophisticated storage engine, while Dexie.js offers an elegant, developer-friendly interface that doesn't sacrifice performance or capabilities."}),"\n",(0,s.jsx)(r.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"IndexedDB Architecture"}),": Understanding the underlying B+ tree structures, transaction management, and browser storage mechanisms helps in making informed design decisions."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Dexie's Value Proposition"}),": The wrapper doesn't just simplify the API\u2014it provides transaction management, query optimization, and error handling that would be complex to implement correctly with raw IndexedDB."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Performance Considerations"}),": Proper indexing strategies, transaction scoping, and memory management are crucial for production applications."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Browser Differences"}),": While IndexedDB is standardized, browser implementations vary in storage limits, eviction policies, and performance characteristics."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Future-Proofing"}),": Both technologies continue to evolve, with new features like partitioned storage, improved quota management, and enhanced debugging tools."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"The combination of IndexedDB's power and Dexie's elegance provides a robust foundation for building sophisticated offline-first web applications with complex data requirements. Whether you're building a simple cache or a full-featured collaborative application, understanding both the underlying mechanisms and the abstraction layer ensures you can build performant, reliable data storage solutions."}),"\n",(0,s.jsx)(r.h3,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://dexie.org",children:"Dexie.js Official Documentation"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API",children:"IndexedDB API Reference"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://github.com/dexie/Dexie.js",children:"Dexie.js GitHub Repository"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API",children:"Web Storage API Documentation"})}),"\n",(0,s.jsx)(r.li,{children:(0,s.jsx)(r.a,{href:"https://web.dev/storage-for-the-web/",children:"Storage for the Web"})}),"\n"]})]})}function u(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>i});var t=n(6540);const s={},a=t.createContext(s);function o(e){const r=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:r},e.children)}}}]);