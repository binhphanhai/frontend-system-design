"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9398],{2017:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"project-detail/recharts","title":"Recharts: React Data Visualization Library","description":"Table of Contents","source":"@site/docs/project-detail/recharts.md","sourceDirName":"project-detail","slug":"/project-detail/recharts","permalink":"/frontend-system-design/docs/project-detail/recharts","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/recharts.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"React Router: Declarative Routing for React","permalink":"/frontend-system-design/docs/project-detail/react-router"},"next":{"title":"Single-SPA: Microfrontend Framework","permalink":"/frontend-system-design/docs/project-detail/single-spa"}}');var a=r(4848),i=r(8453);const s={},o="Recharts: React Data Visualization Library",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Principles",id:"key-principles",level:3},{value:"Getting Started",id:"getting-started",level:2},{value:"Installation",id:"installation",level:3},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Component Composition",id:"component-composition",level:3},{value:"Data Structure",id:"data-structure",level:3},{value:"Under the Hood: How Recharts Works",id:"under-the-hood-how-recharts-works",level:2},{value:"Component Rendering Process",id:"component-rendering-process",level:3},{value:"D3 Integration",id:"d3-integration",level:3},{value:"Component Architecture",id:"component-architecture",level:2},{value:"Container Components",id:"container-components",level:3},{value:"Data Components",id:"data-components",level:3},{value:"Data Processing and Scaling",id:"data-processing-and-scaling",level:2},{value:"Domain and Range Calculations",id:"domain-and-range-calculations",level:3},{value:"Data Transformation",id:"data-transformation",level:3},{value:"SVG Rendering System",id:"svg-rendering-system",level:2},{value:"SVG Structure",id:"svg-structure",level:3},{value:"Animation System",id:"animation-system",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Custom Components",id:"custom-components",level:3},{value:"Event Handling",id:"event-handling",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Memoization and Optimization",id:"memoization-and-optimization",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Component Organization",id:"component-organization",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Further Resources",id:"further-resources",level:3}];function d(n){const e={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"recharts-react-data-visualization-library",children:"Recharts: React Data Visualization Library"})}),"\n",(0,a.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getting-started",children:"Getting Started"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#core-concepts",children:"Core Concepts"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#under-the-hood-how-recharts-works",children:"Under the Hood: How Recharts Works"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#component-architecture",children:"Component Architecture"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#data-processing-and-scaling",children:"Data Processing and Scaling"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#svg-rendering-system",children:"SVG Rendering System"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#advanced-features",children:"Advanced Features"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(e.p,{children:["Recharts is a React charting library built with React and D3. As highlighted in the ",(0,a.jsx)(e.a,{href:"https://github.com/recharts/recharts",children:"Recharts GitHub repository"}),", it provides a redefined chart library that emphasizes simplicity, native SVG support, and declarative components for building data visualizations."]}),"\n",(0,a.jsx)(e.h3,{id:"key-principles",children:"Key Principles"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Simply deploy with React components"}),": Declarative API that feels natural to React developers"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Native SVG support"}),": Lightweight with minimal dependencies"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Declarative components"}),": Compose charts using React component patterns"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,a.jsx)(e.h3,{id:"installation",children:"Installation"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this does"}),": Install Recharts library and its peer dependency ",(0,a.jsx)(e.code,{children:"react-is"})," which is required for React component type checking."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Input"}),": Package manager command",(0,a.jsx)(e.br,{}),"\n",(0,a.jsx)(e.strong,{children:"Output"}),": Recharts library installed in your project with all dependencies"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"# Install Recharts with npm (most common)\r\nnpm install recharts react-is\r\n\r\n# Or using yarn (alternative package manager)\r\nyarn add recharts react-is\r\n\r\n# Or using pnpm (faster, disk space efficient)\r\npnpm add recharts react-is\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Note"}),": ",(0,a.jsx)(e.code,{children:"react-is"})," is a peer dependency that Recharts uses internally for React component validation and type checking."]}),"\n",(0,a.jsx)(e.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Creates a responsive line chart displaying sales and profit data over time with interactive features like tooltips and legends."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Import necessary Recharts components"}),"\n",(0,a.jsx)(e.li,{children:"Define sample data with consistent structure"}),"\n",(0,a.jsx)(e.li,{children:"Create a responsive chart component with multiple data lines"}),"\n",(0,a.jsx)(e.li,{children:"Configure visual elements (grid, axes, tooltips)"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Input"}),": Array of data objects with consistent properties",(0,a.jsx)(e.br,{}),"\n",(0,a.jsx)(e.strong,{children:"Output"}),": Interactive line chart rendered as SVG"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'import React from "react";\r\nimport {\r\n  LineChart, // Main chart container for line charts\r\n  Line, // Individual line component for data series\r\n  XAxis, // Horizontal axis component\r\n  YAxis, // Vertical axis component\r\n  CartesianGrid, // Background grid lines\r\n  Tooltip, // Interactive hover information\r\n  Legend, // Chart legend for data series\r\n  ResponsiveContainer, // Auto-sizing wrapper\r\n} from "recharts";\r\n\r\n// Sample data: Each object represents one data point with multiple metrics\r\nconst data = [\r\n  { name: "Jan", sales: 4000, profit: 2400, expenses: 2400 },\r\n  { name: "Feb", sales: 3000, profit: 1398, expenses: 2210 },\r\n  { name: "Mar", sales: 2000, profit: 9800, expenses: 2290 },\r\n  { name: "Apr", sales: 2780, profit: 3908, expenses: 2000 },\r\n  { name: "May", sales: 1890, profit: 4800, expenses: 2181 },\r\n  { name: "Jun", sales: 2390, profit: 3800, expenses: 2500 },\r\n];\r\n\r\nconst SimpleChart = () => {\r\n  return (\r\n    // ResponsiveContainer automatically adjusts chart size to parent\r\n    <ResponsiveContainer width="100%" height={400}>\r\n      <LineChart\r\n        data={data} // Pass data to chart\r\n        margin={{ top: 20, right: 30, left: 20, bottom: 5 }} // Chart padding\r\n      >\r\n        {/* Grid lines for better readability */}\r\n        <CartesianGrid strokeDasharray="3 3" />\r\n\r\n        {/* X-axis showing month names */}\r\n        <XAxis dataKey="name" />\r\n\r\n        {/* Y-axis with automatic scaling */}\r\n        <YAxis />\r\n\r\n        {/* Interactive tooltip on hover */}\r\n        <Tooltip />\r\n\r\n        {/* Legend showing data series names */}\r\n        <Legend />\r\n\r\n        {/* First data line: Sales */}\r\n        <Line\r\n          type="monotone" // Smooth curved line\r\n          dataKey="sales" // Data property to plot\r\n          stroke="#8884d8" // Line color (blue)\r\n          strokeWidth={2} // Line thickness\r\n          dot={{ r: 4 }} // Regular dot size\r\n          activeDot={{ r: 6 }} // Hover dot size (larger)\r\n        />\r\n\r\n        {/* Second data line: Profit */}\r\n        <Line\r\n          type="monotone" // Smooth curved line\r\n          dataKey="profit" // Data property to plot\r\n          stroke="#82ca9d" // Line color (green)\r\n          strokeWidth={2} // Line thickness\r\n        />\r\n      </LineChart>\r\n    </ResponsiveContainer>\r\n  );\r\n};\r\n\r\nexport default SimpleChart;\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Key Features"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Responsive Design"}),": Automatically adapts to container size"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Multiple Data Series"}),": Can display multiple metrics on same chart"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Interactive Elements"}),": Hover tooltips and clickable legend"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Smooth Curves"}),": Uses monotone interpolation for natural-looking lines"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,a.jsx)(e.h3,{id:"component-composition",children:"Component Composition"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this demonstrates"}),": How Recharts uses React's composition pattern to build complex charts from small, reusable components."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Concept"}),": Instead of monolithic chart components, you compose charts by combining specialized components for different purposes (containers, visual elements, coordinate systems, interactions)."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Benefits"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Modularity"}),": Each component has a single responsibility"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Reusability"}),": Components can be mixed and matched across chart types"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Flexibility"}),": Easy to customize or replace individual parts"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// 1. CHART CONTAINERS - Define the chart type and layout\r\nimport {\r\n  LineChart, // For line/trend visualizations\r\n  BarChart, // For categorical comparisons\r\n  PieChart, // For part-to-whole relationships\r\n  AreaChart, // For cumulative data over time\r\n  ScatterChart, // For correlation analysis\r\n} from "recharts";\r\n\r\n// 2. VISUAL ELEMENTS - Components that render actual data\r\nimport {\r\n  Line, // Line segments connecting data points\r\n  Bar, // Rectangular bars for categorical data\r\n  Pie, // Pie slices for proportional data\r\n  Area, // Filled areas under lines\r\n  Scatter, // Individual points for scatter plots\r\n} from "recharts";\r\n\r\n// 3. COORDINATE SYSTEM - Components that define chart axes and grids\r\nimport {\r\n  XAxis, // Horizontal axis (usually categories or time)\r\n  YAxis, // Vertical axis (usually values)\r\n  ZAxis, // Third dimension for bubble charts\r\n  PolarGrid, // Circular grid for polar charts\r\n  RadialBar, // Radial bars for circular bar charts\r\n} from "recharts";\r\n\r\n// 4. LAYOUT AND INTERACTION - Components for user experience\r\nimport {\r\n  CartesianGrid, // Background grid lines\r\n  Tooltip, // Hover information boxes\r\n  Legend, // Chart legend for data series\r\n  ResponsiveContainer, // Auto-sizing wrapper\r\n} from "recharts";\r\n\r\n// Example of composition: Building a chart by combining components\r\nconst ComposedChart = () => (\r\n  <ResponsiveContainer width="100%" height={400}>\r\n    {/* Chart container defines the chart type */}\r\n    <LineChart data={data}>\r\n      {/* Coordinate system components */}\r\n      <CartesianGrid strokeDasharray="3 3" /> {/* Background grid */}\r\n      <XAxis dataKey="name" /> {/* X-axis using \'name\' field */}\r\n      <YAxis /> {/* Y-axis with auto-scaling */}\r\n      {/* Interactive elements */}\r\n      <Tooltip /> {/* Show data on hover */}\r\n      <Legend /> {/* Show series names */}\r\n      {/* Data visualization components */}\r\n      <Line dataKey="sales" stroke="#8884d8" /> {/* Sales line in blue */}\r\n      <Line dataKey="profit" stroke="#82ca9d" /> {/* Profit line in green */}\r\n    </LineChart>\r\n  </ResponsiveContainer>\r\n);\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Component Hierarchy"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"ResponsiveContainer"})," (outermost wrapper)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Chart Container"})," (LineChart, BarChart, etc.)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Coordinate Components"})," (XAxis, YAxis, Grid)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Interactive Components"})," (Tooltip, Legend)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Data Components"})," (Line, Bar, Area, etc.)"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"data-structure",children:"Data Structure"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this shows"}),": Different data structures that Recharts can work with, from simple to complex scenarios."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Key Principle"}),": Recharts expects data as an array of objects where each object represents one data point with consistent properties."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Requirements"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Array format (not single objects)"}),"\n",(0,a.jsx)(e.li,{children:"Consistent property names across all data points"}),"\n",(0,a.jsx)(e.li,{children:"Flat structure preferred (though nesting is possible with custom accessors)"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// 1. BASIC DATA STRUCTURE - Most common pattern\r\n// Each object = one data point, properties = different metrics\r\nconst chartData = [\r\n  { category: "A", value: 100, secondary: 200 }, // Data point 1\r\n  { category: "B", value: 150, secondary: 180 }, // Data point 2\r\n  { category: "C", value: 120, secondary: 220 }, // Data point 3\r\n];\r\n// Usage: <XAxis dataKey="category" /> <Line dataKey="value" />\r\n\r\n// 2. COMPLEX DATA WITH NESTED OBJECTS - Requires custom accessors\r\n// Useful when you have hierarchical data from APIs\r\nconst complexData = [\r\n  {\r\n    month: "Jan", // Primary identifier\r\n    metrics: {\r\n      // Nested metrics object\r\n      revenue: 4000,\r\n      costs: 2400,\r\n      users: 1200,\r\n    },\r\n    breakdown: [\r\n      // Array of sub-categories\r\n      { type: "product", value: 3000 },\r\n      { type: "service", value: 1000 },\r\n    ],\r\n  },\r\n  // ... more months\r\n];\r\n// Usage: <Line dataKey="metrics.revenue" /> or custom accessor function\r\n\r\n// 3. TIME SERIES DATA - For temporal visualizations\r\n// Common in dashboards and monitoring applications\r\nconst timeSeriesData = [\r\n  { timestamp: "2024-01-01T00:00:00Z", value: 100, trend: "up" },\r\n  { timestamp: "2024-01-02T00:00:00Z", value: 120, trend: "up" },\r\n  { timestamp: "2024-01-03T00:00:00Z", value: 98, trend: "down" },\r\n];\r\n// Usage: <XAxis dataKey="timestamp" type="category" />\r\n//        <Line dataKey="value" />\r\n\r\n// 4. MULTI-METRIC DATA - Multiple measurements per data point\r\nconst businessData = [\r\n  {\r\n    quarter: "Q1",\r\n    revenue: 100000,\r\n    expenses: 75000,\r\n    profit: 25000,\r\n    growth: 15.5, // Percentage\r\n    customers: 1250, // Count\r\n  },\r\n  {\r\n    quarter: "Q2",\r\n    revenue: 120000,\r\n    expenses: 85000,\r\n    profit: 35000,\r\n    growth: 20.0,\r\n    customers: 1500,\r\n  },\r\n];\r\n// Can plot multiple lines: revenue, expenses, profit on same chart\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Data Structure Best Practices"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Consistent Keys"}),": All objects should have the same property names"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Flat Structure"}),": Avoid deep nesting when possible"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Meaningful Names"}),": Use descriptive property names for better accessibility"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Proper Types"}),": Numbers for numeric data, strings for categories"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"No Missing Values"}),": Handle nulls/undefined before passing to charts"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"under-the-hood-how-recharts-works",children:"Under the Hood: How Recharts Works"}),"\n",(0,a.jsx)(e.h3,{id:"component-rendering-process",children:"Component Rendering Process"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this shows"}),": The internal workings of how Recharts transforms data into SVG visualizations."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Process Overview"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Data Processing"}),": Calculate domains and ranges from input data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Scale Creation"}),": Use D3 to create mathematical functions that map data to pixel coordinates"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Path Generation"}),": Convert data points into SVG path strings"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"SVG Rendering"}),": Compose final SVG with all visual elements"]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Key Insight"}),": Recharts uses D3 for mathematical calculations but React for DOM rendering, combining the best of both libraries."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Simplified Recharts rendering concept - shows the internal process\r\nclass LineChart extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      data: props.data, // Chart data\r\n      width: props.width, // Total chart width\r\n      height: props.height, // Total chart height\r\n    };\r\n  }\r\n\r\n  // STEP 1: Process data and calculate scales\r\n  // This transforms raw data into mathematical coordinate systems\r\n  processData() {\r\n    const { data, width, height, margin } = this.props;\r\n\r\n    // Calculate available space for actual chart (excluding margins)\r\n    const chartWidth = width - margin.left - margin.right; // Space for data\r\n    const chartHeight = height - margin.top - margin.bottom; // Space for data\r\n\r\n    // Create D3 scales to map data values to pixel coordinates\r\n    const xScale = d3\r\n      .scaleLinear() // Linear scale for continuous data\r\n      .domain(d3.extent(data, (d) => d.x)) // Input range: [min_x, max_x]\r\n      .range([0, chartWidth]); // Output range: [0, chart_width]\r\n\r\n    const yScale = d3\r\n      .scaleLinear() // Linear scale for continuous data\r\n      .domain(d3.extent(data, (d) => d.y)) // Input range: [min_y, max_y]\r\n      .range([chartHeight, 0]); // Output range: [chart_height, 0] - inverted for SVG\r\n\r\n    return { xScale, yScale, chartWidth, chartHeight };\r\n  }\r\n\r\n  // STEP 2: Generate SVG path data\r\n  // Converts data points into a single SVG path string\r\n  generatePath(data, xScale, yScale) {\r\n    const line = d3\r\n      .line() // D3 line generator\r\n      .x((d) => xScale(d.x)) // X coordinate from data\r\n      .y((d) => yScale(d.y)) // Y coordinate from data\r\n      .curve(d3.curveMonotoneX); // Smooth curve interpolation\r\n\r\n    return line(data); // Returns SVG path string like "M10,20L30,40L50,60"\r\n  }\r\n\r\n  // STEP 3: Render SVG elements\r\n  // Combines all visual elements into final SVG structure\r\n  render() {\r\n    // Get calculated scales and dimensions\r\n    const { xScale, yScale, chartWidth, chartHeight } = this.processData();\r\n\r\n    // Generate path string for the line\r\n    const pathData = this.generatePath(this.props.data, xScale, yScale);\r\n\r\n    return (\r\n      <svg width={this.props.width} height={this.props.height}>\r\n        {/* Main chart group with margin offset */}\r\n        <g\r\n          transform={`translate(${this.props.margin.left}, ${this.props.margin.top})`}\r\n        >\r\n          {/* Invisible chart area for event handling */}\r\n          <rect\r\n            width={chartWidth}\r\n            height={chartHeight}\r\n            fill="transparent"\r\n            className="chart-background"\r\n          />\r\n          {/* Background grid lines for readability */}\r\n          {this.renderGrid(xScale, yScale, chartWidth, chartHeight)}\r\n          {/* Chart axes with labels and tick marks */}\r\n          {this.renderXAxis(xScale, chartHeight)} {/* Bottom axis */}\r\n          {this.renderYAxis(yScale)} {/* Left axis */}\r\n          {/* The actual data line */}\r\n          <path\r\n            d={pathData} // SVG path string\r\n            fill="none" // No fill, just stroke\r\n            stroke="#8884d8" // Line color\r\n            strokeWidth={2} // Line thickness\r\n            className="data-line"\r\n          />\r\n          {/* Individual data points as circles */}\r\n          {this.renderDataPoints(this.props.data, xScale, yScale)}\r\n        </g>\r\n      </svg>\r\n    );\r\n  }\r\n}\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Rendering Pipeline"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Props \u2192 State"}),": Receive data and dimensions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Data \u2192 Scales"}),": Calculate mathematical mappings"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Scales \u2192 Paths"}),": Generate SVG path strings"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Paths \u2192 SVG"}),": Render final visual elements"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Interactions"}),": Handle mouse events and updates"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"d3-integration",children:"D3 Integration"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this demonstrates"}),": How Recharts leverages D3's mathematical functions while keeping React in control of rendering."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Architecture"}),': Recharts uses D3 as a "calculation engine" rather than a rendering library. D3 handles complex mathematical transformations (scales, shapes, statistics) while React manages the DOM and component lifecycle.']}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Benefits"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Performance"}),": D3's optimized mathematical functions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Flexibility"}),": Access to D3's extensive scale and shape libraries"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"React Integration"}),": Maintain React's declarative programming model"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Best of Both"}),": D3's math power + React's component architecture"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// How Recharts uses D3 for calculations while React handles rendering\r\nimport * as d3 from "d3-scale"; // Scaling functions\r\nimport * as d3Array from "d3-array"; // Array manipulation utilities\r\nimport * as d3Shape from "d3-shape"; // Path generation functions\r\n\r\nclass Chart {\r\n  // SCALE CREATION: Maps data values to visual coordinates\r\n  createScales(data, domain, range) {\r\n    // 1. LINEAR SCALE - For continuous numerical data\r\n    // Maps continuous input domain to continuous output range\r\n    const linearScale = d3\r\n      .scaleLinear()\r\n      .domain(domain) // Input range: [min_value, max_value]\r\n      .range(range); // Output range: [min_pixel, max_pixel]\r\n    // Example: domain([0, 100]) \u2192 range([0, 400]) means value 50 \u2192 pixel 200\r\n\r\n    // 2. BAND SCALE - For categorical data (bars, columns)\r\n    // Divides range into equal bands for each category\r\n    const bandScale = d3\r\n      .scaleBand()\r\n      .domain(data.map((d) => d.category)) // All category names\r\n      .range(range) // Available pixel space\r\n      .padding(0.1); // Space between bands (10%)\r\n    // Example: categories ["A", "B", "C"] \u2192 bands at pixels [0-120], [140-260], [280-400]\r\n\r\n    // 3. TIME SCALE - For temporal data (dates, timestamps)\r\n    // Handles time-based data with intelligent tick generation\r\n    const timeScale = d3\r\n      .scaleTime()\r\n      .domain(d3Array.extent(data, (d) => new Date(d.date))) // [earliest, latest]\r\n      .range(range); // Pixel range\r\n    // Example: domain([Jan 1, Dec 31]) \u2192 range([0, 800]) for one year timeline\r\n\r\n    return { linearScale, bandScale, timeScale };\r\n  }\r\n\r\n  // PATH GENERATION: Converts data points into SVG path strings\r\n  generateShapes(data, scales) {\r\n    // 1. LINE PATH - Connects data points with lines\r\n    const line = d3Shape\r\n      .line()\r\n      .x((d) => scales.xScale(d.x)) // X coordinate from data\r\n      .y((d) => scales.yScale(d.y)) // Y coordinate from data\r\n      .curve(d3Shape.curveMonotoneX); // Smooth interpolation\r\n    // Output: "M10,20L30,15L50,25" (SVG path string)\r\n\r\n    // 2. AREA PATH - Filled area under a line\r\n    const area = d3Shape\r\n      .area()\r\n      .x((d) => scales.xScale(d.x)) // X coordinate\r\n      .y0(scales.yScale(0)) // Bottom baseline (usually 0)\r\n      .y1((d) => scales.yScale(d.y)) // Top line (data values)\r\n      .curve(d3Shape.curveMonotoneX); // Smooth curves\r\n    // Output: Area path string for filled regions\r\n\r\n    // 3. PIE/ARC PATHS - For pie charts and donut charts\r\n    const pie = d3Shape\r\n      .pie()\r\n      .value((d) => d.value) // Extract numeric value\r\n      .sort(null); // Don\'t sort data automatically\r\n\r\n    const arc = d3Shape\r\n      .arc()\r\n      .innerRadius(0) // 0 = pie chart, >0 = donut chart\r\n      .outerRadius(100); // Size of pie\r\n\r\n    // Generate individual arc paths for each data slice\r\n    const pieData = pie(data); // Calculate angles and positions\r\n    const pieArcs = pieData.map(arc); // Convert to SVG path strings\r\n\r\n    return {\r\n      linePath: line(data), // Single line path\r\n      areaPath: area(data), // Single area path\r\n      pieArcs: pieArcs, // Array of arc paths\r\n    };\r\n  }\r\n}\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"D3 vs React Responsibilities"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"D3 Handles"}),": Mathematical calculations, scales, path generation, data transformations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"React Handles"}),": Component lifecycle, DOM updates, event handling, state management"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"component-architecture",children:"Component Architecture"}),"\n",(0,a.jsx)(e.h3,{id:"container-components",children:"Container Components"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this shows"}),": How Recharts creates container components that manage chart layout, coordinate systems, and provide context to child components."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Purpose"}),': Container components handle the "infrastructure" concerns like sizing, scaling, and coordinate systems, allowing data components to focus purely on visualization.']}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Key Concepts"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Context Sharing"}),": Pass calculated scales and dimensions to all child components"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Responsive Design"}),": Automatically adapt to container size changes"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Separation of Concerns"}),": Containers handle layout, children handle data visualization"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Chart containers manage layout and coordinate system\r\nconst ChartContainer = ({ width, height, children, data }) => {\r\n  // CONTEXT CREATION: Calculate and share common chart properties\r\n  const chartContext = {\r\n    data, // Raw chart data\r\n    scales: calculateScales(data, width, height), // D3 scale functions\r\n    dimensions: { width, height }, // Chart dimensions\r\n  };\r\n\r\n  // CONTEXT PROVIDER: Makes chart properties available to all children\r\n  return (\r\n    <ChartContext.Provider value={chartContext}>\r\n      <svg width={width} height={height}>\r\n        {/* All child components can access chartContext via useContext */}\r\n        {children}\r\n      </svg>\r\n    </ChartContext.Provider>\r\n  );\r\n};\r\n\r\n// RESPONSIVE CONTAINER: Automatically adjusts chart size to fit parent\r\nconst ResponsiveContainer = ({ children, aspect = 2 }) => {\r\n  // State to track current container dimensions\r\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\r\n  const containerRef = useRef(); // Reference to DOM element\r\n\r\n  useEffect(() => {\r\n    // DIMENSION CALCULATION: Measure parent container and update chart size\r\n    const updateDimensions = () => {\r\n      if (containerRef.current) {\r\n        const { offsetWidth } = containerRef.current; // Get available width\r\n        setDimensions({\r\n          width: offsetWidth, // Use full width\r\n          height: offsetWidth / aspect, // Calculate height from aspect ratio\r\n        });\r\n      }\r\n    };\r\n\r\n    // INITIAL SIZING: Set dimensions on first render\r\n    updateDimensions();\r\n\r\n    // RESPONSIVE UPDATES: Listen for window resize events\r\n    window.addEventListener("resize", updateDimensions);\r\n\r\n    // CLEANUP: Remove event listener when component unmounts\r\n    return () => window.removeEventListener("resize", updateDimensions);\r\n  }, [aspect]);\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      style={{ width: "100%", height: "100%" }} // Fill parent container\r\n    >\r\n      {/* Only render chart when dimensions are available */}\r\n      {dimensions.width > 0 && React.cloneElement(children, dimensions)}\r\n    </div>\r\n  );\r\n};\r\n\r\n// USAGE EXAMPLE: How containers work together\r\nconst App = () => (\r\n  <ResponsiveContainer aspect={2}>\r\n    {" "}\r\n    {/* Outer responsive wrapper */}\r\n    <ChartContainer data={data}>\r\n      {" "}\r\n      {/* Inner chart context provider */}\r\n      <Line dataKey="sales" />{" "}\r\n      {/* Data component (gets context automatically) */}\r\n      <XAxis dataKey="month" /> {/* Axis component (gets scales from context) */}\r\n    </ChartContainer>\r\n  </ResponsiveContainer>\r\n);\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Container Responsibilities"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Layout Management"}),": Handle margins, padding, and available space"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Scale Calculation"}),": Create and share D3 scale functions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Responsive Behavior"}),": Adapt to container size changes"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Context Provision"}),": Share common properties with child components"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Event Coordination"}),": Manage interactions between components"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"data-components",children:"Data Components"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this shows"}),": How individual data visualization components render SVG elements based on processed data and scales."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Purpose"}),': Data components are the "visual elements" that actually draw your data. They receive scales from container components and transform data points into SVG paths, rectangles, circles, etc.']}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Key Principles"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Single Responsibility"}),": Each component handles one visualization type"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Performance"}),": Use memoization for expensive calculations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Flexibility"}),": Accept styling props for customization"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// LINE COMPONENT: Renders connected data points as SVG path\r\nconst Line = ({ dataKey, stroke, strokeWidth, data, xScale, yScale }) => {\r\n  // MEMOIZED PATH CALCULATION: Only recalculate when dependencies change\r\n  const pathData = useMemo(() => {\r\n    // Create D3 line generator with current scales\r\n    const line = d3\r\n      .line()\r\n      .x((d, i) => xScale(i)) // X position using index\r\n      .y((d) => yScale(d[dataKey])) // Y position using data value\r\n      .curve(d3.curveMonotoneX); // Smooth curve interpolation\r\n\r\n    return line(data); // Generate SVG path string: "M10,20L30,15L50,25..."\r\n  }, [data, dataKey, xScale, yScale]); // Recalculate when any dependency changes\r\n\r\n  // RENDER SVG PATH: Single path element for entire line\r\n  return (\r\n    <path\r\n      d={pathData} // SVG path string from D3\r\n      fill="none" // Lines have no fill, only stroke\r\n      stroke={stroke} // Line color\r\n      strokeWidth={strokeWidth} // Line thickness\r\n      className="recharts-line" // CSS class for styling\r\n    />\r\n  );\r\n};\r\n\r\n// BAR COMPONENT: Renders individual rectangles for categorical data\r\nconst Bar = ({ data, dataKey, fill, xScale, yScale }) => {\r\n  // RENDER MULTIPLE RECTANGLES: One rect per data point\r\n  return (\r\n    <g className="recharts-bar">\r\n      {" "}\r\n      {/* Group element to contain all bars */}\r\n      {data.map((entry, index) => (\r\n        <rect\r\n          key={index} // Unique key for React\r\n          x={xScale(index)} // Left edge position\r\n          y={yScale(entry[dataKey])} // Top edge position (SVG y=0 is top)\r\n          width={xScale.bandwidth()} // Bar width from band scale\r\n          height={yScale(0) - yScale(entry[dataKey])} // Bar height (distance from 0 to value)\r\n          fill={fill} // Bar color\r\n          className="recharts-bar-rectangle" // CSS class for individual bars\r\n        />\r\n      ))}\r\n    </g>\r\n  );\r\n};\r\n\r\n// AREA COMPONENT: Renders filled area under a line\r\nconst Area = ({ data, dataKey, fill, xScale, yScale }) => {\r\n  // GENERATE AREA PATH: Similar to line but with baseline\r\n  const areaPath = useMemo(() => {\r\n    const area = d3\r\n      .area()\r\n      .x((d, i) => xScale(i)) // X coordinate\r\n      .y0(yScale(0)) // Bottom baseline (usually 0)\r\n      .y1((d) => yScale(d[dataKey])) // Top line (data values)\r\n      .curve(d3.curveMonotoneX); // Smooth curves\r\n\r\n    return area(data); // Returns closed path that can be filled\r\n  }, [data, dataKey, xScale, yScale]);\r\n\r\n  return (\r\n    <path\r\n      d={areaPath}\r\n      fill={fill} // Areas have fill color\r\n      fillOpacity={0.6} // Semi-transparent\r\n      stroke="none" // No outline\r\n      className="recharts-area"\r\n    />\r\n  );\r\n};\r\n\r\n// SCATTER COMPONENT: Renders individual points\r\nconst Scatter = ({ data, dataKey, fill, xScale, yScale }) => {\r\n  return (\r\n    <g className="recharts-scatter">\r\n      {data.map((entry, index) => (\r\n        <circle\r\n          key={index}\r\n          cx={xScale(entry.x)} // Center X coordinate\r\n          cy={yScale(entry[dataKey])} // Center Y coordinate\r\n          r={4} // Radius\r\n          fill={fill} // Point color\r\n          className="recharts-scatter-point"\r\n        />\r\n      ))}\r\n    </g>\r\n  );\r\n};\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Data Component Patterns"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Path-based"}),": Line, Area (single SVG path for all data)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Shape-based"}),": Bar, Scatter (individual SVG shapes per data point)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Memoization"}),": Cache expensive calculations using useMemo"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Responsive"}),": Automatically adapt when scales change"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"data-processing-and-scaling",children:"Data Processing and Scaling"}),"\n",(0,a.jsx)(e.h3,{id:"domain-and-range-calculations",children:"Domain and Range Calculations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Data domain calculation\r\nconst calculateDomain = (data, dataKey, type = "number") => {\r\n  switch (type) {\r\n    case "number":\r\n      return d3.extent(data, (d) => d[dataKey]);\r\n\r\n    case "category":\r\n      return data.map((d) => d[dataKey]);\r\n\r\n    case "time":\r\n      return d3.extent(data, (d) => new Date(d[dataKey]));\r\n\r\n    default:\r\n      return [0, 1];\r\n  }\r\n};\r\n\r\n// Scale creation and management\r\nclass ScaleManager {\r\n  constructor(data, width, height, margin) {\r\n    this.data = data;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.margin = margin;\r\n\r\n    this.chartWidth = width - margin.left - margin.right;\r\n    this.chartHeight = height - margin.top - margin.bottom;\r\n  }\r\n\r\n  createLinearScale(dataKey, range = [this.chartHeight, 0]) {\r\n    const domain = d3.extent(this.data, (d) => d[dataKey]);\r\n    return d3.scaleLinear().domain(domain).range(range);\r\n  }\r\n\r\n  createBandScale(dataKey, range = [0, this.chartWidth]) {\r\n    const domain = this.data.map((d) => d[dataKey]);\r\n    return d3.scaleBand().domain(domain).range(range).padding(0.1);\r\n  }\r\n\r\n  createTimeScale(dataKey, range = [0, this.chartWidth]) {\r\n    const domain = d3.extent(this.data, (d) => new Date(d[dataKey]));\r\n    return d3.scaleTime().domain(domain).range(range);\r\n  }\r\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"data-transformation",children:"Data Transformation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Data processing pipeline\r\nconst processChartData = (rawData, config) => {\r\n  // 1. Filter and validate data\r\n  const validData = rawData.filter(\r\n    (item) =>\r\n      item != null &&\r\n      typeof item === "object" &&\r\n      config.dataKeys.every((key) => item[key] != null)\r\n  );\r\n\r\n  // 2. Sort data if needed\r\n  const sortedData = config.sortBy\r\n    ? validData.sort((a, b) => a[config.sortBy] - b[config.sortBy])\r\n    : validData;\r\n\r\n  // 3. Aggregate data if needed\r\n  const aggregatedData = config.groupBy\r\n    ? groupAndAggregate(sortedData, config.groupBy, config.aggregation)\r\n    : sortedData;\r\n\r\n  // 4. Calculate derived values\r\n  const enrichedData = aggregatedData.map((item) => ({\r\n    ...item,\r\n    // Add calculated fields\r\n    total: config.dataKeys.reduce((sum, key) => sum + (item[key] || 0), 0),\r\n    percentage: (item[config.primaryKey] / config.total) * 100,\r\n  }));\r\n\r\n  return enrichedData;\r\n};\r\n\r\n// Data aggregation helper\r\nconst groupAndAggregate = (data, groupKey, aggregation) => {\r\n  const grouped = d3.group(data, (d) => d[groupKey]);\r\n\r\n  return Array.from(grouped, ([key, values]) => ({\r\n    [groupKey]: key,\r\n    ...Object.keys(aggregation).reduce((acc, field) => {\r\n      const aggFunc = aggregation[field];\r\n      const fieldValues = values.map((v) => v[field]);\r\n\r\n      acc[field] =\r\n        aggFunc === "sum"\r\n          ? d3.sum(fieldValues)\r\n          : aggFunc === "mean"\r\n          ? d3.mean(fieldValues)\r\n          : d3.max(fieldValues);\r\n\r\n      return acc;\r\n    }, {}),\r\n  }));\r\n};\n'})}),"\n",(0,a.jsx)(e.h2,{id:"svg-rendering-system",children:"SVG Rendering System"}),"\n",(0,a.jsx)(e.h3,{id:"svg-structure",children:"SVG Structure"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// SVG chart structure\r\nconst ChartSVG = ({ width, height, margin, children }) => {\r\n  return (\r\n    <svg\r\n      width={width}\r\n      height={height}\r\n      viewBox={`0 0 ${width} ${height}`}\r\n      className="recharts-wrapper"\r\n    >\r\n      {/* Definitions for gradients, patterns, etc. */}\r\n      <defs>\r\n        <linearGradient id="colorGradient" x1="0%" y1="0%" x2="0%" y2="100%">\r\n          <stop offset="0%" stopColor="#8884d8" stopOpacity={0.8} />\r\n          <stop offset="100%" stopColor="#8884d8" stopOpacity={0.1} />\r\n        </linearGradient>\r\n      </defs>\r\n\r\n      {/* Main chart group with margin translation */}\r\n      <g transform={`translate(${margin.left}, ${margin.top})`}>\r\n        {/* Background */}\r\n        <rect\r\n          width={width - margin.left - margin.right}\r\n          height={height - margin.top - margin.bottom}\r\n          fill="transparent"\r\n          className="recharts-chart-background"\r\n        />\r\n\r\n        {/* Chart content */}\r\n        {children}\r\n      </g>\r\n    </svg>\r\n  );\r\n};\n'})}),"\n",(0,a.jsx)(e.h3,{id:"animation-system",children:"Animation System"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Animation utilities\r\nconst useAnimation = (targetValue, duration = 300) => {\r\n  const [currentValue, setCurrentValue] = useState(0);\r\n\r\n  useEffect(() => {\r\n    const startValue = currentValue;\r\n    const startTime = Date.now();\r\n\r\n    const animate = () => {\r\n      const elapsed = Date.now() - startTime;\r\n      const progress = Math.min(elapsed / duration, 1);\r\n\r\n      // Easing function\r\n      const easedProgress = 1 - Math.pow(1 - progress, 3);\r\n\r\n      const newValue = startValue + (targetValue - startValue) * easedProgress;\r\n      setCurrentValue(newValue);\r\n\r\n      if (progress < 1) {\r\n        requestAnimationFrame(animate);\r\n      }\r\n    };\r\n\r\n    requestAnimationFrame(animate);\r\n  }, [targetValue, duration]);\r\n\r\n  return currentValue;\r\n};\r\n\r\n// Animated line component\r\nconst AnimatedLine = ({ data, dataKey, xScale, yScale }) => {\r\n  const animatedData = useAnimation(data.length);\r\n\r\n  const pathData = useMemo(() => {\r\n    const animatedLength = Math.floor(animatedData);\r\n    const visibleData = data.slice(0, animatedLength);\r\n\r\n    const line = d3\r\n      .line()\r\n      .x((d, i) => xScale(i))\r\n      .y((d) => yScale(d[dataKey]))\r\n      .curve(d3.curveMonotoneX);\r\n\r\n    return line(visibleData);\r\n  }, [data, dataKey, xScale, yScale, animatedData]);\r\n\r\n  return <path d={pathData} fill="none" stroke="#8884d8" strokeWidth={2} />;\r\n};\n'})}),"\n",(0,a.jsx)(e.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this section covers"}),": Advanced customization techniques including custom components, event handling, and interactive behaviors that go beyond basic chart functionality."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"When to use"}),": When you need specialized visualizations, custom interactions, or behavior that isn't available through standard Recharts props."]}),"\n",(0,a.jsx)(e.h3,{id:"custom-components",children:"Custom Components"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this demonstrates"}),": How to create completely custom components that integrate with Recharts' coordinate system and data flow."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Key Benefits"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Full Control"}),": Design exactly the visualization you need"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Integration"}),": Automatically receive position and data from Recharts"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Reusability"}),": Create components that work across different chart types"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// CUSTOM TOOLTIP: Enhanced tooltip with rich formatting and conditional content\r\nconst CustomTooltip = ({ active, payload, label }) => {\r\n  // Only show tooltip when hovering over data points\r\n  if (active && payload && payload.length) {\r\n    return (\r\n      <div\r\n        className="custom-tooltip"\r\n        style={{\r\n          backgroundColor: "rgba(255, 255, 255, 0.95)",\r\n          border: "1px solid #ccc",\r\n          borderRadius: "4px",\r\n          padding: "10px",\r\n          boxShadow: "0 2px 8px rgba(0,0,0,0.1)",\r\n        }}\r\n      >\r\n        {/* Header showing the category/time */}\r\n        <p\r\n          className="label"\r\n          style={{ fontWeight: "bold", marginBottom: "8px" }}\r\n        >\r\n          {`${label}`}\r\n        </p>\r\n\r\n        {/* Data values with color coding */}\r\n        {payload.map((entry, index) => (\r\n          <p\r\n            key={index}\r\n            style={{\r\n              color: entry.color,\r\n              margin: "4px 0",\r\n              display: "flex",\r\n              justifyContent: "space-between",\r\n              minWidth: "120px",\r\n            }}\r\n          >\r\n            <span>{entry.dataKey}:</span>\r\n            <strong>{formatValue(entry.value)}</strong> {/* Custom formatting */}\r\n          </p>\r\n        ))}\r\n\r\n        {/* Additional calculated information */}\r\n        <div\r\n          style={{\r\n            borderTop: "1px solid #eee",\r\n            paddingTop: "8px",\r\n            marginTop: "8px",\r\n          }}\r\n        >\r\n          <p>Total: {calculateTotal(payload)}</p>\r\n          <p>Change: {calculateChange(payload)}%</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n  return null; // Hide tooltip when not active\r\n};\r\n\r\n// CUSTOM DOT: Conditional styling based on data values\r\nconst CustomDot = ({ cx, cy, payload }) => {\r\n  // Dynamic styling based on data properties\r\n  const isHighValue = payload.value > 1000;\r\n  const isNegative = payload.value < 0;\r\n\r\n  // Different styles for different data conditions\r\n  const dotStyle = {\r\n    high: { r: 6, fill: "#ff7300", stroke: "#fff" },\r\n    normal: { r: 4, fill: "#8884d8", stroke: "#fff" },\r\n    negative: { r: 5, fill: "#ff4444", stroke: "#fff" },\r\n  };\r\n\r\n  const style = isNegative\r\n    ? dotStyle.negative\r\n    : isHighValue\r\n    ? dotStyle.high\r\n    : dotStyle.normal;\r\n\r\n  return (\r\n    <circle\r\n      cx={cx} // X position from Recharts\r\n      cy={cy} // Y position from Recharts\r\n      r={style.r} // Dynamic radius\r\n      fill={style.fill} // Dynamic color\r\n      stroke={style.stroke} // Border color\r\n      strokeWidth={2}\r\n      className="custom-dot"\r\n      // Add hover effects\r\n      style={{ cursor: "pointer" }}\r\n    />\r\n  );\r\n};\r\n\r\n// CUSTOM LEGEND: Interactive legend with filtering capabilities\r\nconst CustomLegend = ({ payload, onLegendClick }) => {\r\n  return (\r\n    <div\r\n      className="custom-legend"\r\n      style={{\r\n        display: "flex",\r\n        justifyContent: "center",\r\n        flexWrap: "wrap",\r\n        marginTop: "20px",\r\n      }}\r\n    >\r\n      {payload.map((entry, index) => (\r\n        <div\r\n          key={index}\r\n          onClick={() => onLegendClick(entry.dataKey)} // Interactive click\r\n          style={{\r\n            display: "flex",\r\n            alignItems: "center",\r\n            margin: "0 15px",\r\n            cursor: "pointer",\r\n            opacity: entry.inactive ? 0.5 : 1, // Show active/inactive state\r\n          }}\r\n        >\r\n          {/* Color indicator */}\r\n          <div\r\n            style={{\r\n              width: "12px",\r\n              height: "12px",\r\n              backgroundColor: entry.color,\r\n              marginRight: "8px",\r\n              borderRadius: "2px",\r\n            }}\r\n          />\r\n\r\n          {/* Legend text */}\r\n          <span style={{ fontSize: "14px" }}>{entry.value}</span>\r\n        </div>\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\n// USAGE: Chart with custom components\r\nconst CustomChart = () => {\r\n  const [hiddenSeries, setHiddenSeries] = useState([]);\r\n\r\n  const handleLegendClick = (dataKey) => {\r\n    setHiddenSeries(\r\n      (prev) =>\r\n        prev.includes(dataKey)\r\n          ? prev.filter((key) => key !== dataKey) // Show series\r\n          : [...prev, dataKey] // Hide series\r\n    );\r\n  };\r\n\r\n  return (\r\n    <LineChart data={data}>\r\n      {/* Custom dot component for each data point */}\r\n      <Line\r\n        dataKey="value"\r\n        dot={<CustomDot />}\r\n        hide={hiddenSeries.includes("value")} // Conditional visibility\r\n      />\r\n\r\n      {/* Custom tooltip with enhanced information */}\r\n      <Tooltip content={<CustomTooltip />} />\r\n\r\n      {/* Custom interactive legend */}\r\n      <Legend content={<CustomLegend onLegendClick={handleLegendClick} />} />\r\n    </LineChart>\r\n  );\r\n};\n'})}),"\n",(0,a.jsx)(e.h3,{id:"event-handling",children:"Event Handling"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this demonstrates"}),": How to add interactivity to charts through mouse events, creating dynamic and responsive user experiences."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Common Use Cases"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Data selection and filtering"}),"\n",(0,a.jsx)(e.li,{children:"Drill-down navigation"}),"\n",(0,a.jsx)(e.li,{children:"Hover effects and highlighting"}),"\n",(0,a.jsx)(e.li,{children:"Data export or sharing"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// INTERACTIVE CHART: Comprehensive event handling with state management\r\nconst InteractiveChart = () => {\r\n  // State for tracking user interactions\r\n  const [selectedData, setSelectedData] = useState(null); // Currently selected data point\r\n  const [hoveredIndex, setHoveredIndex] = useState(null); // Currently hovered bar index\r\n  const [zoomedRange, setZoomedRange] = useState(null); // Zoom selection range\r\n\r\n  // MOUSE ENTER: Highlight hovered element\r\n  const handleMouseEnter = (data, index, event) => {\r\n    setHoveredIndex(index);\r\n\r\n    // Optional: Show additional UI feedback\r\n    event.target.style.opacity = "0.8";\r\n\r\n    console.log("Hovering over:", data);\r\n  };\r\n\r\n  // MOUSE LEAVE: Remove highlight\r\n  const handleMouseLeave = (event) => {\r\n    setHoveredIndex(null);\r\n\r\n    // Reset visual feedback\r\n    event.target.style.opacity = "1";\r\n  };\r\n\r\n  // CLICK: Select data point for detailed view\r\n  const handleClick = (data, index, event) => {\r\n    setSelectedData(data);\r\n\r\n    // Prevent event bubbling\r\n    event.stopPropagation();\r\n\r\n    console.log("Selected data:", data);\r\n\r\n    // Optional: Trigger external actions\r\n    // onDataSelect(data);\r\n    // navigateToDetail(data.id);\r\n  };\r\n\r\n  // DOUBLE CLICK: Reset selection or zoom\r\n  const handleDoubleClick = () => {\r\n    setSelectedData(null);\r\n    setZoomedRange(null);\r\n  };\r\n\r\n  // BRUSH SELECTION: Handle range selection for zooming\r\n  const handleBrushChange = (range) => {\r\n    if (range && range.startIndex !== range.endIndex) {\r\n      setZoomedRange(range);\r\n      console.log("Zoom range:", range);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div onDoubleClick={handleDoubleClick}>\r\n      {" "}\r\n      {/* Container for global events */}\r\n      <BarChart\r\n        data={data}\r\n        onMouseDown={(e) => console.log("Chart mouse down")}\r\n      >\r\n        <Bar\r\n          dataKey="value"\r\n          fill="#8884d8"\r\n          // Individual bar event handlers\r\n          onMouseEnter={handleMouseEnter}\r\n          onMouseLeave={handleMouseLeave}\r\n          onClick={handleClick}\r\n          // Dynamic styling based on interaction state\r\n          style={{\r\n            cursor: "pointer",\r\n            filter:\r\n              hoveredIndex !== null && hoveredIndex !== data.indexOf()\r\n                ? "brightness(0.7)"\r\n                : "brightness(1)",\r\n          }}\r\n        />\r\n\r\n        {/* Conditional highlighting for selected data */}\r\n        {selectedData && (\r\n          <Bar\r\n            dataKey="value"\r\n            data={[selectedData]} // Only show selected data\r\n            fill="#ff7300" // Different color for selection\r\n            isAnimationActive={false}\r\n          />\r\n        )}\r\n\r\n        <Tooltip\r\n          content={({ active, payload, label }) => {\r\n            if (active && payload) {\r\n              return (\r\n                <div>\r\n                  <p>{`${label}: ${payload[0].value}`}</p>\r\n                  {hoveredIndex !== null && <p>Index: {hoveredIndex}</p>}\r\n                  <p>Click to select</p>\r\n                </div>\r\n              );\r\n            }\r\n            return null;\r\n          }}\r\n        />\r\n\r\n        {/* Brush for range selection */}\r\n        <Brush dataKey="name" height={30} onChange={handleBrushChange} />\r\n      </BarChart>\r\n      {/* Display selected data information */}\r\n      {selectedData && (\r\n        <div className="selected-data-panel">\r\n          <h3>Selected Data</h3>\r\n          <p>Value: {selectedData.value}</p>\r\n          <p>Category: {selectedData.name}</p>\r\n          <button onClick={() => setSelectedData(null)}>Clear Selection</button>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Event Handling Best Practices"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Performance"}),": Use event delegation for large datasets"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Accessibility"}),": Ensure keyboard navigation works"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"State Management"}),": Keep interaction state separate from data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"User Feedback"}),": Provide clear visual feedback for interactions"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Why this matters"}),": Charts with large datasets or frequent updates can cause performance issues. This section shows optimization techniques to maintain smooth interactions."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Common Performance Issues"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Re-rendering on every data change"}),"\n",(0,a.jsx)(e.li,{children:"Expensive calculations on each render"}),"\n",(0,a.jsx)(e.li,{children:"Large datasets overwhelming the browser"}),"\n",(0,a.jsx)(e.li,{children:"Frequent resize events causing layout thrashing"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"memoization-and-optimization",children:"Memoization and Optimization"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this demonstrates"}),": Techniques to cache expensive calculations and prevent unnecessary re-renders using React optimization patterns."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Key Strategies"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"React.memo"}),": Prevent re-renders when props haven't changed"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"useMemo"}),": Cache expensive data transformations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Debouncing"}),": Limit frequency of expensive operations"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// OPTIMIZED CHART COMPONENT: Uses multiple optimization techniques\r\nconst OptimizedChart = React.memo(({ data, width, height }) => {\r\n  // MEMOIZE EXPENSIVE DATA PROCESSING: Only recalculate when data changes\r\n  const processedData = useMemo(() => {\r\n    console.log("Processing data..."); // This should only log when data actually changes\r\n\r\n    return data.map((item) => ({\r\n      ...item,\r\n      // Example expensive calculations that we want to cache\r\n      calculated: expensiveCalculation(item), // Mathematical transformations\r\n      normalized: item.value / maxValue, // Normalization\r\n      trend: calculateTrend(item, previousData), // Trend analysis\r\n    }));\r\n  }, [data]); // Only recalculate when \'data\' reference changes\r\n\r\n  // MEMOIZE SCALE CALCULATIONS: Recreate scales only when dependencies change\r\n  const scales = useMemo(() => {\r\n    console.log("Creating scales..."); // Should only log when dependencies change\r\n\r\n    return createScales(processedData, width, height);\r\n  }, [processedData, width, height]); // Recalculate when data or dimensions change\r\n\r\n  // DEBOUNCE RESIZE EVENTS: Prevent excessive recalculations during window resizing\r\n  const debouncedDimensions = useMemo(() => {\r\n    // Wait 100ms after last resize before updating\r\n    return debounce({ width, height }, 100);\r\n  }, [width, height]);\r\n\r\n  // OPTIMIZED RENDER: Chart only re-renders when memoized values change\r\n  return (\r\n    <LineChart data={processedData} {...debouncedDimensions}>\r\n      <Line dataKey="value" />\r\n    </LineChart>\r\n  );\r\n}); // React.memo prevents re-render if props are the same\r\n\r\n// VIRTUAL SCROLLING: Handle large datasets by only rendering visible portion\r\nconst VirtualizedChart = ({ data, itemHeight = 50 }) => {\r\n  // Track which data points are currently visible\r\n  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 100 });\r\n\r\n  // MEMOIZE VISIBLE DATA SLICE: Only include data points that should be rendered\r\n  const visibleData = useMemo(() => {\r\n    console.log(`Showing items ${visibleRange.start} to ${visibleRange.end}`);\r\n\r\n    // Only render data points in the visible range\r\n    return data.slice(visibleRange.start, visibleRange.end);\r\n  }, [data, visibleRange]); // Recalculate when data or visible range changes\r\n\r\n  // SCROLL HANDLER: Update visible range as user scrolls\r\n  const handleScroll = useCallback(\r\n    (e) => {\r\n      const scrollTop = e.target.scrollTop; // Current scroll position\r\n      const start = Math.floor(scrollTop / itemHeight); // First visible item\r\n      const end = start + Math.ceil(window.innerHeight / itemHeight); // Last visible item\r\n\r\n      // Only update if range actually changed (prevents unnecessary re-renders)\r\n      setVisibleRange((prevRange) => {\r\n        if (prevRange.start !== start || prevRange.end !== end) {\r\n          return { start, end };\r\n        }\r\n        return prevRange;\r\n      });\r\n    },\r\n    [itemHeight]\r\n  );\r\n\r\n  return (\r\n    <div\r\n      onScroll={handleScroll}\r\n      style={{ height: "400px", overflow: "auto" }} // Scrollable container\r\n    >\r\n      {/* Spacer to maintain scroll height for items above visible range */}\r\n      <div style={{ height: visibleRange.start * itemHeight }} />\r\n\r\n      {/* Chart showing only visible data */}\r\n      <LineChart data={visibleData} height={visibleData.length * itemHeight}>\r\n        <Line dataKey="value" />\r\n      </LineChart>\r\n\r\n      {/* Spacer to maintain scroll height for items below visible range */}\r\n      <div style={{ height: (data.length - visibleRange.end) * itemHeight }} />\r\n    </div>\r\n  );\r\n};\r\n\r\n// DEBOUNCE UTILITY: Limits function execution frequency\r\nconst debounce = (value, delay) => {\r\n  const [debouncedValue, setDebouncedValue] = useState(value);\r\n\r\n  useEffect(() => {\r\n    // Set up timer to update value after delay\r\n    const handler = setTimeout(() => {\r\n      setDebouncedValue(value);\r\n    }, delay);\r\n\r\n    // Clear timer if value changes before delay expires\r\n    return () => {\r\n      clearTimeout(handler);\r\n    };\r\n  }, [value, delay]);\r\n\r\n  return debouncedValue;\r\n};\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Performance Best Practices"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Memoize Heavy Calculations"}),": Use useMemo for data transformations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Optimize Re-renders"}),": Use React.memo and useCallback appropriately"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Virtual Scrolling"}),": Only render visible data for large datasets"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Debounce Events"}),": Limit frequency of resize/scroll handlers"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Data Structure"}),": Keep data flat and avoid deep object comparisons"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(e.h3,{id:"component-organization",children:"Component Organization"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Reusable chart components\r\nconst BaseChart = ({ children, ...props }) => (\r\n  <ResponsiveContainer width="100%" height={400}>\r\n    <LineChart {...props}>\r\n      <CartesianGrid strokeDasharray="3 3" />\r\n      <XAxis dataKey="name" />\r\n      <YAxis />\r\n      <Tooltip />\r\n      <Legend />\r\n      {children}\r\n    </LineChart>\r\n  </ResponsiveContainer>\r\n);\r\n\r\n// Specialized chart variants\r\nconst SalesChart = ({ data }) => (\r\n  <BaseChart data={data}>\r\n    <Line dataKey="sales" stroke="#8884d8" name="Sales" />\r\n    <Line dataKey="profit" stroke="#82ca9d" name="Profit" />\r\n  </BaseChart>\r\n);\r\n\r\nconst PerformanceChart = ({ data }) => (\r\n  <BaseChart data={data}>\r\n    <Line dataKey="cpu" stroke="#ff7300" name="CPU Usage" />\r\n    <Line dataKey="memory" stroke="#387908" name="Memory Usage" />\r\n  </BaseChart>\r\n);\n'})}),"\n",(0,a.jsx)(e.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Error boundary for charts\r\nclass ChartErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { hasError: false, error: null };\r\n  }\r\n\r\n  static getDerivedStateFromError(error) {\r\n    return { hasError: true, error };\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return (\r\n        <div className="chart-error">\r\n          <p>Unable to render chart</p>\r\n          <button\r\n            onClick={() => this.setState({ hasError: false, error: null })}\r\n          >\r\n            Retry\r\n          </button>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\n// Safe chart wrapper\r\nconst SafeChart = ({ data, ...props }) => {\r\n  if (!data || data.length === 0) {\r\n    return <div className="no-data">No data available</div>;\r\n  }\r\n\r\n  return (\r\n    <ChartErrorBoundary>\r\n      <LineChart data={data} {...props}>\r\n        <Line dataKey="value" />\r\n      </LineChart>\r\n    </ChartErrorBoundary>\r\n  );\r\n};\n'})}),"\n",(0,a.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(e.p,{children:"Recharts provides a powerful and flexible solution for creating data visualizations in React applications. By leveraging React's component model and D3's mathematical utilities, it offers a declarative approach to building charts while maintaining the performance and capabilities needed for complex visualizations."}),"\n",(0,a.jsx)(e.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Component Composition"}),": Recharts' modular architecture enables flexible chart creation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"D3 Integration"}),": Leverages D3 for calculations while React handles rendering"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"SVG-Based"}),": Native SVG support ensures crisp rendering and accessibility"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Performance"}),": Proper memoization and optimization strategies ensure smooth interactions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Customization"}),": Extensive customization options through props and custom components"]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:["As referenced in the ",(0,a.jsx)(e.a,{href:"https://github.com/recharts/recharts",children:"Recharts GitHub repository"}),", the library continues to evolve with strong community support and comprehensive documentation for modern data visualization needs."]}),"\n",(0,a.jsx)(e.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://recharts.org/",children:"Recharts Documentation"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://github.com/recharts/recharts",children:"Recharts GitHub Repository"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://recharts.org/en-US/examples",children:"Recharts Examples"})}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>s,x:()=>o});var t=r(6540);const a={},i=t.createContext(a);function s(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);