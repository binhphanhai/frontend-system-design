"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1561],{5201:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"project-detail/redux","title":"Redux: Predictable State Management","description":"Table of Contents","source":"@site/docs/project-detail/redux.md","sourceDirName":"project-detail","slug":"/project-detail/redux","permalink":"/frontend-system-design/docs/project-detail/redux","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/redux.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Ant Design: Enterprise-Class UI Library","permalink":"/frontend-system-design/docs/project-detail/ant-design"},"next":{"title":"Redux Toolkit: Modern Redux Development","permalink":"/frontend-system-design/docs/project-detail/redux-toolkit"}}');var o=n(4848),s=n(8453);const i={},a="Redux: Predictable State Management",d={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Principles",id:"key-principles",level:3},{value:"When to Use Redux",id:"when-to-use-redux",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Actions",id:"actions",level:3},{value:"Reducers",id:"reducers",level:3},{value:"Store",id:"store",level:3},{value:"Getting Started",id:"getting-started",level:2},{value:"Installation",id:"installation",level:3},{value:"Basic Setup with React",id:"basic-setup-with-react",level:3},{value:"Connecting Components",id:"connecting-components",level:3},{value:"Under the Hood: How Redux Works",id:"under-the-hood-how-redux-works",level:2},{value:"State Tree Structure",id:"state-tree-structure",level:3},{value:"Store Implementation Simplified",id:"store-implementation-simplified",level:3},{value:"Action Dispatch Flow",id:"action-dispatch-flow",level:3},{value:"Redux Toolkit (Modern Redux)",id:"redux-toolkit-modern-redux",level:2},{value:"Setting Up with Redux Toolkit",id:"setting-up-with-redux-toolkit",level:3},{value:"Creating Slices",id:"creating-slices",level:3},{value:"Modern React Hooks Usage",id:"modern-react-hooks-usage",level:3},{value:"Middleware and Async Actions",id:"middleware-and-async-actions",level:2},{value:"Redux Thunk for Async Actions",id:"redux-thunk-for-async-actions",level:3},{value:"RTK Query for Data Fetching",id:"rtk-query-for-data-fetching",level:3},{value:"Custom Middleware",id:"custom-middleware",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Selector Optimization",id:"selector-optimization",level:3},{value:"Component Optimization",id:"component-optimization",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"State Structure",id:"state-structure",level:3},{value:"Action Design",id:"action-design",level:3},{value:"Reducer Guidelines",id:"reducer-guidelines",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Further Resources",id:"further-resources",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"redux-predictable-state-management",children:"Redux: Predictable State Management"})}),"\n",(0,o.jsx)(t.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#core-concepts",children:"Core Concepts"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#getting-started",children:"Getting Started"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#under-the-hood-how-redux-works",children:"Under the Hood: How Redux Works"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#redux-toolkit-modern-redux",children:"Redux Toolkit (Modern Redux)"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#middleware-and-async-actions",children:"Middleware and Async Actions"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsxs)(t.p,{children:["Redux is a predictable state container for JavaScript applications, most commonly used with React. As highlighted in the ",(0,o.jsx)(t.a,{href:"https://github.com/reduxjs/redux",children:"Redux GitHub repository"}),", it helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test."]}),"\n",(0,o.jsx)(t.h3,{id:"key-principles",children:"Key Principles"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Single Source of Truth"}),": The global state is stored in a single store"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"State is Read-Only"}),": The only way to change state is by dispatching actions"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Changes are Made with Pure Functions"}),": Reducers specify how the state tree is transformed"]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"when-to-use-redux",children:"When to Use Redux"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"You have reasonable amounts of data changing over time"}),"\n",(0,o.jsx)(t.li,{children:"You need a single source of truth for your state"}),"\n",(0,o.jsx)(t.li,{children:"You find that keeping all your state in a top-level component is no longer sufficient"}),"\n",(0,o.jsx)(t.li,{children:"You need to share data between components that don't have a parent-child relationship"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,o.jsx)(t.h3,{id:"actions",children:"Actions"}),"\n",(0,o.jsxs)(t.p,{children:["Actions are plain JavaScript objects that describe what happened in your application. They are the only way to trigger state changes in Redux and must have a ",(0,o.jsx)(t.code,{children:"type"})," property that indicates the type of action being performed."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"What this code does:"})," Defines action types and action creator functions for a todo application\r\n",(0,o.jsx)(t.strong,{children:"Steps:"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Define string constants for action types (prevents typos and enables better tooling)"}),"\n",(0,o.jsx)(t.li,{children:"Create action creator functions that return action objects"}),"\n",(0,o.jsxs)(t.li,{children:["Include relevant data in the ",(0,o.jsx)(t.code,{children:"payload"})," property"]}),"\n",(0,o.jsx)(t.li,{children:"Follow consistent naming conventions for predictable patterns"}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Input:"})," Action creators receive parameters (text, id) to create specific actions\r\n",(0,o.jsx)(t.strong,{children:"Output:"})," Plain JavaScript objects with ",(0,o.jsx)(t.code,{children:"type"})," and ",(0,o.jsx)(t.code,{children:"payload"})," properties that describe state changes"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Key concepts:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Action types are string constants that describe what happened"}),"\n",(0,o.jsx)(t.li,{children:"Action creators are functions that return action objects"}),"\n",(0,o.jsx)(t.li,{children:"Payload contains the data needed to perform the state change"}),"\n",(0,o.jsx)(t.li,{children:"Actions are dispatched to the store to trigger state updates"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// Action types - string constants prevent typos and enable IDE autocomplete\r\nconst ADD_TODO = "ADD_TODO"; // Action to add a new todo item\r\nconst TOGGLE_TODO = "TOGGLE_TODO"; // Action to toggle todo completion status\r\nconst DELETE_TODO = "DELETE_TODO"; // Action to remove a todo item\r\n\r\n// Action creators - functions that return action objects\r\n// These provide a consistent API for creating actions with proper structure\r\n\r\nconst addTodo = (text) => ({\r\n  type: ADD_TODO, // Required: describes what happened\r\n  payload: {\r\n    // Optional: data needed for the action\r\n    id: Date.now(), // Simple ID generation (use uuid in production)\r\n    text, // The todo text from user input\r\n    completed: false, // New todos start as incomplete\r\n  },\r\n});\r\n\r\nconst toggleTodo = (id) => ({\r\n  type: TOGGLE_TODO,\r\n  payload: { id }, // Only need the ID to find and toggle the todo\r\n});\r\n\r\nconst deleteTodo = (id) => ({\r\n  type: DELETE_TODO,\r\n  payload: { id }, // Only need the ID to find and delete the todo\r\n});\r\n\r\n// Example usage:\r\n// dispatch(addTodo("Learn Redux"));     // Creates: { type: "ADD_TODO", payload: { id: 123, text: "Learn Redux", completed: false } }\r\n// dispatch(toggleTodo(123));            // Creates: { type: "TOGGLE_TODO", payload: { id: 123 } }\r\n// dispatch(deleteTodo(123));            // Creates: { type: "DELETE_TODO", payload: { id: 123 } }\n'})}),"\n",(0,o.jsx)(t.h3,{id:"reducers",children:"Reducers"}),"\n",(0,o.jsx)(t.p,{children:"Reducers are pure functions that take the current state and an action, and return a new state. They specify how the application's state changes in response to actions and must follow strict rules: they must be pure, never mutate state directly, and always return a new state object."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"What this code does:"})," Implements a reducer function that manages todo list state\r\n",(0,o.jsx)(t.strong,{children:"Steps:"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Define initial state structure with todos array and filter setting"}),"\n",(0,o.jsx)(t.li,{children:"Create reducer function that accepts current state and action"}),"\n",(0,o.jsx)(t.li,{children:"Use switch statement to handle different action types"}),"\n",(0,o.jsx)(t.li,{children:"Return new state objects without mutating the original state"}),"\n",(0,o.jsx)(t.li,{children:"Handle unknown actions by returning current state unchanged"}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Input:"})," Current state object and action object with type and payload\r\n",(0,o.jsx)(t.strong,{children:"Output:"})," New state object with updated data based on the action"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Reducer rules:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Must be pure functions (same input always produces same output)"}),"\n",(0,o.jsx)(t.li,{children:"Never mutate the state directly"}),"\n",(0,o.jsx)(t.li,{children:"Always return a new state object for changes"}),"\n",(0,o.jsx)(t.li,{children:"Return current state for unknown action types"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"State immutability patterns:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Use spread operator (...) to copy objects and arrays"}),"\n",(0,o.jsx)(t.li,{children:"Use array methods like map(), filter() that return new arrays"}),"\n",(0,o.jsx)(t.li,{children:"Never use push(), pop(), splice() or direct property assignment"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// Initial state defines the structure and default values for the todo app\r\nconst initialState = {\r\n  todos: [], // Array to store all todo items\r\n  filter: "ALL", // Current filter: ALL, ACTIVE, COMPLETED\r\n};\r\n\r\n// Reducer function - the heart of Redux state management\r\n// Takes current state and action, returns new state\r\nconst todoReducer = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case ADD_TODO:\r\n      // Immutable update: create new state object with new todo added\r\n      return {\r\n        ...state, // Copy all existing state properties\r\n        todos: [...state.todos, action.payload], // Create new array with new todo\r\n      };\r\n\r\n    case TOGGLE_TODO:\r\n      // Immutable update: create new state with modified todo\r\n      return {\r\n        ...state, // Copy all existing state properties\r\n        todos: state.todos.map(\r\n          (\r\n            todo // Create new array with updated todo\r\n          ) =>\r\n            todo.id === action.payload.id\r\n              ? { ...todo, completed: !todo.completed } // Update matching todo\r\n              : todo // Keep other todos unchanged\r\n        ),\r\n      };\r\n\r\n    case DELETE_TODO:\r\n      // Immutable update: create new state without the deleted todo\r\n      return {\r\n        ...state, // Copy all existing state properties\r\n        todos: state.todos.filter(\r\n          (\r\n            todo // Create new array excluding deleted todo\r\n          ) => todo.id !== action.payload.id\r\n        ),\r\n      };\r\n\r\n    default:\r\n      // Always return current state for unknown actions\r\n      // This ensures the reducer handles any action type gracefully\r\n      return state;\r\n  }\r\n};\r\n\r\n// Example state transformations:\r\n// Initial: { todos: [], filter: "ALL" }\r\n// ADD_TODO: { todos: [{ id: 1, text: "Learn Redux", completed: false }], filter: "ALL" }\r\n// TOGGLE_TODO: { todos: [{ id: 1, text: "Learn Redux", completed: true }], filter: "ALL" }\r\n// DELETE_TODO: { todos: [], filter: "ALL" }\n'})}),"\n",(0,o.jsx)(t.h3,{id:"store",children:"Store"}),"\n",(0,o.jsx)(t.p,{children:"The store holds the complete state tree of your application and provides methods to access state, dispatch actions, and subscribe to changes. It's the central hub that coordinates all Redux operations and ensures predictable state management."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"What this code does:"})," Creates a Redux store and demonstrates basic store operations\r\n",(0,o.jsx)(t.strong,{children:"Steps:"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Import createStore function from Redux"}),"\n",(0,o.jsx)(t.li,{children:"Create store by passing in the root reducer"}),"\n",(0,o.jsx)(t.li,{children:"Subscribe to state changes for debugging/logging"}),"\n",(0,o.jsx)(t.li,{children:"Dispatch actions to trigger state updates"}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Input:"})," Reducer function that defines how state changes\r\n",(0,o.jsx)(t.strong,{children:"Output:"})," Store object with methods to interact with application state"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Store methods:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"getState()"}),": Returns the current state tree"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"dispatch(action)"}),": Sends an action to update state"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"subscribe(listener)"}),": Registers a callback for state changes"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"replaceReducer(nextReducer)"}),": Replaces the current reducer (advanced use)"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Store responsibilities:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Holds the complete application state"}),"\n",(0,o.jsx)(t.li,{children:"Provides access to state via getState()"}),"\n",(0,o.jsx)(t.li,{children:"Allows state updates via dispatch(action)"}),"\n",(0,o.jsx)(t.li,{children:"Registers listeners via subscribe(listener)"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'import { createStore } from "redux";\r\n\r\n// Create the Redux store with our todo reducer\r\n// The store holds the entire state tree and manages all state changes\r\nconst store = createStore(todoReducer);\r\n\r\n// Subscribe to state changes - useful for debugging and side effects\r\n// The listener function runs every time the state is updated\r\nstore.subscribe(() => {\r\n  console.log("State updated:", store.getState());\r\n  // This will log the complete state tree after each action\r\n  // In a real app, this is where you might trigger re-renders or side effects\r\n});\r\n\r\n// Dispatch actions to modify the state\r\n// Each dispatch call triggers the reducer and updates the state\r\n\r\nstore.dispatch(addTodo("Learn Redux"));\r\n// State after: { todos: [{ id: timestamp1, text: "Learn Redux", completed: false }], filter: "ALL" }\r\n\r\nstore.dispatch(addTodo("Build amazing apps"));\r\n// State after: { todos: [{ id: timestamp1, text: "Learn Redux", completed: false },\r\n//                       { id: timestamp2, text: "Build amazing apps", completed: false }], filter: "ALL" }\r\n\r\nstore.dispatch(toggleTodo(timestamp1));\r\n// State after: { todos: [{ id: timestamp1, text: "Learn Redux", completed: true },\r\n//                       { id: timestamp2, text: "Build amazing apps", completed: false }], filter: "ALL" }\r\n\r\n// Access current state at any time\r\nconsole.log("Current state:", store.getState());\r\n\r\n// The store ensures:\r\n// 1. State is only modified through dispatched actions\r\n// 2. All state changes go through the reducer\r\n// 3. Subscribers are notified of every state change\r\n// 4. State remains predictable and debuggable\n'})}),"\n",(0,o.jsx)(t.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,o.jsx)(t.h3,{id:"installation",children:"Installation"}),"\n",(0,o.jsx)(t.p,{children:"Before you can use Redux in your React application, you need to install the necessary packages. There are two main approaches: using core Redux for learning, or using Redux Toolkit for production applications."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"What this does:"})," Installs Redux libraries for state management in React applications\r\n",(0,o.jsx)(t.strong,{children:"Options:"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Core Redux: Basic Redux with React bindings (good for learning)"}),"\n",(0,o.jsx)(t.li,{children:"Redux Toolkit: Modern, opinionated Redux with best practices built-in (recommended)"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Packages explained:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"redux"}),": Core Redux library for state management"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"react-redux"}),": Official React bindings for Redux"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"@reduxjs/toolkit"}),": Modern Redux with simplified API and built-in best practices"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-bash",children:"# Option 1: Core Redux (for learning purposes)\r\n# Use this to understand fundamental Redux concepts\r\nnpm install redux react-redux\r\n\r\n# Option 2: Modern approach with Redux Toolkit (recommended for production)\r\n# Redux Toolkit includes Redux, Immer, Redux Thunk, and other utilities\r\nnpm install @reduxjs/toolkit react-redux\r\n\r\n# Additional packages you might need:\r\n# npm install redux-devtools-extension  # For Redux DevTools (if not using RTK)\r\n# npm install redux-thunk               # For async actions (if not using RTK)\r\n# npm install reselect                  # For memoized selectors (if not using RTK)\n"})}),"\n",(0,o.jsx)(t.h3,{id:"basic-setup-with-react",children:"Basic Setup with React"}),"\n",(0,o.jsx)(t.p,{children:"Setting up Redux with React requires creating a store and providing it to your React application through the Provider component. This makes the Redux store available to all components in your app."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"What this code does:"})," Sets up Redux store and connects it to a React application\r\n",(0,o.jsx)(t.strong,{children:"Steps:"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Create a Redux store with your reducer"}),"\n",(0,o.jsx)(t.li,{children:"Import Provider component from react-redux"}),"\n",(0,o.jsx)(t.li,{children:"Wrap your app with Provider and pass the store"}),"\n",(0,o.jsx)(t.li,{children:"All child components can now access Redux state"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"File structure:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"store.js"}),": Creates and configures the Redux store"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"App.js"}),": Root component that provides store to the app"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"TodoApp.js"}),": Main application component that uses Redux"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Key concepts:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Provider makes store available to all components via React context"}),"\n",(0,o.jsx)(t.li,{children:"Only components wrapped by Provider can access Redux state"}),"\n",(0,o.jsx)(t.li,{children:"Store should be created once at the application root"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// store.js - Central store configuration\r\nimport { createStore } from "redux";\r\nimport todoReducer from "./reducers/todoReducer";\r\n\r\n// Create the Redux store with our root reducer\r\n// This store will hold the entire application state\r\nconst store = createStore(\r\n  todoReducer,                           // Root reducer that manages state updates\r\n  window.__REDUX_DEVTOOLS_EXTENSION__ && // Enable Redux DevTools in development\r\n    window.__REDUX_DEVTOOLS_EXTENSION__()\r\n);\r\n\r\nexport default store;\r\n\r\n// App.js - Root component that provides Redux store to the entire app\r\nimport React from "react";\r\nimport { Provider } from "react-redux";   // React-Redux integration component\r\nimport store from "./store";             // Our configured Redux store\r\nimport TodoApp from "./TodoApp";         // Main application component\r\n\r\nfunction App() {\r\n  return (\r\n    {/* Provider makes Redux store available to all child components */}\r\n    <Provider store={store}>\r\n      {/* TodoApp and all its children can now access Redux state */}\r\n      <TodoApp />\r\n    </Provider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n// Alternative setup with error boundaries and additional providers\r\nfunction AppWithErrorBoundary() {\r\n  return (\r\n    <ErrorBoundary>                      {/* Catch and handle errors */}\r\n      <Provider store={store}>           {/* Provide Redux store */}\r\n        <Router>                         {/* Routing (if using React Router) */}\r\n          <ThemeProvider>                {/* UI theming (if needed) */}\r\n            <TodoApp />\r\n          </ThemeProvider>\r\n        </Router>\r\n      </Provider>\r\n    </ErrorBoundary>\r\n  );\r\n}\n'})}),"\n",(0,o.jsx)(t.h3,{id:"connecting-components",children:"Connecting Components"}),"\n",(0,o.jsxs)(t.p,{children:["Connecting React components to Redux involves accessing state from the store and dispatching actions to update that state. The traditional approach uses the ",(0,o.jsx)(t.code,{children:"connect"})," higher-order component (HOC) to map state and dispatch to component props."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"What this code does:"})," Connects a React component to Redux store using the classic connect HOC\r\n",(0,o.jsx)(t.strong,{children:"Steps:"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Import connect function from react-redux"}),"\n",(0,o.jsx)(t.li,{children:"Create component that receives Redux state and actions as props"}),"\n",(0,o.jsx)(t.li,{children:"Define mapStateToProps to select needed state"}),"\n",(0,o.jsx)(t.li,{children:"Define mapDispatchToProps to provide action creators"}),"\n",(0,o.jsx)(t.li,{children:"Connect component using connect(mapStateToProps, mapDispatchToProps)"}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Input:"})," Redux state and action creators\r\n",(0,o.jsx)(t.strong,{children:"Output:"})," React component with access to Redux state and dispatch"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Connect pattern benefits:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Explicit mapping of state to props"}),"\n",(0,o.jsx)(t.li,{children:"Automatic re-rendering when relevant state changes"}),"\n",(0,o.jsx)(t.li,{children:"Action creators automatically bound to dispatch"}),"\n",(0,o.jsx)(t.li,{children:"Separation of concerns between state access and component logic"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Performance optimization:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Component only re-renders when mapped state changes"}),"\n",(0,o.jsx)(t.li,{children:"Shallow equality checking prevents unnecessary renders"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// TodoList.js - Component connected to Redux using classic connect HOC\r\nimport React from "react";\r\nimport { connect } from "react-redux"; // HOC for connecting to Redux\r\nimport { toggleTodo, deleteTodo } from "./actions"; // Action creators\r\n\r\n// Presentational component - receives all data via props\r\n// This component doesn\'t know about Redux, making it easily testable\r\nconst TodoList = ({ todos, toggleTodo, deleteTodo }) => (\r\n  <ul>\r\n    {todos.map((todo) => (\r\n      <li key={todo.id}>\r\n        {/* Click handler toggles todo completion status */}\r\n        <span\r\n          style={{\r\n            textDecoration: todo.completed ? "line-through" : "none",\r\n            cursor: "pointer", // Visual feedback for clickable element\r\n          }}\r\n          onClick={() => toggleTodo(todo.id)} // Dispatch toggle action with todo ID\r\n        >\r\n          {todo.text}\r\n        </span>\r\n\r\n        {/* Delete button dispatches delete action */}\r\n        <button\r\n          onClick={() => deleteTodo(todo.id)} // Dispatch delete action with todo ID\r\n          style={{ marginLeft: "10px" }}\r\n        >\r\n          Delete\r\n        </button>\r\n      </li>\r\n    ))}\r\n  </ul>\r\n);\r\n\r\n// mapStateToProps: Selects which parts of Redux state this component needs\r\n// This function runs every time the store state changes\r\nconst mapStateToProps = (state) => ({\r\n  todos: state.todos, // Extract todos array from state\r\n  // Could also derive computed values:\r\n  // todoCount: state.todos.length,\r\n  // completedCount: state.todos.filter(t => t.completed).length\r\n});\r\n\r\n// mapDispatchToProps: Defines which action creators are available as props\r\n// Two approaches: object shorthand (recommended) or function\r\nconst mapDispatchToProps = {\r\n  toggleTodo, // Action creator becomes prop function\r\n  deleteTodo, // Action creator becomes prop function\r\n};\r\n\r\n// Alternative function approach for mapDispatchToProps:\r\n// const mapDispatchToProps = (dispatch) => ({\r\n//   toggleTodo: (id) => dispatch(toggleTodo(id)),\r\n//   deleteTodo: (id) => dispatch(deleteTodo(id)),\r\n//   // This approach gives more control but is more verbose\r\n// });\r\n\r\n// connect() creates a higher-order component that:\r\n// 1. Subscribes to Redux store\r\n// 2. Passes selected state as props\r\n// 3. Passes bound action creators as props\r\n// 4. Re-renders component when relevant state changes\r\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoList);\r\n\r\n// The connected component can be used like any other React component:\r\n// <TodoList />\r\n// It automatically receives todos, toggleTodo, and deleteTodo as props\n'})}),"\n",(0,o.jsx)(t.h2,{id:"under-the-hood-how-redux-works",children:"Under the Hood: How Redux Works"}),"\n",(0,o.jsx)(t.h3,{id:"state-tree-structure",children:"State Tree Structure"}),"\n",(0,o.jsx)(t.p,{children:"Redux maintains your entire application state as a single JavaScript object called the state tree. This centralized approach makes state predictable, debuggable, and easy to reason about."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"What this code shows:"})," Example structure of a Redux state tree for a todo application\r\n",(0,o.jsx)(t.strong,{children:"Key principles:"})]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Single source of truth: all state in one object"}),"\n",(0,o.jsx)(t.li,{children:"Nested structure organizes related data"}),"\n",(0,o.jsx)(t.li,{children:"Each piece of state has a specific purpose"}),"\n",(0,o.jsx)(t.li,{children:"State shape determines how you'll access data in components"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"State organization strategies:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Group related data together (todos, user info, UI state)"}),"\n",(0,o.jsx)(t.li,{children:"Keep state flat when possible to avoid deep nesting"}),"\n",(0,o.jsx)(t.li,{children:"Separate domain data from UI state"}),"\n",(0,o.jsx)(t.li,{children:"Use consistent naming conventions"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Benefits of centralized state:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Easy to debug with Redux DevTools"}),"\n",(0,o.jsx)(t.li,{children:"Time-travel debugging capabilities"}),"\n",(0,o.jsx)(t.li,{children:"Predictable data flow"}),"\n",(0,o.jsx)(t.li,{children:"Easy to persist or hydrate state"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// Redux state is a single JavaScript object - the complete application state\r\nconst stateTree = {\r\n  // Domain data: Core business logic and entities\r\n  todos: [\r\n    { id: 1, text: "Learn Redux", completed: false }, // Todo items with business data\r\n    { id: 2, text: "Build app", completed: true },\r\n  ],\r\n  filter: "ALL", // Current filter setting: ALL, ACTIVE, COMPLETED\r\n\r\n  // User data: Authentication and user information\r\n  user: {\r\n    id: 123,\r\n    name: "John Doe",\r\n    email: "john@example.com",\r\n    isAuthenticated: true, // Auth status\r\n    preferences: {\r\n      // User settings\r\n      theme: "dark",\r\n      language: "en",\r\n    },\r\n  },\r\n\r\n  // UI state: Interface state not related to domain data\r\n  ui: {\r\n    loading: false, // Global loading state\r\n    errors: [], // Error messages to display\r\n    modals: {\r\n      // Modal visibility states\r\n      editTodo: false,\r\n      confirmDelete: false,\r\n    },\r\n    sidebar: {\r\n      isOpen: true, // UI layout state\r\n      activeSection: "todos",\r\n    },\r\n  },\r\n\r\n  // Additional app state sections might include:\r\n  // api: { /* API call states, cache, etc. */ },\r\n  // router: { /* Current route, history, etc. */ },\r\n  // form: { /* Form data, validation states */ },\r\n};\r\n\r\n// State access examples:\r\n// state.todos                    // Array of all todos\r\n// state.user.isAuthenticated     // Boolean auth status\r\n// state.ui.loading              // Global loading state\r\n// state.user.preferences.theme   // User theme preference\r\n\r\n// The state tree structure determines:\r\n// 1. How you\'ll organize your reducers\r\n// 2. How components will select data\r\n// 3. How actions will update specific parts\r\n// 4. What your selectors will look like\n'})}),"\n",(0,o.jsx)(t.h3,{id:"store-implementation-simplified",children:"Store Implementation Simplified"}),"\n",(0,o.jsx)(t.p,{children:"Understanding how Redux store works internally helps you debug issues and appreciate the elegant simplicity of Redux's design. This simplified implementation shows the core mechanics of state management."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"What this code does:"})," Implements a simplified version of Redux's createStore function\r\n",(0,o.jsx)(t.strong,{children:"Key responsibilities:"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Holds the current state"}),"\n",(0,o.jsx)(t.li,{children:"Allows access to state via getState()"}),"\n",(0,o.jsx)(t.li,{children:"Allows state updates via dispatch(action)"}),"\n",(0,o.jsx)(t.li,{children:"Registers listeners via subscribe()"}),"\n",(0,o.jsx)(t.li,{children:"Prevents recursive dispatching"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Store architecture:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Closures maintain private state and listeners"}),"\n",(0,o.jsx)(t.li,{children:"Single state object holds entire application state"}),"\n",(0,o.jsx)(t.li,{children:"Observer pattern notifies components of changes"}),"\n",(0,o.jsx)(t.li,{children:"Dispatching is synchronous and prevents race conditions"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"How it ensures predictability:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"State can only be changed by dispatching actions"}),"\n",(0,o.jsx)(t.li,{children:"All changes go through the reducer function"}),"\n",(0,o.jsx)(t.li,{children:"Listeners are notified after state updates"}),"\n",(0,o.jsx)(t.li,{children:"No direct state mutation allowed"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// Simplified Redux store implementation - shows the core mechanics\r\nfunction createStore(reducer, preloadedState) {\r\n  let currentState = preloadedState; // Private state variable\r\n  let listeners = []; // Array of subscriber functions\r\n  let isDispatching = false; // Prevents recursive dispatching\r\n\r\n  // Returns current state snapshot\r\n  function getState() {\r\n    if (isDispatching) {\r\n      throw new Error(\r\n        "You may not call store.getState() while the reducer is executing."\r\n      );\r\n    }\r\n    return currentState; // Return current state immutably\r\n  }\r\n\r\n  // Registers a callback that runs when state changes\r\n  function subscribe(listener) {\r\n    if (typeof listener !== "function") {\r\n      throw new Error("Expected listener to be a function.");\r\n    }\r\n\r\n    listeners.push(listener); // Add listener to array\r\n\r\n    // Return unsubscribe function for cleanup\r\n    return function unsubscribe() {\r\n      const index = listeners.indexOf(listener);\r\n      listeners.splice(index, 1); // Remove listener from array\r\n    };\r\n  }\r\n\r\n  // Dispatches an action to update state\r\n  function dispatch(action) {\r\n    // Validate action structure\r\n    if (typeof action.type === "undefined") {\r\n      throw new Error("Actions must have a type property.");\r\n    }\r\n\r\n    // Prevent recursive dispatching (calling dispatch inside reducer)\r\n    if (isDispatching) {\r\n      throw new Error("Reducers may not dispatch actions.");\r\n    }\r\n\r\n    try {\r\n      isDispatching = true; // Set dispatching flag\r\n      currentState = reducer(currentState, action); // Calculate new state\r\n    } finally {\r\n      isDispatching = false; // Always reset flag\r\n    }\r\n\r\n    // Notify all subscribers of state change\r\n    listeners.forEach((listener) => {\r\n      try {\r\n        listener(); // Call each listener\r\n      } catch (error) {\r\n        console.error("Listener error:", error); // Prevent one bad listener from breaking others\r\n      }\r\n    });\r\n\r\n    return action; // Return action for middleware compatibility\r\n  }\r\n\r\n  // Initialize store with dummy action to setup initial state\r\n  dispatch({ type: "@@redux/INIT" + Math.random().toString(36) });\r\n\r\n  // Public API - only these methods are exposed\r\n  return {\r\n    dispatch, // Method to trigger state changes\r\n    subscribe, // Method to listen for state changes\r\n    getState, // Method to access current state\r\n  };\r\n}\r\n\r\n// Usage example:\r\n// const store = createStore(myReducer, initialState);\r\n// const unsubscribe = store.subscribe(() => console.log(store.getState()));\r\n// store.dispatch({ type: \'SOME_ACTION\', payload: data });\r\n// unsubscribe(); // Clean up when done\n'})}),"\n",(0,o.jsx)(t.h3,{id:"action-dispatch-flow",children:"Action Dispatch Flow"}),"\n",(0,o.jsx)(t.p,{children:"The Redux dispatch flow is a predictable sequence of steps that ensures state changes happen in a controlled, traceable manner. Understanding this flow helps you debug issues and optimize performance."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"What this shows:"})," The complete lifecycle of a Redux action from dispatch to UI update\r\n",(0,o.jsx)(t.strong,{children:"Flow stages:"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Action creation and dispatch"}),"\n",(0,o.jsx)(t.li,{children:"Reducer execution with current state"}),"\n",(0,o.jsx)(t.li,{children:"State update in store"}),"\n",(0,o.jsx)(t.li,{children:"Subscriber notification"}),"\n",(0,o.jsx)(t.li,{children:"Component re-rendering"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Timing characteristics:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Synchronous execution (unless middleware intervenes)"}),"\n",(0,o.jsx)(t.li,{children:"Atomic updates (all or nothing)"}),"\n",(0,o.jsx)(t.li,{children:"Predictable order of operations"}),"\n",(0,o.jsx)(t.li,{children:"Traceable with Redux DevTools"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Performance implications:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"All subscribers are notified on every dispatch"}),"\n",(0,o.jsx)(t.li,{children:"Components re-render based on state changes"}),"\n",(0,o.jsx)(t.li,{children:"Memoization and selectors can optimize re-renders"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// Complete Redux dispatch flow - step by step breakdown\r\n\r\n// 1. Action is dispatched (triggered by user interaction or side effect)\r\nstore.dispatch(addTodo("Learn Redux"));\r\n// At this point: { type: "ADD_TODO", payload: { id: 123, text: "Learn Redux", completed: false } }\r\n\r\n// 2. Redux calls the reducer with current state and action\r\n// The reducer is a pure function that calculates the new state\r\nconst currentState = store.getState();\r\n// Current state: { todos: [], filter: "ALL" }\r\n\r\nconst newState = todoReducer(currentState, action);\r\n// Reducer processes the action and returns new state\r\n// New state: { todos: [{ id: 123, text: "Learn Redux", completed: false }], filter: "ALL" }\r\n\r\n// 3. Store saves the new state (replaces the old state entirely)\r\n// This happens inside the store\'s dispatch method\r\ncurrentState = newState;\r\n\r\n// 4. All subscribers are notified of the state change\r\n// Every component connected to Redux gets a chance to check if it needs to update\r\nlisteners.forEach((listener) => {\r\n  listener(); // Each listener checks if its relevant state changed\r\n});\r\n\r\n// 5. UI components re-render with new state\r\n// React-Redux optimizes this by only re-rendering components whose selected state changed\r\n\r\n// Detailed flow with middleware (e.g., Redux Thunk):\r\n/*\r\n1. store.dispatch(action) called\r\n2. Middleware chain processes action (can modify, delay, or create new actions)\r\n3. Action reaches reducer\r\n4. Reducer calculates new state\r\n5. Store updates state\r\n6. Subscribers notified\r\n7. Connected components check for changes\r\n8. Components re-render if their selected state changed\r\n*/\r\n\r\n// Example with timing:\r\nconsole.log("Before dispatch:", store.getState());\r\n// { todos: [], filter: "ALL" }\r\n\r\nstore.dispatch(addTodo("Learn Redux"));\r\n// Synchronous - state is updated immediately\r\n\r\nconsole.log("After dispatch:", store.getState());\r\n// { todos: [{ id: 123, text: "Learn Redux", completed: false }], filter: "ALL" }\r\n\r\n// This predictable flow enables:\r\n// - Time-travel debugging\r\n// - Action replay\r\n// - Predictable testing\r\n// - Performance optimization\n'})}),"\n",(0,o.jsx)(t.h2,{id:"redux-toolkit-modern-redux",children:"Redux Toolkit (Modern Redux)"}),"\n",(0,o.jsxs)(t.p,{children:["Redux Toolkit is the official recommended approach for writing Redux logic, as mentioned in the ",(0,o.jsx)(t.a,{href:"https://github.com/reduxjs/redux",children:"Redux repository"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"setting-up-with-redux-toolkit",children:"Setting Up with Redux Toolkit"}),"\n",(0,o.jsx)(t.p,{children:"Redux Toolkit (RTK) simplifies Redux setup by providing opinionated defaults and reducing boilerplate code. It includes utilities for store configuration, creating reducers, and handling immutable updates."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"What this code does:"})," Sets up a Redux store using Redux Toolkit's modern approach\r\n",(0,o.jsx)(t.strong,{children:"Steps:"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Import configureStore from Redux Toolkit"}),"\n",(0,o.jsx)(t.li,{children:"Import slice reducers from feature modules"}),"\n",(0,o.jsx)(t.li,{children:"Configure store with reducer object"}),"\n",(0,o.jsx)(t.li,{children:"Export typed store interfaces for TypeScript"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"RTK advantages over classic Redux:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"No boilerplate action types and creators"}),"\n",(0,o.jsx)(t.li,{children:"Built-in Immer for immutable updates"}),"\n",(0,o.jsx)(t.li,{children:"Redux DevTools automatically configured"}),"\n",(0,o.jsx)(t.li,{children:"Redux Thunk included by default"}),"\n",(0,o.jsx)(t.li,{children:"Better TypeScript support"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"configureStore benefits:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Automatic middleware setup"}),"\n",(0,o.jsx)(t.li,{children:"Development-time checks for common mistakes"}),"\n",(0,o.jsx)(t.li,{children:"Simplified store configuration"}),"\n",(0,o.jsx)(t.li,{children:"Built-in dev tools integration"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// store.js - Modern Redux store setup with Redux Toolkit\r\nimport { configureStore } from "@reduxjs/toolkit";\r\nimport todoSlice from "./features/todoSlice"; // Import slice reducer\r\nimport userSlice from "./features/userSlice"; // Additional feature slice\r\nimport uiSlice from "./features/uiSlice"; // UI state slice\r\n\r\n// Configure store with RTK - replaces createStore + middleware setup\r\nexport const store = configureStore({\r\n  reducer: {\r\n    todos: todoSlice, // Each slice manages part of state\r\n    user: userSlice, // Combines multiple reducers automatically\r\n    ui: uiSlice,\r\n  },\r\n\r\n  // Optional: customize middleware (RTK provides good defaults)\r\n  middleware: (getDefaultMiddleware) =>\r\n    getDefaultMiddleware({\r\n      serializableCheck: {\r\n        ignoredActions: ["persist/PERSIST"], // Ignore non-serializable actions\r\n        ignoredPaths: ["register"], // Ignore non-serializable state paths\r\n      },\r\n    }),\r\n\r\n  // Optional: add custom enhancers\r\n  enhancers: (getDefaultEnhancers) =>\r\n    getDefaultEnhancers({\r\n      autoBatch: false, // Disable automatic batching if needed\r\n    }),\r\n\r\n  // Development-only options\r\n  devTools: process.env.NODE_ENV !== "production", // Enable Redux DevTools in development\r\n});\r\n\r\n// TypeScript type exports for strong typing throughout the app\r\nexport type RootState = ReturnType<typeof store.getState>;\r\n// RootState represents the complete state tree shape:\r\n// { todos: TodoState, user: UserState, ui: UIState }\r\n\r\nexport type AppDispatch = typeof store.dispatch;\r\n// AppDispatch includes types for any custom middleware\r\n\r\n// Usage in React components with TypeScript:\r\n// const todos = useSelector((state: RootState) => state.todos);\r\n// const dispatch = useDispatch<AppDispatch>();\r\n\r\n// Store configuration comparison:\r\n// Classic Redux: ~50 lines of boilerplate\r\n// Redux Toolkit: ~10 lines with better defaults\r\n\r\n// RTK automatically includes:\r\n// - Redux Thunk for async actions\r\n// - Redux DevTools Extension\r\n// - Immutability checks (development)\r\n// - Serializability checks (development)\r\n// - Action creator type checking\n'})}),"\n",(0,o.jsx)(t.h3,{id:"creating-slices",children:"Creating Slices"}),"\n",(0,o.jsxs)(t.p,{children:["Redux Toolkit's ",(0,o.jsx)(t.code,{children:"createSlice"}),' function is the modern way to write Redux logic. It automatically generates action creators and action types, and uses Immer internally to allow "mutative" logic while maintaining immutability.']}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"What this code does:"})," Creates a complete Redux slice with reducers and action creators\r\n",(0,o.jsx)(t.strong,{children:"Steps:"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Define slice name and initial state"}),"\n",(0,o.jsx)(t.li,{children:'Write reducer functions using "mutative" syntax'}),"\n",(0,o.jsx)(t.li,{children:"Export generated action creators"}),"\n",(0,o.jsx)(t.li,{children:"Export the reducer for store configuration"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"createSlice benefits:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Auto-generates action creators and types"}),"\n",(0,o.jsx)(t.li,{children:"Eliminates action type constants"}),"\n",(0,o.jsx)(t.li,{children:"Uses Immer for immutable updates"}),"\n",(0,o.jsx)(t.li,{children:"Reduces boilerplate by 70-80%"}),"\n",(0,o.jsx)(t.li,{children:"Better TypeScript inference"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Immer integration:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Write code that looks like mutations"}),"\n",(0,o.jsx)(t.li,{children:"Immer creates immutable updates behind the scenes"}),"\n",(0,o.jsx)(t.li,{children:"Prevents accidental mutations"}),"\n",(0,o.jsx)(t.li,{children:"Maintains Redux's immutability guarantees"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// features/todoSlice.js - Modern Redux slice with RTK\r\nimport { createSlice, PayloadAction } from "@reduxjs/toolkit";\r\n\r\n// Define the shape of our slice state\r\ninterface TodoState {\r\n  items: Todo[];\r\n  filter: "ALL" | "ACTIVE" | "COMPLETED";\r\n  loading: boolean;\r\n}\r\n\r\ninterface Todo {\r\n  id: number;\r\n  text: string;\r\n  completed: boolean;\r\n  createdAt: string;\r\n}\r\n\r\n// Initial state for the slice\r\nconst initialState: TodoState = {\r\n  items: [],\r\n  filter: "ALL",\r\n  loading: false,\r\n};\r\n\r\n// Create slice with reducers and auto-generated actions\r\nconst todoSlice = createSlice({\r\n  name: "todos", // Used for action type prefixes\r\n  initialState,\r\n  reducers: {\r\n    // RTK uses Immer internally, so we can "mutate" the state safely\r\n    addTodo: (state, action: PayloadAction<string>) => {\r\n      // This looks like mutation but Immer makes it immutable\r\n      state.items.push({\r\n        id: Date.now(), // Simple ID (use nanoid in production)\r\n        text: action.payload,\r\n        completed: false,\r\n        createdAt: new Date().toISOString(),\r\n      });\r\n      // Equivalent classic Redux would require:\r\n      // return { ...state, items: [...state.items, newTodo] }\r\n    },\r\n\r\n    toggleTodo: (state, action: PayloadAction<number>) => {\r\n      // Find and update specific todo\r\n      const todo = state.items.find((todo) => todo.id === action.payload);\r\n      if (todo) {\r\n        todo.completed = !todo.completed; // Direct "mutation" with Immer\r\n      }\r\n      // Equivalent classic Redux would require complex spread operations\r\n    },\r\n\r\n    deleteTodo: (state, action: PayloadAction<number>) => {\r\n      // Filter creates new array - this is actually immutable\r\n      state.items = state.items.filter((todo) => todo.id !== action.payload);\r\n    },\r\n\r\n    setFilter: (\r\n      state,\r\n      action: PayloadAction<"ALL" | "ACTIVE" | "COMPLETED">\r\n    ) => {\r\n      state.filter = action.payload; // Simple property update\r\n    },\r\n\r\n    // Reducer for handling loading states\r\n    setLoading: (state, action: PayloadAction<boolean>) => {\r\n      state.loading = action.payload;\r\n    },\r\n\r\n    // Batch operations - multiple state updates in one action\r\n    clearCompleted: (state) => {\r\n      state.items = state.items.filter((todo) => !todo.completed);\r\n    },\r\n\r\n    // Complex reducer with multiple state changes\r\n    toggleAll: (state) => {\r\n      const allCompleted = state.items.every((todo) => todo.completed);\r\n      state.items.forEach((todo) => {\r\n        todo.completed = !allCompleted;\r\n      });\r\n    },\r\n  },\r\n});\r\n\r\n// Auto-generated action creators - no need to write these manually\r\nexport const {\r\n  addTodo, // Creates: { type: "todos/addTodo", payload: "text" }\r\n  toggleTodo, // Creates: { type: "todos/toggleTodo", payload: id }\r\n  deleteTodo, // Creates: { type: "todos/deleteTodo", payload: id }\r\n  setFilter, // Creates: { type: "todos/setFilter", payload: "ALL" }\r\n  setLoading,\r\n  clearCompleted,\r\n  toggleAll,\r\n} = todoSlice.actions;\r\n\r\n// Export reducer for store configuration\r\nexport default todoSlice.reducer;\r\n\r\n// The slice automatically creates:\r\n// 1. Action creators with correct TypeScript types\r\n// 2. Action type strings (todos/addTodo, todos/toggleTodo, etc.)\r\n// 3. A reducer function that handles all actions\r\n// 4. Proper immutable updates using Immer\r\n\r\n// Usage in components:\r\n// dispatch(addTodo("Learn RTK"));\r\n// dispatch(toggleTodo(123));\r\n// dispatch(setFilter("COMPLETED"));\n'})}),"\n",(0,o.jsx)(t.h3,{id:"modern-react-hooks-usage",children:"Modern React Hooks Usage"}),"\n",(0,o.jsxs)(t.p,{children:["Modern Redux development uses React hooks (",(0,o.jsx)(t.code,{children:"useSelector"})," and ",(0,o.jsx)(t.code,{children:"useDispatch"}),") instead of the ",(0,o.jsx)(t.code,{children:"connect"})," HOC. This approach provides a cleaner, more functional component style with better TypeScript support."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"What this code does:"})," Creates a React component using modern Redux hooks\r\n",(0,o.jsx)(t.strong,{children:"Steps:"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["Use ",(0,o.jsx)(t.code,{children:"useSelector"})," to access Redux state"]}),"\n",(0,o.jsxs)(t.li,{children:["Use ",(0,o.jsx)(t.code,{children:"useDispatch"})," to dispatch actions"]}),"\n",(0,o.jsx)(t.li,{children:"Handle form submission and user interactions"}),"\n",(0,o.jsx)(t.li,{children:"Render UI based on Redux state"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Hooks vs connect benefits:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Less boilerplate code"}),"\n",(0,o.jsx)(t.li,{children:"Better TypeScript inference"}),"\n",(0,o.jsx)(t.li,{children:"More flexible component composition"}),"\n",(0,o.jsx)(t.li,{children:"Easier to test individual pieces"}),"\n",(0,o.jsx)(t.li,{children:"Cleaner component code"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Performance considerations:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"useSelector"})," automatically subscribes to store updates"]}),"\n",(0,o.jsx)(t.li,{children:"Component re-renders when selected state changes"}),"\n",(0,o.jsx)(t.li,{children:"Use multiple selectors for better optimization"}),"\n",(0,o.jsx)(t.li,{children:"Memoize complex selectors"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// TodoApp.js - Modern Redux component using hooks\r\nimport React, { useState, useMemo } from "react";\r\nimport { useSelector, useDispatch } from "react-redux";\r\nimport {\r\n  addTodo,\r\n  toggleTodo,\r\n  deleteTodo,\r\n  setFilter,\r\n  clearCompleted\r\n} from "./features/todoSlice";\r\nimport type { RootState } from "./store";\r\n\r\nconst TodoApp = () => {\r\n  // Local component state for form input\r\n  const [inputText, setInputText] = useState("");\r\n\r\n  // Select state from Redux store using useSelector\r\n  const todos = useSelector((state: RootState) => state.todos.items);\r\n  const filter = useSelector((state: RootState) => state.todos.filter);\r\n  const loading = useSelector((state: RootState) => state.todos.loading);\r\n\r\n  // Get dispatch function to send actions\r\n  const dispatch = useDispatch();\r\n\r\n  // Memoized derived state to avoid recalculating on every render\r\n  const filteredTodos = useMemo(() => {\r\n    switch (filter) {\r\n      case \'ACTIVE\':\r\n        return todos.filter(todo => !todo.completed);\r\n      case \'COMPLETED\':\r\n        return todos.filter(todo => todo.completed);\r\n      default:\r\n        return todos;\r\n    }\r\n  }, [todos, filter]);\r\n\r\n  const completedCount = useMemo(() =>\r\n    todos.filter(todo => todo.completed).length,\r\n    [todos]\r\n  );\r\n\r\n  // Form submission handler\r\n  const handleSubmit = (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n    if (inputText.trim()) {\r\n      dispatch(addTodo(inputText.trim()));        // Dispatch action with payload\r\n      setInputText("");                           // Clear local state\r\n    }\r\n  };\r\n\r\n  // Filter change handler\r\n  const handleFilterChange = (newFilter: \'ALL\' | \'ACTIVE\' | \'COMPLETED\') => {\r\n    dispatch(setFilter(newFilter));\r\n  };\r\n\r\n  return (\r\n    <div className="todo-app">\r\n      {/* Form for adding new todos */}\r\n      <form onSubmit={handleSubmit}>\r\n        <input\r\n          type="text"\r\n          value={inputText}\r\n          onChange={(e) => setInputText(e.target.value)}\r\n          placeholder="Add a todo..."\r\n          disabled={loading}                      // Disable during loading\r\n        />\r\n        <button type="submit" disabled={loading || !inputText.trim()}>\r\n          {loading ? "Adding..." : "Add"}\r\n        </button>\r\n      </form>\r\n\r\n      {/* Filter buttons */}\r\n      <div className="filters">\r\n        {([\'ALL\', \'ACTIVE\', \'COMPLETED\'] as const).map((filterType) => (\r\n          <button\r\n            key={filterType}\r\n            onClick={() => handleFilterChange(filterType)}\r\n            className={filter === filterType ? \'active\' : \'\'}\r\n          >\r\n            {filterType}\r\n          </button>\r\n        ))}\r\n      </div>\r\n\r\n      {/* Todo list */}\r\n      <ul className="todo-list">\r\n        {filteredTodos.map((todo) => (\r\n          <li key={todo.id} className={todo.completed ? \'completed\' : \'\'}>\r\n            {/* Todo text - click to toggle completion */}\r\n            <span\r\n              style={{\r\n                textDecoration: todo.completed ? "line-through" : "none",\r\n                cursor: "pointer",\r\n                flex: 1,\r\n              }}\r\n              onClick={() => dispatch(toggleTodo(todo.id))} // Dispatch toggle action\r\n            >\r\n              {todo.text}\r\n            </span>\r\n\r\n            {/* Delete button */}\r\n            <button\r\n              onClick={() => dispatch(deleteTodo(todo.id))} // Dispatch delete action\r\n              className="delete-btn"\r\n              aria-label={`Delete ${todo.text}`}\r\n            >\r\n              Delete\r\n            </button>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n\r\n      {/* Todo statistics and bulk actions */}\r\n      <div className="todo-footer">\r\n        <span>{todos.length - completedCount} items left</span>\r\n\r\n        {completedCount > 0 && (\r\n          <button\r\n            onClick={() => dispatch(clearCompleted())}\r\n            className="clear-completed"\r\n          >\r\n            Clear completed ({completedCount})\r\n          </button>\r\n        )}\r\n      </div>\r\n\r\n      {/* Empty state */}\r\n      {todos.length === 0 && (\r\n        <div className="empty-state">\r\n          <p>No todos yet. Add one above!</p>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TodoApp;\r\n\r\n// Hook usage patterns:\r\n// 1. useSelector for reading state\r\n// 2. useDispatch for sending actions\r\n// 3. Multiple selectors for different state slices\r\n// 4. Memoization for derived state\r\n// 5. TypeScript for type safety\n'})}),"\n",(0,o.jsx)(t.h2,{id:"middleware-and-async-actions",children:"Middleware and Async Actions"}),"\n",(0,o.jsx)(t.h3,{id:"redux-thunk-for-async-actions",children:"Redux Thunk for Async Actions"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// Async action creator with Redux Thunk\r\nconst fetchTodos = () => async (dispatch, getState) => {\r\n  dispatch(setLoading(true));\r\n\r\n  try {\r\n    const response = await fetch("/api/todos");\r\n    const todos = await response.json();\r\n    dispatch(setTodos(todos));\r\n  } catch (error) {\r\n    dispatch(setError(error.message));\r\n  } finally {\r\n    dispatch(setLoading(false));\r\n  }\r\n};\r\n\r\n// Usage in component\r\nconst handleFetchTodos = () => {\r\n  dispatch(fetchTodos());\r\n};\n'})}),"\n",(0,o.jsx)(t.h3,{id:"rtk-query-for-data-fetching",children:"RTK Query for Data Fetching"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// api/todosApi.js\r\nimport { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";\r\n\r\nexport const todosApi = createApi({\r\n  reducerPath: "todosApi",\r\n  baseQuery: fetchBaseQuery({ baseUrl: "/api/" }),\r\n  tagTypes: ["Todo"],\r\n  endpoints: (builder) => ({\r\n    getTodos: builder.query({\r\n      query: () => "todos",\r\n      providesTags: ["Todo"],\r\n    }),\r\n    addTodo: builder.mutation({\r\n      query: (newTodo) => ({\r\n        url: "todos",\r\n        method: "POST",\r\n        body: newTodo,\r\n      }),\r\n      invalidatesTags: ["Todo"],\r\n    }),\r\n  }),\r\n});\r\n\r\nexport const { useGetTodosQuery, useAddTodoMutation } = todosApi;\n'})}),"\n",(0,o.jsx)(t.h3,{id:"custom-middleware",children:"Custom Middleware"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// Logger middleware\r\nconst loggerMiddleware = (store) => (next) => (action) => {\r\n  console.log("Dispatching:", action);\r\n  const result = next(action);\r\n  console.log("Next state:", store.getState());\r\n  return result;\r\n};\r\n\r\n// Apply middleware\r\nconst store = configureStore({\r\n  reducer: rootReducer,\r\n  middleware: (getDefaultMiddleware) =>\r\n    getDefaultMiddleware().concat(loggerMiddleware),\r\n});\n'})}),"\n",(0,o.jsx)(t.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(t.h3,{id:"selector-optimization",children:"Selector Optimization"}),"\n",(0,o.jsx)(t.p,{children:"Selectors are functions that extract specific pieces of state from the Redux store. Memoized selectors prevent unnecessary recalculations and component re-renders by only recalculating when their input values change."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"What this code does:"})," Creates memoized selectors using createSelector for optimal performance\r\n",(0,o.jsx)(t.strong,{children:"Steps:"})]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Create basic selectors for raw state access"}),"\n",(0,o.jsx)(t.li,{children:"Create memoized selectors for derived/computed state"}),"\n",(0,o.jsx)(t.li,{children:"Use selectors in components via useSelector"}),"\n",(0,o.jsx)(t.li,{children:"Selectors only recalculate when input dependencies change"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Benefits of memoized selectors:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Prevent expensive recalculations"}),"\n",(0,o.jsx)(t.li,{children:"Reduce component re-renders"}),"\n",(0,o.jsx)(t.li,{children:"Improve app performance with large datasets"}),"\n",(0,o.jsx)(t.li,{children:"Enable complex data transformations"}),"\n",(0,o.jsx)(t.li,{children:"Better separation of concerns"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"When to use createSelector:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Expensive computations (filtering, sorting, aggregating)"}),"\n",(0,o.jsx)(t.li,{children:"Derived state calculations"}),"\n",(0,o.jsx)(t.li,{children:"Cross-slice data combinations"}),"\n",(0,o.jsx)(t.li,{children:"Complex data transformations"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'import { createSelector } from "@reduxjs/toolkit";\r\nimport type { RootState } from "../store";\r\n\r\n// Basic selectors - simple state extraction\r\nconst selectTodos = (state: RootState) => state.todos.items;\r\nconst selectFilter = (state: RootState) => state.todos.filter;\r\nconst selectSearchTerm = (state: RootState) => state.todos.searchTerm;\r\n\r\n// Memoized selector for filtered todos\r\n// Only recalculates when todos or filter change\r\nconst selectFilteredTodos = createSelector(\r\n  [selectTodos, selectFilter], // Input selectors\r\n  (todos, filter) => {\r\n    // Result function\r\n    console.log("Recalculating filtered todos"); // Only logs when recalculating\r\n\r\n    switch (filter) {\r\n      case "ACTIVE":\r\n        return todos.filter((todo) => !todo.completed);\r\n      case "COMPLETED":\r\n        return todos.filter((todo) => todo.completed);\r\n      default:\r\n        return todos;\r\n    }\r\n  }\r\n);\r\n\r\n// Complex memoized selector with multiple inputs\r\nconst selectSearchedAndFilteredTodos = createSelector(\r\n  [selectFilteredTodos, selectSearchTerm],\r\n  (filteredTodos, searchTerm) => {\r\n    if (!searchTerm) return filteredTodos;\r\n\r\n    return filteredTodos.filter((todo) =>\r\n      todo.text.toLowerCase().includes(searchTerm.toLowerCase())\r\n    );\r\n  }\r\n);\r\n\r\n// Aggregate data selectors\r\nconst selectTodoStats = createSelector([selectTodos], (todos) => ({\r\n  total: todos.length,\r\n  completed: todos.filter((todo) => todo.completed).length,\r\n  active: todos.filter((todo) => !todo.completed).length,\r\n  completionRate:\r\n    todos.length > 0\r\n      ? Math.round(\r\n          (todos.filter((todo) => todo.completed).length / todos.length) * 100\r\n        )\r\n      : 0,\r\n}));\r\n\r\n// Selector with parameters using factory pattern\r\nconst selectTodoById = createSelector(\r\n  [selectTodos, (state: RootState, todoId: number) => todoId],\r\n  (todos, todoId) => todos.find((todo) => todo.id === todoId)\r\n);\r\n\r\n// Usage in components\r\nconst TodoList = () => {\r\n  // Using memoized selectors - component only re-renders when result changes\r\n  const filteredTodos = useSelector(selectFilteredTodos);\r\n  const searchedTodos = useSelector(selectSearchedAndFilteredTodos);\r\n  const stats = useSelector(selectTodoStats);\r\n\r\n  // Using parametric selector with useCallback for stable reference\r\n  const specificTodoId = 123;\r\n  const specificTodo = useSelector(\r\n    useCallback(\r\n      (state: RootState) => selectTodoById(state, specificTodoId),\r\n      [specificTodoId]\r\n    )\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      <div>\r\n        Total: {stats.total}, Completed: {stats.completed}\r\n      </div>\r\n      {searchedTodos.map((todo) => (\r\n        <div key={todo.id}>{todo.text}</div>\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\n// Performance comparison:\r\n// Without selectors: Component recalculates filtered todos on every render\r\n// With selectors: Filtered todos only recalculated when todos or filter change\r\n// Result: 70-90% reduction in unnecessary calculations\n'})}),"\n",(0,o.jsx)(t.h3,{id:"component-optimization",children:"Component Optimization"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'import React, { memo } from "react";\r\n\r\n// Memoize component to prevent unnecessary re-renders\r\nconst TodoItem = memo(({ todo, onToggle, onDelete }) => (\r\n  <li>\r\n    <span\r\n      style={{\r\n        textDecoration: todo.completed ? "line-through" : "none",\r\n      }}\r\n      onClick={() => onToggle(todo.id)}\r\n    >\r\n      {todo.text}\r\n    </span>\r\n    <button onClick={() => onDelete(todo.id)}>Delete</button>\r\n  </li>\r\n));\r\n\r\n// Use callback hooks for stable references\r\nconst TodoList = () => {\r\n  const todos = useSelector(selectFilteredTodos);\r\n  const dispatch = useDispatch();\r\n\r\n  const handleToggle = useCallback(\r\n    (id) => dispatch(toggleTodo(id)),\r\n    [dispatch]\r\n  );\r\n\r\n  const handleDelete = useCallback(\r\n    (id) => dispatch(deleteTodo(id)),\r\n    [dispatch]\r\n  );\r\n\r\n  return (\r\n    <ul>\r\n      {todos.map((todo) => (\r\n        <TodoItem\r\n          key={todo.id}\r\n          todo={todo}\r\n          onToggle={handleToggle}\r\n          onDelete={handleDelete}\r\n        />\r\n      ))}\r\n    </ul>\r\n  );\r\n};\n'})}),"\n",(0,o.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(t.h3,{id:"state-structure",children:"State Structure"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// \u2705 Good - Normalized state\r\nconst goodState = {\r\n  todos: {\r\n    byId: {\r\n      1: { id: 1, text: "Learn Redux", completed: false },\r\n      2: { id: 2, text: "Build app", completed: true },\r\n    },\r\n    allIds: [1, 2],\r\n  },\r\n  visibilityFilter: "ALL",\r\n};\r\n\r\n// \u274c Bad - Nested and denormalized\r\nconst badState = {\r\n  todos: [\r\n    {\r\n      id: 1,\r\n      text: "Learn Redux",\r\n      completed: false,\r\n      author: {\r\n        id: 1,\r\n        name: "John",\r\n        todos: [\r\n          /* circular reference */\r\n        ],\r\n      },\r\n    },\r\n  ],\r\n};\n'})}),"\n",(0,o.jsx)(t.h3,{id:"action-design",children:"Action Design"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// \u2705 Good - Descriptive action types and consistent structure\r\nconst FETCH_USERS_REQUEST = "users/fetchRequest";\r\nconst FETCH_USERS_SUCCESS = "users/fetchSuccess";\r\nconst FETCH_USERS_FAILURE = "users/fetchFailure";\r\n\r\nconst fetchUsersRequest = () => ({\r\n  type: FETCH_USERS_REQUEST,\r\n});\r\n\r\nconst fetchUsersSuccess = (users) => ({\r\n  type: FETCH_USERS_SUCCESS,\r\n  payload: users,\r\n});\r\n\r\nconst fetchUsersFailure = (error) => ({\r\n  type: FETCH_USERS_FAILURE,\r\n  payload: error,\r\n  error: true,\r\n});\n'})}),"\n",(0,o.jsx)(t.h3,{id:"reducer-guidelines",children:"Reducer Guidelines"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"// \u2705 Good - Pure function, immutable updates\r\nconst todosReducer = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case ADD_TODO:\r\n      return {\r\n        ...state,\r\n        todos: [...state.todos, action.payload],\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\n// \u274c Bad - Mutating state\r\nconst badReducer = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case ADD_TODO:\r\n      state.todos.push(action.payload); // Direct mutation\r\n      return state;\r\n    default:\r\n      return state;\r\n  }\r\n};\n"})}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"Redux provides a powerful and predictable way to manage application state. While the core concepts remain the same, modern Redux development with Redux Toolkit significantly simplifies the development experience while maintaining all the benefits of the original Redux architecture."}),"\n",(0,o.jsx)(t.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Predictable State Management"}),": Single source of truth with unidirectional data flow"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Debugging and Time Travel"}),": Excellent developer tools for debugging and state inspection"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Middleware Ecosystem"}),": Powerful middleware system for handling side effects and async actions"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Performance Optimization"}),": Memoization and selective updates for optimal performance"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Modern Tooling"}),": Redux Toolkit provides excellent developer experience and best practices"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["As highlighted in the ",(0,o.jsx)(t.a,{href:"https://github.com/reduxjs/redux",children:"Redux GitHub repository"}),", Redux continues to be a valuable tool for organizing application state, especially when combined with modern tools like Redux Toolkit and RTK Query."]}),"\n",(0,o.jsx)(t.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://redux.js.org/",children:"Redux Documentation"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://redux-toolkit.js.org/",children:"Redux Toolkit Documentation"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://github.com/reduxjs/redux",children:"Redux GitHub Repository"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://react-redux.js.org/",children:"React-Redux Documentation"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var r=n(6540);const o={},s=r.createContext(o);function i(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);