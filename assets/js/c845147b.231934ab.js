"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[827],{676:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"project-detail/redux-toolkit","title":"Redux Toolkit: Modern Redux Development","description":"Table of Contents","source":"@site/docs/project-detail/redux-toolkit.md","sourceDirName":"project-detail","slug":"/project-detail/redux-toolkit","permalink":"/frontend-system-design/docs/project-detail/redux-toolkit","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/redux-toolkit.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Redux: Predictable State Management","permalink":"/frontend-system-design/docs/project-detail/redux"},"next":{"title":"React Router: Declarative Routing for React","permalink":"/frontend-system-design/docs/project-detail/react-router"}}');var o=r(4848),i=r(8453);const s={},a="Redux Toolkit: Modern Redux Development",d={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Core Problems Redux Toolkit Solves",id:"core-problems-redux-toolkit-solves",level:2},{value:"1. Store Configuration Complexity",id:"1-store-configuration-complexity",level:3},{value:"2. Boilerplate Reduction",id:"2-boilerplate-reduction",level:3},{value:"Installation and Setup",id:"installation-and-setup",level:2},{value:"Store Configuration",id:"store-configuration",level:3},{value:"Core APIs Deep Dive",id:"core-apis-deep-dive",level:2},{value:"createSlice() - The Heart of RTK",id:"createslice---the-heart-of-rtk",level:3},{value:"createAsyncThunk() - Async Logic",id:"createasyncthunk---async-logic",level:3},{value:"Under the Hood: How RTK Works",id:"under-the-hood-how-rtk-works",level:2},{value:"createSlice Implementation Concept",id:"createslice-implementation-concept",level:3},{value:"Immer Integration",id:"immer-integration",level:3},{value:"RTK Query: Data Fetching Solution",id:"rtk-query-data-fetching-solution",level:2},{value:"Basic RTK Query Setup",id:"basic-rtk-query-setup",level:3},{value:"Using RTK Query Hooks",id:"using-rtk-query-hooks",level:3},{value:"Advanced Patterns and Best Practices",id:"advanced-patterns-and-best-practices",level:2},{value:"Feature-Based File Structure",id:"feature-based-file-structure",level:3},{value:"Type-Safe Redux Hooks",id:"type-safe-redux-hooks",level:3},{value:"Slice Composition",id:"slice-composition",level:3},{value:"Performance Optimizations",id:"performance-optimizations",level:2},{value:"Selector Optimization",id:"selector-optimization",level:3},{value:"RTK Query Cache Configuration",id:"rtk-query-cache-configuration",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key RTK Advantages",id:"key-rtk-advantages",level:3},{value:"Further Resources",id:"further-resources",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"redux-toolkit-modern-redux-development",children:"Redux Toolkit: Modern Redux Development"})}),"\n",(0,o.jsx)(t.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#core-problems-redux-toolkit-solves",children:"Core Problems Redux Toolkit Solves"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#installation-and-setup",children:"Installation and Setup"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#core-apis-deep-dive",children:"Core APIs Deep Dive"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#under-the-hood-how-rtk-works",children:"Under the Hood: How RTK Works"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#rtk-query-data-fetching-solution",children:"RTK Query: Data Fetching Solution"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#advanced-patterns-and-best-practices",children:"Advanced Patterns and Best Practices"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#performance-optimizations",children:"Performance Optimizations"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsxs)(t.p,{children:["Redux Toolkit (RTK) is the official, opinionated, batteries-included toolset for efficient Redux development. As stated in the ",(0,o.jsx)(t.a,{href:"https://github.com/reduxjs/redux-toolkit",children:"Redux Toolkit GitHub repository"}),", it was created to address three common concerns about Redux: complex store configuration, excessive boilerplate code, and the need for multiple packages to make Redux useful."]}),"\n",(0,o.jsx)(t.p,{children:"Since you already understand Redux fundamentals, RTK essentially provides a layer of abstraction that simplifies Redux development while maintaining all the core principles and benefits of Redux."}),"\n",(0,o.jsx)(t.h2,{id:"core-problems-redux-toolkit-solves",children:"Core Problems Redux Toolkit Solves"}),"\n",(0,o.jsx)(t.h3,{id:"1-store-configuration-complexity",children:"1. Store Configuration Complexity"}),"\n",(0,o.jsx)(t.p,{children:"Traditional Redux store configuration requires multiple imports and manual setup of middleware, dev tools, and reducers. This comparison demonstrates how Redux Toolkit dramatically simplifies store creation by providing sensible defaults and automatic configuration."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What this code demonstrates:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),": Multiple reducer functions that need to be combined into a single store"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Process"}),": Store creation with middleware and development tools setup"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Output"}),": A configured Redux store ready for use in your application"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Key differences"}),": RTK reduces ~15 lines to ~8 lines while providing the same functionality"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// Traditional Redux store setup - Manual configuration required\r\n// This approach requires importing multiple Redux utilities and manually\r\n// configuring middleware, dev tools, and combining reducers\r\nimport { createStore, combineReducers, applyMiddleware, compose } from "redux";\r\nimport thunk from "redux-thunk"; // For async actions\r\nimport { composeWithDevTools } from "redux-devtools-extension"; // Dev tools\r\nimport todosReducer from "./todosReducer";\r\nimport usersReducer from "./usersReducer";\r\n\r\n// Step 1: Manually combine all reducers into a root reducer\r\nconst rootReducer = combineReducers({\r\n  todos: todosReducer,\r\n  users: usersReducer,\r\n});\r\n\r\n// Step 2: Create store with middleware and dev tools manually configured\r\nconst store = createStore(\r\n  rootReducer, // The combined reducer\r\n  composeWithDevTools(applyMiddleware(thunk)) // Manual middleware setup\r\n);\r\n\r\n// RTK simplified version - Automatic configuration with sensible defaults\r\n// Redux Toolkit automatically includes thunk middleware, dev tools integration,\r\n// and immutability/serializability checks in development\r\nimport { configureStore } from "@reduxjs/toolkit";\r\nimport todosSlice from "./todosSlice";\r\nimport usersSlice from "./usersSlice";\r\n\r\n// Single function call creates a fully configured store\r\n// Automatically includes: redux-thunk, Redux DevTools, and development checks\r\nconst store = configureStore({\r\n  reducer: {\r\n    todos: todosSlice, // Slice reducers are automatically combined\r\n    users: usersSlice,\r\n  },\r\n  // All middleware and dev tools are included by default!\r\n});\n'})}),"\n",(0,o.jsx)(t.h3,{id:"2-boilerplate-reduction",children:"2. Boilerplate Reduction"}),"\n",(0,o.jsxs)(t.p,{children:["Traditional Redux requires separate action types, action creators, and reducer logic, resulting in repetitive boilerplate code. This example shows how Redux Toolkit's ",(0,o.jsx)(t.code,{children:"createSlice"})," eliminates this redundancy by automatically generating action creators and types while allowing you to write simpler reducer logic."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What this code demonstrates:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),": Todo operations (add new todo, toggle completion status)"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Traditional approach"}),": ~30 lines with manual action types, creators, and immutable updates"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"RTK approach"}),': ~15 lines with automatic action generation and "mutable" syntax']}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Key benefit"}),": 50% code reduction while maintaining the same functionality"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// Traditional Redux - Manual action types, creators, and reducer\r\n// This approach requires defining action types as constants, creating action creators,\r\n// and writing reducer logic with manual immutable updates\r\n\r\n// Step 1: Define action type constants to avoid typos\r\nconst ADD_TODO = "todos/addTodo";\r\nconst TOGGLE_TODO = "todos/toggleTodo";\r\n\r\n// Step 2: Create action creator functions that return action objects\r\nconst addTodo = (text) => ({ type: ADD_TODO, payload: text });\r\nconst toggleTodo = (id) => ({ type: TOGGLE_TODO, payload: id });\r\n\r\n// Step 3: Write reducer with switch statement and manual immutable updates\r\nconst todosReducer = (state = [], action) => {\r\n  switch (action.type) {\r\n    case ADD_TODO:\r\n      // Must manually create new array and object (immutable update)\r\n      return [\r\n        ...state, // Spread existing todos\r\n        { id: Date.now(), text: action.payload, completed: false }, // Add new todo\r\n      ];\r\n    case TOGGLE_TODO:\r\n      // Must map over array and create new objects for immutability\r\n      return state.map(\r\n        (todo) =>\r\n          todo.id === action.payload\r\n            ? { ...todo, completed: !todo.completed } // Update matching todo\r\n            : todo // Keep other todos unchanged\r\n      );\r\n    default:\r\n      return state; // Always return current state for unknown actions\r\n  }\r\n};\r\n\r\n// RTK equivalent - Automatic action generation with simpler syntax\r\n// createSlice automatically generates action types, action creators, and\r\n// uses Immer internally to handle immutable updates behind the scenes\r\nimport { createSlice } from "@reduxjs/toolkit";\r\n\r\nconst todosSlice = createSlice({\r\n  name: "todos", // Used to generate action types: "todos/addTodo", "todos/toggleTodo"\r\n  initialState: [], // Starting state value\r\n  reducers: {\r\n    // Each property becomes an action creator and reducer case\r\n    addTodo: (state, action) => {\r\n      // Looks like mutation but Immer makes it immutable under the hood\r\n      state.push({ id: Date.now(), text: action.payload, completed: false });\r\n    },\r\n    toggleTodo: (state, action) => {\r\n      // Direct property assignment - Immer handles immutability\r\n      const todo = state.find((todo) => todo.id === action.payload);\r\n      if (todo) {\r\n        todo.completed = !todo.completed; // "Mutate" directly\r\n      }\r\n    },\r\n  },\r\n});\r\n\r\n// Action creators are automatically generated and exported\r\nexport const { addTodo, toggleTodo } = todosSlice.actions;\r\n// Reducer is automatically created and exported\r\nexport default todosSlice.reducer;\n'})}),"\n",(0,o.jsx)(t.h2,{id:"installation-and-setup",children:"Installation and Setup"}),"\n",(0,o.jsx)(t.p,{children:"Getting started with Redux Toolkit requires minimal setup. These commands will install the necessary packages and optionally bootstrap a new project with RTK already configured."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What these commands do:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"npm install"}),": Adds Redux Toolkit and React-Redux to your project dependencies"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"npx degit"}),": Creates a new project using an official RTK template with best practices pre-configured"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Result"}),": A fully functional Redux setup ready for development"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-bash",children:"# Install Redux Toolkit and React-Redux\r\n# @reduxjs/toolkit: Core RTK package with createSlice, configureStore, etc.\r\n# react-redux: React bindings for Redux (useSelector, useDispatch hooks)\r\nnpm install @reduxjs/toolkit react-redux\r\n\r\n# Using RTK templates for new projects (optional)\r\n# This creates a new project with RTK, TypeScript, and Vite pre-configured\r\n# Includes proper folder structure and example code\r\nnpx degit reduxjs/redux-templates/packages/vite-template-redux my-app\n"})}),"\n",(0,o.jsx)(t.h3,{id:"store-configuration",children:"Store Configuration"}),"\n",(0,o.jsxs)(t.p,{children:["This code demonstrates how to set up a Redux store using ",(0,o.jsx)(t.code,{children:"configureStore"}),". The store configuration is the central hub that combines all your feature slices and provides them to your React application through the provider pattern."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What this code does:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),": Individual slice reducers from different features"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Process"}),": Combines reducers and automatically configures middleware"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Output"}),": A Redux store ready to be provided to your React app"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"TypeScript benefit"}),": Automatic type inference for state and dispatch"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// store.js - Central store configuration\r\nimport { configureStore } from "@reduxjs/toolkit";\r\nimport todosSlice from "./features/todos/todosSlice"; // Todo feature reducer\r\nimport usersSlice from "./features/users/usersSlice"; // User feature reducer\r\n\r\n// Create and configure the Redux store\r\nexport const store = configureStore({\r\n  reducer: {\r\n    // Each property becomes a slice of state accessible via state.todos, state.users\r\n    todos: todosSlice,\r\n    users: usersSlice,\r\n  },\r\n  // RTK includes these by default (no manual configuration needed):\r\n  // - redux-thunk middleware: Enables async actions and functions as actions\r\n  // - Redux DevTools Extension: Browser dev tools integration for debugging\r\n  // - Immutability and serializability middleware (in dev): Catches common mistakes\r\n});\r\n\r\n// TypeScript type definitions for type-safe Redux usage\r\n// RootState: Represents the shape of your entire Redux state tree\r\nexport type RootState = ReturnType<typeof store.getState>;\r\n// AppDispatch: Represents the type of your store\'s dispatch function\r\nexport type AppDispatch = typeof store.dispatch;\n'})}),"\n",(0,o.jsx)(t.h2,{id:"core-apis-deep-dive",children:"Core APIs Deep Dive"}),"\n",(0,o.jsx)(t.h3,{id:"createslice---the-heart-of-rtk",children:"createSlice() - The Heart of RTK"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"createSlice"})," function is Redux Toolkit's most powerful API, combining action creators, action types, and reducers into a single declaration. This comprehensive example shows how to build a feature-complete todo slice with TypeScript, multiple reducer types, and advanced patterns like the prepare callback."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What this code demonstrates:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),": Various todo operations (add, toggle, remove, filter) with different payload types"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Process"}),": Automatic action creator generation, type-safe reducers, and immutable state updates"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Output"}),": Action creators and a reducer function ready for store integration"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Advanced features"}),": Custom payload preparation and complex state management"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'import { createSlice, PayloadAction } from "@reduxjs/toolkit";\r\n\r\n// TypeScript interfaces for type safety and better developer experience\r\ninterface Todo {\r\n  id: number;\r\n  text: string;\r\n  completed: boolean;\r\n}\r\n\r\n// State shape definition - helps with type inference and documentation\r\ninterface TodosState {\r\n  items: Todo[]; // Array of todo items\r\n  filter: "all" | "active" | "completed"; // Current filter for displaying todos\r\n}\r\n\r\n// Initial state that matches our TodosState interface\r\nconst initialState: TodosState = {\r\n  items: [], // Start with empty todo list\r\n  filter: "all", // Show all todos by default\r\n};\r\n\r\n// createSlice automatically generates action creators and action types\r\nconst todosSlice = createSlice({\r\n  name: "todos", // Used as prefix for action types: "todos/addTodo", etc.\r\n  initialState,\r\n  reducers: {\r\n    // RTK uses Immer internally - you can "mutate" the state safely\r\n    // Immer converts these mutations into immutable updates behind the scenes\r\n\r\n    // Simple reducer: takes a string and adds a new todo\r\n    addTodo: (state, action: PayloadAction<string>) => {\r\n      state.items.push({\r\n        id: Date.now(), // Simple ID generation (use proper UUID in production)\r\n        text: action.payload, // Todo text from action\r\n        completed: false, // New todos start as incomplete\r\n      });\r\n    },\r\n\r\n    // Reducer that finds and updates a specific todo by ID\r\n    toggleTodo: (state, action: PayloadAction<number>) => {\r\n      const todo = state.items.find((todo) => todo.id === action.payload);\r\n      if (todo) {\r\n        // Direct property mutation - Immer makes this immutable\r\n        todo.completed = !todo.completed;\r\n      }\r\n      // If todo not found, state remains unchanged\r\n    },\r\n\r\n    // Reducer that removes a todo by filtering it out\r\n    removeTodo: (state, action: PayloadAction<number>) => {\r\n      // Reassign the items array to a filtered version\r\n      state.items = state.items.filter((todo) => todo.id !== action.payload);\r\n    },\r\n\r\n    // Reducer that updates the filter setting\r\n    setFilter: (\r\n      state,\r\n      action: PayloadAction<"all" | "active" | "completed">\r\n    ) => {\r\n      state.filter = action.payload; // Update filter state\r\n    },\r\n\r\n    // Advanced pattern: Prepare callback for complex action payloads\r\n    // This pattern is useful when you need to transform or validate input\r\n    addTodoWithId: {\r\n      // The actual reducer function\r\n      reducer: (state, action: PayloadAction<Todo>) => {\r\n        state.items.push(action.payload); // Add the complete todo object\r\n      },\r\n      // Prepare function runs before the reducer, transforms input\r\n      prepare: (text: string) => ({\r\n        payload: {\r\n          id: Math.random(), // Generate ID in prepare function\r\n          text,\r\n          completed: false,\r\n        },\r\n      }),\r\n    },\r\n  },\r\n});\r\n\r\n// Destructure and export action creators (automatically generated)\r\n// These functions can be imported and dispatched from components\r\nexport const { addTodo, toggleTodo, removeTodo, setFilter, addTodoWithId } =\r\n  todosSlice.actions;\r\n\r\n// Export the reducer function to be included in store configuration\r\nexport default todosSlice.reducer;\n'})}),"\n",(0,o.jsx)(t.h3,{id:"createasyncthunk---async-logic",children:"createAsyncThunk() - Async Logic"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"createAsyncThunk"})," is Redux Toolkit's solution for handling asynchronous operations like API calls. It automatically generates action creators for pending, fulfilled, and rejected states, eliminating the need to manually manage loading states and error handling in async operations."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What this code demonstrates:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),": User ID for fetching todos, todo text for creating new todos"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Process"}),": HTTP requests with proper error handling and state management integration"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Output"}),": Automatic action dispatching for loading/success/error states"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Key benefits"}),": Simplified async logic, automatic loading states, built-in error handling"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\r\n\r\n// Async thunk for fetching todos from API\r\n// createAsyncThunk automatically generates three action types:\r\n// - 'todos/fetchTodos/pending' (when request starts)\r\n// - 'todos/fetchTodos/fulfilled' (when request succeeds)\r\n// - 'todos/fetchTodos/rejected' (when request fails)\r\nexport const fetchTodos = createAsyncThunk(\r\n  'todos/fetchTodos', // Action type prefix\r\n  async (userId: number, { rejectWithValue }) => {\r\n    try {\r\n      // Make HTTP request to fetch user's todos\r\n      const response = await fetch(`/api/users/${userId}/todos`);\r\n\r\n      // Check if response is successful\r\n      if (!response.ok) {\r\n        throw new Error('Failed to fetch todos');\r\n      }\r\n\r\n      // Return response data - this becomes action.payload in fulfilled case\r\n      return await response.json();\r\n    } catch (error) {\r\n      // Use rejectWithValue to return custom error payload\r\n      // This becomes action.payload in rejected case\r\n      return rejectWithValue(error.message);\r\n    }\r\n  }\r\n);\r\n\r\n// More complex async thunk with access to state and dispatch\r\nexport const addTodoAsync = createAsyncThunk(\r\n  'todos/addTodo',\r\n  async (text: string, { getState, dispatch }) => {\r\n    // Access current Redux state using getState()\r\n    const state = getState() as RootState;\r\n\r\n    // Make POST request to create new todo\r\n    const response = await fetch('/api/todos', {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({\r\n        text,\r\n        userId: state.auth.user.id // Access nested state\r\n      }),\r\n    });\r\n\r\n    // Return the created todo data\r\n    return await response.json();\r\n  }\r\n);\r\n\r\n// Slice that handles both sync and async actions\r\nconst todosSlice = createSlice({\r\n  name: 'todos',\r\n  initialState: {\r\n    items: [], // Array of todo items\r\n    loading: false, // Loading state for async operations\r\n    error: null, // Error message if operations fail\r\n  },\r\n  reducers: {\r\n    // Synchronous reducers would go here\r\n    // e.g., clearError, resetTodos, etc.\r\n  },\r\n  // extraReducers handles actions created outside this slice\r\n  // (like async thunks or actions from other slices)\r\n  extraReducers: (builder) => {\r\n    builder\r\n      // Handle fetchTodos async thunk lifecycle\r\n      .addCase(fetchTodos.pending, (state) => {\r\n        state.loading = true; // Show loading indicator\r\n        state.error = null; // Clear previous errors\r\n      })\r\n      .addCase(fetchTodos.fulfilled, (state, action) => {\r\n        state.loading = false; // Hide loading indicator\r\n        state.items = action.payload; // Update todos with fetched data\r\n      })\r\n      .addCase(fetchTodos.rejected, (state, action) => {\r\n        state.loading = false; // Hide loading indicator\r\n        state.error = action.payload as string; // Store error message\r\n      })\r\n\r\n      // Handle addTodoAsync lifecycle\r\n      .addCase(addTodoAsync.pending, (state) => {\r\n        state.loading = true;\r\n      })\r\n      .addCase(addTodoAsync.fulfilled, (state, action) => {\r\n        state.loading = false;\r\n        state.items.push(action.payload); // Add new todo to list\r\n      })\r\n      .addCase(addTodoAsync.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.error.message || 'Failed to add todo';\r\n      });\r\n  },\r\n});\n"})}),"\n",(0,o.jsx)(t.h2,{id:"under-the-hood-how-rtk-works",children:"Under the Hood: How RTK Works"}),"\n",(0,o.jsx)(t.h3,{id:"createslice-implementation-concept",children:"createSlice Implementation Concept"}),"\n",(0,o.jsxs)(t.p,{children:["Understanding how ",(0,o.jsx)(t.code,{children:"createSlice"})," works internally helps appreciate the magic it performs. This simplified implementation shows the core concepts: automatic action creator generation, reducer creation with Immer integration, and the builder pattern for handling external actions."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What this implementation demonstrates:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),": Slice configuration object with name, initial state, and reducers"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Process"}),": Dynamic action creator generation, reducer function creation, and Immer integration"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Output"}),": Object containing action creators and a combined reducer function"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Key insight"}),": RTK automates what developers previously had to write manually"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// Simplified createSlice implementation to understand the internal mechanics\r\n// This shows the core concepts without all the TypeScript and edge case handling\r\nfunction createSlice({ name, initialState, reducers, extraReducers }) {\r\n  const actionCreators = {}; // Will store generated action creators\r\n  const actionTypes = {}; // Will store action type constants\r\n\r\n  // Step 1: Generate action types and creators for each reducer\r\n  Object.keys(reducers).forEach((reducerName) => {\r\n    // Create action type string: "sliceName/reducerName"\r\n    const type = `${name}/${reducerName}`;\r\n    actionTypes[reducerName] = type;\r\n\r\n    // Create action creator function that returns an action object\r\n    actionCreators[reducerName] = (payload) => ({\r\n      type, // The generated action type\r\n      payload, // The data passed to the action creator\r\n    });\r\n  });\r\n\r\n  // Step 2: Create the main reducer function that handles slice actions\r\n  const reducer = (state = initialState, action) => {\r\n    // Use Immer\'s produce for immutable updates\r\n    // This allows writing "mutative" code that\'s actually immutable\r\n    return produce(state, (draft) => {\r\n      const caseReducer = reducers[action.type];\r\n      if (caseReducer) {\r\n        // Call the case reducer with the draft state and action\r\n        caseReducer(draft, action);\r\n      }\r\n      // If no matching reducer, Immer returns the original state\r\n    });\r\n  };\r\n\r\n  // Step 3: Handle extraReducers (for async thunks or external actions)\r\n  if (extraReducers) {\r\n    const extraReducerMap = {}; // Map action types to their reducers\r\n\r\n    // Builder pattern implementation\r\n    const builder = {\r\n      addCase: (actionCreator, reducer) => {\r\n        // Store the reducer function keyed by action type\r\n        extraReducerMap[actionCreator.type] = reducer;\r\n      },\r\n    };\r\n\r\n    // Call the extraReducers function with our builder\r\n    extraReducers(builder);\r\n\r\n    // Step 4: Merge extra reducers with main reducer\r\n    const originalReducer = reducer;\r\n    reducer = (state, action) => {\r\n      // First check if this action should be handled by extraReducers\r\n      const extraReducer = extraReducerMap[action.type];\r\n      if (extraReducer) {\r\n        // Use Immer to handle the extra reducer\r\n        return produce(state, (draft) => extraReducer(draft, action));\r\n      }\r\n      // Fall back to original reducer for slice-specific actions\r\n      return originalReducer(state, action);\r\n    };\r\n  }\r\n\r\n  // Return the complete slice object\r\n  return {\r\n    actions: actionCreators, // All generated action creators\r\n    reducer, // The combined reducer function\r\n    actionTypes, // Action type constants (for debugging)\r\n  };\r\n}\n'})}),"\n",(0,o.jsx)(t.h3,{id:"immer-integration",children:"Immer Integration"}),"\n",(0,o.jsx)(t.p,{children:'Immer is the secret sauce that makes Redux Toolkit\'s "mutative" syntax work. It creates a draft copy of your state that you can safely mutate, then produces an immutable result. This eliminates the verbose spread syntax required in traditional Redux while maintaining immutability.'}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What this code demonstrates:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),': State object and "mutative" operations']}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Process"}),": Immer creates a draft proxy, tracks changes, and produces immutable result"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Output"}),": New immutable state object with changes applied"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Key benefit"}),": Write simple mutation code that automatically becomes immutable updates"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// What RTK does internally with Immer\r\nimport produce from "immer";\r\n\r\n// Your "mutative" code in RTK reducers\r\n// This looks like direct mutation but is actually safe\r\nconst reducer = (state, action) => {\r\n  state.items.push(newItem); // Appears to mutate state directly\r\n  state.count += 1; // Appears to modify properties directly\r\n};\r\n\r\n// What Immer actually does behind the scenes\r\nconst actualReducer = (state, action) => {\r\n  return produce(state, (draft) => {\r\n    // `draft` is a special proxy object that tracks changes\r\n    draft.items.push(newItem); // Mutation tracked by Immer\r\n    draft.count += 1; // Property changes tracked by Immer\r\n\r\n    // Immer creates a new immutable state with only changed parts replaced\r\n    // Unchanged parts are structurally shared for performance\r\n  });\r\n};\r\n\r\n// Example: How Immer handles nested state updates\r\nconst complexReducer = (state, action) => {\r\n  // Traditional Redux would require deep spreading:\r\n  // return {\r\n  //   ...state,\r\n  //   user: {\r\n  //     ...state.user,\r\n  //     profile: {\r\n  //       ...state.user.profile,\r\n  //       name: action.payload\r\n  //     }\r\n  //   }\r\n  // }\r\n\r\n  // With Immer (what RTK allows):\r\n  state.user.profile.name = action.payload; // Simple assignment!\r\n};\n'})}),"\n",(0,o.jsx)(t.h2,{id:"rtk-query-data-fetching-solution",children:"RTK Query: Data Fetching Solution"}),"\n",(0,o.jsx)(t.p,{children:"RTK Query is Redux Toolkit's powerful data fetching and caching solution that eliminates the need to write data fetching logic manually. It provides automatic caching, background updates, and optimistic updates while integrating seamlessly with Redux DevTools."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Key RTK Query benefits:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Automatic caching"}),": Avoid redundant network requests"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Background refetching"}),": Keep data fresh automatically"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Optimistic updates"}),": Instant UI updates with rollback on errors"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Generated hooks"}),": Type-safe hooks for React components"]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"basic-rtk-query-setup",children:"Basic RTK Query Setup"}),"\n",(0,o.jsx)(t.p,{children:"This example shows how to set up a complete API slice with queries (for fetching data) and mutations (for creating/updating data). RTK Query automatically generates React hooks and manages all the complex caching logic for you."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What this code creates:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),": API endpoint definitions and caching strategies"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Process"}),": Automatic hook generation, caching, and cache invalidation"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Output"}),": React hooks ready to use in components"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Generated hooks"}),": ",(0,o.jsx)(t.code,{children:"useGetTodosQuery"}),", ",(0,o.jsx)(t.code,{children:"useAddTodoMutation"}),", ",(0,o.jsx)(t.code,{children:"useUpdateTodoMutation"})]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// api/apiSlice.js - Centralized API definition\r\nimport { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";\r\n\r\nexport const apiSlice = createApi({\r\n  // Unique key for this API slice in the Redux store\r\n  reducerPath: "api",\r\n\r\n  // Base query configuration for all endpoints\r\n  baseQuery: fetchBaseQuery({\r\n    baseUrl: "/api", // Base URL for all API calls\r\n\r\n    // Function to prepare headers for each request\r\n    prepareHeaders: (headers, { getState }) => {\r\n      // Access current state to get authentication token\r\n      const token = getState().auth.token;\r\n      if (token) {\r\n        // Add authorization header if token exists\r\n        headers.set("authorization", `Bearer ${token}`);\r\n      }\r\n      return headers;\r\n    },\r\n  }),\r\n\r\n  // Define tag types for cache invalidation system\r\n  // Tags help RTK Query know which cached data to invalidate when mutations occur\r\n  tagTypes: ["Todo", "User"],\r\n\r\n  // Define API endpoints (queries for fetching, mutations for modifying)\r\n  endpoints: (builder) => ({\r\n    // Query endpoint for fetching todos\r\n    getTodos: builder.query({\r\n      query: () => "todos", // GET /api/todos\r\n      providesTags: ["Todo"], // This query provides "Todo" data\r\n    }),\r\n\r\n    // Mutation endpoint for creating new todos\r\n    addTodo: builder.mutation({\r\n      query: (newTodo) => ({\r\n        url: "todos", // POST /api/todos\r\n        method: "POST",\r\n        body: newTodo, // Request body with todo data\r\n      }),\r\n      // After successful creation, invalidate Todo cache to refetch fresh data\r\n      invalidatesTags: ["Todo"],\r\n    }),\r\n\r\n    // Mutation endpoint for updating existing todos\r\n    updateTodo: builder.mutation({\r\n      query: ({ id, ...patch }) => ({\r\n        url: `todos/${id}`, // PATCH /api/todos/:id\r\n        method: "PATCH",\r\n        body: patch, // Only the fields to update\r\n      }),\r\n      // After successful update, invalidate Todo cache\r\n      invalidatesTags: ["Todo"],\r\n    }),\r\n\r\n    // Additional query with more complex caching\r\n    getTodoById: builder.query({\r\n      query: (id) => `todos/${id}`, // GET /api/todos/:id\r\n      providesTags: (result, error, id) => [{ type: "Todo", id }], // Specific tag for this todo\r\n    }),\r\n  }),\r\n});\r\n\r\n// Export auto-generated hooks for use in React components\r\n// These hooks handle loading states, errors, caching, and refetching automatically\r\nexport const {\r\n  useGetTodosQuery,\r\n  useAddTodoMutation,\r\n  useUpdateTodoMutation,\r\n  useGetTodoByIdQuery,\r\n} = apiSlice;\n'})}),"\n",(0,o.jsx)(t.h3,{id:"using-rtk-query-hooks",children:"Using RTK Query Hooks"}),"\n",(0,o.jsx)(t.p,{children:"RTK Query hooks make data fetching incredibly simple in React components. They automatically handle loading states, errors, caching, and re-fetching, eliminating the need for useEffect and manual state management for API calls."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What this component demonstrates:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),": No manual setup needed - hooks handle everything"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Process"}),": Automatic data fetching, caching, loading/error state management"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Output"}),": Reactive UI that updates when data changes"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Key features"}),": Automatic refetching, optimistic updates, error handling"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'import { useGetTodosQuery, useAddTodoMutation } from "./api/apiSlice";\r\n\r\nconst TodoList = () => {\r\n  // useGetTodosQuery automatically handles:\r\n  // - Making the initial API call\r\n  // - Caching the result\r\n  // - Providing loading and error states\r\n  // - Re-fetching when cache is invalidated\r\n  const {\r\n    data: todos, // The fetched todo data (undefined while loading)\r\n    error, // Any error that occurred during fetching\r\n    isLoading, // True during the initial fetch\r\n    isFetching, // True during any fetch (including background refetches)\r\n    refetch, // Function to manually trigger a refetch\r\n  } = useGetTodosQuery();\r\n\r\n  // useAddTodoMutation returns a trigger function and state\r\n  const [\r\n    addTodo, // Function to trigger the mutation\r\n    {\r\n      isLoading: isAdding, // Loading state specific to this mutation\r\n      error: addError, // Error state specific to this mutation\r\n    },\r\n  ] = useAddTodoMutation();\r\n\r\n  // Handle adding a new todo with error handling\r\n  const handleAddTodo = async (text) => {\r\n    try {\r\n      // Call the mutation and unwrap the result\r\n      // unwrap() throws an error if the mutation fails, allowing us to catch it\r\n      const result = await addTodo({ text }).unwrap();\r\n      console.log("Todo added successfully:", result);\r\n\r\n      // The todos list will automatically update due to cache invalidation\r\n      // No manual state updates needed!\r\n    } catch (error) {\r\n      // Handle the error (could show a toast notification)\r\n      console.error("Failed to add todo:", error);\r\n    }\r\n  };\r\n\r\n  // Handle different UI states\r\n  if (isLoading) return <div>Loading todos...</div>;\r\n  if (error) return <div>Error loading todos: {error.message}</div>;\r\n\r\n  return (\r\n    <div>\r\n      <h2>Todo List</h2>\r\n\r\n      {/* Render todos with optional chaining for safety */}\r\n      {todos?.map((todo) => (\r\n        <TodoItem key={todo.id} todo={todo} />\r\n      ))}\r\n\r\n      {/* Add new todo button with loading state */}\r\n      <button onClick={() => handleAddTodo("New todo")} disabled={isAdding}>\r\n        {isAdding ? "Adding..." : "Add Todo"}\r\n      </button>\r\n\r\n      {/* Manual refetch button (useful for pull-to-refresh) */}\r\n      <button onClick={() => refetch()}>Refresh Todos</button>\r\n\r\n      {/* Show add error if any */}\r\n      {addError && (\r\n        <div style={{ color: "red" }}>\r\n          Failed to add todo: {addError.message}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\n'})}),"\n",(0,o.jsx)(t.h2,{id:"advanced-patterns-and-best-practices",children:"Advanced Patterns and Best Practices"}),"\n",(0,o.jsx)(t.h3,{id:"feature-based-file-structure",children:"Feature-Based File Structure"}),"\n",(0,o.jsx)(t.p,{children:"Organizing Redux Toolkit code by features rather than by file types creates better maintainability and makes it easier to understand the codebase. This structure groups related functionality together and promotes code reusability."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What this structure provides:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),": Related functionality grouped by domain (todos, users, etc.)"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Process"}),": Co-location of slices, API definitions, and components"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Output"}),": More maintainable and scalable codebase"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Benefits"}),": Easier to find code, better separation of concerns, reusable feature modules"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"src/\r\n  features/                    # Feature-based organization\r\n    todos/                     # Everything related to todos\r\n      todosSlice.js           # Redux slice for todo state management\r\n      todosApi.js             # RTK Query API definitions for todos\r\n      TodoList.jsx            # React components for todo functionality\r\n      TodoItem.jsx\r\n      hooks/                  # Feature-specific custom hooks\r\n        useTodoFilters.js\r\n      types/                  # TypeScript types for this feature\r\n        todo.types.ts\r\n    users/                     # Everything related to users\r\n      usersSlice.js           # User state management\r\n      usersApi.js             # User API definitions\r\n      UserProfile.jsx         # User-related components\r\n      UserSettings.jsx\r\n    auth/                      # Authentication feature\r\n      authSlice.js\r\n      authApi.js\r\n      LoginForm.jsx\r\n      ProtectedRoute.jsx\r\n  app/                         # App-level configuration\r\n    store.js                  # Redux store configuration\r\n    rootReducer.js            # Root reducer (if needed)\r\n    middleware.js             # Custom middleware\r\n  shared/                      # Shared utilities and components\r\n    components/               # Reusable UI components\r\n    hooks/                    # App-wide custom hooks\r\n    utils/                    # Utility functions\r\n    types/                    # Shared TypeScript types\n"})}),"\n",(0,o.jsx)(t.h3,{id:"type-safe-redux-hooks",children:"Type-Safe Redux Hooks"}),"\n",(0,o.jsxs)(t.p,{children:["These custom hooks provide type safety for Redux operations in TypeScript projects. They ensure that ",(0,o.jsx)(t.code,{children:"useSelector"})," and ",(0,o.jsx)(t.code,{children:"useDispatch"})," are properly typed with your specific store configuration, enabling better IntelliSense and catching type errors at compile time."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What these hooks provide:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),": Redux store state and dispatch function"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Process"}),": Type-safe wrappers around standard Redux hooks"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Output"}),": Fully typed hooks that provide autocomplete and type checking"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Benefits"}),": Better developer experience, fewer runtime errors, improved IntelliSense"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:'// app/hooks.ts - Type-safe Redux hooks for better TypeScript experience\r\nimport { TypedUseSelectorHook, useDispatch, useSelector } from "react-redux";\r\nimport type { RootState, AppDispatch } from "./store";\r\n\r\n// Type-safe dispatch hook\r\n// Use this instead of the plain `useDispatch` from react-redux\r\n// Provides autocomplete for thunk actions and proper typing\r\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\r\n\r\n// Type-safe selector hook\r\n// Use this instead of the plain `useSelector` from react-redux\r\n// Provides autocomplete for state properties and type checking\r\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\r\n\r\n// Example usage in a component:\r\n// const dispatch = useAppDispatch(); // Fully typed dispatch\r\n// const todos = useAppSelector(state => state.todos.items); // Fully typed selector\r\n\r\n// Optional: Pre-configured selectors for common patterns\r\nexport const useAppStore = () => useAppSelector((state) => state);\r\nexport const useAppLoading = () => useAppSelector((state) => state.loading);\n'})}),"\n",(0,o.jsx)(t.h3,{id:"slice-composition",children:"Slice Composition"}),"\n",(0,o.jsx)(t.p,{children:"Slice composition allows you to combine multiple slices and even implement lazy loading for better code splitting. This is particularly useful in large applications where you want to load features on demand rather than including everything in the initial bundle."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What this pattern enables:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),": Multiple independent slices from different features"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Process"}),": Dynamic combination and lazy loading of slices"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Output"}),": Optimized bundle size and runtime slice injection"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Benefits"}),": Better performance, code splitting, feature-based loading"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'// Combining multiple slices using combineSlices (RTK 2.0+)\r\nimport { combineSlices } from "@reduxjs/toolkit";\r\nimport { todosSlice } from "./features/todos/todosSlice";\r\nimport { usersSlice } from "./features/users/usersSlice";\r\n\r\n// Automatically combines slice reducers and infers state shape\r\nexport const rootReducer = combineSlices(todosSlice, usersSlice);\r\n\r\n// Alternative: Manual combination for older RTK versions\r\nexport const manualRootReducer = {\r\n  todos: todosSlice.reducer,\r\n  users: usersSlice.reducer,\r\n};\r\n\r\n// Lazy slice loading pattern for code splitting\r\nconst store = configureStore({\r\n  reducer: {\r\n    // Start with essential slices only\r\n    todos: todosSlice.reducer,\r\n    // Users slice will be loaded later when needed\r\n  },\r\n});\r\n\r\n// Function to dynamically inject new slices at runtime\r\nexport const injectSlice = (sliceName, sliceReducer) => {\r\n  // Add the new slice to the store dynamically\r\n  store.replaceReducer({\r\n    ...store.getState(),\r\n    [sliceName]: sliceReducer,\r\n  });\r\n};\r\n\r\n// Example: Load users slice when user navigates to user section\r\nconst loadUsersFeature = async () => {\r\n  // Lazy import the slice (enables code splitting)\r\n  const { usersSlice } = await import("./features/users/usersSlice");\r\n\r\n  // Inject the slice into the running store\r\n  injectSlice("users", usersSlice.reducer);\r\n\r\n  return usersSlice;\r\n};\r\n\r\n// Usage in a React component with lazy loading\r\nconst UserSection = () => {\r\n  const [usersLoaded, setUsersLoaded] = useState(false);\r\n\r\n  useEffect(() => {\r\n    loadUsersFeature().then(() => {\r\n      setUsersLoaded(true);\r\n    });\r\n  }, []);\r\n\r\n  if (!usersLoaded) return <div>Loading users feature...</div>;\r\n\r\n  return <UserList />;\r\n};\n'})}),"\n",(0,o.jsx)(t.h2,{id:"performance-optimizations",children:"Performance Optimizations"}),"\n",(0,o.jsx)(t.h3,{id:"selector-optimization",children:"Selector Optimization"}),"\n",(0,o.jsx)(t.p,{children:"Memoized selectors prevent unnecessary re-computations and re-renders by only recalculating when their input dependencies change. This is crucial for performance in larger applications where expensive calculations might run on every state change."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What this optimization provides:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),": Raw state slices that need transformation or filtering"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Process"}),": Memoized computation that only runs when dependencies change"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Output"}),": Optimized derived state that prevents unnecessary re-renders"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Benefits"}),": Better performance, fewer component re-renders, cached calculations"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'import { createSelector } from "@reduxjs/toolkit";\r\n\r\n// Basic input selectors - these extract data from state\r\nconst selectTodos = (state) => state.todos.items;\r\nconst selectFilter = (state) => state.todos.filter;\r\nconst selectSearchTerm = (state) => state.todos.searchTerm;\r\n\r\n// Memoized selector that combines multiple inputs\r\n// Only recalculates when todos or filter changes\r\nexport const selectFilteredTodos = createSelector(\r\n  [selectTodos, selectFilter],\r\n  (todos, filter) => {\r\n    // This expensive filtering only runs when todos or filter changes\r\n    switch (filter) {\r\n      case "active":\r\n        return todos.filter((todo) => !todo.completed);\r\n      case "completed":\r\n        return todos.filter((todo) => todo.completed);\r\n      default:\r\n        return todos;\r\n    }\r\n  }\r\n);\r\n\r\n// More complex selector with multiple dependencies\r\nexport const selectFilteredAndSearchedTodos = createSelector(\r\n  [selectFilteredTodos, selectSearchTerm],\r\n  (filteredTodos, searchTerm) => {\r\n    if (!searchTerm) return filteredTodos;\r\n\r\n    // Only runs when filteredTodos or searchTerm changes\r\n    return filteredTodos.filter((todo) =>\r\n      todo.text.toLowerCase().includes(searchTerm.toLowerCase())\r\n    );\r\n  }\r\n);\r\n\r\n// Selector for computed statistics\r\nexport const selectTodoStats = createSelector([selectTodos], (todos) => ({\r\n  total: todos.length,\r\n  completed: todos.filter((todo) => todo.completed).length,\r\n  active: todos.filter((todo) => !todo.completed).length,\r\n  completionPercentage:\r\n    todos.length > 0\r\n      ? Math.round(\r\n          (todos.filter((todo) => todo.completed).length / todos.length) * 100\r\n        )\r\n      : 0,\r\n}));\n'})}),"\n",(0,o.jsx)(t.h3,{id:"rtk-query-cache-configuration",children:"RTK Query Cache Configuration"}),"\n",(0,o.jsx)(t.p,{children:"RTK Query's caching system is highly configurable, allowing you to optimize for different use cases like real-time data, infrequently changing data, or user-specific content. Proper cache configuration can dramatically improve user experience and reduce server load."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"What these configurations control:"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Input"}),": API endpoints and their specific caching requirements"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Process"}),": Automatic cache management, background updates, and invalidation"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Output"}),": Optimized data fetching with minimal redundant requests"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Benefits"}),": Faster UX, reduced bandwidth, better offline experience"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'const apiSlice = createApi({\r\n  reducerPath: "api",\r\n  baseQuery: fetchBaseQuery({ baseUrl: "/api" }),\r\n\r\n  // Global cache settings\r\n  keepUnusedDataFor: 60, // Cache data for 60 seconds after last component unmounts\r\n\r\n  // Global refetch settings\r\n  refetchOnMountOrArgChange: true, // Refetch when component mounts or args change\r\n  refetchOnFocus: true, // Refetch when window regains focus\r\n  refetchOnReconnect: true, // Refetch when network connection is restored\r\n\r\n  tagTypes: ["Todo", "User"],\r\n\r\n  endpoints: (builder) => ({\r\n    // Endpoint with custom cache behavior\r\n    getTodos: builder.query({\r\n      query: () => "todos",\r\n      // Override global settings for this endpoint\r\n      keepUnusedDataFor: 30, // Cache for only 30 seconds\r\n\r\n      // Advanced caching: provide specific tags for fine-grained invalidation\r\n      providesTags: (result, error, arg) =>\r\n        result\r\n          ? [\r\n              ...result.map(({ id }) => ({ type: "Todo" as const, id })),\r\n              { type: "Todo", id: "LIST" },\r\n            ]\r\n          : [{ type: "Todo", id: "LIST" }],\r\n    }),\r\n\r\n    // Endpoint with polling for real-time updates\r\n    getLiveTodos: builder.query({\r\n      query: () => "todos/live",\r\n      // Poll every 5 seconds for real-time updates\r\n      pollingInterval: 5000,\r\n      // Skip polling when tab is not visible\r\n      skipPollingIfUnfocused: true,\r\n    }),\r\n\r\n    // Endpoint with transformation and caching\r\n    getTodoWithStats: builder.query({\r\n      query: (id) => `todos/${id}`,\r\n      // Transform response before caching\r\n      transformResponse: (response, meta, arg) => ({\r\n        ...response,\r\n        // Add computed properties\r\n        isOverdue: new Date(response.dueDate) < new Date(),\r\n        daysRemaining: Math.ceil((new Date(response.dueDate) - new Date()) / (1000 * 60 * 60 * 24))\r\n      }),\r\n      // Cache for a longer time since this data doesn\'t change often\r\n      keepUnusedDataFor: 300, // 5 minutes\r\n    }),\r\n\r\n    // Mutation with optimistic updates\r\n    updateTodo: builder.mutation({\r\n      query: ({ id, ...patch }) => ({\r\n        url: `todos/${id}`,\r\n        method: "PATCH",\r\n        body: patch,\r\n      }),\r\n      // Optimistic update - immediately update cache before API response\r\n      onQueryStarted: async ({ id, ...patch }, { dispatch, queryFulfilled }) => {\r\n        // Optimistically update the cache\r\n        const patchResult = dispatch(\r\n          apiSlice.util.updateQueryData("getTodos", undefined, (draft) => {\r\n            const todo = draft.find((todo) => todo.id === id);\r\n            if (todo) {\r\n              Object.assign(todo, patch);\r\n            }\r\n          })\r\n        );\r\n\r\n        try {\r\n          await queryFulfilled;\r\n        } catch {\r\n          // Rollback optimistic update on error\r\n          patchResult.undo();\r\n        }\r\n      },\r\n      invalidatesTags: (result, error, { id }) => [{ type: "Todo", id }],\r\n    }),\r\n  }),\r\n});\n'})}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"Redux Toolkit transforms Redux development from a verbose, configuration-heavy experience into a streamlined, developer-friendly process. By abstracting away common patterns and providing sensible defaults, RTK allows you to focus on your application logic rather than Redux boilerplate."}),"\n",(0,o.jsx)(t.h3,{id:"key-rtk-advantages",children:"Key RTK Advantages"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Dramatic Boilerplate Reduction"}),": ",(0,o.jsx)(t.code,{children:"createSlice"})," eliminates action types and creators"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Simplified Store Setup"}),": ",(0,o.jsx)(t.code,{children:"configureStore"})," provides sensible defaults"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Built-in Immer"}),': Write "mutative" logic that\'s actually immutable']}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Powerful Data Fetching"}),": RTK Query handles caching, loading states, and cache invalidation"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Excellent TypeScript Support"}),": First-class TypeScript integration"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Performance Optimized"}),": Built-in memoization and optimization strategies"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["As highlighted in the ",(0,o.jsx)(t.a,{href:"https://github.com/reduxjs/redux-toolkit",children:"Redux Toolkit repository"}),", RTK is now the recommended approach for all Redux development, providing the benefits of Redux with significantly improved developer experience and reduced complexity."]}),"\n",(0,o.jsx)(t.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://redux-toolkit.js.org/",children:"Redux Toolkit Documentation"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://redux-toolkit.js.org/rtk-query/overview",children:"RTK Query Overview"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://github.com/reduxjs/redux-toolkit",children:"Redux Toolkit GitHub"})}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>a});var n=r(6540);const o={},i=n.createContext(o);function s(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);