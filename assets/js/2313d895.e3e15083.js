"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6724],{2272:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"project-detail/styled-component","title":"Styled Components: CSS-in-JS Simplified","description":"Table of Contents","source":"@site/docs/project-detail/styled-component.md","sourceDirName":"project-detail","slug":"/project-detail/styled-component","permalink":"/frontend-system-design/docs/project-detail/styled-component","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/styled-component.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Service Workers: The Gateway to Progressive Web Apps","permalink":"/frontend-system-design/docs/project-detail/service-worker"},"next":{"title":"Ant Design: Enterprise-Class UI Library","permalink":"/frontend-system-design/docs/project-detail/ant-design"}}');var o=t(4848),i=t(8453);const r={},a="Styled Components: CSS-in-JS Simplified",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Benefits",id:"key-benefits",level:3},{value:"Getting Started",id:"getting-started",level:2},{value:"Installation",id:"installation",level:3},{value:"Babel Configuration",id:"babel-configuration",level:3},{value:"Basic Usage and Syntax",id:"basic-usage-and-syntax",level:2},{value:"Creating Styled Components",id:"creating-styled-components",level:3},{value:"Styling Existing Components",id:"styling-existing-components",level:3},{value:"Under the Hood: How Styled Components Work",id:"under-the-hood-how-styled-components-work",level:2},{value:"Tagged Template Literals Processing",id:"tagged-template-literals-processing",level:3},{value:"CSS Generation and Injection",id:"css-generation-and-injection",level:3},{value:"Dynamic Styling with Props",id:"dynamic-styling-with-props",level:2},{value:"Props-Based Conditional Styling",id:"props-based-conditional-styling",level:3},{value:"Helper Functions for Complex Logic",id:"helper-functions-for-complex-logic",level:3},{value:"Theming System",id:"theming-system",level:2},{value:"Theme Provider and Theme Access",id:"theme-provider-and-theme-access",level:3},{value:"Dynamic Theme Switching",id:"dynamic-theme-switching",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Extending and Composition",id:"extending-and-composition",level:3},{value:"Polymorphic Components",id:"polymorphic-components",level:3},{value:"Global Styles and CSS Reset",id:"global-styles-and-css-reset",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Optimization Techniques",id:"optimization-techniques",level:3},{value:"Server-Side Rendering (SSR)",id:"server-side-rendering-ssr",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Component Organization",id:"component-organization",level:3},{value:"Naming Conventions",id:"naming-conventions",level:3},{value:"Performance Guidelines",id:"performance-guidelines",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Further Resources",id:"further-resources",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"styled-components-css-in-js-simplified",children:"Styled Components: CSS-in-JS Simplified"})}),"\n",(0,o.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#getting-started",children:"Getting Started"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#basic-usage-and-syntax",children:"Basic Usage and Syntax"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#under-the-hood-how-styled-components-work",children:"Under the Hood: How Styled Components Work"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#dynamic-styling-with-props",children:"Dynamic Styling with Props"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#theming-system",children:"Theming System"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#advanced-patterns",children:"Advanced Patterns"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsxs)(n.p,{children:["Styled Components is a popular CSS-in-JS library for React and React Native that allows you to write actual CSS code to style your components using tagged template literals. As highlighted in the ",(0,o.jsx)(n.a,{href:"https://github.com/styled-components/styled-components",children:"official Styled Components repository"}),", it removes the mapping between components and styles, making component-level styling intuitive and maintainable."]}),"\n",(0,o.jsx)(n.h3,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Component-scoped styling"}),": No more global CSS conflicts"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dynamic styling"}),": Props-based conditional styling"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Automatic vendor prefixing"}),": Cross-browser compatibility out of the box"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dead code elimination"}),": Unused styles are automatically removed"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Theming support"}),": Consistent design system implementation"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,o.jsx)(n.h3,{id:"installation",children:"Installation"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this section covers"}),": Setting up styled-components in your React project with all necessary dependencies and development tools."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Steps explained"}),":"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Install the core styled-components library"}),"\n",(0,o.jsx)(n.li,{children:"Add TypeScript support for better development experience"}),"\n",(0,o.jsx)(n.li,{children:"Install Babel plugin for enhanced debugging and performance"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Expected outcome"}),": A fully configured styled-components setup ready for development."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Step 1: Install the core styled-components library\n# This provides the main functionality for CSS-in-JS styling\nnpm install styled-components\n\n# Step 2: Install TypeScript definitions (recommended for TypeScript projects)\n# Provides type safety and IntelliSense support in your IDE\nnpm install --save-dev @types/styled-components\n\n# Step 3: Install Babel plugin for enhanced development experience\n# Enables better component names in DevTools and improved performance\nnpm install --save-dev babel-plugin-styled-components\n"})}),"\n",(0,o.jsx)(n.h3,{id:"babel-configuration",children:"Babel Configuration"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Purpose"}),": Configure Babel to optimize styled-components for development and production builds."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Configuration benefits"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"displayName"}),": Shows readable component names in React DevTools"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"fileName"}),": Includes file names in component names for easier debugging"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"ssr"}),": Enables server-side rendering support"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Input"}),": Babel configuration file\n",(0,o.jsx)(n.strong,{children:"Output"}),": Enhanced development experience and optimized builds"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'// .babelrc or babel.config.js\n// Configuration file that tells Babel how to transform styled-components\n{\n  "plugins": [\n    [\n      "babel-plugin-styled-components",\n      {\n        // Shows component names like "Button" instead of generic class names in DevTools\n        "displayName": true,\n        // Includes file path in component names for easier debugging\n        "fileName": true,\n        // Enables server-side rendering optimizations\n        "ssr": true\n      }\n    ]\n  ]\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"basic-usage-and-syntax",children:"Basic Usage and Syntax"}),"\n",(0,o.jsx)(n.h3,{id:"creating-styled-components",children:"Creating Styled Components"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this code demonstrates"}),": How to create your first styled component using tagged template literals."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Process breakdown"}),":"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Import the styled function from styled-components"}),"\n",(0,o.jsx)(n.li,{children:"Use template literals to define CSS styles"}),"\n",(0,o.jsx)(n.li,{children:"styled-components automatically generates unique class names"}),"\n",(0,o.jsx)(n.li,{children:"The component can be used like any other React component"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Input"}),": CSS styles written in template literal syntax\n",(0,o.jsx)(n.strong,{children:"Output"}),": A React component with scoped styles and unique class names"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Key benefits"}),": No CSS class name conflicts, component-scoped styling, pseudo-selector support"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// Import the main styled function\nimport styled from "styled-components";\n\n// Create a styled button component using tagged template literals\n// This creates a React component that renders a <button> with the specified styles\nconst Button = styled.button`\n  /* Base styles - these apply to all button instances */\n  background-color: #007bff; /* Primary blue color */\n  color: white; /* White text for contrast */\n  border: none; /* Remove default button border */\n  padding: 12px 24px; /* Internal spacing */\n  border-radius: 4px; /* Rounded corners */\n  font-size: 16px; /* Readable text size */\n  cursor: pointer; /* Show it\'s clickable */\n  transition: background-color 0.2s ease; /* Smooth color transitions */\n\n  /* Pseudo-selectors work just like in regular CSS */\n  &:hover {\n    background-color: #0056b3; /* Darker blue on hover */\n  }\n\n  /* Handle disabled state styling */\n  &:disabled {\n    background-color: #6c757d; /* Gray background when disabled */\n    cursor: not-allowed; /* Show disabled cursor */\n  }\n`;\n\n// Usage: Styled components work exactly like regular React components\n// They accept all standard HTML attributes and props\nfunction App() {\n  return (\n    <div>\n      {/* Regular button with default styling */}\n      <Button>Click me</Button>\n\n      {/* Button with disabled attribute - will use disabled styles */}\n      <Button disabled>Disabled</Button>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"styling-existing-components",children:"Styling Existing Components"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Purpose"}),": Learn how to apply styled-components to existing React components (third-party libraries, custom components)."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use cases"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Styling components from libraries like React Router, Material-UI, etc."}),"\n",(0,o.jsx)(n.li,{children:"Creating component hierarchies with nested styling"}),"\n",(0,o.jsx)(n.li,{children:"Maintaining component functionality while changing appearance"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Input"}),": Existing React component + CSS styles\n",(0,o.jsx)(n.strong,{children:"Output"}),": New styled component that wraps the original with custom styles"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// Example: Styling a third-party component (React Router\'s Link)\nimport { Link } from "react-router-dom";\n\n// Wrap an existing component with styled-components\n// The Link component keeps all its original functionality (routing)\n// but gets our custom styling\nconst StyledLink = styled(Link)`\n  color: #007bff; /* Blue color for links */\n  text-decoration: none; /* Remove default underline */\n  font-weight: 600; /* Make text semi-bold */\n\n  /* Add hover effects */\n  &:hover {\n    text-decoration: underline; /* Show underline on hover */\n  }\n`;\n\n// Advanced: Using component selectors for nested styling\n// This demonstrates how to style child components within parent components\nconst Card = styled.div`\n  /* Base card styling */\n  padding: 20px; /* Internal spacing */\n  border: 1px solid #e0e0e0; /* Light gray border */\n  border-radius: 8px; /* Rounded corners */\n\n  /* Nested component styling using component selector */\n  /* This targets StyledLink components that are children of this Card */\n  ${StyledLink} {\n    display: block; /* Make links block-level elements */\n    margin-top: 10px; /* Add space above each link */\n  }\n`;\n\n// Usage example:\n// <Card>\n//   <p>Card content</p>\n//   <StyledLink to="/page1">Link 1</StyledLink>\n//   <StyledLink to="/page2">Link 2</StyledLink>\n// </Card>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"under-the-hood-how-styled-components-work",children:"Under the Hood: How Styled Components Work"}),"\n",(0,o.jsx)(n.h3,{id:"tagged-template-literals-processing",children:"Tagged Template Literals Processing"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this section explains"}),": The internal mechanism of how styled-components processes template literals and converts them into React components."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Process flow"}),":"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Parse template literal strings and expressions"}),"\n",(0,o.jsx)(n.li,{children:"Evaluate dynamic expressions (functions with props)"}),"\n",(0,o.jsx)(n.li,{children:"Generate unique CSS class names"}),"\n",(0,o.jsx)(n.li,{children:"Inject CSS rules into the DOM"}),"\n",(0,o.jsx)(n.li,{children:"Return a React component with the generated class"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Input"}),": Template literal with CSS + dynamic expressions\n",(0,o.jsx)(n.strong,{children:"Output"}),": React component with unique class name and injected styles"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Why this matters"}),": Understanding this helps with debugging and performance optimization."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// Simplified representation of how styled-components processes template literals\n// This is NOT the actual implementation, but shows the conceptual flow\nfunction styledComponentsProcessor(template, ...expressions) {\n  // Step 1: Parse and combine template literal parts with dynamic expressions\n  const cssString = template.reduce((result, string, i) => {\n    // Get the expression at the current position\n    const expression = expressions[i - 1];\n\n    // If expression is a function, call it with props to get the value\n    // If it\'s a static value, use it directly\n    const evaluatedExpression =\n      typeof expression === "function" ? expression(props) : expression;\n\n    // Combine the static string with the evaluated expression\n    return result + evaluatedExpression + string;\n  });\n\n  // Step 2: Generate a unique class name for this component\n  // This ensures style isolation between different components\n  const className = generateUniqueClassName(cssString);\n\n  // Step 3: Inject the CSS styles into the document head\n  // This creates actual CSS rules that browsers can use\n  injectStyles(className, cssString);\n\n  // Step 4: Return a React component that uses the generated class\n  return createStyledComponent(className);\n}\n\n// Conceptual implementation of the styled object\n// Each HTML element (button, div, span, etc.) gets its own method\nconst styled = {\n  // Example for button elements\n  button: (template, ...expressions) => {\n    // Return a function that creates React elements\n    return (props) => {\n      // Process the template with current props\n      const className = processTemplate(template, expressions, props);\n\n      // Create a button element with the generated class and all passed props\n      return React.createElement("button", { ...props, className });\n    };\n  },\n  // Similar methods exist for div, span, p, etc.\n};\n'})}),"\n",(0,o.jsx)(n.h3,{id:"css-generation-and-injection",children:"CSS Generation and Injection"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Purpose"}),": Understand how styled-components manages CSS rules in the browser and maintains performance."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Key concepts"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Dynamic style sheet creation and management"}),"\n",(0,o.jsx)(n.li,{children:"Unique class name generation to prevent conflicts"}),"\n",(0,o.jsx)(n.li,{children:"Efficient CSS rule injection and cleanup"}),"\n",(0,o.jsx)(n.li,{children:"Memory management for unused styles"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Process flow"}),":"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Create a style sheet in the document head"}),"\n",(0,o.jsx)(n.li,{children:"Generate unique class names for each component"}),"\n",(0,o.jsx)(n.li,{children:"Inject CSS rules into the style sheet"}),"\n",(0,o.jsx)(n.li,{children:"Track and cleanup unused styles"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Performance benefits"}),": Prevents duplicate styles, enables dead code elimination, manages memory usage"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"// Simplified representation of how styled-components manages CSS\n// This shows the conceptual approach to style management\nclass StyleManager {\n  constructor() {\n    // Map to track injected styles and prevent duplicates\n    this.styles = new Map();\n    // Reference to the style sheet for CSS rule manipulation\n    this.sheet = this.createStyleSheet();\n  }\n\n  // Creates a new style sheet in the document head\n  createStyleSheet() {\n    // Create a new <style> element\n    const style = document.createElement(\"style\");\n    style.type = \"text/css\";\n\n    // Add it to the document head so browsers can use the styles\n    document.head.appendChild(style);\n\n    // Return the CSSStyleSheet interface for rule manipulation\n    return style.sheet;\n  }\n\n  // Generates unique class names to prevent style conflicts\n  generateClassName(componentId, hash) {\n    // Format: sc-{componentId}-{hash}\n    // Example: \"sc-button-abc123\"\n    return `sc-${componentId}-${hash}`;\n  }\n\n  // Injects CSS rules into the style sheet\n  injectStyles(className, cssText) {\n    // Check if we've already injected this style to avoid duplicates\n    if (!this.styles.has(className)) {\n      // Create a CSS rule string\n      const rule = `.${className} { ${cssText} }`;\n\n      // Insert the rule at the end of the style sheet\n      this.sheet.insertRule(rule, this.sheet.cssRules.length);\n\n      // Track that we've injected this style\n      this.styles.set(className, cssText);\n    }\n  }\n\n  // Removes unused styles to prevent memory leaks\n  removeStyles(className) {\n    // Only proceed if the style exists\n    if (this.styles.has(className)) {\n      // Find the CSS rule in the style sheet\n      for (let i = 0; i < this.sheet.cssRules.length; i++) {\n        // Check if this rule matches our class name\n        if (this.sheet.cssRules[i].selectorText.includes(className)) {\n          // Remove the rule from the style sheet\n          this.sheet.deleteRule(i);\n          break;\n        }\n      }\n      // Remove from our tracking map\n      this.styles.delete(className);\n    }\n  }\n}\n\n// Example usage:\n// const manager = new StyleManager();\n// manager.injectStyles('sc-button-abc123', 'background: blue; color: white;');\n// Results in: .sc-button-abc123 { background: blue; color: white; }\n"})}),"\n",(0,o.jsx)(n.h2,{id:"dynamic-styling-with-props",children:"Dynamic Styling with Props"}),"\n",(0,o.jsx)(n.h3,{id:"props-based-conditional-styling",children:"Props-Based Conditional Styling"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this demonstrates"}),": How to create dynamic, reusable components that change their appearance based on props."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Key concepts"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Functions in template literals receive props as arguments"}),"\n",(0,o.jsx)(n.li,{children:"Conditional logic can determine styles based on prop values"}),"\n",(0,o.jsx)(n.li,{children:"TypeScript interfaces provide type safety for props"}),"\n",(0,o.jsx)(n.li,{children:"Destructuring props makes code cleaner"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Input"}),": Component props (size, variant, outlined, etc.)\n",(0,o.jsx)(n.strong,{children:"Output"}),": Dynamic CSS styles based on prop values"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Benefits"}),": Single component handles multiple visual variations, reducing code duplication"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// Example of a highly configurable button component\n// This single component can handle multiple sizes, variants, and styles\nconst Button = styled.button`\n  /* Dynamic padding based on size prop */\n  padding: ${(props) => (props.size === "large" ? "16px 32px" : "8px 16px")};\n\n  /* Background color determined by variant prop */\n  background-color: ${(props) => {\n    // Switch statement allows for multiple variants\n    switch (props.variant) {\n      case "primary":\n        return "#007bff"; // Blue for primary actions\n      case "secondary":\n        return "#6c757d"; // Gray for secondary actions\n      case "danger":\n        return "#dc3545"; // Red for destructive actions\n      default:\n        return "#f8f9fa"; // Light gray as default\n    }\n  }};\n\n  /* Text color adapts to background */\n  color: ${(props) => (props.variant === "default" ? "#212529" : "white")};\n\n  /* Conditional border for outlined style */\n  border: 2px solid ${(props) =>\n      props.outlined ? "currentColor" : "transparent"};\n\n  /* Override background for outlined buttons */\n  background-color: ${(props) => props.outlined && "transparent"};\n`;\n\n// TypeScript interface for better development experience\n// Defines exactly what props the component accepts\ninterface ButtonProps {\n  variant?: "primary" | "secondary" | "danger" | "default"; // Color scheme\n  size?: "small" | "medium" | "large"; // Size variations\n  outlined?: boolean; // Style variant\n  fullWidth?: boolean; // Layout option\n}\n\n// TypeScript-enabled styled component with type safety\n// The <ButtonProps> generic provides IntelliSense and type checking\nconst TypedButton =\n  styled.button <\n  ButtonProps >\n  `\n  /* Using destructuring for cleaner prop access */\n  padding: ${({ size }) => {\n    // Object lookup is cleaner than switch statements\n    const sizes = {\n      small: "4px 8px",\n      medium: "8px 16px",\n      large: "12px 24px",\n    };\n    // Provide default value if size is undefined\n    return sizes[size || "medium"];\n  }};\n  \n  /* Conditional width styling */\n  width: ${({ fullWidth }) => fullWidth && "100%"};\n  \n  /* Other base styles would go here */\n`;\n\n// Usage examples:\n// <Button variant="primary" size="large">Primary Button</Button>\n// <Button variant="danger" outlined>Outlined Danger</Button>\n// <TypedButton fullWidth variant="secondary">Full Width</TypedButton>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"helper-functions-for-complex-logic",children:"Helper Functions for Complex Logic"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Purpose"}),": Extract complex styling logic into reusable utility functions for cleaner, more maintainable styled components."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Reduces code duplication across multiple components"}),"\n",(0,o.jsx)(n.li,{children:"Makes complex logic easier to test and maintain"}),"\n",(0,o.jsx)(n.li,{children:"Improves readability of styled component definitions"}),"\n",(0,o.jsx)(n.li,{children:"Enables consistent styling patterns across your application"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Pattern"}),": Create utility functions that return style objects or values, then use them in styled components."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Input"}),": Props or configuration values\n",(0,o.jsx)(n.strong,{children:"Output"}),": Style values or CSS properties"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// Utility function that encapsulates button variant logic\n// This keeps the styled component clean and makes the logic reusable\nconst getButtonVariant = (variant) => {\n  // Define all possible button variants in one place\n  const variants = {\n    primary: { bg: "#007bff", color: "white" }, // Blue primary button\n    secondary: { bg: "#6c757d", color: "white" }, // Gray secondary button\n    success: { bg: "#28a745", color: "white" }, // Green success button\n    danger: { bg: "#dc3545", color: "white" }, // Red danger button\n  };\n\n  // Return the variant object, or default to primary if variant doesn\'t exist\n  return variants[variant] || variants.primary;\n};\n\n// Clean, readable styled component that uses the utility function\nconst Button = styled.button`\n  /* Use helper function for background color */\n  background-color: ${(props) => getButtonVariant(props.variant).bg};\n\n  /* Use helper function for text color */\n  color: ${(props) => getButtonVariant(props.variant).color};\n\n  /* Standard button styling */\n  padding: 12px 24px; /* Comfortable button size */\n  border: none; /* Remove default border */\n  border-radius: 4px; /* Rounded corners */\n  cursor: pointer; /* Show it\'s interactive */\n  transition: all 0.2s ease; /* Smooth animations */\n\n  /* Interactive hover effects */\n  &:hover {\n    transform: translateY(-1px); /* Slight lift effect */\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow */\n  }\n`;\n\n// Usage examples:\n// <Button variant="primary">Primary Action</Button>\n// <Button variant="danger">Delete Item</Button>\n// <Button variant="success">Save Changes</Button>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"theming-system",children:"Theming System"}),"\n",(0,o.jsx)(n.h3,{id:"theme-provider-and-theme-access",children:"Theme Provider and Theme Access"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this demonstrates"}),": How to create a centralized design system using ThemeProvider for consistent styling across your entire application."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Key concepts"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"ThemeProvider uses React Context to make theme available to all child components"}),"\n",(0,o.jsx)(n.li,{children:"Theme objects organize design tokens (colors, spacing, typography, breakpoints)"}),"\n",(0,o.jsxs)(n.li,{children:["Components access theme via the ",(0,o.jsx)(n.code,{children:"theme"})," prop in template literals"]}),"\n",(0,o.jsx)(n.li,{children:"Responsive design is easier with centralized breakpoint definitions"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Consistent design system across the app"}),"\n",(0,o.jsx)(n.li,{children:"Easy theme switching (light/dark modes)"}),"\n",(0,o.jsx)(n.li,{children:"Centralized design token management"}),"\n",(0,o.jsx)(n.li,{children:"Better maintainability and scalability"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Flow"}),": Define theme \u2192 Wrap app with ThemeProvider \u2192 Access theme in styled components"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'import styled, { ThemeProvider } from "styled-components";\n\n// Central theme object - the single source of truth for your design system\nconst theme = {\n  // Color palette - organized by purpose\n  colors: {\n    primary: "#007bff", // Main brand color\n    secondary: "#6c757d", // Secondary actions\n    success: "#28a745", // Success states\n    danger: "#dc3545", // Error/danger states\n    light: "#f8f9fa", // Light backgrounds\n    dark: "#212529", // Dark text/backgrounds\n  },\n\n  // Spacing scale - consistent spacing throughout the app\n  spacing: {\n    xs: "4px", // Extra small spacing\n    sm: "8px", // Small spacing\n    md: "16px", // Medium spacing (base unit)\n    lg: "24px", // Large spacing\n    xl: "32px", // Extra large spacing\n  },\n\n  // Responsive breakpoints - mobile-first approach\n  breakpoints: {\n    mobile: "576px", // Small devices\n    tablet: "768px", // Medium devices\n    desktop: "992px", // Large devices\n    wide: "1200px", // Extra large devices\n  },\n\n  // Typography system - consistent text styling\n  typography: {\n    fontFamily: "Arial, sans-serif",\n    fontSize: {\n      small: "12px", // Small text\n      medium: "16px", // Body text\n      large: "20px", // Headings\n      xlarge: "24px", // Large headings\n    },\n  },\n};\n\n// Styled component that uses theme values\n// The { theme } parameter gives access to the theme object\nconst ThemedButton = styled.button`\n  /* Use theme colors for consistency */\n  background-color: ${({ theme }) => theme.colors.primary};\n  color: white;\n\n  /* Combine spacing values for padding */\n  padding: ${({ theme }) => `${theme.spacing.sm} ${theme.spacing.md}`};\n\n  /* Use theme typography */\n  font-family: ${({ theme }) => theme.typography.fontFamily};\n  font-size: ${({ theme }) => theme.typography.fontSize.medium};\n\n  /* Standard button styles */\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n\n  /* Responsive design using theme breakpoints */\n  @media (min-width: ${({ theme }) => theme.breakpoints.tablet}) {\n    /* Larger padding on tablet and up */\n    padding: ${({ theme }) => `${theme.spacing.md} ${theme.spacing.lg}`};\n  }\n`;\n\n// App component wrapped with ThemeProvider\n// This makes the theme available to ALL child components\nfunction App() {\n  return (\n    <ThemeProvider theme={theme}>\n      {/* All components inside can now access the theme */}\n      <ThemedButton>Themed Button</ThemedButton>\n      {/* Other components can also use the theme */}\n    </ThemeProvider>\n  );\n}\n\n// Additional themed components can be created anywhere in the app:\n// const ThemedCard = styled.div`\n//   background: ${({ theme }) => theme.colors.light};\n//   padding: ${({ theme }) => theme.spacing.lg};\n// `;\n'})}),"\n",(0,o.jsx)(n.h3,{id:"dynamic-theme-switching",children:"Dynamic Theme Switching"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this demonstrates"}),": How to implement theme switching (like dark/light mode) using React state and ThemeProvider."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Key concepts"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Multiple theme objects for different modes"}),"\n",(0,o.jsx)(n.li,{children:"React state to track current theme"}),"\n",(0,o.jsx)(n.li,{children:"Conditional theme selection based on state"}),"\n",(0,o.jsx)(n.li,{children:"Smooth transitions between themes using CSS transitions"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use cases"}),": Dark/light mode, seasonal themes, user preference settings, accessibility themes"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Implementation steps"}),":"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Define multiple theme objects"}),"\n",(0,o.jsx)(n.li,{children:"Use React state to track active theme"}),"\n",(0,o.jsx)(n.li,{children:"Conditionally pass theme to ThemeProvider"}),"\n",(0,o.jsx)(n.li,{children:"Add transitions for smooth theme changes"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'import { useState } from "react";\n\n// Light theme configuration\nconst lightTheme = {\n  colors: {\n    background: "#ffffff", // White background\n    text: "#000000", // Black text for contrast\n    // Add more light theme colors as needed\n  },\n};\n\n// Dark theme configuration\nconst darkTheme = {\n  colors: {\n    background: "#000000", // Black background\n    text: "#ffffff", // White text for contrast\n    // Add more dark theme colors as needed\n  },\n};\n\n// Main app component with theme switching logic\nfunction ThemeToggleApp() {\n  // State to track whether dark theme is active\n  const [isDark, setIsDark] = useState(false);\n\n  // Conditionally select theme based on state\n  const currentTheme = isDark ? darkTheme : lightTheme;\n\n  return (\n    // ThemeProvider with dynamic theme\n    <ThemeProvider theme={currentTheme}>\n      <Container>\n        {/* Button to toggle between themes */}\n        <button onClick={() => setIsDark(!isDark)}>\n          Switch to {isDark ? "Light" : "Dark"} Theme\n        </button>\n\n        {/* Your app content goes here */}\n        {/* All child components will automatically use the new theme */}\n      </Container>\n    </ThemeProvider>\n  );\n}\n\n// Container component that responds to theme changes\nconst Container = styled.div`\n  /* Use theme colors - these will change when theme switches */\n  background-color: ${({ theme }) => theme.colors.background};\n  color: ${({ theme }) => theme.colors.text};\n\n  /* Layout styles */\n  min-height: 100vh; /* Full viewport height */\n  padding: 20px; /* Comfortable padding */\n\n  /* Smooth transition when theme changes */\n  transition: all 0.3s ease;\n`;\n\n// Advanced theme switching with localStorage persistence:\n// function useTheme() {\n//   const [isDark, setIsDark] = useState(() => {\n//     // Load theme preference from localStorage\n//     return localStorage.getItem(\'theme\') === \'dark\';\n//   });\n//\n//   const toggleTheme = () => {\n//     setIsDark(!isDark);\n//     // Save theme preference\n//     localStorage.setItem(\'theme\', !isDark ? \'dark\' : \'light\');\n//   };\n//\n//   return { isDark, toggleTheme };\n// }\n'})}),"\n",(0,o.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,o.jsx)(n.h3,{id:"extending-and-composition",children:"Extending and Composition"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this demonstrates"}),": How to build component hierarchies using inheritance and composition patterns in styled-components."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Key benefits"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Reduces code duplication by sharing common styles"}),"\n",(0,o.jsx)(n.li,{children:"Creates consistent base styles across component variants"}),"\n",(0,o.jsx)(n.li,{children:"Makes it easy to maintain and update shared styling"}),"\n",(0,o.jsx)(n.li,{children:"Follows DRY (Don't Repeat Yourself) principles"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Pattern"}),": Create base components with shared styles, then extend them for specific variants."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use cases"}),": Button variants, card types, form input variations, typography scales"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"// Base button component with shared styles\n// This contains all the common styling that every button variant will have\nconst BaseButton = styled.button`\n  /* Common button properties shared by all variants */\n  padding: 12px 24px; /* Standard button size */\n  border: none; /* Remove default browser border */\n  border-radius: 4px; /* Rounded corners */\n  cursor: pointer; /* Show it's clickable */\n  font-size: 16px; /* Readable text size */\n  transition: all 0.2s ease; /* Smooth interactions */\n\n  /* Base styles that variants can override */\n  display: inline-block;\n  text-align: center;\n  text-decoration: none;\n  font-weight: 400;\n`;\n\n// Primary button extends BaseButton with specific styling\n// Inherits all BaseButton styles and adds variant-specific ones\nconst PrimaryButton = styled(BaseButton)`\n  /* Primary button specific styles */\n  background-color: #007bff; /* Blue background */\n  color: white; /* White text */\n\n  /* Primary button hover state */\n  &:hover {\n    background-color: #0056b3; /* Darker blue on hover */\n  }\n\n  /* Primary button focus state for accessibility */\n  &:focus {\n    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);\n  }\n`;\n\n// Outline button variant with different styling approach\nconst OutlineButton = styled(BaseButton)`\n  /* Outline button specific styles */\n  background-color: transparent; /* No background initially */\n  color: #007bff; /* Blue text */\n  border: 2px solid #007bff; /* Blue border */\n\n  /* Outline button hover state - inverts colors */\n  &:hover {\n    background-color: #007bff; /* Fill with blue background */\n    color: white; /* White text */\n  }\n\n  /* Outline button active state */\n  &:active {\n    background-color: #0056b3;\n    border-color: #0056b3;\n  }\n`;\n\n// Usage examples:\n// <BaseButton>Basic Button</BaseButton>\n// <PrimaryButton>Primary Action</PrimaryButton>\n// <OutlineButton>Secondary Action</OutlineButton>\n\n// You can create as many variants as needed:\n// const DangerButton = styled(BaseButton)`\n//   background-color: #dc3545;\n//   color: white;\n//   &:hover { background-color: #c82333; }\n// `;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"polymorphic-components",children:"Polymorphic Components"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this demonstrates"}),": How to create flexible components that can render as different HTML elements or React components while maintaining the same styling."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Key concepts"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"as"})," prop allows changing the underlying HTML element"]}),"\n",(0,o.jsx)(n.li,{children:"Same styles can be applied to different semantic elements"}),"\n",(0,o.jsx)(n.li,{children:"Works with both HTML elements and React components"}),"\n",(0,o.jsx)(n.li,{children:"Maintains accessibility and semantic meaning"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Reduces component duplication"}),"\n",(0,o.jsx)(n.li,{children:"Maintains consistent styling across different element types"}),"\n",(0,o.jsx)(n.li,{children:"Improves semantic HTML usage"}),"\n",(0,o.jsx)(n.li,{children:"Better accessibility support"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use cases"}),": Typography systems, layout components, navigation elements"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// Flexible text component that can render as any text element\n// This single component can handle paragraphs, headings, spans, etc.\nconst Text = styled.p`\n  /* Base text styling applied regardless of element type */\n  margin: 0; /* Reset browser defaults */\n  font-size: 16px; /* Base font size */\n  line-height: 1.5; /* Good readability */\n  color: ${({ theme }) => theme.colors.text}; /* Theme-aware text color */\n\n  /* Additional properties you might want */\n  font-family: inherit; /* Use parent font family */\n  font-weight: normal; /* Normal weight by default */\n`;\n\n// Examples showing the flexibility of polymorphic components\nfunction TextExamples() {\n  return (\n    <>\n      {/* Default usage - renders as <p> element */}\n      <Text>Default paragraph</Text>\n\n      {/* Renders as <span> for inline text */}\n      <Text as="span">Rendered as span</Text>\n\n      {/* Renders as <h2> for semantic heading */}\n      <Text as="h2">Rendered as heading</Text>\n\n      {/* Renders as custom React component */}\n      <Text as={Link} to="/home">\n        Rendered as Link component\n      </Text>\n\n      {/* Other HTML elements */}\n      <Text as="label">Form label text</Text>\n      <Text as="div">Block-level text</Text>\n      <Text as="strong">Important text</Text>\n    </>\n  );\n}\n\n// Advanced polymorphic component with conditional styling\nconst FlexibleButton = styled.button`\n  /* Base button styles */\n  padding: 12px 24px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n\n  /* Conditional styling based on the \'as\' prop */\n  ${({ as }) =>\n    as === "a" &&\n    `\n    text-decoration: none;\n    display: inline-block;\n  `}\n`;\n\n// Usage:\n// <FlexibleButton>Regular Button</FlexibleButton>\n// <FlexibleButton as="a" href="/link">Link styled as button</FlexibleButton>\n// <FlexibleButton as={RouterLink} to="/page">Router Link Button</FlexibleButton>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"global-styles-and-css-reset",children:"Global Styles and CSS Reset"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this demonstrates"}),": How to apply global styles and CSS resets using styled-components' ",(0,o.jsx)(n.code,{children:"createGlobalStyle"})," function."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Key concepts"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Global styles affect the entire document, not just components"}),"\n",(0,o.jsx)(n.li,{children:"CSS resets normalize browser default styles"}),"\n",(0,o.jsx)(n.li,{children:"Global styles can access theme values"}),"\n",(0,o.jsx)(n.li,{children:"Should be rendered at the root level of your app"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use cases"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"CSS resets and normalizations"}),"\n",(0,o.jsx)(n.li,{children:"Global font and color settings"}),"\n",(0,o.jsx)(n.li,{children:"Base HTML element styling"}),"\n",(0,o.jsx)(n.li,{children:"Third-party component overrides"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Best practices"}),": Keep global styles minimal, use them for base styles only"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'import { createGlobalStyle } from "styled-components";\n\n// Global style component that injects CSS into the document head\n// This affects ALL elements in your application\nconst GlobalStyle = createGlobalStyle`\n  /* Universal box-sizing for more predictable layouts */\n  * {\n    box-sizing: border-box;    /* Include padding and border in element width/height */\n  }\n\n  /* Reset and base styles for the body element */\n  body {\n    margin: 0;                 /* Remove default browser margins */\n    padding: 0;                /* Remove default browser padding */\n    \n    /* Theme-aware typography */\n    font-family: ${({ theme }) => theme.typography.fontFamily};\n    background-color: ${({ theme }) => theme.colors.background};\n    color: ${({ theme }) => theme.colors.text};\n    \n    /* Additional body styles for better UX */\n    line-height: 1.6;          /* Improve text readability */\n    -webkit-font-smoothing: antialiased;  /* Better font rendering on macOS */\n  }\n\n  /* Consistent heading spacing using theme values */\n  h1, h2, h3, h4, h5, h6 {\n    margin: 0 0 ${({ theme }) => theme.spacing.md} 0;  /* Bottom margin only */\n    font-weight: 600;          /* Slightly bolder headings */\n    line-height: 1.2;          /* Tighter line height for headings */\n  }\n\n  /* Reset button styles to inherit from parent */\n  button {\n    font-family: inherit;      /* Use same font as parent */\n    font-size: inherit;        /* Don\'t let browser override font size */\n  }\n  \n  /* Remove default list styling when lists are used for navigation */\n  ul, ol {\n    padding-left: 0;\n    margin: 0;\n  }\n  \n  /* Better link styling */\n  a {\n    color: ${({ theme }) => theme.colors.primary};\n    text-decoration: none;\n    \n    &:hover {\n      text-decoration: underline;\n    }\n  }\n  \n  /* Responsive images by default */\n  img {\n    max-width: 100%;\n    height: auto;\n  }\n`;\n\n// App component with global styles applied\nfunction App() {\n  return (\n    <ThemeProvider theme={theme}>\n      {/* Global styles must be inside ThemeProvider to access theme */}\n      <GlobalStyle />\n\n      {/* Rest of your application components */}\n      {/* All components will inherit these global styles */}\n    </ThemeProvider>\n  );\n}\n\n// Note: GlobalStyle is a component, not a regular styled component\n// It should be rendered once at the root level of your application\n// Multiple GlobalStyle components can be used if needed\n'})}),"\n",(0,o.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(n.h3,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this section covers"}),": Performance optimization strategies to ensure your styled-components render efficiently and don't cause unnecessary re-renders."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Key optimization principles"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Minimize function calls in template literals"}),"\n",(0,o.jsx)(n.li,{children:"Use static object syntax for unchanging styles"}),"\n",(0,o.jsx)(n.li,{children:"Memoize expensive computations"}),"\n",(0,o.jsx)(n.li,{children:"Extract complex logic outside of styled components"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Performance impact"}),": Proper optimization can reduce bundle size and improve runtime performance"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// Technique 1: Use object styles for completely static styles\n// This is more performant than template literals for static content\n// because it doesn\'t need to be processed on every render\nconst StaticButton = styled.button({\n  padding: "12px 24px" /* Static padding value */,\n  border: "none" /* Static border removal */,\n  borderRadius: "4px" /* Static border radius */,\n  cursor: "pointer" /* Static cursor style */,\n  // Use this approach when styles never change based on props or theme\n});\n\n// Technique 2: Memoize expensive computations using css helper\nimport { css } from "styled-components";\n\n// Pre-computed CSS blocks that can be reused\n// These are created once and cached, not recreated on every render\nconst buttonVariants = {\n  primary: css`\n    background-color: #007bff; /* Primary blue background */\n    color: white; /* White text */\n  `,\n  secondary: css`\n    background-color: #6c757d; /* Secondary gray background */\n    color: white; /* White text */\n  `,\n  // Add more variants as needed\n};\n\n// Optimized button that uses pre-computed variants\nconst OptimizedButton = styled.button`\n  /* Static styles that never change */\n  padding: 12px 24px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n\n  /* Dynamic styles using memoized CSS blocks */\n  ${(props) => buttonVariants[props.variant] || buttonVariants.primary}\n`;\n\n// Technique 3: Avoid inline functions - they hurt performance\n\n// \u274c BAD: Creates new function on every render\n// This causes styled-components to think the styles changed\n// even when the props are the same\nconst BadButton = styled.button`\n  color: ${(props) => (props.primary ? "white" : "black")};\n`;\n\n// \u2705 GOOD: Extract function outside of component\n// This function is created once and reused\nconst getButtonColor = (props) => (props.primary ? "white" : "black");\n\nconst GoodButton = styled.button`\n  color: ${getButtonColor}; /* Reference to stable function */\n`;\n\n// \u2705 ALTERNATIVE: Use css helper for conditional styles\nconst AlternativeButton = styled.button`\n  ${(props) =>\n    props.primary &&\n    css`\n      color: white;\n      background-color: blue;\n    `}\n  ${(props) =>\n    !props.primary &&\n    css`\n      color: black;\n      background-color: gray;\n    `}\n`;\n\n// Performance tip: For frequently changing props, consider using CSS custom properties\nconst CSSVariableButton = styled.button`\n  --button-color: ${(props) => props.color};\n  color: var(--button-color);\n  /* Browser handles the CSS variable changes more efficiently */\n`;\n'})}),"\n",(0,o.jsx)(n.h3,{id:"server-side-rendering-ssr",children:"Server-Side Rendering (SSR)"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this demonstrates"}),": How to properly configure styled-components for server-side rendering to prevent styling issues and improve performance."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"SSR challenges with CSS-in-JS"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Styles are generated at runtime, but SSR happens before JavaScript runs"}),"\n",(0,o.jsx)(n.li,{children:"Without proper setup, you get unstyled content flash (FOUC)"}),"\n",(0,o.jsx)(n.li,{children:"Style injection must happen on the server and be rehydrated on the client"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Solution"}),": Use ServerStyleSheet to collect styles during SSR and inject them into the initial HTML"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Benefits"}),": Faster first paint, better SEO, no flash of unstyled content"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"// Server-side rendering setup for Next.js\n// This ensures styles are available immediately when the page loads\nimport Document from \"next/document\";\nimport { ServerStyleSheet } from \"styled-components\";\n\n// Custom Document component that handles SSR style injection\nexport default class MyDocument extends Document {\n  static async getInitialProps(ctx) {\n    // Create a new ServerStyleSheet instance for this request\n    const sheet = new ServerStyleSheet();\n\n    // Store the original renderPage function\n    const originalRenderPage = ctx.renderPage;\n\n    try {\n      // Override renderPage to collect styles during rendering\n      ctx.renderPage = () =>\n        originalRenderPage({\n          // Enhance the App component to collect styles\n          enhanceApp: (App) => (props) =>\n            // Wrap the app with ServerStyleSheet to collect all styled-component styles\n            sheet.collectStyles(<App {...props} />),\n        });\n\n      // Get the initial props from the default Document\n      const initialProps = await Document.getInitialProps(ctx);\n\n      // Return the props with collected styles\n      return {\n        ...initialProps,\n        styles: (\n          <>\n            {/* Include any existing styles */}\n            {initialProps.styles}\n            {/* Add the collected styled-components styles */}\n            {sheet.getStyleElement()}\n          </>\n        ),\n      };\n    } finally {\n      // Clean up the style sheet to prevent memory leaks\n      sheet.seal();\n    }\n  }\n}\n\n// Alternative setup for other SSR frameworks (Express + React):\n// import { renderToString } from 'react-dom/server';\n// import { ServerStyleSheet } from 'styled-components';\n//\n// app.get('/', (req, res) => {\n//   const sheet = new ServerStyleSheet();\n//   try {\n//     const html = renderToString(\n//       sheet.collectStyles(<App />)\n//     );\n//     const styleTags = sheet.getStyleTags();\n//\n//     res.send(`\n//       <!DOCTYPE html>\n//       <html>\n//         <head>\n//           ${styleTags}\n//         </head>\n//         <body>\n//           <div id=\"root\">${html}</div>\n//         </body>\n//       </html>\n//     `);\n//   } finally {\n//     sheet.seal();\n//   }\n// });\n"})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(n.h3,{id:"component-organization",children:"Component Organization"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this demonstrates"}),": Best practices for organizing styled components in a maintainable and scalable way."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Organization benefits"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Clear separation of concerns"}),"\n",(0,o.jsx)(n.li,{children:"Easy to locate and maintain styles"}),"\n",(0,o.jsx)(n.li,{children:"Consistent file structure across the project"}),"\n",(0,o.jsx)(n.li,{children:"Better collaboration in team environments"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Recommended structure"}),": Keep styled components in separate files but close to their usage"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Alternative patterns"}),": Co-location, style directories, theme-based organization"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// File structure approach 1: Separate styles file\n// ComponentName/index.js - Main component logic\nimport { StyledWrapper, StyledTitle } from "./styles";\n\n// Clean component file focused on logic and structure\nexport function MyComponent({ title, children }) {\n  return (\n    <StyledWrapper>\n      <StyledTitle>{title}</StyledTitle>\n      {children}\n    </StyledWrapper>\n  );\n}\n\n// ComponentName/styles.js - All styling for this component\n// This keeps styles organized and easy to find\nexport const StyledWrapper = styled.div`\n  padding: 20px; /* Container spacing */\n  border: 1px solid #e0e0e0; /* Light border */\n  border-radius: 8px; /* Rounded corners */\n  background-color: white; /* Clean background */\n\n  /* Add responsive behavior */\n  @media (max-width: 768px) {\n    padding: 16px; /* Less padding on mobile */\n  }\n`;\n\nexport const StyledTitle = styled.h2`\n  margin: 0 0 16px 0; /* Bottom margin only */\n  color: #333; /* Dark gray text */\n  font-size: 1.5rem; /* Relative font size */\n  font-weight: 600; /* Semi-bold weight */\n  line-height: 1.2; /* Tight line height for headings */\n`;\n\n// Alternative approach 1: Co-location (styles in same file)\n// MyComponent.js\n// const StyledWrapper = styled.div`...`;\n// const StyledTitle = styled.h2`...`;\n// export function MyComponent() { ... }\n\n// Alternative approach 2: Theme-based organization\n// styles/\n//   components/\n//     Button.js\n//     Card.js\n//   layout/\n//     Grid.js\n//     Container.js\n//   typography/\n//     Heading.js\n//     Text.js\n\n// Alternative approach 3: Feature-based organization\n// features/\n//   user-profile/\n//     components/\n//       UserCard/\n//         index.js\n//         styles.js\n//     styles/\n//       shared.js\n'})}),"\n",(0,o.jsx)(n.h3,{id:"naming-conventions",children:"Naming Conventions"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this covers"}),": Best practices for naming styled components to improve code readability and maintainability."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Naming principles"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Use descriptive names that indicate purpose or content"}),"\n",(0,o.jsx)(n.li,{children:"Include the component type or role in the name"}),"\n",(0,o.jsx)(n.li,{children:"Avoid generic names that don't provide context"}),"\n",(0,o.jsx)(n.li,{children:"Be consistent across your codebase"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Benefits"}),": Easier debugging, better code understanding, improved team collaboration"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"// \u2705 GOOD: Clear, descriptive names that explain purpose\nconst NavigationHeader = styled.header`\n  /* Clearly indicates this is a header for navigation */\n  display: flex;\n  justify-content: space-between;\n  padding: 1rem 2rem;\n  background-color: white;\n  border-bottom: 1px solid #e0e0e0;\n`;\n\nconst PrimaryActionButton = styled.button`\n  /* Name indicates this is the main action button */\n  background-color: #007bff;\n  color: white;\n  padding: 12px 24px;\n  border: none;\n  border-radius: 4px;\n  font-weight: 600;\n`;\n\nconst ProductCardContainer = styled.div`\n  /* Clearly shows this contains product card content */\n  display: flex;\n  flex-direction: column;\n  border: 1px solid #ddd;\n  border-radius: 8px;\n  padding: 16px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n`;\n\n// \u2705 MORE GOOD EXAMPLES:\nconst UserProfileSection = styled.section``;\nconst SearchInputField = styled.input``;\nconst LoadingSpinner = styled.div``;\nconst ErrorMessageText = styled.p``;\nconst ModalOverlay = styled.div``;\n\n// \u274c AVOID: Generic or unclear names\nconst Wrapper = styled.div`\n  /* What does this wrap? Too generic */\n`;\n\nconst Container = styled.div`\n  /* What does this contain? Not descriptive */\n`;\n\nconst StyledDiv = styled.div`\n  /* Just says it's styled, but doesn't indicate purpose */\n`;\n\nconst Component = styled.div`\n  /* Extremely generic, provides no information */\n`;\n\n// \u274c MORE TO AVOID:\nconst Box = styled.div`;          /* Too generic */\nconst Element = styled.span`; /* Meaningless */\nconst Thing = styled.div`;        /* Unhelpful */\nconst MyStyledComponent = styled.div`; /* Not descriptive */\n\n// \u2705 NAMING PATTERNS TO FOLLOW:\n// For layout: HeaderSection, MainContent, SidebarPanel\n// For UI elements: SubmitButton, CancelLink, ErrorIcon\n// For cards/containers: ProductCard, UserProfile, CommentBlock\n// For form elements: EmailInput, PasswordField, SubmitButton\n// For navigation: NavLink, BreadcrumbItem, MenuToggle\n"})}),"\n",(0,o.jsx)(n.h3,{id:"performance-guidelines",children:"Performance Guidelines"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"What this covers"}),": Performance best practices to ensure your styled components render efficiently and don't cause performance bottlenecks."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Key performance principles"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Keep complex logic outside of template literals"}),"\n",(0,o.jsx)(n.li,{children:"Use simple conditions for dynamic styles"}),"\n",(0,o.jsx)(n.li,{children:"Extract expensive computations to external functions"}),"\n",(0,o.jsx)(n.li,{children:"Order styles logically (static first, then dynamic)"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Performance impact"}),": Following these guidelines prevents unnecessary re-renders and keeps your app responsive"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// \u2705 GOOD: Well-structured component with performance in mind\nconst Button = styled.button`\n  /* Static styles first - these never change and are most efficient */\n  padding: 12px 24px; /* Always the same padding */\n  border: none; /* Always remove border */\n  border-radius: 4px; /* Always rounded corners */\n  cursor: pointer; /* Always show pointer cursor */\n  font-size: 16px; /* Consistent font size */\n  transition: all 0.2s ease; /* Smooth transitions */\n\n  /* Simple dynamic styles - minimal performance impact */\n  background-color: ${(props) => (props.primary ? "#007bff" : "#6c757d")};\n  color: ${(props) => (props.primary ? "white" : "#333")};\n\n  /* Complex logic extracted to external functions - computed once */\n  ${(props) => getButtonVariant(props.variant)}\n  ${(props) => getButtonSize(props.size)}\n`;\n\n// External functions are created once, not on every render\nconst getButtonVariant = (variant) => {\n  const variants = {\n    success: "background-color: #28a745; color: white;",\n    danger: "background-color: #dc3545; color: white;",\n    warning: "background-color: #ffc107; color: black;",\n  };\n  return variants[variant] || "";\n};\n\nconst getButtonSize = (size) => {\n  const sizes = {\n    small: "padding: 6px 12px; font-size: 14px;",\n    large: "padding: 16px 32px; font-size: 18px;",\n  };\n  return sizes[size] || "";\n};\n\n// \u274c BAD: Expensive computations inside template literals\nconst BadButton = styled.button`\n  /* This runs on EVERY render, even when props haven\'t changed */\n  color: ${(props) => {\n    // Complex computation that happens repeatedly\n    const colors = calculateColors(props.theme); // Expensive function call\n    const matchedColor = colors.find((color) => color.name === props.variant);\n    const finalColor = matchedColor?.value || "black";\n\n    // Additional processing that slows down renders\n    return finalColor.toUpperCase();\n  }};\n\n  /* Another expensive operation */\n  font-size: ${(props) => {\n    // Complex calculation on every render\n    const baseSize = 16;\n    const multiplier =\n      props.theme.typography.sizeMultipliers.find((m) => m.name === props.size)\n        ?.value || 1;\n    return `${baseSize * multiplier}px`;\n  }};\n`;\n\n// \u2705 BETTER: Extract complex logic to memoized functions or external modules\nimport { useMemo } from "react";\n\n// Memoized computation (if used in a component)\nconst OptimizedComponent = ({ variant, theme }) => {\n  const buttonColor = useMemo(() => {\n    const colors = calculateColors(theme);\n    return colors.find((color) => color.name === variant)?.value || "black";\n  }, [variant, theme]);\n\n  return <OptimizedButton color={buttonColor}>Click me</OptimizedButton>;\n};\n\nconst OptimizedButton = styled.button`\n  /* Use the pre-computed value */\n  color: ${(props) => props.color};\n`;\n'})}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"Styled Components revolutionizes how we approach styling in React applications by bringing CSS directly into the component paradigm. By leveraging tagged template literals and providing powerful features like theming, props-based styling, and automatic scoping, it eliminates many traditional CSS pain points while maintaining the full power of CSS."}),"\n",(0,o.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Component-Scoped Styling"}),": Eliminates global CSS conflicts through automatic scoping"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dynamic Styling"}),": Props-based conditional styling enables flexible, reusable components"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Powerful Theming"}),": Centralized theme management with context-based propagation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Performance Considerations"}),": Proper usage patterns ensure optimal runtime performance"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Developer Experience"}),": Excellent tooling support and debugging capabilities"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Styled Components continues to be a popular choice for modern React applications, offering a balance of flexibility, maintainability, and performance. As referenced in the ",(0,o.jsx)(n.a,{href:"https://github.com/styled-components/styled-components",children:"Styled Components GitHub repository"}),", the library remains actively maintained with a strong community and comprehensive documentation."]}),"\n",(0,o.jsx)(n.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://styled-components.com/docs",children:"Styled Components Documentation"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://github.com/styled-components/styled-components",children:"Styled Components GitHub Repository"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://styled-components.com/docs/best-practices",children:"CSS-in-JS Best Practices"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://styled-components.com/docs/faqs#performance",children:"Performance Optimization Guide"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);