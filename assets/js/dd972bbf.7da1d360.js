"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4927],{2950:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"project-detail/react-router","title":"React Router: Declarative Routing for React","description":"Table of Contents","source":"@site/docs/project-detail/react-router.md","sourceDirName":"project-detail","slug":"/project-detail/react-router","permalink":"/frontend-system-design/docs/project-detail/react-router","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/react-router.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Redux Toolkit: Modern Redux Development","permalink":"/frontend-system-design/docs/project-detail/redux-toolkit"},"next":{"title":"Recharts: React Data Visualization Library","permalink":"/frontend-system-design/docs/project-detail/recharts"}}');var o=n(4848),s=n(8453);const a={},i="React Router: Declarative Routing for React",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Features",id:"key-features",level:3},{value:"Getting Started",id:"getting-started",level:2},{value:"Installation",id:"installation",level:3},{value:"Basic Setup",id:"basic-setup",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Router Types",id:"router-types",level:3},{value:"Route Configuration",id:"route-configuration",level:3},{value:"Under the Hood: How React Router Works",id:"under-the-hood-how-react-router-works",level:2},{value:"Router Implementation Concept",id:"router-implementation-concept",level:3},{value:"Route Matching System",id:"route-matching-system",level:3},{value:"Navigation System",id:"navigation-system",level:2},{value:"History Management",id:"history-management",level:3},{value:"Link and Navigation Components",id:"link-and-navigation-components",level:3},{value:"Advanced Routing Patterns",id:"advanced-routing-patterns",level:2},{value:"Nested Routes and Outlets",id:"nested-routes-and-outlets",level:3},{value:"Dynamic Route Loading",id:"dynamic-route-loading",level:3},{value:"Hooks and Navigation",id:"hooks-and-navigation",level:2},{value:"Core Router Hooks",id:"core-router-hooks",level:3},{value:"Custom Router Hooks",id:"custom-router-hooks",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Route Preloading",id:"route-preloading",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Route Organization",id:"route-organization",level:3},{value:"Error Boundaries",id:"error-boundaries",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Further Resources",id:"further-resources",level:3}];function d(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"react-router-declarative-routing-for-react",children:"React Router: Declarative Routing for React"})}),"\n",(0,o.jsx)(r.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"#getting-started",children:"Getting Started"})}),"\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"#core-concepts",children:"Core Concepts"})}),"\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"#under-the-hood-how-react-router-works",children:"Under the Hood: How React Router Works"})}),"\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"#navigation-system",children:"Navigation System"})}),"\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"#advanced-routing-patterns",children:"Advanced Routing Patterns"})}),"\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"#hooks-and-navigation",children:"Hooks and Navigation"})}),"\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsxs)(r.p,{children:["React Router is a declarative routing library for React applications. As highlighted in the ",(0,o.jsx)(r.a,{href:"https://github.com/remix-run/react-router",children:"React Router GitHub repository"}),", it serves as a multi-strategy router for React, bridging the gap from React 18 to React 19 and can be used maximally as a React framework or minimally as a library."]}),"\n",(0,o.jsx)(r.h3,{id:"key-features",children:"Key Features"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Declarative routing"}),": Define routes using JSX components"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Nested routing"}),": Support for complex UI hierarchies"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Dynamic routing"}),": Route parameters and programmatic navigation"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Code splitting"}),": Lazy loading of route components"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"History management"}),": Browser history integration"]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,o.jsx)(r.h3,{id:"installation",children:"Installation"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this does"}),": Install React Router DOM package which provides routing functionality for web applications."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Choose your preferred package manager (npm, yarn, or pnpm)"}),"\n",(0,o.jsx)(r.li,{children:"Run the installation command in your project directory"}),"\n",(0,o.jsxs)(r.li,{children:["The package will be added to your ",(0,o.jsx)(r.code,{children:"package.json"})," dependencies"]}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": Package manager command\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": React Router DOM installed and ready to use"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-bash",children:"# Install React Router DOM using npm (most common)\r\nnpm install react-router-dom\r\n\r\n# Or using yarn (alternative package manager)\r\nyarn add react-router-dom\r\n\r\n# Or using pnpm (fast, disk space efficient package manager)\r\npnpm add react-router-dom\n"})}),"\n",(0,o.jsx)(r.h3,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Creates a complete routing setup with a layout component, multiple pages, and navigation. This demonstrates the fundamental pattern of React Router with nested routes."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Import necessary React Router components"}),"\n",(0,o.jsx)(r.li,{children:"Create simple page components"}),"\n",(0,o.jsx)(r.li,{children:"Create a layout component with navigation"}),"\n",(0,o.jsx)(r.li,{children:"Configure the router with route definitions"}),"\n",(0,o.jsx)(r.li,{children:"Wrap the app with RouterProvider"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": URL changes (e.g., ",(0,o.jsx)(r.code,{children:"/"}),", ",(0,o.jsx)(r.code,{children:"/about"}),", ",(0,o.jsx)(r.code,{children:"/contact"}),")\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Different page components rendered while maintaining the same layout"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'import React from "react";\r\nimport { createBrowserRouter, RouterProvider, Outlet } from "react-router-dom";\r\n\r\n// Simple page components - these represent different "pages" in your app\r\nconst Home = () => <h1>Home Page</h1>;\r\nconst About = () => <h1>About Page</h1>;\r\nconst Contact = () => <h1>Contact Page</h1>;\r\n\r\n// Layout component - provides consistent structure across all pages\r\nconst Layout = () => (\r\n  <div>\r\n    {/* Navigation bar that appears on every page */}\r\n    <nav>\r\n      <a href="/">Home</a> | <a href="/about">About</a> |{" "}\r\n      <a href="/contact">Contact</a>\r\n    </nav>\r\n    {/* Main content area where child routes will be rendered */}\r\n    <main>\r\n      <Outlet /> {/* This is where child route components appear */}\r\n    </main>\r\n  </div>\r\n);\r\n\r\n// Router configuration - defines which component shows for each URL\r\nconst router = createBrowserRouter([\r\n  {\r\n    path: "/", // Root path\r\n    element: <Layout />, // Layout wraps all child routes\r\n    children: [\r\n      // Nested routes that render inside <Outlet />\r\n      { path: "/", element: <Home /> }, // localhost:3000/\r\n      { path: "/about", element: <About /> }, // localhost:3000/about\r\n      { path: "/contact", element: <Contact /> }, // localhost:3000/contact\r\n    ],\r\n  },\r\n]);\r\n\r\n// Main App component - entry point of your application\r\nfunction App() {\r\n  // RouterProvider makes routing context available to entire app\r\n  return <RouterProvider router={router} />;\r\n}\r\n\r\nexport default App;\n'})}),"\n",(0,o.jsx)(r.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,o.jsx)(r.h3,{id:"router-types",children:"Router Types"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Demonstrates the three main types of routers available in React Router, each serving different use cases and environments."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Import router creation functions from React Router"}),"\n",(0,o.jsx)(r.li,{children:"Create browser router for production web apps"}),"\n",(0,o.jsx)(r.li,{children:"Create hash router for legacy environments"}),"\n",(0,o.jsx)(r.li,{children:"Create memory router for testing or non-browser environments"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": Route configuration arrays with path and element mappings\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Router instances ready to be used with RouterProvider"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Use Cases"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Browser Router"}),": Modern web apps with server support for clean URLs"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Hash Router"}),": Static hosting or legacy servers that can't handle client-side routing"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Memory Router"}),": Testing environments or non-browser contexts"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'import {\r\n  createBrowserRouter,\r\n  createHashRouter,\r\n  createMemoryRouter,\r\n} from "react-router-dom";\r\n\r\n// Browser Router - Uses HTML5 History API (most common for web apps)\r\n// URLs look like: example.com/about\r\n// Requires server configuration to handle client-side routing\r\nconst browserRouter = createBrowserRouter([\r\n  { path: "/", element: <Home /> },\r\n  { path: "/about", element: <About /> },\r\n]);\r\n\r\n// Hash Router - Uses URL hash for routing\r\n// URLs look like: example.com/#/about\r\n// Works with any server setup, including static hosting\r\nconst hashRouter = createHashRouter([\r\n  { path: "/", element: <Home /> },\r\n  { path: "/about", element: <About /> },\r\n]);\r\n\r\n// Memory Router - Keeps routing state in memory (no URL changes)\r\n// Perfect for testing, React Native, or embedded environments\r\n// User won\'t see URL changes in the browser\r\nconst memoryRouter = createMemoryRouter([\r\n  { path: "/", element: <Home /> },\r\n  { path: "/about", element: <About /> },\r\n]);\n'})}),"\n",(0,o.jsx)(r.h3,{id:"route-configuration",children:"Route Configuration"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Demonstrates advanced route configuration patterns including nested routes, dynamic parameters, wildcard matching, and error handling."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Define route objects with path and element properties"}),"\n",(0,o.jsx)(r.li,{children:"Use nested children arrays for route hierarchies"}),"\n",(0,o.jsxs)(r.li,{children:["Configure dynamic route parameters with ",(0,o.jsx)(r.code,{children:":id"})," syntax"]}),"\n",(0,o.jsxs)(r.li,{children:["Set up wildcard routes with ",(0,o.jsx)(r.code,{children:"*"})," for catch-all behavior"]}),"\n",(0,o.jsx)(r.li,{children:"Create the router instance with the configuration"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": URL patterns and route definitions\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Configured router that matches URLs to components"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Route Patterns Explained"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.code,{children:"index: true"}),": Default child route (shows when parent path is matched exactly)"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.code,{children:":id"}),": Dynamic parameter (accessible via ",(0,o.jsx)(r.code,{children:"useParams()"})," hook)"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.code,{children:"*"}),": Wildcard that matches any remaining path segments"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.code,{children:'path: "*"'}),": Catch-all route for 404 handling"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'// Declarative route configuration - defines the entire app structure\r\nconst routes = [\r\n  {\r\n    path: "/", // Root path\r\n    element: <Layout />, // Layout component wraps all children\r\n    children: [\r\n      { index: true, element: <Home /> }, // Default route for "/"\r\n      { path: "about", element: <About /> }, // Static route "/about"\r\n      { path: "products/:id", element: <ProductDetail /> }, // Dynamic route "/products/123"\r\n      { path: "categories/*", element: <Categories /> }, // Wildcard route "/categories/anything/else"\r\n    ],\r\n  },\r\n  {\r\n    path: "/dashboard", // Separate route branch\r\n    element: <DashboardLayout />, // Different layout for dashboard\r\n    children: [\r\n      { path: "analytics", element: <Analytics /> }, // "/dashboard/analytics"\r\n      { path: "settings", element: <Settings /> }, // "/dashboard/settings"\r\n    ],\r\n  },\r\n  { path: "*", element: <NotFound /> }, // Catch-all for unmatched routes (404 page)\r\n];\r\n\r\n// Create the router instance with our route configuration\r\nconst router = createBrowserRouter(routes);\n'})}),"\n",(0,o.jsx)(r.h2,{id:"under-the-hood-how-react-router-works",children:"Under the Hood: How React Router Works"}),"\n",(0,o.jsx)(r.h3,{id:"router-implementation-concept",children:"Router Implementation Concept"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Shows a simplified version of how React Router works internally, demonstrating the core concepts of route matching, history management, and change notification."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Initialize router with routes and browser APIs"}),"\n",(0,o.jsx)(r.li,{children:"Listen for browser navigation events (back/forward buttons)"}),"\n",(0,o.jsx)(r.li,{children:"Match current URL against route patterns"}),"\n",(0,o.jsx)(r.li,{children:"Convert route patterns to regular expressions"}),"\n",(0,o.jsx)(r.li,{children:"Handle programmatic navigation"}),"\n",(0,o.jsx)(r.li,{children:"Notify components when routes change"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": Route definitions and URL changes\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Matched route information and component updates"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Key Concepts"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"History API"}),": Browser's native navigation system"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Pattern Matching"}),": Converting route patterns to regex for URL matching"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Observer Pattern"}),": Notifying components of route changes"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"State Management"}),": Tracking current location and navigation history"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'// Simplified Router implementation - shows core concepts\r\nclass Router {\r\n  constructor(routes) {\r\n    this.routes = routes; // Store route configuration\r\n    this.history = window.history; // Browser\'s History API\r\n    this.location = window.location; // Current browser location\r\n    this.listeners = []; // Components listening for changes\r\n\r\n    // Listen for browser navigation (back/forward buttons)\r\n    window.addEventListener("popstate", this.handlePopState.bind(this));\r\n  }\r\n\r\n  // Match current URL to route configuration\r\n  matchRoute(pathname) {\r\n    // Loop through all routes to find a match\r\n    for (const route of this.routes) {\r\n      const match = this.matchPath(route.path, pathname);\r\n      if (match) {\r\n        return { route, match }; // Return first matching route\r\n      }\r\n    }\r\n    return null; // No route matched\r\n  }\r\n\r\n  // Path matching algorithm - converts route patterns to regex\r\n  matchPath(routePath, pathname) {\r\n    // Convert route path to regex pattern\r\n    const pattern = routePath\r\n      .replace(/:[^/]+/g, "([^/]+)") // :id becomes ([^/]+) - matches any non-slash chars\r\n      .replace(/\\*/g, "(.*)"); // * becomes (.*) - matches anything\r\n\r\n    const regex = new RegExp(`^${pattern}$`); // Exact match required\r\n    const match = pathname.match(regex); // Test current path\r\n\r\n    if (match) {\r\n      const [, ...params] = match; // Extract captured groups (parameters)\r\n      return { params, pathname };\r\n    }\r\n\r\n    return null; // No match found\r\n  }\r\n\r\n  // Navigation methods - programmatic route changes\r\n  navigate(to, options = {}) {\r\n    if (options.replace) {\r\n      // Replace current history entry (no back button to previous page)\r\n      this.history.replaceState(null, "", to);\r\n    } else {\r\n      // Add new history entry (back button will work)\r\n      this.history.pushState(null, "", to);\r\n    }\r\n\r\n    // Tell all components about the route change\r\n    this.notifyListeners();\r\n  }\r\n\r\n  // Browser back/forward handling\r\n  handlePopState(event) {\r\n    // User clicked back or forward - update components\r\n    this.notifyListeners();\r\n  }\r\n\r\n  // Notify components of route changes\r\n  notifyListeners() {\r\n    const currentMatch = this.matchRoute(this.location.pathname);\r\n    // Call all registered listeners with current match\r\n    this.listeners.forEach((listener) => listener(currentMatch));\r\n  }\r\n\r\n  // Subscribe to route changes (components register themselves)\r\n  subscribe(listener) {\r\n    this.listeners.push(listener);\r\n    // Return unsubscribe function\r\n    return () => {\r\n      this.listeners = this.listeners.filter((l) => l !== listener);\r\n    };\r\n  }\r\n}\n'})}),"\n",(0,o.jsx)(r.h3,{id:"route-matching-system",children:"Route Matching System"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Implements a sophisticated route matching system that converts route patterns (like ",(0,o.jsx)(r.code,{children:"/users/:id"}),") into regular expressions and extracts parameters from URLs."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Convert route patterns to regular expressions"}),"\n",(0,o.jsx)(r.li,{children:"Extract parameter names from route patterns"}),"\n",(0,o.jsx)(r.li,{children:"Match current URL against the regex pattern"}),"\n",(0,o.jsx)(r.li,{children:"Extract parameter values from the matched URL"}),"\n",(0,o.jsx)(r.li,{children:"Return structured match result with parameters"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": Route pattern (",(0,o.jsx)(r.code,{children:"/users/:id"}),") and current URL (",(0,o.jsx)(r.code,{children:"/users/123"}),")\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Match object with extracted parameters (",(0,o.jsx)(r.code,{children:'{ params: { id: "123" } }'}),")"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Pattern Matching Examples"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.code,{children:"/users/:id"})," matches ",(0,o.jsx)(r.code,{children:"/users/123"})," \u2192 ",(0,o.jsx)(r.code,{children:'{ id: "123" }'})]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.code,{children:"/products/:category/:id"})," matches ",(0,o.jsx)(r.code,{children:"/products/electronics/456"})," \u2192 ",(0,o.jsx)(r.code,{children:'{ category: "electronics", id: "456" }'})]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.code,{children:"/search/*"})," matches ",(0,o.jsx)(r.code,{children:"/search/anything/here"})," \u2192 captures the wildcard part"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'// Path-to-RegExp style matching - converts route patterns to regex\r\nconst pathToRegexp = (path) => {\r\n  // Handle dynamic segments (:paramName)\r\n  const paramNames = []; // Store parameter names in order\r\n\r\n  // Replace :paramName with regex capture groups\r\n  const pattern = path.replace(/:([^/]+)/g, (match, paramName) => {\r\n    paramNames.push(paramName); // Remember parameter name\r\n    return "([^/]+)"; // Match any non-slash characters\r\n  });\r\n\r\n  return {\r\n    regex: new RegExp(`^${pattern}$`), // Exact match required (^ and $)\r\n    paramNames, // Array of parameter names\r\n  };\r\n};\r\n\r\n// Route matching function - tests if a URL matches a route pattern\r\nconst matchRoute = (routePath, currentPath) => {\r\n  const { regex, paramNames } = pathToRegexp(routePath);\r\n  const match = currentPath.match(regex); // Test URL against pattern\r\n\r\n  if (!match) return null; // No match found\r\n\r\n  // Extract captured groups (skip first element which is full match)\r\n  const [, ...values] = match;\r\n\r\n  // Create params object by mapping names to values\r\n  const params = paramNames.reduce((acc, name, index) => {\r\n    acc[name] = values[index]; // Associate parameter name with captured value\r\n    return acc;\r\n  }, {});\r\n\r\n  return { params, path: currentPath }; // Return match result\r\n};\r\n\r\n// Example usage - real-world route patterns\r\nconst routes = [\r\n  { path: "/users/:id", component: UserProfile }, // Single parameter\r\n  { path: "/products/:category/:id", component: ProductDetail }, // Multiple parameters\r\n  { path: "/search/*", component: SearchResults }, // Wildcard\r\n];\r\n\r\n// Test route matching\r\nconst currentPath = "/users/123";\r\nconst match = matchRoute("/users/:id", currentPath);\r\n// Result: { params: { id: "123" }, path: "/users/123" }\r\n\r\n// More examples:\r\n// matchRoute("/products/:category/:id", "/products/electronics/456")\r\n// Result: { params: { category: "electronics", id: "456" }, path: "/products/electronics/456" }\n'})}),"\n",(0,o.jsx)(r.h2,{id:"navigation-system",children:"Navigation System"}),"\n",(0,o.jsx)(r.h3,{id:"history-management",children:"History Management"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Implements a history management system that abstracts browser navigation, tracks navigation state, and provides programmatic control over browser history."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Initialize history with starting location and state"}),"\n",(0,o.jsx)(r.li,{children:"Provide methods for navigation (push, replace, go, back, forward)"}),"\n",(0,o.jsx)(r.li,{children:"Maintain internal history stack with current position"}),"\n",(0,o.jsx)(r.li,{children:"Sync with browser's native history API"}),"\n",(0,o.jsx)(r.li,{children:"Notify listeners when navigation occurs"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": Navigation commands (URLs, state objects, direction)\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Updated browser URL and component notifications"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Key Methods Explained"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"push()"}),": Add new history entry (normal navigation)"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"replace()"}),": Replace current entry (redirect behavior)"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"go()"}),": Navigate by offset (-1 for back, +1 for forward)"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"back()/forward()"}),": Convenience methods for common navigation"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'// History abstraction - manages browser navigation state\r\nclass History {\r\n  constructor() {\r\n    this.index = 0; // Current position in history stack\r\n    this.entries = [{ pathname: "/", state: null }]; // History stack (starts with root)\r\n    this.listeners = []; // Components listening for changes\r\n  }\r\n\r\n  // Navigate to new location (normal navigation - creates back button)\r\n  push(to, state = null) {\r\n    this.index++; // Move to next position\r\n    this.entries = this.entries.slice(0, this.index); // Remove any "forward" history\r\n    this.entries.push({ pathname: to, state }); // Add new entry\r\n\r\n    // Update browser URL and history\r\n    window.history.pushState(state, "", to);\r\n    this.notify(); // Tell components about change\r\n  }\r\n\r\n  // Replace current location (redirect - no back button to previous page)\r\n  replace(to, state = null) {\r\n    this.entries[this.index] = { pathname: to, state }; // Overwrite current entry\r\n\r\n    // Update browser URL without creating new history entry\r\n    window.history.replaceState(state, "", to);\r\n    this.notify(); // Tell components about change\r\n  }\r\n\r\n  // Go back/forward by number of steps\r\n  go(n) {\r\n    const newIndex = this.index + n; // Calculate new position\r\n\r\n    // Check bounds - can\'t go before start or after end\r\n    if (newIndex >= 0 && newIndex < this.entries.length) {\r\n      this.index = newIndex; // Update current position\r\n      const entry = this.entries[this.index]; // Get target entry\r\n      window.history.go(n); // Tell browser to navigate\r\n      this.notify(); // Tell components about change\r\n    }\r\n  }\r\n\r\n  // Convenience method - go back one step\r\n  back() {\r\n    this.go(-1);\r\n  }\r\n\r\n  // Convenience method - go forward one step\r\n  forward() {\r\n    this.go(1);\r\n  }\r\n\r\n  // Get current location object\r\n  get location() {\r\n    return this.entries[this.index]; // Return current history entry\r\n  }\r\n\r\n  // Listen for navigation changes (components subscribe here)\r\n  listen(listener) {\r\n    this.listeners.push(listener); // Add listener to list\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n      this.listeners = this.listeners.filter((l) => l !== listener);\r\n    };\r\n  }\r\n\r\n  // Notify all listeners of navigation change\r\n  notify() {\r\n    // Call each listener with current location\r\n    this.listeners.forEach((listener) => listener(this.location));\r\n  }\r\n}\n'})}),"\n",(0,o.jsx)(r.h3,{id:"link-and-navigation-components",children:"Link and Navigation Components"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Implements Link and NavLink components that enable client-side navigation without full page reloads, with support for active states and modifier key handling."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Create Link component that prevents default anchor behavior"}),"\n",(0,o.jsx)(r.li,{children:"Handle click events and delegate to React Router's navigation"}),"\n",(0,o.jsx)(r.li,{children:"Respect modifier keys for new tab/window behavior"}),"\n",(0,o.jsx)(r.li,{children:"Add NavLink with active state detection for styling"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": Target route, children content, optional styling props\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Clickable elements that trigger client-side navigation"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Key Features"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Client-side Navigation"}),": No page refresh when clicking links"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Modifier Key Support"}),": Ctrl/Cmd+click opens in new tab (native browser behavior)"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Active State"}),": NavLink can style the currently active route"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Accessibility"}),": Maintains semantic HTML anchor elements"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'// Link component implementation - enables client-side navigation\r\nconst Link = ({ to, children, replace = false, ...props }) => {\r\n  const navigate = useNavigate(); // Get navigation function from React Router\r\n\r\n  const handleClick = (event) => {\r\n    event.preventDefault(); // Prevent browser\'s default navigation\r\n\r\n    // Handle modifier keys - allow native browser behavior\r\n    // Ctrl/Cmd+click = new tab, Shift+click = new window\r\n    if (event.metaKey || event.ctrlKey || event.shiftKey) {\r\n      return; // Let browser handle this naturally\r\n    }\r\n\r\n    // Use React Router navigation instead of page reload\r\n    navigate(to, { replace });\r\n  };\r\n\r\n  return (\r\n    // Still render as anchor for accessibility and SEO\r\n    <a href={to} onClick={handleClick} {...props}>\r\n      {children}\r\n    </a>\r\n  );\r\n};\r\n\r\n// NavLink with active state - highlights current page in navigation\r\nconst NavLink = ({ to, children, activeClassName, ...props }) => {\r\n  const location = useLocation(); // Get current location\r\n  const isActive = location.pathname === to; // Check if this link is current page\r\n\r\n  return (\r\n    <Link\r\n      to={to}\r\n      className={isActive ? activeClassName : ""} // Apply active styles conditionally\r\n      {...props}\r\n    >\r\n      {children}\r\n    </Link>\r\n  );\r\n};\r\n\r\n// Usage examples:\r\n// <Link to="/about">About Us</Link>\r\n// <NavLink to="/products" activeClassName="active">Products</NavLink>\n'})}),"\n",(0,o.jsx)(r.h2,{id:"advanced-routing-patterns",children:"Advanced Routing Patterns"}),"\n",(0,o.jsx)(r.h3,{id:"nested-routes-and-outlets",children:"Nested Routes and Outlets"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Demonstrates nested routing architecture where parent components provide layout structure and child routes render within designated areas using the Outlet component."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Create layout component with navigation and content areas"}),"\n",(0,o.jsx)(r.li,{children:"Use Outlet component to mark where child routes render"}),"\n",(0,o.jsx)(r.li,{children:"Configure nested route structure in router configuration"}),"\n",(0,o.jsx)(r.li,{children:"Support multiple levels of nesting for complex UIs"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": Nested route definitions with parent-child relationships\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Hierarchical UI structure where layouts wrap content components"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Nesting Benefits"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Layout Persistence"}),": Navigation and sidebars stay visible during route changes"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Code Organization"}),": Logical grouping of related routes"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Shared Logic"}),": Common functionality at parent level (auth, data loading)"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Deep URLs"}),": Support for complex URL structures like ",(0,o.jsx)(r.code,{children:"/dashboard/users/123/edit"})]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'// Layout with nested routes - provides structure for dashboard section\r\nconst DashboardLayout = () => {\r\n  return (\r\n    <div className="dashboard">\r\n      {/* Sidebar navigation - stays visible for all dashboard routes */}\r\n      <aside>\r\n        <nav>\r\n          <Link to="/dashboard">Overview</Link> {/* /dashboard */}\r\n          <Link to="/dashboard/analytics">Analytics</Link> {/* /dashboard/analytics */}\r\n          <Link to="/dashboard/settings">Settings</Link>{" "}\r\n          {/* /dashboard/settings */}\r\n        </nav>\r\n      </aside>\r\n\r\n      {/* Main content area where child routes appear */}\r\n      <main>\r\n        <Outlet /> {/* This is where child route components render */}\r\n      </main>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Route configuration with nesting - creates hierarchical structure\r\nconst routes = [\r\n  {\r\n    path: "/dashboard", // Parent route\r\n    element: <DashboardLayout />, // Layout component wraps all children\r\n    children: [\r\n      // Child routes render inside <Outlet />\r\n      { index: true, element: <DashboardHome /> }, // Default: /dashboard\r\n      { path: "analytics", element: <Analytics /> }, // /dashboard/analytics\r\n      { path: "settings", element: <Settings /> }, // /dashboard/settings\r\n\r\n      // Deeply nested routes - another level of nesting\r\n      {\r\n        path: "users", // /dashboard/users\r\n        element: <UsersLayout />, // Another layout component\r\n        children: [\r\n          // More nested routes\r\n          { index: true, element: <UsersList /> }, // /dashboard/users\r\n          { path: ":id", element: <UserDetail /> }, // /dashboard/users/123\r\n          { path: ":id/edit", element: <UserEdit /> }, // /dashboard/users/123/edit\r\n        ],\r\n      },\r\n    ],\r\n  },\r\n];\r\n\r\n// Example URL structure this creates:\r\n// /dashboard \u2192 DashboardLayout + DashboardHome\r\n// /dashboard/analytics \u2192 DashboardLayout + Analytics\r\n// /dashboard/users \u2192 DashboardLayout + UsersLayout + UsersList\r\n// /dashboard/users/123 \u2192 DashboardLayout + UsersLayout + UserDetail\r\n// /dashboard/users/123/edit \u2192 DashboardLayout + UsersLayout + UserEdit\n'})}),"\n",(0,o.jsx)(r.h3,{id:"dynamic-route-loading",children:"Dynamic Route Loading"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Implements code splitting and lazy loading for route components, reducing initial bundle size and improving application performance by loading components only when needed."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Use React.lazy() to create lazy-loaded components"}),"\n",(0,o.jsx)(r.li,{children:"Wrap lazy components with Suspense for loading states"}),"\n",(0,o.jsx)(r.li,{children:"Create reusable helper function for consistent lazy loading"}),"\n",(0,o.jsx)(r.li,{children:"Configure routes with lazy-loaded components"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": Import functions that dynamically load components\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Smaller initial bundle, faster app startup, on-demand component loading"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Performance Benefits"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Reduced Initial Bundle"}),": Only load essential code upfront"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Faster Startup"}),": Quicker time to interactive"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Progressive Loading"}),": Load features as users navigate"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Better Caching"}),": Separate bundles can be cached independently"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'// Lazy loading with React.lazy - creates dynamically imported components\r\nconst LazyDashboard = React.lazy(() => import("./Dashboard")); // Loads Dashboard.js on demand\r\nconst LazySettings = React.lazy(() => import("./Settings")); // Loads Settings.js on demand\r\n\r\n// Route configuration with lazy loading - wraps with Suspense for loading UI\r\nconst routes = [\r\n  {\r\n    path: "/dashboard",\r\n    element: (\r\n      // Suspense shows fallback UI while component loads\r\n      <Suspense fallback={<div>Loading Dashboard...</div>}>\r\n        <LazyDashboard />\r\n      </Suspense>\r\n    ),\r\n  },\r\n  {\r\n    path: "/settings",\r\n    element: (\r\n      // Custom loading message for each route\r\n      <Suspense fallback={<div>Loading Settings...</div>}>\r\n        <LazySettings />\r\n      </Suspense>\r\n    ),\r\n  },\r\n];\r\n\r\n// Route-based code splitting - reusable helper for consistent lazy loading\r\nconst createLazyRoute = (importFunc, fallback = <div>Loading...</div>) => {\r\n  const LazyComponent = React.lazy(importFunc); // Create lazy component\r\n\r\n  return (\r\n    // Return wrapped component ready for route configuration\r\n    <Suspense fallback={fallback}>\r\n      <LazyComponent />\r\n    </Suspense>\r\n  );\r\n};\r\n\r\n// Usage - cleaner route configuration with helper function\r\nconst routes = [\r\n  {\r\n    path: "/products",\r\n    // Dynamically loads ./Products component\r\n    element: createLazyRoute(() => import("./Products")),\r\n  },\r\n  {\r\n    path: "/orders",\r\n    // Dynamically loads ./Orders component with custom loading UI\r\n    element: createLazyRoute(\r\n      () => import("./Orders"),\r\n      <div>Loading Orders...</div>\r\n    ),\r\n  },\r\n];\r\n\r\n// Bundle splitting result:\r\n// main.js - Core app code\r\n// products.chunk.js - Products component (loaded when visiting /products)\r\n// orders.chunk.js - Orders component (loaded when visiting /orders)\n'})}),"\n",(0,o.jsx)(r.h2,{id:"hooks-and-navigation",children:"Hooks and Navigation"}),"\n",(0,o.jsx)(r.h3,{id:"core-router-hooks",children:"Core Router Hooks"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Demonstrates React Router's built-in hooks that provide access to navigation functions, current location, route parameters, and URL search parameters within functional components."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Import necessary hooks from React Router"}),"\n",(0,o.jsx)(r.li,{children:"Use useNavigate for programmatic navigation"}),"\n",(0,o.jsx)(r.li,{children:"Access current location and route parameters"}),"\n",(0,o.jsx)(r.li,{children:"Manage URL search parameters"}),"\n",(0,o.jsx)(r.li,{children:"Handle navigation with various options"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": Hook function calls within React components\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Access to routing state and navigation functions"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Hook Functions Explained"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"useNavigate()"}),": Returns function for programmatic navigation"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"useLocation()"}),": Returns current location object (pathname, search, etc.)"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"useParams()"}),": Returns object with dynamic route parameters"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"useSearchParams()"}),": Returns array with search params and setter function"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'import {\r\n  useNavigate,\r\n  useLocation,\r\n  useParams,\r\n  useSearchParams,\r\n} from "react-router-dom";\r\n\r\n// Navigation hook example - programmatic navigation\r\nconst Navigation = () => {\r\n  const navigate = useNavigate(); // Get navigation function\r\n\r\n  const handleNavigation = () => {\r\n    // Basic programmatic navigation (equivalent to clicking a link)\r\n    navigate("/dashboard");\r\n\r\n    // Navigation with state - pass data to target route\r\n    navigate("/profile", { state: { from: "dashboard" } });\r\n\r\n    // Replace current entry - no back button to this page\r\n    navigate("/login", { replace: true });\r\n\r\n    // Go back in history (same as browser back button)\r\n    navigate(-1);\r\n\r\n    // Go forward in history\r\n    navigate(1);\r\n  };\r\n\r\n  return <button onClick={handleNavigation}>Navigate</button>;\r\n};\r\n\r\n// Location and params hooks - access routing information\r\nconst UserProfile = () => {\r\n  const location = useLocation(); // Current route info\r\n  const params = useParams(); // Dynamic route parameters\r\n  const [searchParams, setSearchParams] = useSearchParams(); // URL query parameters\r\n\r\n  // Access location properties\r\n  console.log("Current path:", location.pathname); // e.g., "/users/123"\r\n  console.log("Search string:", location.search); // e.g., "?tab=settings&filter=active"\r\n  console.log("Hash:", location.hash); // e.g., "#profile"\r\n  console.log("State:", location.state); // Data passed via navigate()\r\n\r\n  // Access route parameters (from route like "/users/:id")\r\n  console.log("User ID:", params.id); // e.g., "123"\r\n\r\n  // Access and manipulate search parameters\r\n  console.log("Search query:", searchParams.get("q")); // Get specific param\r\n  console.log("Filter:", searchParams.get("filter")); // Get another param\r\n\r\n  const updateSearch = () => {\r\n    // Update search parameters (URL becomes /users/123?q=new+search&filter=active)\r\n    setSearchParams({ q: "new search", filter: "active" });\r\n  };\r\n\r\n  const clearFilter = () => {\r\n    // Remove specific parameter\r\n    const newParams = new URLSearchParams(searchParams);\r\n    newParams.delete("filter");\r\n    setSearchParams(newParams);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <h1>User Profile: {params.id}</h1>\r\n      <p>Current tab: {searchParams.get("tab") || "overview"}</p>\r\n      <button onClick={updateSearch}>Update Search</button>\r\n      <button onClick={clearFilter}>Clear Filter</button>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Example for route: /users/:id?tab=settings&filter=active\r\n// params.id = "123"\r\n// searchParams.get("tab") = "settings"\r\n// searchParams.get("filter") = "active"\n'})}),"\n",(0,o.jsx)(r.h3,{id:"custom-router-hooks",children:"Custom Router Hooks"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Creates reusable custom hooks that encapsulate common routing patterns like authentication guards and query parameter management, making these features easy to use across components."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Create authentication guard hook for protected routes"}),"\n",(0,o.jsx)(r.li,{children:"Implement query parameter management utilities"}),"\n",(0,o.jsx)(r.li,{children:"Use React Router hooks internally for functionality"}),"\n",(0,o.jsx)(r.li,{children:"Return convenient API for components to use"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": Component needs (authentication state, query params)\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Reusable hooks with clean APIs for common routing tasks"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Custom Hook Benefits"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Code Reuse"}),": Same logic across multiple components"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Abstraction"}),": Hide complex routing logic behind simple APIs"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Consistency"}),": Standardized patterns for common needs"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Testability"}),": Easier to test isolated hook logic"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'// Custom hook for route guards - protects routes requiring authentication\r\nconst useAuthGuard = (redirectTo = "/login") => {\r\n  const navigate = useNavigate(); // Navigation function\r\n  const location = useLocation(); // Current location for redirect back\r\n  const isAuthenticated = useAuth(); // Your authentication logic\r\n\r\n  useEffect(() => {\r\n    // If user is not authenticated, redirect to login\r\n    if (!isAuthenticated) {\r\n      navigate(redirectTo, {\r\n        state: { from: location }, // Remember where user was trying to go\r\n        replace: true, // Replace history entry (no back button)\r\n      });\r\n    }\r\n  }, [isAuthenticated, navigate, redirectTo, location]);\r\n\r\n  return isAuthenticated; // Return auth status for component use\r\n};\r\n\r\n// Custom hook for query parameters - simplifies URL parameter management\r\nconst useQueryParams = () => {\r\n  const [searchParams, setSearchParams] = useSearchParams(); // Get URL search params\r\n\r\n  // Get single parameter value\r\n  const getParam = (key) => searchParams.get(key);\r\n\r\n  // Set single parameter value\r\n  const setParam = (key, value) => {\r\n    const newParams = new URLSearchParams(searchParams); // Copy current params\r\n\r\n    if (value === null || value === undefined) {\r\n      newParams.delete(key); // Remove if null/undefined\r\n    } else {\r\n      newParams.set(key, value); // Set new value\r\n    }\r\n\r\n    setSearchParams(newParams); // Update URL\r\n  };\r\n\r\n  // Remove specific parameter\r\n  const removeParam = (key) => {\r\n    const newParams = new URLSearchParams(searchParams);\r\n    newParams.delete(key); // Remove parameter\r\n    setSearchParams(newParams); // Update URL\r\n  };\r\n\r\n  // Return convenient API for managing query parameters\r\n  return { getParam, setParam, removeParam, searchParams };\r\n};\r\n\r\n// Usage examples:\r\n\r\n// Protected component using auth guard\r\nconst DashboardPage = () => {\r\n  const isAuthenticated = useAuthGuard(); // Automatically redirects if not authenticated\r\n\r\n  if (!isAuthenticated) {\r\n    return null; // Component won\'t render if redirecting\r\n  }\r\n\r\n  return <div>Dashboard Content</div>;\r\n};\r\n\r\n// Component using query parameter management\r\nconst ProductList = () => {\r\n  const { getParam, setParam } = useQueryParams();\r\n\r\n  const currentCategory = getParam("category") || "all";\r\n  const currentSort = getParam("sort") || "name";\r\n\r\n  const handleCategoryChange = (category) => {\r\n    setParam("category", category); // Updates URL: ?category=electronics\r\n  };\r\n\r\n  const handleSortChange = (sort) => {\r\n    setParam("sort", sort); // Updates URL: ?category=electronics&sort=price\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <select\r\n        value={currentCategory}\r\n        onChange={(e) => handleCategoryChange(e.target.value)}\r\n      >\r\n        <option value="all">All Categories</option>\r\n        <option value="electronics">Electronics</option>\r\n      </select>\r\n    </div>\r\n  );\r\n};\n'})}),"\n",(0,o.jsx)(r.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(r.h3,{id:"route-preloading",children:"Route Preloading"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Implements intelligent route preloading strategies to load components before users navigate to them, improving perceived performance by reducing loading times."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Create preloading function for lazy-loaded routes"}),"\n",(0,o.jsx)(r.li,{children:"Implement hover-based preloading for links"}),"\n",(0,o.jsx)(r.li,{children:"Use Intersection Observer for viewport-based preloading"}),"\n",(0,o.jsx)(r.li,{children:"Optimize timing to balance performance vs resource usage"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": Route definitions and user interactions (hover, scroll)\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Preloaded components ready for instant navigation"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Preloading Strategies"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Hover Preloading"}),": Load when user hovers over link (high intent)"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Viewport Preloading"}),": Load when link becomes visible (medium intent)"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Idle Preloading"}),": Load during browser idle time (low priority)"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Predictive Preloading"}),": Load based on user behavior patterns"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'// Route preloading strategy - finds and preloads lazy components\r\nconst preloadRoute = (routePath) => {\r\n  // Find the route configuration for the given path\r\n  const route = routes.find((r) => r.path === routePath);\r\n\r\n  // If route has lazy loading, trigger the import immediately\r\n  if (route && route.lazy) {\r\n    route.lazy(); // This starts downloading the component bundle\r\n  }\r\n};\r\n\r\n// Preload on hover - loads component when user hovers over link\r\nconst PreloadLink = ({ to, children, ...props }) => {\r\n  const handleMouseEnter = () => {\r\n    preloadRoute(to); // Start loading component on hover\r\n  };\r\n\r\n  // Also preload on focus for keyboard navigation\r\n  const handleFocus = () => {\r\n    preloadRoute(to);\r\n  };\r\n\r\n  return (\r\n    <Link\r\n      to={to}\r\n      onMouseEnter={handleMouseEnter} // Mouse hover preloading\r\n      onFocus={handleFocus} // Keyboard focus preloading\r\n      {...props}\r\n    >\r\n      {children}\r\n    </Link>\r\n  );\r\n};\r\n\r\n// Intersection Observer for preloading - loads when links become visible\r\nconst useIntersectionPreload = (routes) => {\r\n  useEffect(() => {\r\n    // Create observer to watch for elements entering viewport\r\n    const observer = new IntersectionObserver(\r\n      (entries) => {\r\n        entries.forEach((entry) => {\r\n          // When element becomes visible in viewport\r\n          if (entry.isIntersecting) {\r\n            const routePath = entry.target.dataset.preloadRoute;\r\n            if (routePath) {\r\n              preloadRoute(routePath); // Preload the route\r\n              observer.unobserve(entry.target); // Stop observing after preload\r\n            }\r\n          }\r\n        });\r\n      },\r\n      {\r\n        rootMargin: "50px", // Start preloading 50px before element is visible\r\n      }\r\n    );\r\n\r\n    // Find all elements marked for preloading and observe them\r\n    document.querySelectorAll("[data-preload-route]").forEach((el) => {\r\n      observer.observe(el);\r\n    });\r\n\r\n    // Cleanup observer when component unmounts\r\n    return () => observer.disconnect();\r\n  }, [routes]);\r\n};\r\n\r\n// Usage examples:\r\n\r\n// Basic preloading link\r\nconst NavigationMenu = () => (\r\n  <nav>\r\n    <PreloadLink to="/dashboard">Dashboard</PreloadLink>\r\n    <PreloadLink to="/settings">Settings</PreloadLink>\r\n  </nav>\r\n);\r\n\r\n// Viewport-based preloading\r\nconst PageWithPreloading = () => {\r\n  useIntersectionPreload(routes); // Setup intersection preloading\r\n\r\n  return (\r\n    <div>\r\n      <h1>Main Content</h1>\r\n      {/* These links will preload when they become visible */}\r\n      <a href="/products" data-preload-route="/products">\r\n        Products\r\n      </a>\r\n      <a href="/about" data-preload-route="/about">\r\n        About\r\n      </a>\r\n    </div>\r\n  );\r\n};\r\n\r\n// Advanced preloading with idle time\r\nconst useIdlePreload = (routePaths) => {\r\n  useEffect(() => {\r\n    // Use requestIdleCallback to preload during browser idle time\r\n    const preloadWhenIdle = () => {\r\n      if ("requestIdleCallback" in window) {\r\n        routePaths.forEach((path) => {\r\n          requestIdleCallback(() => preloadRoute(path));\r\n        });\r\n      } else {\r\n        // Fallback for browsers without requestIdleCallback\r\n        setTimeout(() => {\r\n          routePaths.forEach((path) => preloadRoute(path));\r\n        }, 2000);\r\n      }\r\n    };\r\n\r\n    preloadWhenIdle();\r\n  }, [routePaths]);\r\n};\n'})}),"\n",(0,o.jsx)(r.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Implements memory management strategies for React Router applications to prevent memory leaks, optimize component rendering, and handle large lists of routes efficiently."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Create cleanup hooks for route changes"}),"\n",(0,o.jsx)(r.li,{children:"Implement component memoization for performance"}),"\n",(0,o.jsx)(r.li,{children:"Use virtual scrolling for large route lists"}),"\n",(0,o.jsx)(r.li,{children:"Cancel ongoing operations when routes change"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": Route changes, component props, large data sets\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Optimized memory usage and improved performance"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Memory Management Benefits"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Leak Prevention"}),": Clean up resources when routes change"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Performance"}),": Reduce unnecessary re-renders"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Scalability"}),": Handle large numbers of routes efficiently"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"User Experience"}),": Maintain smooth navigation"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'// Route cleanup and memory management - prevents memory leaks\r\nconst useRouteCleanup = () => {\r\n  const location = useLocation(); // Current route location\r\n\r\n  useEffect(() => {\r\n    // This effect runs when the route changes\r\n\r\n    // Cleanup function runs when leaving the route\r\n    return () => {\r\n      // Cancel any pending HTTP requests to prevent memory leaks\r\n      // Example: abortController.abort();\r\n      // Clear any running intervals or timeouts\r\n      // Example: clearInterval(intervalId);\r\n      // Remove event listeners that might hold references\r\n      // Example: window.removeEventListener(\'resize\', handler);\r\n      // Clear any WebSocket connections\r\n      // Example: websocket.close();\r\n      // Cancel any ongoing animations\r\n      // Example: cancelAnimationFrame(animationId);\r\n    };\r\n  }, [location.pathname]); // Run cleanup when pathname changes\r\n};\r\n\r\n// Memoized route components - prevent unnecessary re-renders\r\nconst MemoizedRoute = React.memo(\r\n  ({ children, ...props }) => {\r\n    // Only re-render if props actually change\r\n    return children;\r\n  },\r\n  (prevProps, nextProps) => {\r\n    // Custom comparison function for complex props\r\n    return JSON.stringify(prevProps) === JSON.stringify(nextProps);\r\n  }\r\n);\r\n\r\n// Memory-efficient route wrapper\r\nconst OptimizedRoute = React.memo(({ component: Component, ...props }) => {\r\n  // Use route cleanup hook\r\n  useRouteCleanup();\r\n\r\n  // Render component with props\r\n  return <Component {...props} />;\r\n});\r\n\r\n// Virtual scrolling for large route lists - only render visible items\r\nconst VirtualRouteList = ({ routes, itemHeight = 50 }) => {\r\n  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 10 });\r\n  const [scrollTop, setScrollTop] = useState(0);\r\n\r\n  const containerHeight = 400; // Fixed container height\r\n  const totalHeight = routes.length * itemHeight; // Total scrollable height\r\n\r\n  // Calculate which routes should be visible\r\n  const handleScroll = (e) => {\r\n    const scrollTop = e.target.scrollTop;\r\n    setScrollTop(scrollTop);\r\n\r\n    const start = Math.floor(scrollTop / itemHeight);\r\n    const end = Math.min(\r\n      start + Math.ceil(containerHeight / itemHeight) + 1,\r\n      routes.length\r\n    );\r\n\r\n    setVisibleRange({ start, end });\r\n  };\r\n\r\n  // Only render visible routes for performance\r\n  const visibleRoutes = routes.slice(visibleRange.start, visibleRange.end);\r\n\r\n  return (\r\n    <div\r\n      style={{ height: containerHeight, overflow: "auto" }}\r\n      onScroll={handleScroll}\r\n    >\r\n      {/* Spacer for scrolled-past items */}\r\n      <div style={{ height: visibleRange.start * itemHeight }} />\r\n\r\n      {/* Render only visible route items */}\r\n      {visibleRoutes.map((route, index) => (\r\n        <MemoizedRoute key={route.path}>\r\n          <div\r\n            style={{ height: itemHeight }}\r\n            data-index={visibleRange.start + index}\r\n          >\r\n            <route.component />\r\n          </div>\r\n        </MemoizedRoute>\r\n      ))}\r\n\r\n      {/* Spacer for remaining items */}\r\n      <div\r\n        style={{\r\n          height: (routes.length - visibleRange.end) * itemHeight,\r\n        }}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\n// Usage example with cleanup:\r\nconst DataHeavyRoute = () => {\r\n  const [data, setData] = useState([]);\r\n  const abortControllerRef = useRef();\r\n\r\n  useEffect(() => {\r\n    // Create abort controller for request cancellation\r\n    abortControllerRef.current = new AbortController();\r\n\r\n    // Fetch data with cancellation support\r\n    fetchData({ signal: abortControllerRef.current.signal })\r\n      .then(setData)\r\n      .catch((error) => {\r\n        if (error.name !== "AbortError") {\r\n          console.error("Fetch error:", error);\r\n        }\r\n      });\r\n\r\n    // Cleanup on unmount or route change\r\n    return () => {\r\n      if (abortControllerRef.current) {\r\n        abortControllerRef.current.abort();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return <div>Data: {data.length} items</div>;\r\n};\n'})}),"\n",(0,o.jsx)(r.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(r.h3,{id:"route-organization",children:"Route Organization"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Demonstrates best practices for organizing routes in a scalable, maintainable way using feature-based grouping and helper functions for consistency."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Create helper function for feature-based route grouping"}),"\n",(0,o.jsx)(r.li,{children:"Organize routes by feature domain (auth, dashboard, etc.)"}),"\n",(0,o.jsx)(r.li,{children:"Use consistent patterns across all route definitions"}),"\n",(0,o.jsx)(r.li,{children:"Combine feature routes into main application configuration"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": Feature domains and their respective routes\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Well-organized, maintainable route structure"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Organization Benefits"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Maintainability"}),": Easy to find and modify related routes"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Scalability"}),": Add new features without cluttering main config"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Consistency"}),": Standardized patterns across features"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Team Collaboration"}),": Clear structure for multiple developers"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'// Feature-based route organization - groups related routes together\r\nconst createFeatureRoutes = (basePath, routes) => ({\r\n  path: basePath, // Base path for this feature (e.g., "/auth")\r\n  children: routes, // Array of routes within this feature\r\n});\r\n\r\n// Auth routes - all authentication-related routes grouped together\r\nconst authRoutes = createFeatureRoutes("/auth", [\r\n  { path: "login", element: <Login /> }, // /auth/login\r\n  { path: "register", element: <Register /> }, // /auth/register\r\n  { path: "forgot-password", element: <ForgotPassword /> }, // /auth/forgot-password\r\n  { path: "reset-password/:token", element: <ResetPassword /> }, // /auth/reset-password/abc123\r\n]);\r\n\r\n// Dashboard routes - all dashboard functionality grouped\r\nconst dashboardRoutes = createFeatureRoutes("/dashboard", [\r\n  { index: true, element: <DashboardHome /> }, // /dashboard (default)\r\n  { path: "analytics", element: <Analytics /> }, // /dashboard/analytics\r\n  { path: "settings", element: <Settings /> }, // /dashboard/settings\r\n  { path: "profile", element: <Profile /> }, // /dashboard/profile\r\n]);\r\n\r\n// User management routes - separate feature for user operations\r\nconst userRoutes = createFeatureRoutes("/users", [\r\n  { index: true, element: <UsersList /> }, // /users\r\n  { path: ":id", element: <UserDetail /> }, // /users/123\r\n  { path: ":id/edit", element: <UserEdit /> }, // /users/123/edit\r\n  { path: "create", element: <UserCreate /> }, // /users/create\r\n]);\r\n\r\n// Product routes - e-commerce functionality\r\nconst productRoutes = createFeatureRoutes("/products", [\r\n  { index: true, element: <ProductsList /> }, // /products\r\n  { path: "categories", element: <Categories /> }, // /products/categories\r\n  { path: ":id", element: <ProductDetail /> }, // /products/456\r\n  { path: ":id/reviews", element: <ProductReviews /> }, // /products/456/reviews\r\n]);\r\n\r\n// Combine all routes - main application route configuration\r\nconst appRoutes = [\r\n  // Root routes\r\n  { path: "/", element: <Home /> }, // Homepage\r\n  { path: "/about", element: <About /> }, // About page\r\n  { path: "/contact", element: <Contact /> }, // Contact page\r\n\r\n  // Feature routes\r\n  authRoutes, // All auth routes\r\n  dashboardRoutes, // All dashboard routes\r\n  userRoutes, // All user management routes\r\n  productRoutes, // All product routes\r\n\r\n  // Error handling\r\n  { path: "*", element: <NotFound /> }, // 404 catch-all\r\n];\r\n\r\n// Advanced organization with lazy loading and guards\r\nconst createProtectedFeatureRoutes = (\r\n  basePath,\r\n  routes,\r\n  requireAuth = true\r\n) => ({\r\n  path: basePath,\r\n  element: requireAuth ? <AuthGuard /> : undefined, // Wrap with auth guard\r\n  children: routes.map((route) => ({\r\n    ...route,\r\n    element: route.lazy\r\n      ? React.lazy(route.lazy) // Lazy load if specified\r\n      : route.element, // Regular component otherwise\r\n  })),\r\n});\r\n\r\n// Usage with protection and lazy loading\r\nconst adminRoutes = createProtectedFeatureRoutes(\r\n  "/admin",\r\n  [\r\n    {\r\n      path: "users",\r\n      lazy: () => import("./admin/UsersManagement"),\r\n    },\r\n    {\r\n      path: "settings",\r\n      lazy: () => import("./admin/AdminSettings"),\r\n    },\r\n  ],\r\n  true\r\n); // Requires authentication\r\n\r\n// Route configuration with metadata for navigation generation\r\nconst routesWithMetadata = [\r\n  {\r\n    path: "/",\r\n    element: <Home />,\r\n    meta: { title: "Home", showInNav: true, icon: "home" },\r\n  },\r\n  {\r\n    path: "/dashboard",\r\n    element: <DashboardLayout />,\r\n    meta: { title: "Dashboard", showInNav: true, icon: "dashboard" },\r\n    children: [\r\n      {\r\n        path: "analytics",\r\n        element: <Analytics />,\r\n        meta: { title: "Analytics", showInNav: true },\r\n      },\r\n    ],\r\n  },\r\n];\n'})}),"\n",(0,o.jsx)(r.h3,{id:"error-boundaries",children:"Error Boundaries"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"What this code does"}),": Implements error boundaries specifically for React Router applications, providing graceful error handling and recovery mechanisms for route-level errors."]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Create class-based error boundary component"}),"\n",(0,o.jsx)(r.li,{children:"Catch and handle JavaScript errors in routes"}),"\n",(0,o.jsx)(r.li,{children:"Provide user-friendly error UI with recovery options"}),"\n",(0,o.jsx)(r.li,{children:"Log errors for debugging and monitoring"}),"\n",(0,o.jsx)(r.li,{children:"Wrap route components with error boundaries"}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Input"}),": JavaScript errors thrown by route components\r\n",(0,o.jsx)(r.strong,{children:"Output"}),": Graceful error handling with recovery UI"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.strong,{children:"Error Boundary Benefits"}),":"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Graceful Degradation"}),": App continues working even when routes fail"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"User Experience"}),": Clear error messages instead of blank screens"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Error Recovery"}),": Users can retry without full page reload"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Debugging"}),": Centralized error logging and reporting"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:'// Route-level error boundary - catches errors in route components\r\nclass RouteErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      hasError: false,\r\n      error: null,\r\n      errorInfo: null,\r\n    };\r\n  }\r\n\r\n  // Called when an error occurs - update state to show error UI\r\n  static getDerivedStateFromError(error) {\r\n    return { hasError: true, error };\r\n  }\r\n\r\n  // Called after error is caught - for logging and side effects\r\n  componentDidCatch(error, errorInfo) {\r\n    console.error("Route error:", error, errorInfo);\r\n\r\n    // Log to error reporting service (e.g., Sentry, LogRocket)\r\n    // errorReportingService.captureException(error, {\r\n    //   tags: { section: \'routing\' },\r\n    //   extra: errorInfo\r\n    // });\r\n\r\n    this.setState({ errorInfo });\r\n  }\r\n\r\n  // Reset error state when route changes\r\n  componentDidUpdate(prevProps) {\r\n    if (prevProps.location !== this.props.location) {\r\n      this.setState({ hasError: false, error: null, errorInfo: null });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return (\r\n        <div className="error-boundary">\r\n          <h2>Oops! Something went wrong</h2>\r\n          <details style={{ whiteSpace: "pre-wrap" }}>\r\n            <summary>Error Details (click to expand)</summary>\r\n            <p>\r\n              <strong>Error:</strong> {this.state.error?.message}\r\n            </p>\r\n            <p>\r\n              <strong>Stack:</strong> {this.state.error?.stack}\r\n            </p>\r\n            {this.state.errorInfo?.componentStack && (\r\n              <p>\r\n                <strong>Component Stack:</strong>{" "}\r\n                {this.state.errorInfo.componentStack}\r\n              </p>\r\n            )}\r\n          </details>\r\n\r\n          <div className="error-actions">\r\n            {/* Reset error state and try again */}\r\n            <button\r\n              onClick={() =>\r\n                this.setState({ hasError: false, error: null, errorInfo: null })\r\n              }\r\n            >\r\n              Try Again\r\n            </button>\r\n\r\n            {/* Navigate to safe route */}\r\n            <button onClick={() => (window.location.href = "/")}>\r\n              Go Home\r\n            </button>\r\n\r\n            {/* Reload the page */}\r\n            <button onClick={() => window.location.reload()}>\r\n              Reload Page\r\n            </button>\r\n          </div>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return this.props.children; // Render children normally if no error\r\n  }\r\n}\r\n\r\n// Functional error boundary using react-error-boundary library (alternative)\r\nimport { ErrorBoundary } from "react-error-boundary";\r\n\r\nconst ErrorFallback = ({ error, resetErrorBoundary }) => (\r\n  <div className="error-fallback">\r\n    <h2>Something went wrong:</h2>\r\n    <pre>{error.message}</pre>\r\n    <button onClick={resetErrorBoundary}>Try again</button>\r\n  </div>\r\n);\r\n\r\n// Wrap routes with error boundary - higher-order component\r\nconst SafeRoute = ({ element }) => (\r\n  <RouteErrorBoundary>{element}</RouteErrorBoundary>\r\n);\r\n\r\n// Alternative using react-error-boundary\r\nconst SafeRouteWithLibrary = ({ element }) => (\r\n  <ErrorBoundary\r\n    FallbackComponent={ErrorFallback}\r\n    onError={(error, errorInfo) => {\r\n      console.error("Route error:", error, errorInfo);\r\n    }}\r\n    onReset={() => {\r\n      // Additional reset logic if needed\r\n      window.location.reload();\r\n    }}\r\n  >\r\n    {element}\r\n  </ErrorBoundary>\r\n);\r\n\r\n// Usage in route configuration\r\nconst routes = [\r\n  {\r\n    path: "/dashboard",\r\n    element: <SafeRoute element={<Dashboard />} />, // Wrapped with error boundary\r\n  },\r\n  {\r\n    path: "/profile",\r\n    element: <SafeRoute element={<UserProfile />} />, // Each route individually protected\r\n  },\r\n  {\r\n    path: "/settings",\r\n    element: <SafeRoute element={<Settings />} />,\r\n  },\r\n];\r\n\r\n// Global error boundary for entire router\r\nconst AppWithErrorBoundary = () => (\r\n  <RouteErrorBoundary>\r\n    <RouterProvider router={router} />\r\n  </RouteErrorBoundary>\r\n);\r\n\r\n// Async error boundary for handling Promise rejections\r\nconst AsyncErrorBoundary = ({ children }) => {\r\n  useEffect(() => {\r\n    const handleUnhandledRejection = (event) => {\r\n      console.error("Unhandled promise rejection:", event.reason);\r\n      // Could trigger error boundary or show notification\r\n    };\r\n\r\n    window.addEventListener("unhandledrejection", handleUnhandledRejection);\r\n\r\n    return () => {\r\n      window.removeEventListener(\r\n        "unhandledrejection",\r\n        handleUnhandledRejection\r\n      );\r\n    };\r\n  }, []);\r\n\r\n  return children;\r\n};\n'})}),"\n",(0,o.jsx)(r.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(r.p,{children:"React Router provides a powerful and flexible routing solution for React applications. By understanding its declarative API, history management, and internal routing mechanisms, developers can build sophisticated navigation systems that enhance user experience."}),"\n",(0,o.jsx)(r.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Declarative Routing"}),": Define routes using JSX configuration objects"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"History Management"}),": Leverages browser History API for seamless navigation"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Route Matching"}),": Powerful pattern matching with parameters and wildcards"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Component Composition"}),": Nested routes and outlet patterns for complex layouts"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Performance"}),": Code splitting and lazy loading for optimal bundle sizes"]}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:["As referenced in the ",(0,o.jsx)(r.a,{href:"https://github.com/remix-run/react-router",children:"React Router GitHub repository"}),", React Router continues to evolve as a comprehensive routing solution, bridging modern React patterns with robust navigation capabilities."]}),"\n",(0,o.jsx)(r.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"https://reactrouter.com/",children:"React Router Documentation"})}),"\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"https://github.com/remix-run/react-router",children:"React Router GitHub Repository"})}),"\n",(0,o.jsx)(r.li,{children:(0,o.jsx)(r.a,{href:"https://reactrouter.com/en/main/start/tutorial",children:"React Router Tutorial"})}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>i});var t=n(6540);const o={},s=t.createContext(o);function a(e){const r=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);