"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5640],{3492:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"project-detail/simple-interpreter","title":"Simple Interpreter: Building a Vietnamese Programming Language","description":"Table of Contents","source":"@site/docs/project-detail/simple-interpreter.md","sourceDirName":"project-detail","slug":"/project-detail/simple-interpreter","permalink":"/frontend-system-design/docs/project-detail/simple-interpreter","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/simple-interpreter.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Single-SPA: Microfrontend Framework","permalink":"/frontend-system-design/docs/project-detail/single-spa"}}');var i=t(4848),s=t(8453);const a={},o="Simple Interpreter: Building a Vietnamese Programming Language",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Project Goals",id:"project-goals",level:3},{value:"Project Overview",id:"project-overview",level:2},{value:"Technology Stack",id:"technology-stack",level:3},{value:"Project Structure",id:"project-structure",level:3},{value:"Interpreter Architecture",id:"interpreter-architecture",level:2},{value:"Three-Phase Compilation Pipeline",id:"three-phase-compilation-pipeline",level:3},{value:"Component Relationships",id:"component-relationships",level:3},{value:"Lexical Analysis (Tokenization)",id:"lexical-analysis-tokenization",level:2},{value:"Token Definition System",id:"token-definition-system",level:3},{value:"Lexer Implementation",id:"lexer-implementation",level:3},{value:"Parsing and AST Generation",id:"parsing-and-ast-generation",level:2},{value:"AST Node Definitions",id:"ast-node-definitions",level:3},{value:"Parser Implementation",id:"parser-implementation",level:3},{value:"Interpreter Execution",id:"interpreter-execution",level:2},{value:"Visitor Pattern for AST Traversal",id:"visitor-pattern-for-ast-traversal",level:3},{value:"Language Features",id:"language-features",level:2},{value:"Example Programs",id:"example-programs",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Memory Management",id:"memory-management",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Browser Integration",id:"browser-integration",level:2},{value:"Web Integration Layer",id:"web-integration-layer",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Code Organization",id:"code-organization",level:3},{value:"Testing Strategy",id:"testing-strategy",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Achievements",id:"key-achievements",level:3},{value:"Technical Highlights",id:"technical-highlights",level:3},{value:"Further Development",id:"further-development",level:3}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"simple-interpreter-building-a-vietnamese-programming-language",children:"Simple Interpreter: Building a Vietnamese Programming Language"})}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#project-overview",children:"Project Overview"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#interpreter-architecture",children:"Interpreter Architecture"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#lexical-analysis-tokenization",children:"Lexical Analysis (Tokenization)"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#parsing-and-ast-generation",children:"Parsing and AST Generation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#interpreter-execution",children:"Interpreter Execution"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#language-features",children:"Language Features"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#implementation-details",children:"Implementation Details"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#browser-integration",children:"Browser Integration"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["The Simple Interpreter project is a Vietnamese programming language interpreter built with Next.js and TypeScript that runs entirely in the browser. As shown in the ",(0,i.jsx)(n.a,{href:"https://github.com/binhphanhai/newbie-interpreter",children:"newbie-interpreter GitHub repository"}),", this project demonstrates how to create a complete programming language interpreter from scratch, featuring an interactive code editor, real-time interpretation, and client-side execution."]}),"\n",(0,i.jsx)(n.h3,{id:"project-goals",children:"Project Goals"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Educational"}),": Demonstrate interpreter construction principles"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Accessible"}),": Vietnamese language keywords for local developers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Interactive"}),": Real-time code execution in the browser"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Portable"}),": No server required, fully client-side implementation"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"project-overview",children:"Project Overview"}),"\n",(0,i.jsx)(n.h3,{id:"technology-stack",children:"Technology Stack"}),"\n",(0,i.jsx)(n.p,{children:"The following code demonstrates the comprehensive technology stack used in building the Vietnamese programming language interpreter. This stack is carefully chosen to balance performance, maintainability, and browser compatibility."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What this code does:"})," Defines the complete technology architecture for the interpreter project.\n",(0,i.jsx)(n.strong,{children:"Input:"})," Configuration object with nested properties for different system components.\n",(0,i.jsx)(n.strong,{children:"Output:"})," A structured overview of all technologies and approaches used.\n",(0,i.jsx)(n.strong,{children:"Purpose:"})," Provides a clear roadmap of technical decisions and architectural choices."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// Project configuration from package.json perspective\n// This object maps out the entire technical ecosystem of the interpreter\nconst projectStack = {\n  // Frontend framework choice - Next.js provides excellent developer experience\n  // with built-in TypeScript support and optimized bundling\n  frontend: "Next.js with TypeScript",\n\n  // UI layer - React components with CSS modules for scoped styling\n  // CSS modules prevent style conflicts and improve maintainability\n  ui: "React components with CSS modules",\n\n  // Deployment strategy - Static export enables hosting on GitHub Pages\n  // No server required, making the interpreter fully client-side\n  deployment: "Static export for GitHub Pages",\n\n  // Core interpreter components - each serves a specific role in the compilation pipeline\n  interpreter: {\n    // Lexer: Converts raw text into meaningful tokens (words, operators, etc.)\n    lexer: "TypeScript-based tokenization",\n\n    // Parser: Builds a tree structure (AST) from the stream of tokens\n    // Uses recursive descent parsing for readable and maintainable code\n    parser: "Recursive descent parser",\n\n    // AST: Intermediate representation that captures program structure\n    // Makes it easy to traverse and manipulate the program before execution\n    ast: "Abstract Syntax Tree representation",\n\n    // Executor: Walks through the AST and actually runs the program\n    // Tree-walking is simple to implement and debug\n    executor: "Tree-walking interpreter",\n  },\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"project-structure",children:"Project Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"newbie-interpreter/\n\u251c\u2500\u2500 component/          # React UI components\n\u251c\u2500\u2500 helper/            # Core interpreter logic \u2b50\n\u2502   \u251c\u2500\u2500 lexer.ts       # Tokenization\n\u2502   \u251c\u2500\u2500 parser.ts      # AST generation\n\u2502   \u251c\u2500\u2500 ast.ts         # AST node definitions\n\u2502   \u2514\u2500\u2500 interpreter.ts # Execution engine\n\u251c\u2500\u2500 examples/          # Sample programs\n\u251c\u2500\u2500 pages/            # Next.js pages\n\u2514\u2500\u2500 public/           # Static assets\n"})}),"\n",(0,i.jsx)(n.h2,{id:"interpreter-architecture",children:"Interpreter Architecture"}),"\n",(0,i.jsx)(n.h3,{id:"three-phase-compilation-pipeline",children:"Three-Phase Compilation Pipeline"}),"\n",(0,i.jsx)(n.p,{children:"This section demonstrates the core architecture of the interpreter using a three-phase compilation pipeline. This is the standard approach used by most programming languages and provides clear separation of concerns."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What this code does:"})," Implements the main interpreter pipeline that processes Vietnamese source code through three distinct phases.\n",(0,i.jsx)(n.strong,{children:"Input:"}),' Raw Vietnamese source code as a string (e.g., "g\xe1n a = 10")\n',(0,i.jsx)(n.strong,{children:"Output:"})," Executed result with program output and final variable states\n",(0,i.jsx)(n.strong,{children:"Steps:"})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lexical Analysis:"})," Breaks down text into meaningful tokens (keywords, operators, numbers, etc.)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Syntax Analysis:"})," Converts tokens into an Abstract Syntax Tree (AST) representing program structure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Execution:"})," Traverses the AST and evaluates the program, producing final results"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Simplified interpreter pipeline\n// This class orchestrates the entire interpretation process from source code to execution\nclass InterpreterPipeline {\n  constructor() {\n    // Initialize the three core components of the interpreter\n    // Each component handles a specific phase of the compilation process\n    this.lexer = new Lexer(); // Phase 1: Text \u2192 Tokens\n    this.parser = new Parser(); // Phase 2: Tokens \u2192 AST\n    this.interpreter = new Interpreter(); // Phase 3: AST \u2192 Results\n  }\n\n  execute(sourceCode) {\n    // Phase 1: Lexical Analysis (Text \u2192 Tokens)\n    // Convert raw Vietnamese text into a stream of meaningful tokens\n    // Example: \"g\xe1n a = 10\" becomes [GAN, IDENTIFIER(a), ASSIGN, NUMBER(10)]\n    const tokens = this.lexer.tokenize(sourceCode);\n\n    // Phase 2: Syntax Analysis (Tokens \u2192 AST)\n    // Build an Abstract Syntax Tree that represents the program's structure\n    // This validates syntax and creates a tree-like representation of the code\n    const ast = this.parser.parse(tokens);\n\n    // Phase 3: Execution (AST \u2192 Result)\n    // Walk through the AST and actually execute the program\n    // Variables are stored, expressions are evaluated, and output is generated\n    const result = this.interpreter.evaluate(ast);\n\n    return result;\n  }\n}\n\n// Example Vietnamese code execution\n// This demonstrates a simple program with variable assignment and arithmetic\nconst code = `\ng\xe1n a = 10    // Assign value 10 to variable 'a'\ng\xe1n b = 20    // Assign value 20 to variable 'b'\nin (a + b)    // Print the sum of a and b (should output 30)\n`;\n\n// Create interpreter instance and execute the Vietnamese code\nconst interpreter = new InterpreterPipeline();\nconst output = interpreter.execute(code); // \u2192 30\n\n// The execution flow:\n// 1. Lexer converts text into tokens: [GAN, IDENTIFIER(a), ASSIGN, NUMBER(10), ...]\n// 2. Parser builds AST with assignment and print statement nodes\n// 3. Interpreter executes: creates variables a=10, b=20, then prints 30\n"})}),"\n",(0,i.jsx)(n.h3,{id:"component-relationships",children:"Component Relationships"}),"\n",(0,i.jsx)(n.p,{children:"This section illustrates how the three main components of the interpreter work together in a pipeline. Understanding these relationships is crucial for debugging and extending the interpreter."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What this code does:"})," Maps the data flow and responsibilities between interpreter components.\n",(0,i.jsx)(n.strong,{children:"Input:"})," Architecture configuration showing component interfaces and dependencies.\n",(0,i.jsx)(n.strong,{children:"Output:"})," Clear understanding of how data flows through the interpretation pipeline.\n",(0,i.jsx)(n.strong,{children:"Purpose:"})," Provides a blueprint for understanding component interactions and debugging issues."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// Interpreter component architecture\n// This object defines the clear separation of concerns and data flow between components\nconst interpreterArchitecture = {\n  // Starting point: Vietnamese source code as plain text\n  input: "Vietnamese source code",\n\n  // LEXER COMPONENT: First phase of interpretation\n  lexer: {\n    // Takes raw Vietnamese text character by character\n    input: "Raw text",\n\n    // Produces a sequence of tokens (keywords, operators, literals, etc.)\n    // Example: "g\xe1n x = 5" \u2192 [GAN_TOKEN, IDENTIFIER_TOKEN(x), ASSIGN_TOKEN, NUMBER_TOKEN(5)]\n    output: "Token stream",\n\n    // Primary job: Convert text into meaningful symbols that the parser can understand\n    // Handles: keyword recognition, string parsing, number parsing, operator detection\n    responsibility: "Character-by-character analysis",\n  },\n\n  // PARSER COMPONENT: Second phase of interpretation\n  parser: {\n    // Consumes the stream of tokens produced by the lexer\n    input: "Token stream",\n\n    // Builds a hierarchical tree structure representing program logic\n    // Each node represents a language construct (statement, expression, etc.)\n    output: "Abstract Syntax Tree",\n\n    // Primary job: Ensure syntax is correct and build meaningful program structure\n    // Handles: Grammar validation, precedence rules, AST node creation\n    responsibility: "Syntax validation and structure building",\n  },\n\n  // INTERPRETER COMPONENT: Third phase of interpretation\n  interpreter: {\n    // Works with the structured AST built by the parser\n    input: "Abstract Syntax Tree",\n\n    // Produces actual program results: printed output, variable values, etc.\n    // Example: Final result might be { output: ["30"], variables: {a: 10, b: 20} }\n    output: "Execution result",\n\n    // Primary job: Actually run the program by walking through the AST\n    // Handles: Variable storage, expression evaluation, statement execution\n    responsibility: "Tree traversal and evaluation",\n  },\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"lexical-analysis-tokenization",children:"Lexical Analysis (Tokenization)"}),"\n",(0,i.jsx)(n.h3,{id:"token-definition-system",children:"Token Definition System"}),"\n",(0,i.jsx)(n.p,{children:"The token definition system is the foundation of the lexer, defining all possible meaningful units in the Vietnamese programming language. Each token represents a specific type of language element that the parser can understand."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What this code does:"})," Defines an enumeration of all token types and the Token interface structure.\n",(0,i.jsx)(n.strong,{children:"Input:"})," Source code characters that need to be classified into meaningful units.\n",(0,i.jsx)(n.strong,{children:"Output:"})," Typed tokens with position information for error reporting and parsing.\n",(0,i.jsx)(n.strong,{children:"Purpose:"})," Creates a standardized vocabulary that both the lexer and parser can use to communicate."]}),"\n",(0,i.jsx)(n.p,{children:"The enum uses string literals instead of numbers for better debugging and error messages. Each token carries positional information (line/column) for helpful error reporting."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Token types for Vietnamese programming language\n// This enum defines every possible type of token our lexer can recognize\nenum TokenType {\n  // LITERALS: Raw values that appear directly in code\n  NUMBER = "NUMBER", // Numeric literals: 42, 3.14, -7\n  STRING = "STRING", // Text literals: "Xin ch\xe0o", "Hello World"\n  BOOLEAN = "BOOLEAN", // Boolean literals: \u0111\xfang (true), sai (false)\n\n  // IDENTIFIERS: User-defined names for variables, functions, etc.\n  IDENTIFIER = "IDENTIFIER", // Variable names: myVar, userName, t\u1ed5ng\n\n  // KEYWORDS (Vietnamese): Reserved words that have special meaning\n  GAN = "GAN", // g\xe1n (assign) - for variable assignment\n  NEU = "NEU", // n\u1ebfu (if) - conditional statements\n  KHAC = "KHAC", // kh\xe1c (else) - alternative branch in conditionals\n  LAP = "LAP", // l\u1eb7p (loop) - for iteration constructs\n  HAM = "HAM", // h\xe0m (function) - function definitions\n  TRA_VE = "TRA_VE", // tr\u1ea3 v\u1ec1 (return) - return statements\n  IN = "IN", // in (print) - output statements\n\n  // OPERATORS: Symbols that perform operations on values\n  PLUS = "PLUS", // + (addition or string concatenation)\n  MINUS = "MINUS", // - (subtraction or negation)\n  MULTIPLY = "MULTIPLY", // * (multiplication)\n  DIVIDE = "DIVIDE", // / (division)\n  ASSIGN = "ASSIGN", // = (assignment operator)\n  EQUAL = "EQUAL", // == (equality comparison)\n  NOT_EQUAL = "NOT_EQUAL", // != (inequality comparison)\n\n  // DELIMITERS: Symbols that structure and separate code elements\n  LPAREN = "LPAREN", // ( (left parenthesis - grouping, function calls)\n  RPAREN = "RPAREN", // ) (right parenthesis)\n  LBRACE = "LBRACE", // { (left brace - code blocks)\n  RBRACE = "RBRACE", // } (right brace)\n  SEMICOLON = "SEMICOLON", // ; (statement terminator)\n  NEWLINE = "NEWLINE", // \\n (line breaks - statement separators)\n\n  // SPECIAL: Control tokens for parsing state\n  EOF = "EOF", // End of file marker - signals completion\n}\n\n// Token interface: Structure that holds token information\n// Every token created by the lexer must conform to this interface\ninterface Token {\n  type: TokenType; // What kind of token this is (from enum above)\n  value: string; // The actual text content (e.g., "g\xe1n", "42", "myVar")\n  line: number; // Line number where token appears (1-based)\n  column: number; // Column position where token starts (1-based)\n}\n\n// Example tokens that would be created:\n// Input: "g\xe1n x = 10"\n// Tokens: [\n//   { type: TokenType.GAN, value: "g\xe1n", line: 1, column: 1 },\n//   { type: TokenType.IDENTIFIER, value: "x", line: 1, column: 5 },\n//   { type: TokenType.ASSIGN, value: "=", line: 1, column: 7 },\n//   { type: TokenType.NUMBER, value: "10", line: 1, column: 9 }\n// ]\n'})}),"\n",(0,i.jsx)(n.h3,{id:"lexer-implementation",children:"Lexer Implementation"}),"\n",(0,i.jsx)(n.p,{children:"The Lexer class is responsible for converting raw Vietnamese source code into a stream of tokens. It processes the input character by character, recognizing patterns and classifying them into appropriate token types."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What this code does:"})," Implements a character-by-character scanner that transforms source code into tokens.\n",(0,i.jsx)(n.strong,{children:"Input:"})," Raw Vietnamese source code as a string.\n",(0,i.jsx)(n.strong,{children:"Output:"})," An array of Token objects representing all meaningful elements in the code.\n",(0,i.jsx)(n.strong,{children:"Key Features:"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Tracks line and column positions for error reporting"}),"\n",(0,i.jsx)(n.li,{children:"Handles Vietnamese Unicode characters properly"}),"\n",(0,i.jsx)(n.li,{children:"Supports escape sequences in strings"}),"\n",(0,i.jsx)(n.li,{children:"Skips whitespace and comments"}),"\n",(0,i.jsx)(n.li,{children:"Provides lookahead capability for multi-character operators"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'class Lexer {\n  // Core state variables for tracking position in the source code\n  private text: string; // The complete source code being tokenized\n  private position: number; // Current character index (0-based)\n  private currentChar: string | null; // Character at current position (null if EOF)\n  private line: number; // Current line number (1-based for human-readable errors)\n  private column: number; // Current column position (1-based)\n\n  constructor(text: string) {\n    // Initialize lexer with source code\n    this.text = text;\n    this.position = 0;\n\n    // Set current character to first character, or null if empty string\n    this.currentChar = this.text[0] || null;\n\n    // Start position tracking at line 1, column 1 (human-readable coordinates)\n    this.line = 1;\n    this.column = 1;\n  }\n\n  // CHARACTER NAVIGATION METHODS\n  // These methods handle moving through the source code while maintaining position tracking\n\n  private advance(): void {\n    // Move to the next character in the source code\n    // This method is crucial for maintaining accurate line/column tracking\n\n    if (this.currentChar === "\\n") {\n      // When encountering a newline, increment line and reset column\n      this.line++;\n      this.column = 1;\n    } else {\n      // For any other character, just move to the next column\n      this.column++;\n    }\n\n    // Move to next position in the source code\n    this.position++;\n\n    // Update currentChar to the new character, or null if we\'ve reached the end\n    this.currentChar =\n      this.position < this.text.length ? this.text[this.position] : null;\n  }\n\n  private peek(): string | null {\n    // Look at the next character without advancing position\n    // This is essential for recognizing multi-character operators like "==" and "!="\n    const peekPos = this.position + 1;\n    return peekPos < this.text.length ? this.text[peekPos] : null;\n  }\n\n  // WHITESPACE AND COMMENT HANDLING\n  // These methods skip over characters that don\'t contribute to the program logic\n\n  private skipWhitespace(): void {\n    // Skip over spaces, tabs, and other whitespace characters\n    // NOTE: We preserve newlines because they can be significant in our language\n    while (\n      this.currentChar &&\n      /\\s/.test(this.currentChar) && // Match any whitespace character\n      this.currentChar !== "\\n" // But preserve newlines for statement separation\n    ) {\n      this.advance();\n    }\n  }\n\n  private skipComment(): void {\n    // Handle single-line comments that start with "//"\n    // Comments extend to the end of the line and are completely ignored\n    if (this.currentChar === "/" && this.peek() === "/") {\n      // Skip the entire comment line\n      while (this.currentChar && this.currentChar !== "\\n") {\n        this.advance();\n      }\n      // Note: The newline character is left for the main tokenizer to handle\n    }\n  }\n\n  // TOKEN CONSTRUCTION METHODS\n  // These methods build specific types of tokens from character sequences\n\n  private readNumber(): Token {\n    // Parse numeric literals (integers and floating-point numbers)\n    // Examples: 42, 3.14, 0, 999.999\n    const start = { line: this.line, column: this.column };\n    let value = "";\n\n    // Keep reading digits and decimal points\n    while (this.currentChar && /[\\d.]/.test(this.currentChar)) {\n      value += this.currentChar;\n      this.advance();\n    }\n\n    // Return the complete number token with position information\n    return {\n      type: TokenType.NUMBER,\n      value, // String representation: "42", "3.14"\n      line: start.line, // Line where number starts\n      column: start.column, // Column where number starts\n    };\n  }\n\n  private readString(): Token {\n    // Parse string literals enclosed in double quotes\n    // Supports escape sequences for special characters\n    // Examples: "Hello", "Xin ch\xe0o", "Line 1\\nLine 2"\n    const start = { line: this.line, column: this.column };\n    let value = "";\n\n    this.advance(); // Skip opening quote character\n\n    // Read characters until we find the closing quote\n    while (this.currentChar && this.currentChar !== \'"\') {\n      if (this.currentChar === "\\\\") {\n        // Handle escape sequences (backslash followed by special character)\n        this.advance(); // Skip the backslash\n\n        // Process the escaped character\n        switch (this.currentChar) {\n          case "n":\n            value += "\\n"; // \\n becomes actual newline\n            break;\n          case "t":\n            value += "\\t"; // \\t becomes actual tab\n            break;\n          case "\\\\":\n            value += "\\\\"; // \\\\ becomes single backslash\n            break;\n          case \'"\':\n            value += \'"\'; // \\" becomes literal quote mark\n            break;\n          default:\n            // For unknown escape sequences, include the character as-is\n            value += this.currentChar;\n        }\n      } else {\n        // Regular character - add directly to string value\n        value += this.currentChar;\n      }\n      this.advance();\n    }\n\n    this.advance(); // Skip closing quote character\n\n    return {\n      type: TokenType.STRING,\n      value, // Processed string content (escape sequences resolved)\n      line: start.line,\n      column: start.column,\n    };\n  }\n\n  private readIdentifier(): Token {\n    // Parse identifiers and Vietnamese keywords\n    // Supports Vietnamese Unicode characters, which is crucial for our language\n    // Examples: myVar, userName, t\u1ed5ng, g\xe1n, n\u1ebfu, kh\xe1c\n    const start = { line: this.line, column: this.column };\n    let value = "";\n\n    // Read all valid identifier characters\n    // Regex includes: a-z, A-Z, Vietnamese characters (\xc0-\u1ef9), digits (0-9), underscore (_)\n    while (this.currentChar && /[a-zA-Z\xc0-\u1ef90-9_]/.test(this.currentChar)) {\n      value += this.currentChar;\n      this.advance();\n    }\n\n    // VIETNAMESE KEYWORD RECOGNITION\n    // Check if the identifier is actually a reserved Vietnamese keyword\n    const keywordMap = new Map([\n      ["g\xe1n", TokenType.GAN], // Assignment keyword\n      ["n\u1ebfu", TokenType.NEU], // If conditional keyword\n      ["kh\xe1c", TokenType.KHAC], // Else keyword\n      ["l\u1eb7p", TokenType.LAP], // Loop keyword\n      ["h\xe0m", TokenType.HAM], // Function keyword\n      ["tr\u1ea3_v\u1ec1", TokenType.TRA_VE], // Return keyword\n      ["in", TokenType.IN], // Print/output keyword\n      ["\u0111\xfang", TokenType.BOOLEAN], // Boolean true keyword\n      ["sai", TokenType.BOOLEAN], // Boolean false keyword\n    ]);\n\n    // Determine token type: keyword if found in map, otherwise it\'s an identifier\n    const tokenType = keywordMap.get(value) || TokenType.IDENTIFIER;\n\n    return {\n      type: tokenType,\n      value, // The actual text: "g\xe1n", "myVar", etc.\n      line: start.line,\n      column: start.column,\n    };\n  }\n\n  // Main tokenization method\n  public tokenize(): Token[] {\n    const tokens: Token[] = [];\n\n    while (this.currentChar) {\n      this.skipWhitespace();\n\n      if (!this.currentChar) break;\n\n      // Handle newlines\n      if (this.currentChar === "\\n") {\n        tokens.push({\n          type: TokenType.NEWLINE,\n          value: "\\n",\n          line: this.line,\n          column: this.column,\n        });\n        this.advance();\n        continue;\n      }\n\n      // Handle comments\n      if (this.currentChar === "/" && this.peek() === "/") {\n        this.skipComment();\n        continue;\n      }\n\n      // Handle numbers\n      if (/\\d/.test(this.currentChar)) {\n        tokens.push(this.readNumber());\n        continue;\n      }\n\n      // Handle strings\n      if (this.currentChar === \'"\') {\n        tokens.push(this.readString());\n        continue;\n      }\n\n      // Handle identifiers and keywords\n      if (/[a-zA-Z\xc0-\u1ef9_]/.test(this.currentChar)) {\n        tokens.push(this.readIdentifier());\n        continue;\n      }\n\n      // Handle operators and delimiters\n      const char = this.currentChar;\n      const nextChar = this.peek();\n\n      switch (char) {\n        case "+":\n          tokens.push({\n            type: TokenType.PLUS,\n            value: "+",\n            line: this.line,\n            column: this.column,\n          });\n          this.advance();\n          break;\n        case "-":\n          tokens.push({\n            type: TokenType.MINUS,\n            value: "-",\n            line: this.line,\n            column: this.column,\n          });\n          this.advance();\n          break;\n        case "*":\n          tokens.push({\n            type: TokenType.MULTIPLY,\n            value: "*",\n            line: this.line,\n            column: this.column,\n          });\n          this.advance();\n          break;\n        case "/":\n          tokens.push({\n            type: TokenType.DIVIDE,\n            value: "/",\n            line: this.line,\n            column: this.column,\n          });\n          this.advance();\n          break;\n        case "=":\n          if (nextChar === "=") {\n            tokens.push({\n              type: TokenType.EQUAL,\n              value: "==",\n              line: this.line,\n              column: this.column,\n            });\n            this.advance();\n            this.advance();\n          } else {\n            tokens.push({\n              type: TokenType.ASSIGN,\n              value: "=",\n              line: this.line,\n              column: this.column,\n            });\n            this.advance();\n          }\n          break;\n        case "!":\n          if (nextChar === "=") {\n            tokens.push({\n              type: TokenType.NOT_EQUAL,\n              value: "!=",\n              line: this.line,\n              column: this.column,\n            });\n            this.advance();\n            this.advance();\n          } else {\n            throw new Error(\n              `Unexpected character: ${char} at line ${this.line}, column ${this.column}`\n            );\n          }\n          break;\n        case "(":\n          tokens.push({\n            type: TokenType.LPAREN,\n            value: "(",\n            line: this.line,\n            column: this.column,\n          });\n          this.advance();\n          break;\n        case ")":\n          tokens.push({\n            type: TokenType.RPAREN,\n            value: ")",\n            line: this.line,\n            column: this.column,\n          });\n          this.advance();\n          break;\n        case "{":\n          tokens.push({\n            type: TokenType.LBRACE,\n            value: "{",\n            line: this.line,\n            column: this.column,\n          });\n          this.advance();\n          break;\n        case "}":\n          tokens.push({\n            type: TokenType.RBRACE,\n            value: "}",\n            line: this.line,\n            column: this.column,\n          });\n          this.advance();\n          break;\n        case ";":\n          tokens.push({\n            type: TokenType.SEMICOLON,\n            value: ";",\n            line: this.line,\n            column: this.column,\n          });\n          this.advance();\n          break;\n        default:\n          throw new Error(\n            `Unexpected character: ${char} at line ${this.line}, column ${this.column}`\n          );\n      }\n    }\n\n    tokens.push({\n      type: TokenType.EOF,\n      value: "",\n      line: this.line,\n      column: this.column,\n    });\n\n    return tokens;\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"parsing-and-ast-generation",children:"Parsing and AST Generation"}),"\n",(0,i.jsx)(n.h3,{id:"ast-node-definitions",children:"AST Node Definitions"}),"\n",(0,i.jsx)(n.p,{children:"The Abstract Syntax Tree (AST) represents the hierarchical structure of the parsed program. Each node type corresponds to a different language construct, and the visitor pattern allows for clean separation between tree traversal and operations performed on nodes."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What this code does:"})," Defines the class hierarchy for all possible AST nodes in the Vietnamese programming language.\n",(0,i.jsx)(n.strong,{children:"Input:"})," Parsed token sequences that need to be represented as tree structures.\n",(0,i.jsx)(n.strong,{children:"Output:"})," Object-oriented representation of program structure that can be traversed and evaluated.\n",(0,i.jsx)(n.strong,{children:"Design Pattern:"})," Uses the Visitor pattern for clean separation between tree structure and operations."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// ABSTRACT BASE CLASS FOR ALL AST NODES\n// This ensures all nodes can be visited by the interpreter using the visitor pattern\nabstract class ASTNode {\n  // Every AST node must implement the accept method for visitor pattern\n  // This allows different visitors (interpreter, pretty-printer, etc.) to process nodes\n  abstract accept<T>(visitor: ASTVisitor<T>): T;\n}\n\n// EXPRESSION NODES\n// These represent values and computations that produce results\n\nclass NumberLiteral extends ASTNode {\n  constructor(public value: number) {\n    // Store the actual numeric value (e.g., 42, 3.14)\n    super();\n  }\n\n  accept<T>(visitor: ASTVisitor<T>): T {\n    // Delegate to visitor\'s number literal handler\n    return visitor.visitNumberLiteral(this);\n  }\n}\n\nclass StringLiteral extends ASTNode {\n  constructor(public value: string) {\n    // Store string content (e.g., "Hello", "Xin ch\xe0o")\n    super();\n  }\n\n  accept<T>(visitor: ASTVisitor<T>): T {\n    return visitor.visitStringLiteral(this);\n  }\n}\n\nclass BooleanLiteral extends ASTNode {\n  constructor(public value: boolean) {\n    // Store true/false value (\u0111\xfang/sai in Vietnamese)\n    super();\n  }\n\n  accept<T>(visitor: ASTVisitor<T>): T {\n    return visitor.visitBooleanLiteral(this);\n  }\n}\n\nclass Identifier extends ASTNode {\n  constructor(public name: string) {\n    // Store variable name (e.g., "x", "userName", "t\u1ed5ng")\n    super();\n  }\n\n  accept<T>(visitor: ASTVisitor<T>): T {\n    return visitor.visitIdentifier(this);\n  }\n}\n\nclass BinaryExpression extends ASTNode {\n  constructor(\n    public left: ASTNode, // Left operand (can be any expression)\n    public operator: Token, // Operator token (+, -, *, /, ==, !=)\n    public right: ASTNode // Right operand (can be any expression)\n  ) {\n    super();\n  }\n\n  accept<T>(visitor: ASTVisitor<T>): T {\n    return visitor.visitBinaryExpression(this);\n  }\n}\n\n// STATEMENT NODES\n// These represent actions or declarations that don\'t produce values directly\n\nclass AssignmentStatement extends ASTNode {\n  constructor(\n    public identifier: Identifier, // Variable being assigned to (e.g., "x", "sum")\n    public value: ASTNode // Expression that produces the value to assign\n  ) {\n    super();\n  }\n\n  accept<T>(visitor: ASTVisitor<T>): T {\n    return visitor.visitAssignmentStatement(this);\n  }\n}\n\nclass PrintStatement extends ASTNode {\n  constructor(public expression: ASTNode) {\n    // Expression to evaluate and print\n    super();\n  }\n\n  accept<T>(visitor: ASTVisitor<T>): T {\n    return visitor.visitPrintStatement(this);\n  }\n}\n\nclass IfStatement extends ASTNode {\n  constructor(\n    public condition: ASTNode, // Boolean expression to test\n    public thenBranch: ASTNode[], // Statements to execute if condition is true\n    public elseBranch?: ASTNode[] // Optional statements for else branch\n  ) {\n    super();\n  }\n\n  accept<T>(visitor: ASTVisitor<T>): T {\n    return visitor.visitIfStatement(this);\n  }\n}\n\n// ROOT NODE\n// This represents the entire program as a sequence of statements\nclass Program extends ASTNode {\n  constructor(public statements: ASTNode[]) {\n    // All top-level statements in the program\n    super();\n  }\n\n  accept<T>(visitor: ASTVisitor<T>): T {\n    return visitor.visitProgram(this);\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"parser-implementation",children:"Parser Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class Parser {\n  private tokens: Token[];\n  private current: number;\n\n  constructor(tokens: Token[]) {\n    this.tokens = tokens;\n    this.current = 0;\n  }\n\n  // Utility methods\n  private peek(): Token {\n    return this.tokens[this.current];\n  }\n\n  private previous(): Token {\n    return this.tokens[this.current - 1];\n  }\n\n  private isAtEnd(): boolean {\n    return this.peek().type === TokenType.EOF;\n  }\n\n  private advance(): Token {\n    if (!this.isAtEnd()) this.current++;\n    return this.previous();\n  }\n\n  private check(type: TokenType): boolean {\n    if (this.isAtEnd()) return false;\n    return this.peek().type === type;\n  }\n\n  private match(...types: TokenType[]): boolean {\n    for (const type of types) {\n      if (this.check(type)) {\n        this.advance();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private consume(type: TokenType, message: string): Token {\n    if (this.check(type)) return this.advance();\n    throw new Error(\n      `${message}. Got ${this.peek().type} at line ${this.peek().line}`\n    );\n  }\n\n  // Grammar rules\n  public parse(): Program {\n    const statements: ASTNode[] = [];\n\n    while (!this.isAtEnd()) {\n      if (this.match(TokenType.NEWLINE)) continue;\n      statements.push(this.statement());\n    }\n\n    return new Program(statements);\n  }\n\n  private statement(): ASTNode {\n    if (this.match(TokenType.GAN)) return this.assignmentStatement();\n    if (this.match(TokenType.IN)) return this.printStatement();\n    if (this.match(TokenType.NEU)) return this.ifStatement();\n\n    throw new Error(\n      `Unexpected token: ${this.peek().value} at line ${this.peek().line}`\n    );\n  }\n\n  private assignmentStatement(): AssignmentStatement {\n    const identifier = this.consume(\n      TokenType.IDENTIFIER,\n      \"Expected identifier after 'g\xe1n'\"\n    );\n    this.consume(TokenType.ASSIGN, \"Expected '=' after identifier\");\n    const value = this.expression();\n\n    return new AssignmentStatement(new Identifier(identifier.value), value);\n  }\n\n  private printStatement(): PrintStatement {\n    this.consume(TokenType.LPAREN, \"Expected '(' after 'in'\");\n    const expression = this.expression();\n    this.consume(TokenType.RPAREN, \"Expected ')' after expression\");\n\n    return new PrintStatement(expression);\n  }\n\n  private ifStatement(): IfStatement {\n    this.consume(TokenType.LPAREN, \"Expected '(' after 'n\u1ebfu'\");\n    const condition = this.expression();\n    this.consume(TokenType.RPAREN, \"Expected ')' after condition\");\n\n    this.consume(TokenType.LBRACE, \"Expected '{' before if body\");\n    const thenBranch: ASTNode[] = [];\n\n    while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {\n      if (this.match(TokenType.NEWLINE)) continue;\n      thenBranch.push(this.statement());\n    }\n\n    this.consume(TokenType.RBRACE, \"Expected '}' after if body\");\n\n    let elseBranch: ASTNode[] | undefined;\n    if (this.match(TokenType.KHAC)) {\n      this.consume(TokenType.LBRACE, \"Expected '{' before else body\");\n      elseBranch = [];\n\n      while (!this.check(TokenType.RBRACE) && !this.isAtEnd()) {\n        if (this.match(TokenType.NEWLINE)) continue;\n        elseBranch.push(this.statement());\n      }\n\n      this.consume(TokenType.RBRACE, \"Expected '}' after else body\");\n    }\n\n    return new IfStatement(condition, thenBranch, elseBranch);\n  }\n\n  private expression(): ASTNode {\n    return this.equality();\n  }\n\n  private equality(): ASTNode {\n    let expr = this.comparison();\n\n    while (this.match(TokenType.EQUAL, TokenType.NOT_EQUAL)) {\n      const operator = this.previous();\n      const right = this.comparison();\n      expr = new BinaryExpression(expr, operator, right);\n    }\n\n    return expr;\n  }\n\n  private comparison(): ASTNode {\n    return this.term();\n  }\n\n  private term(): ASTNode {\n    let expr = this.factor();\n\n    while (this.match(TokenType.MINUS, TokenType.PLUS)) {\n      const operator = this.previous();\n      const right = this.factor();\n      expr = new BinaryExpression(expr, operator, right);\n    }\n\n    return expr;\n  }\n\n  private factor(): ASTNode {\n    let expr = this.unary();\n\n    while (this.match(TokenType.DIVIDE, TokenType.MULTIPLY)) {\n      const operator = this.previous();\n      const right = this.unary();\n      expr = new BinaryExpression(expr, operator, right);\n    }\n\n    return expr;\n  }\n\n  private unary(): ASTNode {\n    if (this.match(TokenType.MINUS)) {\n      const operator = this.previous();\n      const right = this.unary();\n      return new BinaryExpression(new NumberLiteral(0), operator, right);\n    }\n\n    return this.primary();\n  }\n\n  private primary(): ASTNode {\n    if (this.match(TokenType.BOOLEAN)) {\n      return new BooleanLiteral(this.previous().value === \"\u0111\xfang\");\n    }\n\n    if (this.match(TokenType.NUMBER)) {\n      return new NumberLiteral(parseFloat(this.previous().value));\n    }\n\n    if (this.match(TokenType.STRING)) {\n      return new StringLiteral(this.previous().value);\n    }\n\n    if (this.match(TokenType.IDENTIFIER)) {\n      return new Identifier(this.previous().value);\n    }\n\n    if (this.match(TokenType.LPAREN)) {\n      const expr = this.expression();\n      this.consume(TokenType.RPAREN, \"Expected ')' after expression\");\n      return expr;\n    }\n\n    throw new Error(\n      `Unexpected token: ${this.peek().value} at line ${this.peek().line}`\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"interpreter-execution",children:"Interpreter Execution"}),"\n",(0,i.jsx)(n.h3,{id:"visitor-pattern-for-ast-traversal",children:"Visitor Pattern for AST Traversal"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'interface ASTVisitor<T> {\n  visitProgram(node: Program): T;\n  visitAssignmentStatement(node: AssignmentStatement): T;\n  visitPrintStatement(node: PrintStatement): T;\n  visitIfStatement(node: IfStatement): T;\n  visitBinaryExpression(node: BinaryExpression): T;\n  visitNumberLiteral(node: NumberLiteral): T;\n  visitStringLiteral(node: StringLiteral): T;\n  visitBooleanLiteral(node: BooleanLiteral): T;\n  visitIdentifier(node: Identifier): T;\n}\n\nclass Interpreter implements ASTVisitor<any> {\n  private environment: Map<string, any>;\n  private output: string[];\n\n  constructor() {\n    this.environment = new Map();\n    this.output = [];\n  }\n\n  public interpret(program: Program): {\n    output: string[];\n    environment: Map<string, any>;\n  } {\n    this.visitProgram(program);\n    return {\n      output: this.output,\n      environment: new Map(this.environment),\n    };\n  }\n\n  visitProgram(node: Program): void {\n    for (const statement of node.statements) {\n      statement.accept(this);\n    }\n  }\n\n  visitAssignmentStatement(node: AssignmentStatement): void {\n    const value = node.value.accept(this);\n    this.environment.set(node.identifier.name, value);\n  }\n\n  visitPrintStatement(node: PrintStatement): void {\n    const value = node.expression.accept(this);\n    const output = this.stringify(value);\n    this.output.push(output);\n  }\n\n  visitIfStatement(node: IfStatement): void {\n    const condition = node.condition.accept(this);\n\n    if (this.isTruthy(condition)) {\n      for (const statement of node.thenBranch) {\n        statement.accept(this);\n      }\n    } else if (node.elseBranch) {\n      for (const statement of node.elseBranch) {\n        statement.accept(this);\n      }\n    }\n  }\n\n  visitBinaryExpression(node: BinaryExpression): any {\n    const left = node.left.accept(this);\n    const right = node.right.accept(this);\n\n    switch (node.operator.type) {\n      case TokenType.PLUS:\n        if (typeof left === "number" && typeof right === "number") {\n          return left + right;\n        }\n        if (typeof left === "string" || typeof right === "string") {\n          return this.stringify(left) + this.stringify(right);\n        }\n        throw new Error(`Cannot add ${typeof left} and ${typeof right}`);\n\n      case TokenType.MINUS:\n        this.checkNumberOperands(node.operator, left, right);\n        return left - right;\n\n      case TokenType.MULTIPLY:\n        this.checkNumberOperands(node.operator, left, right);\n        return left * right;\n\n      case TokenType.DIVIDE:\n        this.checkNumberOperands(node.operator, left, right);\n        if (right === 0) throw new Error("Division by zero");\n        return left / right;\n\n      case TokenType.EQUAL:\n        return this.isEqual(left, right);\n\n      case TokenType.NOT_EQUAL:\n        return !this.isEqual(left, right);\n\n      default:\n        throw new Error(`Unknown binary operator: ${node.operator.type}`);\n    }\n  }\n\n  visitNumberLiteral(node: NumberLiteral): number {\n    return node.value;\n  }\n\n  visitStringLiteral(node: StringLiteral): string {\n    return node.value;\n  }\n\n  visitBooleanLiteral(node: BooleanLiteral): boolean {\n    return node.value;\n  }\n\n  visitIdentifier(node: Identifier): any {\n    if (this.environment.has(node.name)) {\n      return this.environment.get(node.name);\n    }\n    throw new Error(`Undefined variable: ${node.name}`);\n  }\n\n  // Helper methods\n  private isTruthy(value: any): boolean {\n    if (value === null || value === undefined) return false;\n    if (typeof value === "boolean") return value;\n    return true;\n  }\n\n  private isEqual(a: any, b: any): boolean {\n    return a === b;\n  }\n\n  private checkNumberOperands(operator: Token, left: any, right: any): void {\n    if (typeof left !== "number" || typeof right !== "number") {\n      throw new Error(`Operands must be numbers for ${operator.value}`);\n    }\n  }\n\n  private stringify(value: any): string {\n    if (value === null || value === undefined) return "nil";\n    if (typeof value === "boolean") return value ? "\u0111\xfang" : "sai";\n    return value.toString();\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"language-features",children:"Language Features"}),"\n",(0,i.jsx)(n.h3,{id:"example-programs",children:"Example Programs"}),"\n",(0,i.jsx)(n.p,{children:"These examples demonstrate the Vietnamese programming language features in action. Each example shows how the interpreter processes different types of constructs and produces output."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What these examples show:"})," Progressive complexity from basic arithmetic to conditional logic.\n",(0,i.jsx)(n.strong,{children:"Purpose:"})," Demonstrate real-world usage patterns and help developers understand the language syntax.\n",(0,i.jsx)(n.strong,{children:"Learning Path:"})," Start with Example 1 and progress through increasingly complex features."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// EXAMPLE 1: Basic arithmetic and variables\n// This example demonstrates variable assignment and arithmetic operations\n// Execution flow: create variables \u2192 perform calculation \u2192 store result \u2192 print output\nconst example1 = `\ng\xe1n a = 10        // Assign 10 to variable \'a\'\ng\xe1n b = 20        // Assign 20 to variable \'b\'  \ng\xe1n sum = a + b   // Calculate sum: 10 + 20 = 30, assign to \'sum\'\nin (sum)          // Print the value of sum\n`;\n// Expected output: 30\n// Variables after execution: {a: 10, b: 20, sum: 30}\n\n// EXAMPLE 2: String operations and concatenation\n// Shows how strings work with Vietnamese text and concatenation operator\nconst example2 = `\ng\xe1n firstName = "Nguy\u1ec5n"               // Vietnamese first name\ng\xe1n lastName = "V\u0103n A"                 // Vietnamese last name\ng\xe1n fullName = firstName + " " + lastName  // Concatenate with space\nin (fullName)                          // Print complete name\n`;\n// Expected output: "Nguy\u1ec5n V\u0103n A"\n// Demonstrates: String literals, concatenation, Vietnamese Unicode support\n\n// EXAMPLE 3: Conditional statements with Vietnamese keywords\n// Shows if-else logic using Vietnamese conditional keywords\nconst example3 = `\ng\xe1n age = 18                    // Set age variable\nn\u1ebfu (age >= 18) {              // If age is 18 or greater\n  in ("\u0110\u1ee7 tu\u1ed5i b\u1ea7u c\u1eed")        // Print voting age message\n} kh\xe1c {                       // Else (otherwise)\n  in ("Ch\u01b0a \u0111\u1ee7 tu\u1ed5i b\u1ea7u c\u1eed")   // Print underage message  \n}\n`;\n// Expected output: "\u0110\u1ee7 tu\u1ed5i b\u1ea7u c\u1eed" (Old enough to vote)\n// Shows: Comparison operators, conditional branching, Vietnamese text output\n\n// EXAMPLE 4: Complex expressions with operator precedence\n// Demonstrates arithmetic operator precedence and parentheses grouping\nconst example4 = `\ng\xe1n x = 5                          // Base value\ng\xe1n y = 3                          // Second value\ng\xe1n result = (x + y) * 2 - 1       // Complex calculation with precedence\nin (result)                        // Print final result\n`;\n// Expected output: 15\n// Calculation breakdown: (5 + 3) * 2 - 1 = 8 * 2 - 1 = 16 - 1 = 15\n// Shows: Operator precedence, parentheses grouping, multi-step calculations\n'})}),"\n",(0,i.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.p,{children:"A robust error handling system is essential for providing helpful feedback to users when their Vietnamese code contains mistakes. The interpreter implements a hierarchical error system with detailed position information."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What this code does:"})," Implements a comprehensive error reporting system with position tracking.\n",(0,i.jsx)(n.strong,{children:"Input:"})," Error conditions detected during lexing, parsing, or execution phases.\n",(0,i.jsx)(n.strong,{children:"Output:"})," Detailed error messages with line/column information for debugging.\n",(0,i.jsx)(n.strong,{children:"Benefits:"})," Users get precise error locations and clear descriptions of what went wrong."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// BASE ERROR CLASS\n// All interpreter errors inherit from this class to provide consistent error handling\nclass InterpreterError extends Error {\n  constructor(\n    message: string, // Human-readable error description\n    public line?: number, // Line number where error occurred (optional)\n    public column?: number // Column position where error occurred (optional)\n  ) {\n    super(message);\n    this.name = "InterpreterError";\n  }\n}\n\n// RUNTIME ERROR CLASS\n// Errors that occur during program execution (division by zero, undefined variables, etc.)\nclass RuntimeError extends InterpreterError {\n  constructor(message: string, line?: number, column?: number) {\n    super(`Runtime Error: ${message}`, line, column);\n    this.name = "RuntimeError";\n  }\n}\n\n// SYNTAX ERROR CLASS\n// Errors in program structure detected during parsing phase\nclass SyntaxError extends InterpreterError {\n  constructor(message: string, line?: number, column?: number) {\n    super(`Syntax Error: ${message}`, line, column);\n    this.name = "SyntaxError";\n  }\n}\n\n// ERROR HANDLING IN PRACTICE\n// This shows how to use the error system when executing Vietnamese code\ntry {\n  // Attempt to interpret the Vietnamese program\n  const result = interpreter.interpret(program);\n  console.log("Output:", result.output.join("\\n"));\n} catch (error) {\n  if (error instanceof InterpreterError) {\n    // Handle known interpreter errors with detailed location info\n    console.error(`${error.name} at line ${error.line}: ${error.message}`);\n\n    // Example output: "Runtime Error at line 3: Undefined variable: t\u1ed5ng"\n    // Example output: "Syntax Error at line 1: Expected \')\' after expression"\n  } else {\n    // Handle unexpected system errors\n    console.error("Unexpected error:", error.message);\n  }\n}\n\n// COMMON ERROR SCENARIOS:\n// 1. Runtime Errors:\n//    - "Undefined variable: myVar" (using undefined variable)\n//    - "Division by zero" (mathematical error)\n//    - "Cannot add string and number" (type mismatch)\n//\n// 2. Syntax Errors:\n//    - "Expected \'=\' after identifier" (missing assignment operator)\n//    - "Unexpected token: }" (mismatched braces)\n//    - "Expected \')\' after expression" (unclosed parentheses)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,i.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class Environment {\n  private variables: Map<string, any>;\n  private parent: Environment | null;\n\n  constructor(parent: Environment | null = null) {\n    this.variables = new Map();\n    this.parent = parent;\n  }\n\n  define(name: string, value: any): void {\n    this.variables.set(name, value);\n  }\n\n  get(name: string): any {\n    if (this.variables.has(name)) {\n      return this.variables.get(name);\n    }\n\n    if (this.parent) {\n      return this.parent.get(name);\n    }\n\n    throw new RuntimeError(`Undefined variable: ${name}`);\n  }\n\n  set(name: string, value: any): void {\n    if (this.variables.has(name)) {\n      this.variables.set(name, value);\n      return;\n    }\n\n    if (this.parent) {\n      this.parent.set(name, value);\n      return;\n    }\n\n    throw new RuntimeError(`Undefined variable: ${name}`);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class OptimizedInterpreter extends Interpreter {\n  private cache: Map<string, any>;\n\n  constructor() {\n    super();\n    this.cache = new Map();\n  }\n\n  // Memoization for repeated expressions\n  private memoize(key: string, computation: () => any): any {\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    }\n\n    const result = computation();\n    this.cache.set(key, result);\n    return result;\n  }\n\n  // Optimized binary expression evaluation\n  visitBinaryExpression(node: BinaryExpression): any {\n    const cacheKey = `${node.left.constructor.name}_${node.operator.value}_${node.right.constructor.name}`;\n\n    return this.memoize(cacheKey, () => {\n      return super.visitBinaryExpression(node);\n    });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"browser-integration",children:"Browser Integration"}),"\n",(0,i.jsx)(n.h3,{id:"web-integration-layer",children:"Web Integration Layer"}),"\n",(0,i.jsx)(n.p,{children:"The Browser Integration layer adapts the core interpreter for web environments, providing a user-friendly interface that handles DOM manipulation, error display, and real-time feedback."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"What this code does:"})," Creates a web-friendly wrapper around the core interpreter that handles UI interactions.\n",(0,i.jsx)(n.strong,{children:"Input:"})," Vietnamese source code from web interface (textarea, editor, etc.)\n",(0,i.jsx)(n.strong,{children:"Output:"})," Formatted results displayed in HTML elements with error handling\n",(0,i.jsx)(n.strong,{children:"Key Features:"})," DOM integration, error visualization, real-time execution, state display"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// BROWSER-SPECIFIC INTERPRETER WRAPPER\n// This class bridges the gap between the core interpreter and web browser environment\nclass BrowserInterpreter {\n  private interpreter: Interpreter; // Core interpreter instance\n  private outputElement: HTMLElement; // DOM element for displaying results\n\n  constructor(outputElementId: string) {\n    // Initialize the core interpreter\n    this.interpreter = new Interpreter();\n\n    // Get reference to output DOM element (throws if not found)\n    this.outputElement = document.getElementById(outputElementId)!;\n  }\n\n  public execute(code: string): void {\n    try {\n      // STEP 1: Clear previous execution results\n      // This ensures clean state for each execution\n      this.outputElement.innerHTML = "";\n\n      // STEP 2: Lexical analysis - Convert text to tokens\n      const lexer = new Lexer(code);\n      const tokens = lexer.tokenize();\n\n      // STEP 3: Parsing - Build Abstract Syntax Tree\n      const parser = new Parser(tokens);\n      const program = parser.parse();\n\n      // STEP 4: Execution - Run the program and collect results\n      const result = this.interpreter.interpret(program);\n\n      // STEP 5: Display results in web interface\n      this.displayOutput(result.output); // Show program output\n      this.displayEnvironment(result.environment); // Show variable states\n    } catch (error) {\n      // Handle and display any errors that occurred during execution\n      this.displayError(error);\n    }\n  }\n\n  // DISPLAY METHODS FOR WEB INTERFACE\n  // These methods create DOM elements to show execution results to users\n\n  private displayOutput(output: string[]): void {\n    // Create a container for program output (from \'in\' statements)\n    const outputDiv = document.createElement("div");\n    outputDiv.className = "interpreter-output";\n\n    // Join all output lines with newlines for display\n    outputDiv.textContent = output.join("\\n");\n\n    // Add to the main output container\n    this.outputElement.appendChild(outputDiv);\n  }\n\n  private displayEnvironment(env: Map<string, any>): void {\n    // Create a container to show current variable states\n    const envDiv = document.createElement("div");\n    envDiv.className = "interpreter-environment";\n\n    // Add a title for the variables section\n    const title = document.createElement("h4");\n    title.textContent = "Variables:";\n    envDiv.appendChild(title);\n\n    // Display each variable and its current value\n    env.forEach((value, name) => {\n      const varDiv = document.createElement("div");\n      varDiv.textContent = `${name}: ${value}`; // Format: "variableName: value"\n      envDiv.appendChild(varDiv);\n    });\n\n    // Add the variables display to the main output\n    this.outputElement.appendChild(envDiv);\n  }\n\n  private displayError(error: any): void {\n    // Create a container for error messages with distinct styling\n    const errorDiv = document.createElement("div");\n    errorDiv.className = "interpreter-error"; // CSS class for error styling (red text, etc.)\n\n    // Display the error message\n    errorDiv.textContent = error.message;\n\n    // Add error to the output (errors are shown prominently)\n    this.outputElement.appendChild(errorDiv);\n  }\n}\n\n// Usage in React component\nconst InterpreterComponent: React.FC = () => {\n  const [code, setCode] = useState("");\n  const outputRef = useRef<HTMLDivElement>(null);\n  const interpreterRef = useRef<BrowserInterpreter>();\n\n  useEffect(() => {\n    if (outputRef.current) {\n      interpreterRef.current = new BrowserInterpreter(outputRef.current.id);\n    }\n  }, []);\n\n  const handleExecute = () => {\n    if (interpreterRef.current) {\n      interpreterRef.current.execute(code);\n    }\n  };\n\n  return (\n    <div className="interpreter-container">\n      <textarea\n        value={code}\n        onChange={(e) => setCode(e.target.value)}\n        placeholder="Nh\u1eadp m\xe3 Vietnamese \u1edf \u0111\xe2y..."\n        className="code-editor"\n      />\n      <button onClick={handleExecute}>Ch\u1ea1y m\xe3</button>\n      <div\n        id="interpreter-output"\n        ref={outputRef}\n        className="output-container"\n      />\n    </div>\n  );\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"code-organization",children:"Code Organization"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Modular interpreter design\ninterface InterpreterModule {\n  name: string;\n  version: string;\n  dependencies: string[];\n}\n\nclass ModularInterpreter {\n  private modules: Map<string, InterpreterModule>;\n  private lexer: Lexer;\n  private parser: Parser;\n  private interpreter: Interpreter;\n\n  constructor() {\n    this.modules = new Map();\n    this.initializeCore();\n  }\n\n  private initializeCore(): void {\n    this.lexer = new Lexer("");\n    this.parser = new Parser([]);\n    this.interpreter = new Interpreter();\n  }\n\n  public registerModule(module: InterpreterModule): void {\n    this.modules.set(module.name, module);\n  }\n\n  public execute(code: string, options: { debug?: boolean } = {}): any {\n    if (options.debug) {\n      console.log("Executing code:", code);\n    }\n\n    const tokens = this.lexer.tokenize();\n    const ast = this.parser.parse();\n    const result = this.interpreter.interpret(ast);\n\n    return result;\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"testing-strategy",children:"Testing Strategy"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Unit tests for interpreter components\ndescribe("Vietnamese Interpreter", () => {\n  let interpreter: Interpreter;\n\n  beforeEach(() => {\n    interpreter = new Interpreter();\n  });\n\n  test("should handle basic arithmetic", () => {\n    const code = "g\xe1n result = 10 + 5\\nin (result)";\n    const result = interpreter.execute(code);\n    expect(result.output).toContain("15");\n  });\n\n  test("should handle string concatenation", () => {\n    const code = \'g\xe1n greeting = "Xin " + "ch\xe0o"\\nin (greeting)\';\n    const result = interpreter.execute(code);\n    expect(result.output).toContain("Xin ch\xe0o");\n  });\n\n  test("should handle conditional statements", () => {\n    const code = `\n      g\xe1n age = 20\n      n\u1ebfu (age >= 18) {\n        in ("Ng\u01b0\u1eddi l\u1edbn")\n      } kh\xe1c {\n        in ("Tr\u1ebb em")\n      }\n    `;\n    const result = interpreter.execute(code);\n    expect(result.output).toContain("Ng\u01b0\u1eddi l\u1edbn");\n  });\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"The Simple Interpreter project demonstrates the complete process of building a programming language interpreter from scratch. By implementing lexical analysis, parsing, and execution phases, this project showcases how to create a functional programming language with Vietnamese keywords that runs entirely in the browser."}),"\n",(0,i.jsx)(n.h3,{id:"key-achievements",children:"Key Achievements"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Complete Interpreter Pipeline"}),": Lexer \u2192 Parser \u2192 AST \u2192 Interpreter"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Vietnamese Language Support"}),": Localized keywords and error messages"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Browser Integration"}),": Client-side execution with real-time feedback"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Educational Value"}),": Clear demonstration of interpreter construction principles"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Extensible Architecture"}),": Modular design for adding new language features"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"technical-highlights",children:"Technical Highlights"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"TypeScript Implementation"}),": Type-safe interpreter with excellent developer experience"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visitor Pattern"}),": Clean AST traversal and evaluation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Comprehensive error reporting with line/column information"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance Optimization"}),": Memoization and efficient parsing strategies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Web Integration"}),": Seamless browser execution without server dependencies"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["As shown in the ",(0,i.jsx)(n.a,{href:"https://github.com/binhphanhai/newbie-interpreter",children:"newbie-interpreter repository"}),", this project serves as an excellent foundation for understanding interpreter design and implementation, while providing a practical tool for Vietnamese-speaking developers to learn programming concepts in their native language."]}),"\n",(0,i.jsx)(n.h3,{id:"further-development",children:"Further Development"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Function Definitions"}),": Add support for user-defined functions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Loop Constructs"}),": Implement ",(0,i.jsx)(n.code,{children:"l\u1eb7p"})," (loop) statements"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Array Operations"}),": Support for list data structures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Module System"}),": Import/export functionality"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Standard Library"}),": Built-in functions for common operations"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The project demonstrates that building a programming language interpreter is an achievable goal with proper architectural design and systematic implementation of each component."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);