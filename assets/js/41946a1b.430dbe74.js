"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5891],{7985:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"project-detail/service-worker","title":"Service Workers: The Gateway to Progressive Web Apps","description":"Table of Contents","source":"@site/docs/project-detail/service-worker.md","sourceDirName":"project-detail","slug":"/project-detail/service-worker","permalink":"/frontend-system-design/docs/project-detail/service-worker","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/service-worker.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Web Workers: Background Threading in the Browser","permalink":"/frontend-system-design/docs/project-detail/web-worker"},"next":{"title":"Styled Components: CSS-in-JS Simplified","permalink":"/frontend-system-design/docs/project-detail/styled-component"}}');var s=t(4848),a=t(8453);const i={},c="Service Workers: The Gateway to Progressive Web Apps",o={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Capabilities",id:"key-capabilities",level:3},{value:"Service Worker vs Web Worker",id:"service-worker-vs-web-worker",level:3},{value:"Getting Started with Service Workers",id:"getting-started-with-service-workers",level:2},{value:"Feature Detection and Registration",id:"feature-detection-and-registration",level:3},{value:"Basic Service Worker Structure",id:"basic-service-worker-structure",level:3},{value:"Service Worker Lifecycle",id:"service-worker-lifecycle",level:2},{value:"Lifecycle States and Transitions",id:"lifecycle-states-and-transitions",level:3},{value:"Under the Hood: How Service Workers Work",id:"under-the-hood-how-service-workers-work",level:2},{value:"Browser Architecture with Service Workers",id:"browser-architecture-with-service-workers",level:3},{value:"Service Worker Global Scope",id:"service-worker-global-scope",level:3},{value:"Caching Strategies",id:"caching-strategies",level:2},{value:"Cache-First Strategy",id:"cache-first-strategy",level:3},{value:"Network-First Strategy",id:"network-first-strategy",level:3},{value:"Stale-While-Revalidate Strategy",id:"stale-while-revalidate-strategy",level:3},{value:"Advanced Caching with Expiration",id:"advanced-caching-with-expiration",level:3},{value:"Offline Functionality",id:"offline-functionality",level:2},{value:"Comprehensive Offline Strategy",id:"comprehensive-offline-strategy",level:3},{value:"Push Notifications and Background Sync",id:"push-notifications-and-background-sync",level:2},{value:"Push Notification Implementation",id:"push-notification-implementation",level:3},{value:"Background Sync",id:"background-sync",level:3},{value:"Advanced Patterns and Best Practices",id:"advanced-patterns-and-best-practices",level:2},{value:"Service Worker Update Pattern",id:"service-worker-update-pattern",level:3},{value:"Resource Versioning Strategy",id:"resource-versioning-strategy",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Secure Service Worker Implementation",id:"secure-service-worker-implementation",level:3},{value:"Debugging and Development",id:"debugging-and-development",level:2},{value:"Service Worker Debugging Tools",id:"service-worker-debugging-tools",level:3},{value:"Real-World Implementation",id:"real-world-implementation",level:2},{value:"Complete PWA Service Worker",id:"complete-pwa-service-worker",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Cache Management Best Practices",id:"cache-management-best-practices",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"When to Use Service Workers",id:"when-to-use-service-workers",level:3},{value:"Further Resources",id:"further-resources",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"service-workers-the-gateway-to-progressive-web-apps",children:"Service Workers: The Gateway to Progressive Web Apps"})}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getting-started-with-service-workers",children:"Getting Started with Service Workers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#service-worker-lifecycle",children:"Service Worker Lifecycle"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#under-the-hood-how-service-workers-work",children:"Under the Hood: How Service Workers Work"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#caching-strategies",children:"Caching Strategies"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#offline-functionality",children:"Offline Functionality"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#push-notifications-and-background-sync",children:"Push Notifications and Background Sync"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#advanced-patterns-and-best-practices",children:"Advanced Patterns and Best Practices"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#security-considerations",children:"Security Considerations"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#debugging-and-development",children:"Debugging and Development"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#real-world-implementation",children:"Real-World Implementation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["Service Workers are a cornerstone technology of Progressive Web Apps (PWAs), acting as programmable proxy servers between web applications and the network. As outlined in the ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API",children:"MDN Service Worker API documentation"}),", they enable powerful features like offline functionality, push notifications, and background synchronization."]}),"\n",(0,s.jsx)(n.p,{children:"Unlike regular Web Workers, Service Workers can intercept network requests, cache resources, and serve content even when the network is unavailable. They run in a separate thread from the main application, ensuring that intensive operations don't block the user interface."}),"\n",(0,s.jsx)(n.h3,{id:"key-capabilities",children:"Key Capabilities"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network Interception"}),": Intercept and modify network requests"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Caching"}),": Store resources for offline access"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Background Processing"}),": Handle tasks when the app isn't active"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Push Notifications"}),": Receive and display notifications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Background Sync"}),": Sync data when connectivity is restored"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"service-worker-vs-web-worker",children:"Service Worker vs Web Worker"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Service Worker - Can intercept network requests\nself.addEventListener("fetch", (event) => {\n  event.respondWith(caches.match(event.request));\n});\n\n// Web Worker - Cannot access network layer\n// Network interception is not possible in regular Web Workers\n'})}),"\n",(0,s.jsx)(n.h2,{id:"getting-started-with-service-workers",children:"Getting Started with Service Workers"}),"\n",(0,s.jsx)(n.h3,{id:"feature-detection-and-registration",children:"Feature Detection and Registration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Check for Service Worker support\nif ("serviceWorker" in navigator) {\n  window.addEventListener("load", async () => {\n    try {\n      const registration = await navigator.serviceWorker.register("/sw.js", {\n        scope: "/", // Controls which pages the SW manages\n      });\n\n      console.log("SW registered:", registration.scope);\n\n      // Handle registration updates\n      registration.addEventListener("updatefound", () => {\n        const newWorker = registration.installing;\n        console.log("New service worker installing");\n\n        newWorker.addEventListener("statechange", () => {\n          if (newWorker.state === "installed") {\n            if (navigator.serviceWorker.controller) {\n              console.log("New content available, please refresh");\n              showUpdateNotification();\n            } else {\n              console.log("Content cached for offline use");\n            }\n          }\n        });\n      });\n    } catch (error) {\n      console.error("SW registration failed:", error);\n    }\n  });\n} else {\n  console.log("Service Workers not supported");\n}\n\nfunction showUpdateNotification() {\n  const notification = document.createElement("div");\n  notification.innerHTML = `\n    <div class="update-notification">\n      New version available! \n      <button onclick="window.location.reload()">Refresh</button>\n    </div>\n  `;\n  document.body.appendChild(notification);\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"basic-service-worker-structure",children:"Basic Service Worker Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// sw.js - Service Worker file\nconst CACHE_NAME = "my-app-v1";\nconst urlsToCache = [\n  "/",\n  "/styles/main.css",\n  "/scripts/main.js",\n  "/offline.html",\n];\n\n// Install event - Cache resources\nself.addEventListener("install", (event) => {\n  console.log("Service Worker installing");\n\n  event.waitUntil(\n    caches\n      .open(CACHE_NAME)\n      .then((cache) => {\n        console.log("Caching app shell");\n        return cache.addAll(urlsToCache);\n      })\n      .then(() => {\n        // Skip waiting to activate immediately\n        return self.skipWaiting();\n      })\n  );\n});\n\n// Activate event - Clean up old caches\nself.addEventListener("activate", (event) => {\n  console.log("Service Worker activating");\n\n  event.waitUntil(\n    caches\n      .keys()\n      .then((cacheNames) => {\n        return Promise.all(\n          cacheNames.map((cacheName) => {\n            if (cacheName !== CACHE_NAME) {\n              console.log("Deleting old cache:", cacheName);\n              return caches.delete(cacheName);\n            }\n          })\n        );\n      })\n      .then(() => {\n        // Claim all clients\n        return self.clients.claim();\n      })\n  );\n});\n\n// Fetch event - Serve cached content or fetch from network\nself.addEventListener("fetch", (event) => {\n  event.respondWith(\n    caches\n      .match(event.request)\n      .then((response) => {\n        // Return cached version or fetch from network\n        return response || fetch(event.request);\n      })\n      .catch(() => {\n        // If both cache and network fail, show offline page\n        if (event.request.destination === "document") {\n          return caches.match("/offline.html");\n        }\n      })\n  );\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"service-worker-lifecycle",children:"Service Worker Lifecycle"}),"\n",(0,s.jsx)(n.h3,{id:"lifecycle-states-and-transitions",children:"Lifecycle States and Transitions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Monitor service worker lifecycle\nclass ServiceWorkerManager {\n  constructor() {\n    this.registration = null;\n    this.isUpdateAvailable = false;\n    this.setupServiceWorker();\n  }\n\n  async setupServiceWorker() {\n    if (!("serviceWorker" in navigator)) {\n      console.log("Service Workers not supported");\n      return;\n    }\n\n    try {\n      this.registration = await navigator.serviceWorker.register("/sw.js");\n      this.monitorLifecycle();\n    } catch (error) {\n      console.error("SW registration failed:", error);\n    }\n  }\n\n  monitorLifecycle() {\n    // Monitor installation\n    this.registration.addEventListener("updatefound", () => {\n      const newWorker = this.registration.installing;\n      this.trackWorkerState(newWorker, "Installing");\n    });\n\n    // Monitor state changes\n    navigator.serviceWorker.addEventListener("controllerchange", () => {\n      console.log("Controller changed - page refresh recommended");\n      this.handleControllerChange();\n    });\n\n    // Check for updates periodically\n    setInterval(() => {\n      this.registration.update();\n    }, 60000); // Check every minute\n  }\n\n  trackWorkerState(worker, phase) {\n    worker.addEventListener("statechange", () => {\n      console.log(`${phase} worker state:`, worker.state);\n\n      switch (worker.state) {\n        case "installed":\n          if (navigator.serviceWorker.controller) {\n            this.isUpdateAvailable = true;\n            this.notifyUpdateAvailable();\n          } else {\n            console.log("Content cached for offline use");\n          }\n          break;\n        case "activated":\n          console.log("Service Worker activated");\n          break;\n        case "redundant":\n          console.log("Service Worker became redundant");\n          break;\n      }\n    });\n  }\n\n  notifyUpdateAvailable() {\n    const event = new CustomEvent("sw-update-available");\n    window.dispatchEvent(event);\n  }\n\n  handleControllerChange() {\n    window.location.reload();\n  }\n\n  async forceUpdate() {\n    if (this.registration.waiting) {\n      this.registration.waiting.postMessage({ type: "SKIP_WAITING" });\n    }\n  }\n}\n\n// Initialize service worker manager\nconst swManager = new ServiceWorkerManager();\n\n// Listen for update notifications\nwindow.addEventListener("sw-update-available", () => {\n  const userConfirmed = confirm("New version available. Update now?");\n  if (userConfirmed) {\n    swManager.forceUpdate();\n  }\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"under-the-hood-how-service-workers-work",children:"Under the Hood: How Service Workers Work"}),"\n",(0,s.jsx)(n.h3,{id:"browser-architecture-with-service-workers",children:"Browser Architecture with Service Workers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Browser Process                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Main Thread              \u2502      Service Worker Thread  \u2502\n\u2502  \u251c\u2500\u2500\u2500 DOM/Rendering       \u2502      \u251c\u2500\u2500\u2500 Network Proxy     \u2502\n\u2502  \u251c\u2500\u2500\u2500 JavaScript Engine   \u2502      \u251c\u2500\u2500\u2500 Cache Management  \u2502\n\u2502  \u251c\u2500\u2500\u2500 Event Loop         \u2502      \u251c\u2500\u2500\u2500 Push Notifications \u2502\n\u2502  \u2514\u2500\u2500\u2500 User Interactions   \u2502      \u2514\u2500\u2500\u2500 Background Tasks  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502              Network Layer                              \u2502\n\u2502         (All requests pass through SW)                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h3,{id:"service-worker-global-scope",children:"Service Worker Global Scope"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Service Worker runs in ServiceWorkerGlobalScope\nconsole.log(self); // ServiceWorkerGlobalScope\nconsole.log(self.caches); // CacheStorage interface\nconsole.log(self.clients); // Clients interface\n\n// Available APIs in Service Worker context\nconst availableAPIs = {\n  // Network APIs\n  fetch: typeof fetch !== "undefined",\n  XMLHttpRequest: typeof XMLHttpRequest !== "undefined",\n\n  // Storage APIs\n  caches: typeof caches !== "undefined",\n  indexedDB: typeof indexedDB !== "undefined",\n\n  // Messaging APIs\n  postMessage: typeof self.postMessage !== "undefined",\n  BroadcastChannel: typeof BroadcastChannel !== "undefined",\n\n  // Notification APIs\n  Notification: typeof Notification !== "undefined",\n  showNotification: typeof self.registration?.showNotification !== "undefined",\n\n  // Not available in Service Workers\n  localStorage: typeof localStorage !== "undefined", // false\n  sessionStorage: typeof sessionStorage !== "undefined", // false\n  document: typeof document !== "undefined", // false\n  window: typeof window !== "undefined", // false\n};\n\nconsole.log("Available APIs:", availableAPIs);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"caching-strategies",children:"Caching Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"cache-first-strategy",children:"Cache-First Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Serve from cache first, fallback to network\nself.addEventListener("fetch", (event) => {\n  if (event.request.destination === "image") {\n    event.respondWith(\n      caches.match(event.request).then((cachedResponse) => {\n        if (cachedResponse) {\n          return cachedResponse;\n        }\n\n        return fetch(event.request).then((networkResponse) => {\n          // Cache the new response\n          const responseClone = networkResponse.clone();\n          caches.open(CACHE_NAME).then((cache) => {\n            cache.put(event.request, responseClone);\n          });\n\n          return networkResponse;\n        });\n      })\n    );\n  }\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"network-first-strategy",children:"Network-First Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Try network first, fallback to cache\nself.addEventListener("fetch", (event) => {\n  if (event.request.url.includes("/api/")) {\n    event.respondWith(\n      fetch(event.request)\n        .then((networkResponse) => {\n          // Update cache with fresh data\n          const responseClone = networkResponse.clone();\n          caches.open(CACHE_NAME).then((cache) => {\n            cache.put(event.request, responseClone);\n          });\n\n          return networkResponse;\n        })\n        .catch(() => {\n          // Network failed, try cache\n          return caches.match(event.request);\n        })\n    );\n  }\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"stale-while-revalidate-strategy",children:"Stale-While-Revalidate Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Serve cached content immediately, update cache in background\nself.addEventListener("fetch", (event) => {\n  if (event.request.destination === "document") {\n    event.respondWith(\n      caches.match(event.request).then((cachedResponse) => {\n        const fetchPromise = fetch(event.request).then((networkResponse) => {\n          caches.open(CACHE_NAME).then((cache) => {\n            cache.put(event.request, networkResponse.clone());\n          });\n          return networkResponse;\n        });\n\n        // Return cached response immediately, or wait for network\n        return cachedResponse || fetchPromise;\n      })\n    );\n  }\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-caching-with-expiration",children:"Advanced Caching with Expiration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class CacheManager {\n  constructor(cacheName, maxAge = 24 * 60 * 60 * 1000) {\n    // 24 hours default\n    this.cacheName = cacheName;\n    this.maxAge = maxAge;\n  }\n\n  async get(request) {\n    const cache = await caches.open(this.cacheName);\n    const response = await cache.match(request);\n\n    if (!response) {\n      return null;\n    }\n\n    const cachedTime = response.headers.get("sw-cache-time");\n    if (cachedTime && Date.now() - parseInt(cachedTime) > this.maxAge) {\n      // Cache expired\n      await cache.delete(request);\n      return null;\n    }\n\n    return response;\n  }\n\n  async put(request, response) {\n    const cache = await caches.open(this.cacheName);\n    const responseClone = response.clone();\n\n    // Add timestamp header\n    const headers = new Headers(responseClone.headers);\n    headers.set("sw-cache-time", Date.now().toString());\n\n    const responseWithTimestamp = new Response(responseClone.body, {\n      status: responseClone.status,\n      statusText: responseClone.statusText,\n      headers: headers,\n    });\n\n    await cache.put(request, responseWithTimestamp);\n    return response;\n  }\n\n  async cleanup() {\n    const cache = await caches.open(this.cacheName);\n    const requests = await cache.keys();\n\n    const deletePromises = requests.map(async (request) => {\n      const response = await cache.match(request);\n      const cachedTime = response.headers.get("sw-cache-time");\n\n      if (cachedTime && Date.now() - parseInt(cachedTime) > this.maxAge) {\n        return cache.delete(request);\n      }\n    });\n\n    await Promise.all(deletePromises);\n  }\n}\n\n// Usage in service worker\nconst cacheManager = new CacheManager("api-cache-v1", 30 * 60 * 1000); // 30 minutes\n\nself.addEventListener("fetch", (event) => {\n  if (event.request.url.includes("/api/")) {\n    event.respondWith(\n      cacheManager.get(event.request).then((cachedResponse) => {\n        if (cachedResponse) {\n          return cachedResponse;\n        }\n\n        return fetch(event.request).then((networkResponse) => {\n          return cacheManager.put(event.request, networkResponse);\n        });\n      })\n    );\n  }\n});\n\n// Clean up expired cache entries periodically\nself.addEventListener("message", (event) => {\n  if (event.data.type === "CLEANUP_CACHE") {\n    cacheManager.cleanup();\n  }\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"offline-functionality",children:"Offline Functionality"}),"\n",(0,s.jsx)(n.h3,{id:"comprehensive-offline-strategy",children:"Comprehensive Offline Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const OFFLINE_PAGE = "/offline.html";\nconst FALLBACK_IMAGE = "/images/offline-image.png";\n\nself.addEventListener("fetch", (event) => {\n  // Handle different resource types\n  if (event.request.destination === "document") {\n    event.respondWith(handleDocumentRequest(event.request));\n  } else if (event.request.destination === "image") {\n    event.respondWith(handleImageRequest(event.request));\n  } else {\n    event.respondWith(handleOtherRequests(event.request));\n  }\n});\n\nasync function handleDocumentRequest(request) {\n  try {\n    // Try network first for documents\n    const networkResponse = await fetch(request);\n\n    // Cache successful responses\n    const cache = await caches.open(CACHE_NAME);\n    cache.put(request, networkResponse.clone());\n\n    return networkResponse;\n  } catch (error) {\n    // Network failed, try cache\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n\n    // Show offline page\n    return caches.match(OFFLINE_PAGE);\n  }\n}\n\nasync function handleImageRequest(request) {\n  try {\n    // Try cache first for images\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n\n    // Try network\n    const networkResponse = await fetch(request);\n\n    // Cache the image\n    const cache = await caches.open(CACHE_NAME);\n    cache.put(request, networkResponse.clone());\n\n    return networkResponse;\n  } catch (error) {\n    // Return fallback image\n    return caches.match(FALLBACK_IMAGE);\n  }\n}\n\nasync function handleOtherRequests(request) {\n  try {\n    return await fetch(request);\n  } catch (error) {\n    return caches.match(request);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"push-notifications-and-background-sync",children:"Push Notifications and Background Sync"}),"\n",(0,s.jsx)(n.h3,{id:"push-notification-implementation",children:"Push Notification Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Service Worker push event handler\nself.addEventListener("push", (event) => {\n  let notificationData = {};\n\n  if (event.data) {\n    notificationData = event.data.json();\n  }\n\n  const options = {\n    title: notificationData.title || "Default Title",\n    body: notificationData.body || "Default message",\n    icon: notificationData.icon || "/images/icon-192x192.png",\n    badge: notificationData.badge || "/images/badge-72x72.png",\n    image: notificationData.image,\n    data: notificationData.data,\n    actions: notificationData.actions || [\n      {\n        action: "view",\n        title: "View",\n        icon: "/images/view-icon.png",\n      },\n      {\n        action: "dismiss",\n        title: "Dismiss",\n        icon: "/images/dismiss-icon.png",\n      },\n    ],\n    requireInteraction: notificationData.requireInteraction || false,\n    silent: notificationData.silent || false,\n  };\n\n  event.waitUntil(self.registration.showNotification(options.title, options));\n});\n\n// Handle notification clicks\nself.addEventListener("notificationclick", (event) => {\n  event.notification.close();\n\n  if (event.action === "view") {\n    // Open specific URL\n    event.waitUntil(clients.openWindow(event.notification.data?.url || "/"));\n  } else if (event.action === "dismiss") {\n    // Just close notification\n    return;\n  } else {\n    // Default action - focus existing window or open new one\n    event.waitUntil(\n      clients\n        .matchAll({ type: "window", includeUncontrolled: true })\n        .then((clientList) => {\n          for (const client of clientList) {\n            if (\n              client.url.includes(self.location.origin) &&\n              "focus" in client\n            ) {\n              return client.focus();\n            }\n          }\n          // No existing window found, open new one\n          return clients.openWindow("/");\n        })\n    );\n  }\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"background-sync",children:"Background Sync"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Register background sync\nself.addEventListener("sync", (event) => {\n  if (event.tag === "background-sync") {\n    event.waitUntil(doBackgroundSync());\n  }\n});\n\nasync function doBackgroundSync() {\n  try {\n    // Get pending data from IndexedDB\n    const pendingData = await getPendingData();\n\n    for (const item of pendingData) {\n      try {\n        const response = await fetch("/api/sync", {\n          method: "POST",\n          body: JSON.stringify(item.data),\n          headers: {\n            "Content-Type": "application/json",\n          },\n        });\n\n        if (response.ok) {\n          // Remove from pending queue\n          await removePendingData(item.id);\n        }\n      } catch (error) {\n        console.log("Sync failed for item:", item.id);\n      }\n    }\n  } catch (error) {\n    console.error("Background sync failed:", error);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-patterns-and-best-practices",children:"Advanced Patterns and Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"service-worker-update-pattern",children:"Service Worker Update Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Handle service worker updates gracefully\nself.addEventListener("message", (event) => {\n  if (event.data.type === "SKIP_WAITING") {\n    self.skipWaiting();\n  }\n});\n\n// In main application\nclass ServiceWorkerUpdateManager {\n  constructor() {\n    this.refreshing = false;\n    this.setupUpdateHandling();\n  }\n\n  setupUpdateHandling() {\n    navigator.serviceWorker.addEventListener("controllerchange", () => {\n      if (this.refreshing) return;\n      this.refreshing = true;\n      window.location.reload();\n    });\n  }\n\n  async checkForUpdates() {\n    const registration = await navigator.serviceWorker.ready;\n    registration.update();\n  }\n\n  async promptUpdate() {\n    const registration = await navigator.serviceWorker.ready;\n\n    if (registration.waiting) {\n      const userWantsUpdate = confirm(\n        "A new version is available. Would you like to update?"\n      );\n\n      if (userWantsUpdate) {\n        registration.waiting.postMessage({ type: "SKIP_WAITING" });\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"resource-versioning-strategy",children:"Resource Versioning Strategy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const CACHE_VERSION = "v2.1.0";\nconst STATIC_CACHE = `static-${CACHE_VERSION}`;\nconst DYNAMIC_CACHE = `dynamic-${CACHE_VERSION}`;\n\nconst STATIC_FILES = [\n  "/",\n  "/styles/main.css",\n  "/scripts/main.js",\n  "/images/logo.png",\n  "/manifest.json",\n];\n\nself.addEventListener("install", (event) => {\n  event.waitUntil(\n    Promise.all([\n      caches.open(STATIC_CACHE).then((cache) => cache.addAll(STATIC_FILES)),\n      caches.open(DYNAMIC_CACHE), // Create dynamic cache\n    ])\n  );\n});\n\nself.addEventListener("activate", (event) => {\n  event.waitUntil(\n    caches.keys().then((cacheNames) => {\n      return Promise.all(\n        cacheNames.map((cacheName) => {\n          if (\n            !cacheName.includes(CACHE_VERSION) &&\n            (cacheName.startsWith("static-") ||\n              cacheName.startsWith("dynamic-"))\n          ) {\n            console.log("Deleting old cache:", cacheName);\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"secure-service-worker-implementation",children:"Secure Service Worker Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Validate requests in service worker\nself.addEventListener("fetch", (event) => {\n  // Only handle same-origin requests\n  if (!event.request.url.startsWith(self.location.origin)) {\n    return;\n  }\n\n  // Validate request method\n  if (!["GET", "POST", "PUT", "DELETE"].includes(event.request.method)) {\n    return;\n  }\n\n  // Handle different request types securely\n  if (event.request.url.includes("/api/")) {\n    event.respondWith(handleAPIRequest(event.request));\n  } else {\n    event.respondWith(handleStaticRequest(event.request));\n  }\n});\n\nasync function handleAPIRequest(request) {\n  // Don\'t cache sensitive API requests\n  if (request.url.includes("/auth/") || request.url.includes("/user/")) {\n    return fetch(request);\n  }\n\n  // Use network-first for API requests\n  try {\n    const response = await fetch(request);\n\n    // Only cache successful responses\n    if (response.ok) {\n      const cache = await caches.open(DYNAMIC_CACHE);\n      cache.put(request, response.clone());\n    }\n\n    return response;\n  } catch (error) {\n    return caches.match(request);\n  }\n}\n\n// Content Security Policy headers\nself.addEventListener("fetch", (event) => {\n  if (event.request.destination === "document") {\n    event.respondWith(\n      fetch(event.request).then((response) => {\n        // Add security headers\n        const headers = new Headers(response.headers);\n        headers.set(\n          "Content-Security-Policy",\n          "default-src \'self\'; script-src \'self\' \'unsafe-eval\'; style-src \'self\' \'unsafe-inline\'"\n        );\n        headers.set("X-Frame-Options", "DENY");\n        headers.set("X-Content-Type-Options", "nosniff");\n\n        return new Response(response.body, {\n          status: response.status,\n          statusText: response.statusText,\n          headers: headers,\n        });\n      })\n    );\n  }\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"debugging-and-development",children:"Debugging and Development"}),"\n",(0,s.jsx)(n.h3,{id:"service-worker-debugging-tools",children:"Service Worker Debugging Tools"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Development utilities\nclass ServiceWorkerDebugger {\n  static logCacheContents() {\n    caches.keys().then((cacheNames) => {\n      console.group("Cache Contents");\n\n      cacheNames.forEach((cacheName) => {\n        caches.open(cacheName).then((cache) => {\n          cache.keys().then((requests) => {\n            console.group(cacheName);\n            requests.forEach((request) => {\n              console.log(request.url);\n            });\n            console.groupEnd();\n          });\n        });\n      });\n\n      console.groupEnd();\n    });\n  }\n\n  static clearAllCaches() {\n    return caches.keys().then((cacheNames) => {\n      return Promise.all(\n        cacheNames.map((cacheName) => {\n          console.log("Deleting cache:", cacheName);\n          return caches.delete(cacheName);\n        })\n      );\n    });\n  }\n\n  static async getCacheSize() {\n    const cacheNames = await caches.keys();\n    let totalSize = 0;\n\n    for (const cacheName of cacheNames) {\n      const cache = await caches.open(cacheName);\n      const requests = await cache.keys();\n\n      for (const request of requests) {\n        const response = await cache.match(request);\n        const blob = await response.blob();\n        totalSize += blob.size;\n      }\n    }\n\n    return totalSize;\n  }\n}\n\n// Expose debugging tools in development\nif (self.location.hostname === "localhost") {\n  self.debug = ServiceWorkerDebugger;\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-implementation",children:"Real-World Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"complete-pwa-service-worker",children:"Complete PWA Service Worker"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const APP_VERSION = "1.0.0";\nconst CACHE_NAME = `pwa-cache-${APP_VERSION}`;\nconst API_CACHE = `api-cache-${APP_VERSION}`;\n\nconst PRECACHE_URLS = [\n  "/",\n  "/index.html",\n  "/styles/app.css",\n  "/scripts/app.js",\n  "/images/icon-192.png",\n  "/manifest.json",\n  "/offline.html",\n];\n\n// Install - precache resources\nself.addEventListener("install", (event) => {\n  event.waitUntil(\n    caches\n      .open(CACHE_NAME)\n      .then((cache) => cache.addAll(PRECACHE_URLS))\n      .then(() => self.skipWaiting())\n  );\n});\n\n// Activate - cleanup old caches\nself.addEventListener("activate", (event) => {\n  event.waitUntil(\n    Promise.all([\n      // Cleanup old caches\n      caches.keys().then((cacheNames) => {\n        return Promise.all(\n          cacheNames.map((cacheName) => {\n            if (cacheName !== CACHE_NAME && cacheName !== API_CACHE) {\n              return caches.delete(cacheName);\n            }\n          })\n        );\n      }),\n      // Claim all clients\n      self.clients.claim(),\n    ])\n  );\n});\n\n// Fetch - implement caching strategy\nself.addEventListener("fetch", (event) => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n  // Handle API requests\n  if (url.pathname.startsWith("/api/")) {\n    event.respondWith(handleAPIRequest(request));\n  }\n  // Handle static resources\n  else if (request.destination === "document") {\n    event.respondWith(handleDocumentRequest(request));\n  }\n  // Handle other resources\n  else {\n    event.respondWith(handleResourceRequest(request));\n  }\n});\n\nasync function handleAPIRequest(request) {\n  const cache = await caches.open(API_CACHE);\n\n  try {\n    const response = await fetch(request);\n\n    if (response.ok) {\n      cache.put(request, response.clone());\n    }\n\n    return response;\n  } catch (error) {\n    const cachedResponse = await cache.match(request);\n    return cachedResponse || new Response("Offline", { status: 503 });\n  }\n}\n\nasync function handleDocumentRequest(request) {\n  try {\n    const response = await fetch(request);\n    return response;\n  } catch (error) {\n    return caches.match(request) || caches.match("/offline.html");\n  }\n}\n\nasync function handleResourceRequest(request) {\n  const cachedResponse = await caches.match(request);\n\n  if (cachedResponse) {\n    return cachedResponse;\n  }\n\n  try {\n    const response = await fetch(request);\n\n    if (response.ok) {\n      const cache = await caches.open(CACHE_NAME);\n      cache.put(request, response.clone());\n    }\n\n    return response;\n  } catch (error) {\n    // Return fallback for images\n    if (request.destination === "image") {\n      return caches.match("/images/fallback.png");\n    }\n\n    throw error;\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"cache-management-best-practices",children:"Cache Management Best Practices"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Efficient cache management\nclass OptimizedCacheManager {\n  constructor() {\n    this.maxCacheSize = 50 * 1024 * 1024; // 50MB\n    this.maxCacheAge = 7 * 24 * 60 * 60 * 1000; // 7 days\n  }\n\n  async maintainCache() {\n    await this.removeExpiredEntries();\n    await this.enforcesCacheLimit();\n  }\n\n  async removeExpiredEntries() {\n    const cacheNames = await caches.keys();\n\n    for (const cacheName of cacheNames) {\n      const cache = await caches.open(cacheName);\n      const requests = await cache.keys();\n\n      for (const request of requests) {\n        const response = await cache.match(request);\n        const dateHeader = response.headers.get("date");\n\n        if (dateHeader) {\n          const age = Date.now() - new Date(dateHeader).getTime();\n          if (age > this.maxCacheAge) {\n            await cache.delete(request);\n          }\n        }\n      }\n    }\n  }\n\n  async enforcesCacheLimit() {\n    const totalSize = await this.calculateCacheSize();\n\n    if (totalSize > this.maxCacheSize) {\n      await this.removeOldestEntries(totalSize - this.maxCacheSize);\n    }\n  }\n\n  async calculateCacheSize() {\n    // Implementation for calculating total cache size\n    const cacheNames = await caches.keys();\n    let totalSize = 0;\n\n    for (const cacheName of cacheNames) {\n      const cache = await caches.open(cacheName);\n      const requests = await cache.keys();\n\n      for (const request of requests) {\n        const response = await cache.match(request);\n        const blob = await response.blob();\n        totalSize += blob.size;\n      }\n    }\n\n    return totalSize;\n  }\n}\n\n// Run cache maintenance periodically\nconst cacheManager = new OptimizedCacheManager();\nsetInterval(() => {\n  cacheManager.maintainCache();\n}, 24 * 60 * 60 * 1000); // Daily\n'})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Service Workers are a fundamental technology for building modern web applications that provide native-like experiences. They enable powerful features like offline functionality, push notifications, and background synchronization while maintaining security and performance."}),"\n",(0,s.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Lifecycle Management"}),": Understanding the install, activate, and fetch phases is crucial for effective Service Worker implementation."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Caching Strategies"}),": Different caching strategies (cache-first, network-first, stale-while-revalidate) serve different use cases and performance requirements."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Security First"}),": Service Workers require HTTPS and careful consideration of security implications, including proper scope management and input validation."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Progressive Enhancement"}),": Service Workers should enhance the user experience without breaking functionality for unsupported browsers."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance Impact"}),": While Service Workers can significantly improve performance through caching, they require careful management to avoid bloating storage and degrading performance."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"when-to-use-service-workers",children:"When to Use Service Workers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Building Progressive Web Apps (PWAs)"}),"\n",(0,s.jsx)(n.li,{children:"Implementing offline functionality"}),"\n",(0,s.jsx)(n.li,{children:"Optimizing resource loading and caching"}),"\n",(0,s.jsx)(n.li,{children:"Adding push notification capabilities"}),"\n",(0,s.jsx)(n.li,{children:"Performing background data synchronization"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["As detailed in the ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API",children:"MDN Service Worker API documentation"}),", Service Workers represent a paradigm shift toward more resilient, performant web applications that can compete with native mobile apps in terms of user experience and reliability."]}),"\n",(0,s.jsx)(n.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API",children:"MDN Service Worker API Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developers.google.com/web/fundamentals/primers/service-workers",children:"Google Developers - Service Worker Guide"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://w3c.github.io/ServiceWorker/",children:"Service Worker Specification"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developers.google.com/web/tools/workbox",children:"Workbox - Production-ready Service Worker Libraries"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var r=t(6540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);