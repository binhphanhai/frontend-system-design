"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2979],{4481:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"frontend-system-design/chat-app-summary","title":"15-chat-app: Summary","description":"---","source":"@site/docs/frontend-system-design/15-chat-app-summary.md","sourceDirName":"frontend-system-design","slug":"/frontend-system-design/chat-app-summary","permalink":"/frontend-system-design/docs/frontend-system-design/chat-app-summary","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/frontend-system-design/15-chat-app-summary.md","tags":[],"version":"current","sidebarPosition":15,"frontMatter":{},"sidebar":"summarySidebar","previous":{"title":"14-travel-booking: Summary","permalink":"/frontend-system-design/docs/frontend-system-design/travel-booking-summary"},"next":{"title":"16-photo-sharing: Summary","permalink":"/frontend-system-design/docs/frontend-system-design/photo-sharing-summary"}}');var i=s(4848),t=s(8453);const l={},o="15-chat-app: Summary",a={},d=[];function c(e){const n={blockquote:"blockquote",br:"br",h1:"h1",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"15-chat-app-summary",children:"15-chat-app: Summary"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Interviewer\u2019s Intention"}),(0,i.jsx)(n.br,{}),"\n","Goal: Assess your ability to design a real-time, reliable, and user-friendly chat application frontend (like Messenger/WhatsApp)."]}),"\n",(0,i.jsx)(n.p,{children:"Want to see:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If you can break down the system into messaging, sync, offline, and error handling."}),"\n",(0,i.jsx)(n.li,{children:"How you handle real-time updates, multi-device, and offline scenarios."}),"\n",(0,i.jsx)(n.li,{children:"If you consider accessibility, security, and real-world tradeoffs."}),"\n",(0,i.jsx)(n.li,{children:"How you justify design decisions and communicate alternatives."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Answer Framework"})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Clarify Requirements"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"1:1 messaging, chat history, message status (sent, delivered, read)"}),"\n",(0,i.jsx)(n.li,{children:"Real-time updates, offline support, multi-device sync"}),"\n",(0,i.jsx)(n.li,{children:"Error handling, retries, optimistic UI"}),"\n",(0,i.jsx)(n.li,{children:"Accessibility, security, scalability"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Architecture & Data Flow"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"SPA for high interactivity"})," (React, Redux, Zustand)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"WebSockets for real-time sync"})," (bidirectional updates)"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"IndexedDB for offline storage and multi-tab sync"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Component breakdown:"})," Conversation list, chat window, message input, status indicators"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State management:"})," Client DB for messages, server for source of truth"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Real-Time, Offline, and Error Handling"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Outgoing queue for unsent messages, retry with exponential backoff"}),"\n",(0,i.jsx)(n.li,{children:"Sync on reconnect, deduplicate, handle out-of-order delivery"}),"\n",(0,i.jsx)(n.li,{children:"Optimistic UI for fast feedback"}),"\n",(0,i.jsx)(n.li,{children:"Error messages, manual retry, status icons"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Accessibility & Internationalization"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Keyboard shortcuts, ARIA roles, focus management"}),"\n",(0,i.jsx)(n.li,{children:"Screen reader support, color contrast, RTL support"}),"\n",(0,i.jsx)(n.li,{children:"Localized UI, date/time, emoji support"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Security, Analytics, and Scalability"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"HTTPS, JWT/session tokens, end-to-end encryption (advanced)"}),"\n",(0,i.jsx)(n.li,{children:"Analytics, A/B testing, error reporting, performance monitoring"}),"\n",(0,i.jsx)(n.li,{children:"Horizontal scaling, sharded DBs, message queues"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Tradeoffs & Alternatives"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"WebSockets vs. polling: WebSockets for real-time, polling as fallback"}),"\n",(0,i.jsx)(n.li,{children:"IndexedDB vs. localStorage: IndexedDB for structured, large data"}),"\n",(0,i.jsx)(n.li,{children:"SPA vs. SSR: SPA for chat, SSR not needed for SEO"}),"\n",(0,i.jsx)(n.li,{children:"Offset vs. cursor-based pagination for chat history"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Example Content / Model Answer"})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"\u201cFor a chat app, I\u2019d use SPA with WebSockets for real-time sync, IndexedDB for offline, and optimistic UI for fast feedback. Outgoing messages are queued and retried on reconnect. Accessibility with ARIA and keyboard shortcuts. Tradeoff: WebSockets are best for real-time, but fallback to polling if needed. IndexedDB is better than localStorage for large message history.\u201d"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Pro Tips / Common Pitfalls"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Don\u2019t forget offline, error handling, and accessibility."}),"\n",(0,i.jsx)(n.li,{children:"Optimize for fast load, mobile UX, and real-time sync."}),"\n",(0,i.jsx)(n.li,{children:"Test with slow networks, multi-device, and screen readers."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var r=s(6540);const i={},t=r.createContext(i);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);