"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8632],{336:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"project-detail/web-socket","title":"WebSockets: Real-Time Communication Under the Hood","description":"Table of Contents","source":"@site/docs/project-detail/web-socket.md","sourceDirName":"project-detail","slug":"/project-detail/web-socket","permalink":"/frontend-system-design/docs/project-detail/web-socket","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/web-socket.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Dexie.js and IndexedDB: Under the Hood","permalink":"/frontend-system-design/docs/project-detail/dexie-and-indexed-db"},"next":{"title":"Web Workers: Background Threading in the Browser","permalink":"/frontend-system-design/docs/project-detail/web-worker"}}');var i=t(4848),o=t(8453);const r={},a="WebSockets: Real-Time Communication Under the Hood",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Advantages",id:"key-advantages",level:3},{value:"Common Use Cases",id:"common-use-cases",level:3},{value:"Getting Started with WebSockets",id:"getting-started-with-websockets",level:2},{value:"Basic Client Implementation",id:"basic-client-implementation",level:3},{value:"Enhanced WebSocket Client Class",id:"enhanced-websocket-client-class",level:3},{value:"WebSocket Protocol Deep Dive",id:"websocket-protocol-deep-dive",level:2},{value:"Protocol Overview",id:"protocol-overview",level:3},{value:"HTTP to WebSocket Upgrade Process",id:"http-to-websocket-upgrade-process",level:3},{value:"WebSocket Header Analysis",id:"websocket-header-analysis",level:3},{value:"Connection Establishment and Handshake",id:"connection-establishment-and-handshake",level:2},{value:"Client-Side Connection Process",id:"client-side-connection-process",level:3},{value:"Server-Side Handshake Validation",id:"server-side-handshake-validation",level:3},{value:"Frame Structure and Message Types",id:"frame-structure-and-message-types",level:2},{value:"WebSocket Frame Format",id:"websocket-frame-format",level:3},{value:"Frame Processing Implementation",id:"frame-processing-implementation",level:3},{value:"Connection Management and Lifecycle",id:"connection-management-and-lifecycle",level:2},{value:"Keep-Alive and Heartbeat",id:"keep-alive-and-heartbeat",level:3},{value:"Connection Pool Management",id:"connection-pool-management",level:3},{value:"Server-Side Implementation",id:"server-side-implementation",level:2},{value:"Node.js WebSocket Server",id:"nodejs-websocket-server",level:3},{value:"Real-Time Communication Patterns",id:"real-time-communication-patterns",level:2},{value:"Request-Response Pattern",id:"request-response-pattern",level:3},{value:"Pub/Sub Pattern",id:"pubsub-pattern",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Secure WebSocket Implementation",id:"secure-websocket-implementation",level:3},{value:"Rate Limiting and DDoS Protection",id:"rate-limiting-and-ddos-protection",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Connection Pooling and Load Balancing",id:"connection-pooling-and-load-balancing",level:3},{value:"Message Compression and Batching",id:"message-compression-and-batching",level:3},{value:"Real-World Implementation Examples",id:"real-world-implementation-examples",level:2},{value:"Real-Time Chat Application",id:"real-time-chat-application",level:3},{value:"Error Handling and Debugging",id:"error-handling-and-debugging",level:2},{value:"Comprehensive Error Handling",id:"comprehensive-error-handling",level:3},{value:"WebSocket Debugging Tools",id:"websocket-debugging-tools",level:3},{value:"Best Practices and Common Pitfalls",id:"best-practices-and-common-pitfalls",level:2},{value:"Connection Management Best Practices",id:"connection-management-best-practices",level:3},{value:"Message Handling Best Practices",id:"message-handling-best-practices",level:3},{value:"Performance Optimization Tips",id:"performance-optimization-tips",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Future Considerations",id:"future-considerations",level:3},{value:"Further Resources",id:"further-resources",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"websockets-real-time-communication-under-the-hood",children:"WebSockets: Real-Time Communication Under the Hood"})}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#getting-started-with-websockets",children:"Getting Started with WebSockets"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#websocket-protocol-deep-dive",children:"WebSocket Protocol Deep Dive"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#connection-establishment-and-handshake",children:"Connection Establishment and Handshake"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#frame-structure-and-message-types",children:"Frame Structure and Message Types"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#connection-management-and-lifecycle",children:"Connection Management and Lifecycle"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#server-side-implementation",children:"Server-Side Implementation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#real-time-communication-patterns",children:"Real-Time Communication Patterns"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#security-considerations",children:"Security Considerations"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#real-world-implementation-examples",children:"Real-World Implementation Examples"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#error-handling-and-debugging",children:"Error Handling and Debugging"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#websocket-libraries-and-frameworks",children:"WebSocket Libraries and Frameworks"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#best-practices-and-common-pitfalls",children:"Best Practices and Common Pitfalls"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"WebSockets provide a full-duplex communication channel between a client and server over a single TCP connection. Unlike traditional HTTP requests, WebSockets enable real-time, bidirectional communication with minimal overhead, making them ideal for applications requiring instant data exchange."}),"\n",(0,i.jsxs)(n.p,{children:["As defined in the ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API",children:"WebSocket API specification"}),", WebSockets overcome the limitations of HTTP polling by establishing a persistent connection that allows both client and server to send data at any time."]}),"\n",(0,i.jsx)(n.h3,{id:"key-advantages",children:"Key Advantages"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Full-Duplex Communication"}),": Both client and server can send data simultaneously"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Low Latency"}),": No HTTP header overhead after initial handshake"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Real-Time Updates"}),": Instant data exchange without polling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Efficient Resource Usage"}),": Single persistent connection vs multiple HTTP requests"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Binary and Text Support"}),": Flexible data transmission formats"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Real-time chat applications"}),"\n",(0,i.jsx)(n.li,{children:"Live gaming and multiplayer experiences"}),"\n",(0,i.jsx)(n.li,{children:"Financial trading platforms"}),"\n",(0,i.jsx)(n.li,{children:"Collaborative editing tools"}),"\n",(0,i.jsx)(n.li,{children:"Live notifications and alerts"}),"\n",(0,i.jsx)(n.li,{children:"IoT device communication"}),"\n",(0,i.jsx)(n.li,{children:"Real-time analytics dashboards"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"getting-started-with-websockets",children:"Getting Started with WebSockets"}),"\n",(0,i.jsx)(n.h3,{id:"basic-client-implementation",children:"Basic Client Implementation"}),"\n",(0,i.jsx)(n.p,{children:"This section demonstrates the fundamental WebSocket client implementation using the browser's native WebSocket API. The following code establishes a connection to a WebSocket server and handles the basic lifecycle events."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"What this code does:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Creates a WebSocket connection to the specified server"}),"\n",(0,i.jsx)(n.li,{children:"Sets up event listeners for all WebSocket states (open, message, error, close)"}),"\n",(0,i.jsx)(n.li,{children:"Sends a greeting message when the connection is established"}),"\n",(0,i.jsx)(n.li,{children:"Logs received messages and connection status changes"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input:"})," WebSocket server URL (ws://localhost:8080)\n",(0,i.jsx)(n.strong,{children:"Output:"})," Console logs showing connection status and received messages"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// Create a new WebSocket connection to the server\n// The URL scheme is \'ws://\' for unencrypted or \'wss://\' for encrypted connections\nconst socket = new WebSocket("ws://localhost:8080");\n\n// Event: Connection successfully established\nsocket.addEventListener("open", (event) => {\n  console.log("Connected to WebSocket server");\n  // Send an initial message to the server to confirm connectivity\n  socket.send("Hello Server!");\n});\n\n// Event: Message received from the server\nsocket.addEventListener("message", (event) => {\n  // event.data contains the message payload (string or binary data)\n  console.log("Message from server:", event.data);\n});\n\n// Event: Connection error occurred\nsocket.addEventListener("error", (event) => {\n  // Log any connection or communication errors\n  console.error("WebSocket error:", event);\n});\n\n// Event: Connection closed by either client or server\nsocket.addEventListener("close", (event) => {\n  // event.code: numeric code indicating close reason\n  // event.reason: human-readable close reason\n  console.log("Connection closed:", event.code, event.reason);\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"enhanced-websocket-client-class",children:"Enhanced WebSocket Client Class"}),"\n",(0,i.jsx)(n.p,{children:"The following code demonstrates a production-ready WebSocket client class that handles reconnection, message queuing, and event management. This class provides a robust foundation for real-world applications requiring reliable WebSocket communication."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"What this class provides:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automatic Reconnection"}),": Handles connection drops and retries with exponential backoff"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message Queuing"}),": Buffers messages when disconnected and sends them upon reconnection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Event Management"}),": Custom event system for handling connection states and messages"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Connection State Management"}),": Tracks and manages WebSocket connection states"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Comprehensive error handling with retry logic"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Features:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Configurable reconnection attempts and intervals"}),"\n",(0,i.jsx)(n.li,{children:"Message queue persistence during disconnections"}),"\n",(0,i.jsx)(n.li,{children:"Custom event listeners for application-specific handling"}),"\n",(0,i.jsx)(n.li,{children:"Connection state validation before sending messages"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input:"})," WebSocket URL, optional protocols array, configuration options\n",(0,i.jsx)(n.strong,{children:"Output:"})," Reliable WebSocket connection with automatic reconnection and message queuing"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class WebSocketClient {\n  constructor(url, protocols = []) {\n    // Connection configuration\n    this.url = url; // WebSocket server URL\n    this.protocols = protocols; // Optional subprotocols\n    this.socket = null; // Current WebSocket instance\n\n    // Reconnection management\n    this.reconnectAttempts = 0; // Current number of reconnection attempts\n    this.maxReconnectAttempts = 5; // Maximum reconnection attempts before giving up\n    this.reconnectInterval = 1000; // Base reconnection delay in milliseconds\n\n    // Message handling\n    this.messageQueue = []; // Queue for messages sent while disconnected\n    this.eventListeners = {}; // Custom event listeners registry\n  }\n\n  connect() {\n    try {\n      // Create new WebSocket instance with configured URL and protocols\n      this.socket = new WebSocket(this.url, this.protocols);\n      this.setupEventListeners();\n    } catch (error) {\n      // Handle immediate connection errors (invalid URL, etc.)\n      console.error("Failed to create WebSocket:", error);\n      this.handleReconnect();\n    }\n  }\n\n  setupEventListeners() {\n    // Event: Connection successfully opened\n    this.socket.onopen = (event) => {\n      console.log("WebSocket connected");\n      this.reconnectAttempts = 0; // Reset reconnection counter on successful connection\n      this.processMessageQueue(); // Send any queued messages from disconnection period\n      this.emit("open", event); // Notify application of successful connection\n    };\n\n    // Event: Message received from server\n    this.socket.onmessage = (event) => {\n      const data = this.parseMessage(event.data); // Parse JSON or return raw data\n      this.emit("message", data); // Forward parsed message to application\n    };\n\n    // Event: WebSocket error occurred\n    this.socket.onerror = (event) => {\n      console.error("WebSocket error:", event);\n      this.emit("error", event); // Forward error to application for handling\n    };\n\n    // Event: Connection closed\n    this.socket.onclose = (event) => {\n      console.log("WebSocket closed:", event.code, event.reason);\n      this.emit("close", event); // Notify application of connection closure\n\n      // Attempt reconnection if closure was not clean (unexpected disconnection)\n      if (!event.wasClean) {\n        this.handleReconnect();\n      }\n    };\n  }\n\n  send(data) {\n    // Check if WebSocket is currently connected and ready\n    if (this.isConnected()) {\n      const message = this.formatMessage(data); // Convert data to appropriate format\n      this.socket.send(message); // Send immediately if connected\n    } else {\n      // Queue message for later delivery when connection is restored\n      this.messageQueue.push(data);\n      console.log("Message queued (disconnected):", data);\n    }\n  }\n\n  isConnected() {\n    // Verify socket exists and is in OPEN state (readyState === 1)\n    return this.socket && this.socket.readyState === WebSocket.OPEN;\n  }\n\n  parseMessage(data) {\n    try {\n      // Attempt to parse as JSON for structured data\n      return JSON.parse(data);\n    } catch {\n      // Return raw data if not valid JSON (could be plain text or binary)\n      return data;\n    }\n  }\n\n  formatMessage(data) {\n    // Convert objects to JSON strings, leave primitives as-is\n    return typeof data === "object" ? JSON.stringify(data) : data;\n  }\n\n  processMessageQueue() {\n    // Send all queued messages upon reconnection\n    while (this.messageQueue.length > 0) {\n      const message = this.messageQueue.shift(); // Remove from queue and send\n      this.send(message); // Recursive call, but now connected\n    }\n  }\n\n  handleReconnect() {\n    // Implement exponential backoff reconnection strategy\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Reconnecting... Attempt ${this.reconnectAttempts}`);\n\n      // Exponential backoff: delay increases with each attempt\n      setTimeout(() => {\n        this.connect();\n      }, this.reconnectInterval * this.reconnectAttempts);\n    } else {\n      console.error("Max reconnection attempts reached");\n      this.emit("maxReconnectAttemptsReached"); // Notify application of permanent failure\n    }\n  }\n\n  on(event, callback) {\n    // Register event listener for custom events\n    if (!this.eventListeners[event]) {\n      this.eventListeners[event] = []; // Initialize event array if first listener\n    }\n    this.eventListeners[event].push(callback); // Add callback to event listeners\n  }\n\n  off(event, callback) {\n    // Remove specific event listener\n    if (this.eventListeners[event]) {\n      this.eventListeners[event] = this.eventListeners[event].filter(\n        (cb) => cb !== callback // Keep all callbacks except the one to remove\n      );\n    }\n  }\n\n  emit(event, data) {\n    // Trigger all listeners for a specific event\n    if (this.eventListeners[event]) {\n      this.eventListeners[event].forEach((callback) => {\n        try {\n          callback(data); // Call each registered callback with event data\n        } catch (error) {\n          console.error(`Error in event listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  close(code = 1000, reason = "Normal closure") {\n    // Gracefully close WebSocket connection\n    if (this.socket) {\n      this.socket.close(code, reason); // Send close frame with specified code and reason\n    }\n  }\n\n  getState() {\n    // Return human-readable connection state\n    if (!this.socket) return "UNINITIALIZED";\n\n    // Map WebSocket readyState constants to descriptive strings\n    switch (this.socket.readyState) {\n      case WebSocket.CONNECTING: // 0: Connection is being established\n        return "CONNECTING";\n      case WebSocket.OPEN: // 1: Connection is open and ready\n        return "OPEN";\n      case WebSocket.CLOSING: // 2: Connection is being closed\n        return "CLOSING";\n      case WebSocket.CLOSED: // 3: Connection is closed\n        return "CLOSED";\n      default:\n        return "UNKNOWN";\n    }\n  }\n}\n\n// Usage example demonstrating the enhanced WebSocket client\nconst client = new WebSocketClient("ws://localhost:8080");\n\n// Set up event handlers before connecting\nclient.on("open", () => {\n  console.log("Connected successfully");\n  // Send a structured message upon connection\n  client.send({ type: "greeting", message: "Hello from client!" });\n});\n\nclient.on("message", (data) => {\n  console.log("Received:", data);\n  // Handle different message types based on your application logic\n});\n\nclient.on("error", (error) => {\n  console.error("Connection error:", error);\n});\n\nclient.on("maxReconnectAttemptsReached", () => {\n  console.error("Failed to reconnect after maximum attempts");\n  // Implement fallback logic or notify user\n});\n\n// Initiate the connection\nclient.connect();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"websocket-protocol-deep-dive",children:"WebSocket Protocol Deep Dive"}),"\n",(0,i.jsx)(n.h3,{id:"protocol-overview",children:"Protocol Overview"}),"\n",(0,i.jsx)(n.p,{children:"This section explores the technical details of the WebSocket protocol, from the initial HTTP upgrade handshake to the frame-level communication format. Understanding these fundamentals is crucial for implementing robust WebSocket applications and debugging connection issues."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Protocol Architecture:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"HTTP Upgrade Handshake"}),": Initial negotiation using standard HTTP headers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Protocol Switching"}),": Transition from HTTP to WebSocket binary protocol"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Frame-Based Communication"}),": Structured message format with minimal overhead"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Connection Persistence"}),": Long-lived bidirectional communication channel"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"WebSockets operate over TCP and use HTTP/1.1 for the initial handshake. Once established, the connection switches to the WebSocket protocol, enabling bidirectional communication with minimal overhead. This hybrid approach ensures compatibility with existing web infrastructure while providing the performance benefits of a persistent connection."}),"\n",(0,i.jsx)(n.h3,{id:"http-to-websocket-upgrade-process",children:"HTTP to WebSocket Upgrade Process"}),"\n",(0,i.jsx)(n.p,{children:"The WebSocket handshake is a carefully orchestrated HTTP upgrade process that establishes the WebSocket connection while maintaining compatibility with HTTP infrastructure. The following example shows the complete request-response cycle."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Handshake Process Steps:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Client Request"}),": HTTP GET request with WebSocket upgrade headers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Server Validation"}),": Server validates headers and generates accept key"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Protocol Switch"}),": Server responds with 101 status code to confirm upgrade"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Connection Established"}),": Both parties switch to WebSocket frame protocol"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input:"})," HTTP GET request with WebSocket headers\n",(0,i.jsx)(n.strong,{children:"Output:"})," HTTP 101 response confirming protocol upgrade"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Client Request:\nGET /chat HTTP/1.1                              # Standard HTTP GET request\nHost: server.example.com                        # Target server hostname\nUpgrade: websocket                              # Request protocol upgrade to WebSocket\nConnection: Upgrade                             # Indicate connection should be upgraded\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==     # Random 16-byte value (base64 encoded)\nSec-WebSocket-Version: 13                      # WebSocket protocol version (RFC 6455)\nSec-WebSocket-Protocol: chat, superchat        # Optional: preferred subprotocols\nOrigin: http://example.com                      # Origin header for security validation\n\nServer Response:\nHTTP/1.1 101 Switching Protocols               # Successful protocol upgrade\nUpgrade: websocket                              # Confirm upgrade to WebSocket\nConnection: Upgrade                             # Confirm connection upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=  # SHA-1 hash of key + magic string\nSec-WebSocket-Protocol: chat                   # Selected subprotocol from client's list\n"})}),"\n",(0,i.jsx)(n.h3,{id:"websocket-header-analysis",children:"WebSocket Header Analysis"}),"\n",(0,i.jsx)(n.p,{children:"The following code demonstrates how to implement WebSocket handshake validation and key generation according to RFC 6455 specifications. This implementation shows the cryptographic process used to validate WebSocket connections and prevent connection hijacking."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"What this code demonstrates:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security Key Generation"}),": Creates random 16-byte keys for handshake validation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Accept Key Validation"}),": Implements the SHA-1 hashing algorithm for server response validation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Header Parsing"}),": Extracts and validates WebSocket-specific headers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Protocol Compliance"}),": Ensures adherence to RFC 6455 WebSocket standard"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Security Features:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Random key generation prevents replay attacks"}),"\n",(0,i.jsx)(n.li,{children:"SHA-1 with magic string ensures server WebSocket capability"}),"\n",(0,i.jsx)(n.li,{children:"Header validation prevents malicious upgrade attempts"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input:"})," HTTP headers from WebSocket handshake\n",(0,i.jsx)(n.strong,{children:"Output:"})," Validated connection parameters and security keys"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// WebSocket handshake validation and key generation utilities\nclass WebSocketHandshake {\n  static generateKey() {\n    // Generate cryptographically secure 16-byte random value for handshake\n    const bytes = new Uint8Array(16); // 16 bytes = 128 bits of entropy\n    crypto.getRandomValues(bytes); // Use secure random number generator\n    return btoa(String.fromCharCode(...bytes)); // Encode as base64 string\n  }\n\n  static validateAcceptKey(clientKey, serverAccept) {\n    // RFC 6455 mandated magic string for WebSocket accept key generation\n    const magicString = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";\n    const concatenated = clientKey + magicString; // Combine client key with magic string\n\n    // Compute SHA-1 hash and base64 encode (as per RFC 6455)\n    return crypto.subtle\n      .digest("SHA-1", new TextEncoder().encode(concatenated))\n      .then((hashBuffer) => {\n        const hashArray = new Uint8Array(hashBuffer); // Convert ArrayBuffer to Uint8Array\n        const expectedAccept = btoa(String.fromCharCode(...hashArray)); // Base64 encode\n        return expectedAccept === serverAccept; // Validate server\'s accept key\n      });\n  }\n\n  static parseUpgradeHeaders(headers) {\n    // Extract and normalize WebSocket-specific headers from HTTP request\n    return {\n      upgrade: headers.get("Upgrade")?.toLowerCase(), // Should be "websocket"\n      connection: headers.get("Connection")?.toLowerCase(), // Should contain "upgrade"\n      key: headers.get("Sec-WebSocket-Key"), // Client\'s random key\n      version: headers.get("Sec-WebSocket-Version"), // Should be "13"\n      protocol: headers.get("Sec-WebSocket-Protocol"), // Optional subprotocols\n      extensions: headers.get("Sec-WebSocket-Extensions"), // Optional extensions\n    };\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"connection-establishment-and-handshake",children:"Connection Establishment and Handshake"}),"\n",(0,i.jsx)(n.h3,{id:"client-side-connection-process",children:"Client-Side Connection Process"}),"\n",(0,i.jsx)(n.p,{children:"This section demonstrates advanced client-side connection management with timeout handling, heartbeat mechanisms, and comprehensive state tracking. The implementation provides robust connection establishment with proper cleanup and error handling."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Connection Management Features:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Timeout Protection"}),": Prevents hanging connections with configurable timeouts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State Tracking"}),": Monitors connection lifecycle with descriptive states"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Heartbeat System"}),": Maintains connection health with periodic ping/pong"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Promise-Based API"}),": Modern async/await compatible connection interface"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Cleanup"}),": Proper timer and event listener cleanup"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Connection States:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"IDLE"}),": Initial state before connection attempt"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CONNECTING"}),": WebSocket handshake in progress"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CONNECTED"}),": Connection established and ready"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ERROR"}),": Connection failed or encountered error"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CLOSED"}),": Connection terminated"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input:"})," WebSocket URL and configuration options\n",(0,i.jsx)(n.strong,{children:"Output:"})," Promise resolving to established WebSocket connection"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class WebSocketConnection {\n  constructor(url, options = {}) {\n    this.url = url; // WebSocket server URL\n    this.options = {\n      protocols: options.protocols || [], // Optional WebSocket subprotocols\n      timeout: options.timeout || 30000, // Connection timeout in milliseconds\n      ...options, // Additional configuration options\n    };\n    this.connectionState = "IDLE"; // Initial connection state\n  }\n\n  async connect() {\n    // Return Promise for modern async/await compatibility\n    return new Promise((resolve, reject) => {\n      this.connectionState = "CONNECTING"; // Update state to indicate connection attempt\n\n      // Create WebSocket with configured URL and protocols\n      const socket = new WebSocket(this.url, this.options.protocols);\n\n      // Set up connection timeout to prevent hanging\n      const timeout = setTimeout(() => {\n        socket.close(); // Force close on timeout\n        this.connectionState = "ERROR";\n        reject(new Error("Connection timeout"));\n      }, this.options.timeout);\n\n      // Handle successful connection establishment\n      socket.onopen = () => {\n        clearTimeout(timeout); // Cancel timeout timer\n        this.connectionState = "CONNECTED"; // Update connection state\n        this.socket = socket; // Store socket reference\n        this.setupHeartbeat(); // Initialize heartbeat mechanism\n        resolve(socket); // Resolve promise with socket\n      };\n\n      // Handle connection errors\n      socket.onerror = (error) => {\n        clearTimeout(timeout); // Cancel timeout timer\n        this.connectionState = "ERROR"; // Update state to error\n        reject(error); // Reject promise with error\n      };\n\n      // Handle connection closure\n      socket.onclose = () => {\n        clearTimeout(timeout); // Cancel timeout timer\n        this.connectionState = "CLOSED"; // Update state to closed\n        this.cleanup(); // Clean up resources\n      };\n    });\n  }\n\n  setupHeartbeat() {\n    // Establish periodic heartbeat to maintain connection health\n    this.heartbeatInterval = setInterval(() => {\n      // Only send ping if connection is open and ready\n      if (this.socket?.readyState === WebSocket.OPEN) {\n        this.socket.send(JSON.stringify({ type: "ping" })); // Send ping message\n      }\n    }, 30000); // Send ping every 30 seconds to detect stale connections\n  }\n\n  cleanup() {\n    // Clean up resources and timers to prevent memory leaks\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval); // Stop heartbeat timer\n      this.heartbeatInterval = null; // Clear reference\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"server-side-handshake-validation",children:"Server-Side Handshake Validation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// Node.js WebSocket server handshake handling\nconst crypto = require("crypto");\nconst { EventEmitter } = require("events");\n\nclass WebSocketServer extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.port = options.port || 8080;\n    this.protocols = options.protocols || [];\n  }\n\n  handleUpgrade(request, socket, head) {\n    const headers = request.headers;\n\n    // Validate WebSocket headers\n    if (!this.validateHeaders(headers)) {\n      socket.write("HTTP/1.1 400 Bad Request\\r\\n\\r\\n");\n      socket.destroy();\n      return;\n    }\n\n    // Generate accept key\n    const acceptKey = this.generateAcceptKey(headers["sec-websocket-key"]);\n\n    // Select protocol\n    const selectedProtocol = this.selectProtocol(\n      headers["sec-websocket-protocol"]\n    );\n\n    // Send handshake response\n    const responseHeaders = [\n      "HTTP/1.1 101 Switching Protocols",\n      "Upgrade: websocket",\n      "Connection: Upgrade",\n      `Sec-WebSocket-Accept: ${acceptKey}`,\n    ];\n\n    if (selectedProtocol) {\n      responseHeaders.push(`Sec-WebSocket-Protocol: ${selectedProtocol}`);\n    }\n\n    socket.write(responseHeaders.join("\\r\\n") + "\\r\\n\\r\\n");\n\n    // Create WebSocket connection\n    const websocket = new WebSocketConnection(socket);\n    this.emit("connection", websocket);\n  }\n\n  validateHeaders(headers) {\n    return (\n      headers.upgrade?.toLowerCase() === "websocket" &&\n      headers.connection?.toLowerCase().includes("upgrade") &&\n      headers["sec-websocket-key"] &&\n      headers["sec-websocket-version"] === "13"\n    );\n  }\n\n  generateAcceptKey(clientKey) {\n    const magicString = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";\n    const hash = crypto\n      .createHash("sha1")\n      .update(clientKey + magicString)\n      .digest("base64");\n    return hash;\n  }\n\n  selectProtocol(requestedProtocols) {\n    if (!requestedProtocols) return null;\n\n    const protocols = requestedProtocols.split(",").map((p) => p.trim());\n    return protocols.find((protocol) => this.protocols.includes(protocol));\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"frame-structure-and-message-types",children:"Frame Structure and Message Types"}),"\n",(0,i.jsx)(n.h3,{id:"websocket-frame-format",children:"WebSocket Frame Format"}),"\n",(0,i.jsx)(n.p,{children:"WebSocket communication uses a binary frame format that provides efficient message transmission with minimal overhead. Understanding this frame structure is essential for implementing custom WebSocket protocols or debugging connection issues."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Frame Structure Purpose:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Efficient Encoding"}),": Minimal overhead for small and large messages"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message Fragmentation"}),": Support for splitting large messages across multiple frames"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security Masking"}),": Client-to-server frames are masked to prevent cache poisoning"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Control Frames"}),": Built-in support for ping/pong and connection management"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Extensibility"}),": Reserved bits for future protocol extensions"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Frame Components:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"FIN bit"}),": Indicates if this is the final frame in a message"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"RSV bits"}),": Reserved for extensions (must be 0 if no extension negotiated)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Opcode"}),": Defines frame type (text, binary, close, ping, pong)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"MASK bit"}),": Indicates if payload is masked (required for client-to-server frames)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Payload Length"}),": Variable-length field supporting messages up to 64-bit size"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Masking Key"}),": 32-bit key for payload masking (if MASK bit is set)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Payload Data"}),": The actual message content"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:" 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-------+-+-------------+-------------------------------+\n|F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n|N|V|V|V|       |S|             |   (if payload len==126/127)   |\n| |1|2|3|       |K|             |                               |\n+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n|     Extended payload length continued, if payload len == 127  |\n+ - - - - - - - - - - - - - - - +-------------------------------+\n|                               |Masking-key, if MASK set to 1  |\n+-------------------------------+-------------------------------+\n| Masking-key (continued)       |          Payload Data         |\n+-------------------------------- - - - - - - - - - - - - - - - +\n:                     Payload Data continued ...                :\n+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n|                     Payload Data continued ...                |\n+---------------------------------------------------------------+\n"})}),"\n",(0,i.jsx)(n.h3,{id:"frame-processing-implementation",children:"Frame Processing Implementation"}),"\n",(0,i.jsx)(n.p,{children:"The following implementation demonstrates how to create, parse, and manipulate WebSocket frames according to RFC 6455 specifications. This low-level frame handling is typically abstracted by WebSocket libraries but is crucial for understanding the protocol internals."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"What this implementation provides:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Frame Creation"}),": Build different types of WebSocket frames (text, binary, control)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Payload Masking"}),": Implement client-side masking as required by the protocol"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Frame Serialization"}),": Convert frame objects to binary wire format"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Opcode Management"}),": Handle different frame types with appropriate opcodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security Compliance"}),": Ensure proper masking for client-to-server communication"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Frame Types and Opcodes:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0x0"}),": Continuation frame (for fragmented messages)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0x1"}),": Text frame (UTF-8 encoded text data)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0x2"}),": Binary frame (arbitrary binary data)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0x8"}),": Close frame (connection termination)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0x9"}),": Ping frame (connection keep-alive)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0xA"}),": Pong frame (response to ping)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input:"})," Message data and frame type parameters\n",(0,i.jsx)(n.strong,{children:"Output:"})," Properly formatted WebSocket frame ready for transmission"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class WebSocketFrame {\n  constructor() {\n    // Frame header flags\n    this.fin = false; // Final fragment flag\n    this.rsv1 = false; // Reserved bit 1 (extension use)\n    this.rsv2 = false; // Reserved bit 2 (extension use)\n    this.rsv3 = false; // Reserved bit 3 (extension use)\n    this.opcode = 0; // Frame type (4 bits)\n    this.masked = false; // Payload masking flag\n\n    // Payload information\n    this.payloadLength = 0; // Length of payload data\n    this.maskingKey = null; // 32-bit masking key (if masked)\n    this.payload = null; // Actual payload data\n  }\n\n  // WebSocket frame opcodes as defined in RFC 6455\n  static OPCODES = {\n    CONTINUATION: 0x0, // Continuation frame for fragmented messages\n    TEXT: 0x1, // Text data frame (UTF-8 encoded)\n    BINARY: 0x2, // Binary data frame\n    CLOSE: 0x8, // Connection close frame\n    PING: 0x9, // Ping frame for keep-alive\n    PONG: 0xa, // Pong frame (response to ping)\n  };\n\n  static createTextFrame(data, masked = true) {\n    // Create a new text frame with UTF-8 encoded data\n    const frame = new WebSocketFrame();\n    frame.fin = true; // Mark as final frame\n    frame.opcode = WebSocketFrame.OPCODES.TEXT; // Set text opcode\n    frame.masked = masked; // Apply masking if required\n    frame.payload = Buffer.from(data, "utf8"); // Encode text as UTF-8\n    frame.payloadLength = frame.payload.length; // Set payload length\n\n    // Apply masking for client-to-server frames (security requirement)\n    if (masked) {\n      frame.maskingKey = crypto.randomBytes(4); // Generate random 32-bit key\n      frame.payload = WebSocketFrame.maskPayload(\n        // Apply XOR masking\n        frame.payload,\n        frame.maskingKey\n      );\n    }\n\n    return frame;\n  }\n\n  static createBinaryFrame(data, masked = true) {\n    // Create a new binary frame for arbitrary data\n    const frame = new WebSocketFrame();\n    frame.fin = true; // Mark as final frame\n    frame.opcode = WebSocketFrame.OPCODES.BINARY; // Set binary opcode\n    frame.masked = masked; // Apply masking if required\n    frame.payload = Buffer.isBuffer(data) ? data : Buffer.from(data); // Ensure Buffer format\n    frame.payloadLength = frame.payload.length; // Set payload length\n\n    // Apply masking for client-to-server frames\n    if (masked) {\n      frame.maskingKey = crypto.randomBytes(4); // Generate random masking key\n      frame.payload = WebSocketFrame.maskPayload(\n        // Apply XOR masking\n        frame.payload,\n        frame.maskingKey\n      );\n    }\n\n    return frame;\n  }\n\n  static createPingFrame(data = Buffer.alloc(0)) {\n    // Create ping frame for connection keep-alive\n    const frame = new WebSocketFrame();\n    frame.fin = true; // Ping frames are always complete\n    frame.opcode = WebSocketFrame.OPCODES.PING; // Set ping opcode\n    frame.payload = data; // Optional ping payload\n    frame.payloadLength = data.length; // Set payload length\n    return frame;\n  }\n\n  static createPongFrame(data = Buffer.alloc(0)) {\n    // Create pong frame in response to ping\n    const frame = new WebSocketFrame();\n    frame.fin = true; // Pong frames are always complete\n    frame.opcode = WebSocketFrame.OPCODES.PONG; // Set pong opcode\n    frame.payload = data; // Echo ping payload\n    frame.payloadLength = data.length; // Set payload length\n    return frame;\n  }\n\n  static maskPayload(payload, maskingKey) {\n    // Apply XOR masking to payload data as required by RFC 6455\n    const masked = Buffer.alloc(payload.length); // Allocate buffer for masked data\n    for (let i = 0; i < payload.length; i++) {\n      masked[i] = payload[i] ^ maskingKey[i % 4]; // XOR with rotating masking key\n    }\n    return masked;\n  }\n\n  toBuffer() {\n    // Serialize the frame to binary format for transmission\n    let headerLength = 2; // Minimum header size (2 bytes)\n    let payloadLengthBytes = 0; // Additional bytes for extended length\n\n    // Determine payload length representation\n    if (this.payloadLength < 126) {\n      payloadLengthBytes = 0;\n    } else if (this.payloadLength < 65536) {\n      payloadLengthBytes = 2;\n      headerLength += 2;\n    } else {\n      payloadLengthBytes = 8;\n      headerLength += 8;\n    }\n\n    if (this.masked) {\n      headerLength += 4;\n    }\n\n    const buffer = Buffer.alloc(headerLength + this.payloadLength);\n    let offset = 0;\n\n    // First byte: FIN + RSV + Opcode\n    buffer[offset] =\n      (this.fin ? 0x80 : 0) |\n      (this.rsv1 ? 0x40 : 0) |\n      (this.rsv2 ? 0x20 : 0) |\n      (this.rsv3 ? 0x10 : 0) |\n      (this.opcode & 0x0f);\n    offset++;\n\n    // Second byte: MASK + Payload length\n    if (this.payloadLength < 126) {\n      buffer[offset] = (this.masked ? 0x80 : 0) | this.payloadLength;\n    } else if (this.payloadLength < 65536) {\n      buffer[offset] = (this.masked ? 0x80 : 0) | 126;\n      offset++;\n      buffer.writeUInt16BE(this.payloadLength, offset);\n      offset += 2;\n    } else {\n      buffer[offset] = (this.masked ? 0x80 : 0) | 127;\n      offset++;\n      buffer.writeUInt32BE(0, offset); // High 32 bits\n      buffer.writeUInt32BE(this.payloadLength, offset + 4); // Low 32 bits\n      offset += 8;\n    }\n    offset++;\n\n    // Masking key\n    if (this.masked && this.maskingKey) {\n      this.maskingKey.copy(buffer, offset);\n      offset += 4;\n    }\n\n    // Payload\n    if (this.payload) {\n      this.payload.copy(buffer, offset);\n    }\n\n    return buffer;\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"connection-management-and-lifecycle",children:"Connection Management and Lifecycle"}),"\n",(0,i.jsx)(n.h3,{id:"keep-alive-and-heartbeat",children:"Keep-Alive and Heartbeat"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class WebSocketKeepAlive {\n  constructor(socket, options = {}) {\n    this.socket = socket;\n    this.pingInterval = options.pingInterval || 30000;\n    this.pongTimeout = options.pongTimeout || 5000;\n    this.maxMissedPongs = options.maxMissedPongs || 3;\n    this.missedPongs = 0;\n    this.isAlive = true;\n  }\n\n  start() {\n    this.heartbeatTimer = setInterval(() => {\n      if (!this.isAlive) {\n        this.missedPongs++;\n\n        if (this.missedPongs >= this.maxMissedPongs) {\n          console.log("Connection appears dead, closing");\n          this.socket.terminate();\n          return;\n        }\n      }\n\n      this.isAlive = false;\n      this.socket.ping();\n\n      // Set timeout for pong response\n      this.pongTimer = setTimeout(() => {\n        console.log("Pong timeout");\n        this.isAlive = false;\n      }, this.pongTimeout);\n    }, this.pingInterval);\n\n    this.socket.on("pong", () => {\n      this.isAlive = true;\n      this.missedPongs = 0;\n      if (this.pongTimer) {\n        clearTimeout(this.pongTimer);\n      }\n    });\n  }\n\n  stop() {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n    }\n    if (this.pongTimer) {\n      clearTimeout(this.pongTimer);\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"connection-pool-management",children:"Connection Pool Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class WebSocketPool {\n  constructor(options = {}) {\n    this.connections = new Map();\n    this.groups = new Map();\n    this.maxConnections = options.maxConnections || 1000;\n    this.cleanupInterval = options.cleanupInterval || 60000;\n    this.startCleanup();\n  }\n\n  addConnection(id, socket, metadata = {}) {\n    if (this.connections.size >= this.maxConnections) {\n      throw new Error("Maximum connections reached");\n    }\n\n    const connection = {\n      id,\n      socket,\n      metadata,\n      connectedAt: Date.now(),\n      lastActivity: Date.now(),\n    };\n\n    this.connections.set(id, connection);\n    this.setupConnectionHandlers(connection);\n\n    console.log(`Connection added: ${id} (Total: ${this.connections.size})`);\n    return connection;\n  }\n\n  removeConnection(id) {\n    const connection = this.connections.get(id);\n    if (connection) {\n      connection.socket.terminate();\n      this.connections.delete(id);\n      this.removeFromAllGroups(id);\n      console.log(\n        `Connection removed: ${id} (Total: ${this.connections.size})`\n      );\n    }\n  }\n\n  setupConnectionHandlers(connection) {\n    connection.socket.on("message", (data) => {\n      connection.lastActivity = Date.now();\n    });\n\n    connection.socket.on("close", () => {\n      this.removeConnection(connection.id);\n    });\n\n    connection.socket.on("error", (error) => {\n      console.error(`Connection error for ${connection.id}:`, error);\n      this.removeConnection(connection.id);\n    });\n  }\n\n  broadcast(message, excludeId = null) {\n    const data =\n      typeof message === "string" ? message : JSON.stringify(message);\n    let sent = 0;\n\n    this.connections.forEach((connection) => {\n      if (connection.id !== excludeId && connection.socket.readyState === 1) {\n        connection.socket.send(data);\n        sent++;\n      }\n    });\n\n    return sent;\n  }\n\n  broadcastToGroup(groupId, message, excludeId = null) {\n    const group = this.groups.get(groupId);\n    if (!group) return 0;\n\n    const data =\n      typeof message === "string" ? message : JSON.stringify(message);\n    let sent = 0;\n\n    group.forEach((connectionId) => {\n      if (connectionId !== excludeId) {\n        const connection = this.connections.get(connectionId);\n        if (connection && connection.socket.readyState === 1) {\n          connection.socket.send(data);\n          sent++;\n        }\n      }\n    });\n\n    return sent;\n  }\n\n  addToGroup(groupId, connectionId) {\n    if (!this.groups.has(groupId)) {\n      this.groups.set(groupId, new Set());\n    }\n    this.groups.get(groupId).add(connectionId);\n  }\n\n  removeFromGroup(groupId, connectionId) {\n    const group = this.groups.get(groupId);\n    if (group) {\n      group.delete(connectionId);\n      if (group.size === 0) {\n        this.groups.delete(groupId);\n      }\n    }\n  }\n\n  removeFromAllGroups(connectionId) {\n    this.groups.forEach((group, groupId) => {\n      group.delete(connectionId);\n      if (group.size === 0) {\n        this.groups.delete(groupId);\n      }\n    });\n  }\n\n  startCleanup() {\n    this.cleanupTimer = setInterval(() => {\n      const now = Date.now();\n      const staleConnections = [];\n\n      this.connections.forEach((connection) => {\n        // Remove connections inactive for more than 10 minutes\n        if (now - connection.lastActivity > 600000) {\n          staleConnections.push(connection.id);\n        }\n      });\n\n      staleConnections.forEach((id) => this.removeConnection(id));\n\n      if (staleConnections.length > 0) {\n        console.log(`Cleaned up ${staleConnections.length} stale connections`);\n      }\n    }, this.cleanupInterval);\n  }\n\n  getStats() {\n    const now = Date.now();\n    let activeConnections = 0;\n    let totalGroups = this.groups.size;\n\n    this.connections.forEach((connection) => {\n      if (connection.socket.readyState === 1) {\n        activeConnections++;\n      }\n    });\n\n    return {\n      totalConnections: this.connections.size,\n      activeConnections,\n      totalGroups,\n      uptime: now - this.startTime,\n    };\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"server-side-implementation",children:"Server-Side Implementation"}),"\n",(0,i.jsx)(n.h3,{id:"nodejs-websocket-server",children:"Node.js WebSocket Server"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'const WebSocket = require("ws");\nconst http = require("http");\nconst crypto = require("crypto");\n\nclass CustomWebSocketServer {\n  constructor(options = {}) {\n    this.port = options.port || 8080;\n    this.server = http.createServer();\n    this.wss = new WebSocket.Server({ server: this.server });\n    this.connectionPool = new WebSocketPool();\n    this.messageHandlers = new Map();\n    this.middleware = [];\n\n    this.setupRoutes();\n    this.setupWebSocketHandlers();\n  }\n\n  setupRoutes() {\n    this.server.on("request", (req, res) => {\n      if (req.url === "/health") {\n        res.writeHead(200, { "Content-Type": "application/json" });\n        res.end(JSON.stringify(this.connectionPool.getStats()));\n      } else {\n        res.writeHead(404);\n        res.end("Not Found");\n      }\n    });\n  }\n\n  setupWebSocketHandlers() {\n    this.wss.on("connection", (ws, req) => {\n      const connectionId = this.generateConnectionId();\n      const connection = this.connectionPool.addConnection(connectionId, ws, {\n        userAgent: req.headers["user-agent"],\n        ip: req.connection.remoteAddress,\n      });\n\n      // Setup keep-alive\n      const keepAlive = new WebSocketKeepAlive(ws);\n      keepAlive.start();\n\n      ws.on("message", async (data) => {\n        try {\n          await this.processMessage(connection, data);\n        } catch (error) {\n          console.error("Error processing message:", error);\n          this.sendError(ws, "Message processing failed");\n        }\n      });\n\n      ws.on("close", () => {\n        keepAlive.stop();\n        console.log(`Client disconnected: ${connectionId}`);\n      });\n\n      // Send welcome message\n      this.send(ws, {\n        type: "connection",\n        id: connectionId,\n        message: "Connected successfully",\n      });\n    });\n  }\n\n  async processMessage(connection, rawData) {\n    // Apply middleware\n    for (const middleware of this.middleware) {\n      const result = await middleware(connection, rawData);\n      if (result === false) return; // Middleware rejected the message\n    }\n\n    let message;\n    try {\n      message = JSON.parse(rawData.toString());\n    } catch (error) {\n      this.sendError(connection.socket, "Invalid JSON");\n      return;\n    }\n\n    const handler = this.messageHandlers.get(message.type);\n    if (handler) {\n      await handler(connection, message);\n    } else {\n      this.sendError(\n        connection.socket,\n        `Unknown message type: ${message.type}`\n      );\n    }\n  }\n\n  addMessageHandler(type, handler) {\n    this.messageHandlers.set(type, handler);\n  }\n\n  addMiddleware(middleware) {\n    this.middleware.push(middleware);\n  }\n\n  send(ws, data) {\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify(data));\n    }\n  }\n\n  sendError(ws, message) {\n    this.send(ws, { type: "error", message });\n  }\n\n  broadcast(message, excludeId = null) {\n    return this.connectionPool.broadcast(message, excludeId);\n  }\n\n  generateConnectionId() {\n    return crypto.randomBytes(16).toString("hex");\n  }\n\n  start() {\n    this.server.listen(this.port, () => {\n      console.log(`WebSocket server listening on port ${this.port}`);\n    });\n  }\n}\n\n// Usage example\nconst server = new CustomWebSocketServer({ port: 8080 });\n\n// Add authentication middleware\nserver.addMiddleware(async (connection, data) => {\n  // Check authentication token\n  const message = JSON.parse(data.toString());\n  if (message.type !== "auth" && !connection.authenticated) {\n    server.sendError(connection.socket, "Authentication required");\n    return false;\n  }\n  return true;\n});\n\n// Add message handlers\nserver.addMessageHandler("auth", async (connection, message) => {\n  // Validate token\n  if (message.token === "valid-token") {\n    connection.authenticated = true;\n    server.send(connection.socket, { type: "auth", status: "success" });\n  } else {\n    server.sendError(connection.socket, "Invalid token");\n    connection.socket.close();\n  }\n});\n\nserver.addMessageHandler("chat", async (connection, message) => {\n  if (!connection.authenticated) return;\n\n  const chatMessage = {\n    type: "chat",\n    id: crypto.randomUUID(),\n    user: connection.metadata.userId,\n    message: message.content,\n    timestamp: Date.now(),\n  };\n\n  server.broadcast(chatMessage, connection.id);\n});\n\nserver.start();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"real-time-communication-patterns",children:"Real-Time Communication Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"request-response-pattern",children:"Request-Response Pattern"}),"\n",(0,i.jsx)(n.p,{children:"WebSocket connections are bidirectional, but sometimes you need request-response semantics similar to HTTP. This pattern implements RPC (Remote Procedure Call) functionality over WebSocket connections, enabling asynchronous method calls with promise-based responses."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"RPC Pattern Benefits:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Asynchronous Operations"}),": Non-blocking remote method calls"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Promise-Based API"}),": Modern async/await compatibility"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Request Tracking"}),": Automatic correlation of requests and responses"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Timeout Handling"}),": Prevents hanging requests with configurable timeouts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Propagation"}),": Proper error handling across the connection"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Client sends request with unique ID and method name"}),"\n",(0,i.jsx)(n.li,{children:"Server processes request and sends response with matching ID"}),"\n",(0,i.jsx)(n.li,{children:"Client correlates response with pending request using ID"}),"\n",(0,i.jsx)(n.li,{children:"Promise resolves with result or rejects with error"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input:"})," Method name, parameters, optional timeout\n",(0,i.jsx)(n.strong,{children:"Output:"})," Promise resolving to method result or rejecting with error"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class WebSocketRPC {\n  constructor(socket) {\n    this.socket = socket; // WebSocket connection instance\n    this.pendingRequests = new Map(); // Track ongoing requests by ID\n    this.requestId = 0; // Counter for unique request IDs\n    this.setupMessageHandler(); // Initialize response handling\n  }\n\n  setupMessageHandler() {\n    this.socket.addEventListener("message", (event) => {\n      const data = JSON.parse(event.data);\n\n      if (data.id && this.pendingRequests.has(data.id)) {\n        const { resolve, reject } = this.pendingRequests.get(data.id);\n        this.pendingRequests.delete(data.id);\n\n        if (data.error) {\n          reject(new Error(data.error));\n        } else {\n          resolve(data.result);\n        }\n      }\n    });\n  }\n\n  async call(method, params = {}, timeout = 5000) {\n    return new Promise((resolve, reject) => {\n      const id = ++this.requestId;\n\n      const timer = setTimeout(() => {\n        this.pendingRequests.delete(id);\n        reject(new Error("Request timeout"));\n      }, timeout);\n\n      this.pendingRequests.set(id, {\n        resolve: (result) => {\n          clearTimeout(timer);\n          resolve(result);\n        },\n        reject: (error) => {\n          clearTimeout(timer);\n          reject(error);\n        },\n      });\n\n      this.socket.send(\n        JSON.stringify({\n          id,\n          method,\n          params,\n        })\n      );\n    });\n  }\n}\n\n// Usage\nconst rpc = new WebSocketRPC(socket);\n\ntry {\n  const result = await rpc.call("getUserProfile", { userId: 123 });\n  console.log("User profile:", result);\n} catch (error) {\n  console.error("RPC error:", error);\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"pubsub-pattern",children:"Pub/Sub Pattern"}),"\n",(0,i.jsx)(n.p,{children:"The Publish/Subscribe pattern enables event-driven communication where clients can subscribe to specific channels and receive real-time updates. This pattern is ideal for implementing features like live notifications, chat rooms, or real-time data feeds."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Pub/Sub Pattern Benefits:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Decoupled Communication"}),": Publishers and subscribers don't need direct knowledge of each other"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scalable Broadcasting"}),": One message can reach multiple subscribers efficiently"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Channel-Based Filtering"}),": Clients only receive messages from subscribed channels"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Subscriptions"}),": Subscribe and unsubscribe from channels at runtime"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Event-Driven Architecture"}),": Reactive programming model for real-time applications"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Client subscribes to one or more channels"}),"\n",(0,i.jsx)(n.li,{children:"Server maintains subscription mappings for each client"}),"\n",(0,i.jsx)(n.li,{children:"When events occur, server publishes to relevant channels"}),"\n",(0,i.jsx)(n.li,{children:"All subscribers to a channel receive the published message"}),"\n",(0,i.jsx)(n.li,{children:"Clients can unsubscribe to stop receiving updates"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Live chat applications with multiple rooms"}),"\n",(0,i.jsx)(n.li,{children:"Real-time notifications and alerts"}),"\n",(0,i.jsx)(n.li,{children:"Live data feeds (stock prices, sports scores)"}),"\n",(0,i.jsx)(n.li,{children:"Collaborative editing with multi-user updates"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input:"})," Channel name and subscription callback\n",(0,i.jsx)(n.strong,{children:"Output:"})," Real-time messages from subscribed channels"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class WebSocketPubSub {\n  constructor(socket) {\n    this.socket = socket; // WebSocket connection instance\n    this.subscriptions = new Map(); // Channel subscriptions registry\n    this.setupMessageHandler(); // Initialize message routing\n  }\n\n  setupMessageHandler() {\n    this.socket.addEventListener("message", (event) => {\n      const data = JSON.parse(event.data);\n\n      if (data.type === "publish") {\n        const callbacks = this.subscriptions.get(data.channel);\n        if (callbacks) {\n          callbacks.forEach((callback) => {\n            try {\n              callback(data.payload);\n            } catch (error) {\n              console.error("Subscription callback error:", error);\n            }\n          });\n        }\n      }\n    });\n  }\n\n  subscribe(channel, callback) {\n    if (!this.subscriptions.has(channel)) {\n      this.subscriptions.set(channel, new Set());\n\n      // Send subscription request to server\n      this.socket.send(\n        JSON.stringify({\n          type: "subscribe",\n          channel,\n        })\n      );\n    }\n\n    this.subscriptions.get(channel).add(callback);\n\n    // Return unsubscribe function\n    return () => {\n      const callbacks = this.subscriptions.get(channel);\n      if (callbacks) {\n        callbacks.delete(callback);\n\n        if (callbacks.size === 0) {\n          this.subscriptions.delete(channel);\n\n          // Send unsubscription request to server\n          this.socket.send(\n            JSON.stringify({\n              type: "unsubscribe",\n              channel,\n            })\n          );\n        }\n      }\n    };\n  }\n\n  publish(channel, payload) {\n    this.socket.send(\n      JSON.stringify({\n        type: "publish",\n        channel,\n        payload,\n      })\n    );\n  }\n}\n\n// Usage\nconst pubsub = new WebSocketPubSub(socket);\n\n// Subscribe to user events\nconst unsubscribe = pubsub.subscribe("user.events", (data) => {\n  console.log("User event:", data);\n});\n\n// Publish a message\npubsub.publish("user.events", {\n  action: "login",\n  userId: 123,\n  timestamp: Date.now(),\n});\n\n// Unsubscribe later\nunsubscribe();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"secure-websocket-implementation",children:"Secure WebSocket Implementation"}),"\n",(0,i.jsx)(n.p,{children:"WebSocket security requires careful consideration of authentication, authorization, and protection against various attack vectors. This implementation demonstrates comprehensive security measures for production WebSocket applications."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Security Measures Implemented:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Secure Transport"}),": Always use WSS (WebSocket Secure) for encrypted connections"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authentication"}),": Token-based authentication with proper validation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CSRF Protection"}),": Cross-Site Request Forgery tokens for additional security"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message Validation"}),": Strict validation of incoming message structure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Token Refresh"}),": Automatic handling of authentication token renewal"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Input Sanitization"}),": Prevention of malicious message content"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Security Threats Addressed:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Man-in-the-Middle Attacks"}),": WSS encryption prevents eavesdropping"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cross-Site WebSocket Hijacking"}),": Origin validation and CSRF tokens"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authentication Bypass"}),": Proper token validation and refresh"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message Injection"}),": Strict message structure validation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Denial of Service"}),": Rate limiting and connection management"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Authentication Flow:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Client authenticates with credentials to obtain tokens"}),"\n",(0,i.jsx)(n.li,{children:"WebSocket connection includes authentication headers"}),"\n",(0,i.jsx)(n.li,{children:"Server validates tokens before accepting connection"}),"\n",(0,i.jsx)(n.li,{children:"Ongoing token refresh maintains session security"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input:"})," User credentials and security configuration\n",(0,i.jsx)(n.strong,{children:"Output:"})," Secure WebSocket connection with validated authentication"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class SecureWebSocketClient {\n  constructor(url, options = {}) {\n    this.url = url; // WebSocket server URL\n    this.options = options; // Security configuration options\n    this.authToken = null; // JWT or similar authentication token\n    this.csrfToken = null; // Cross-Site Request Forgery token\n  }\n\n  async connect(credentials) {\n    // Use WSS for secure connections\n    const secureUrl = this.url.replace("ws://", "wss://");\n\n    // Get authentication token\n    this.authToken = await this.authenticate(credentials);\n    this.csrfToken = await this.getCSRFToken();\n\n    const socket = new WebSocket(secureUrl, [], {\n      headers: {\n        Authorization: `Bearer ${this.authToken}`,\n        "X-CSRF-Token": this.csrfToken,\n      },\n    });\n\n    return new Promise((resolve, reject) => {\n      socket.onopen = () => {\n        this.socket = socket;\n        this.setupSecurityHandlers();\n        resolve(socket);\n      };\n\n      socket.onerror = reject;\n    });\n  }\n\n  setupSecurityHandlers() {\n    this.socket.addEventListener("message", (event) => {\n      try {\n        const data = JSON.parse(event.data);\n\n        // Validate message structure\n        if (!this.validateMessage(data)) {\n          console.warn("Invalid message structure received");\n          return;\n        }\n\n        // Check for token refresh\n        if (data.type === "token_refresh") {\n          this.authToken = data.token;\n        }\n\n        this.handleMessage(data);\n      } catch (error) {\n        console.error("Message processing error:", error);\n      }\n    });\n  }\n\n  validateMessage(data) {\n    // Implement message validation logic\n    return (\n      typeof data === "object" &&\n      data !== null &&\n      typeof data.type === "string" &&\n      data.type.length > 0\n    );\n  }\n\n  sendSecureMessage(data) {\n    const message = {\n      ...data,\n      timestamp: Date.now(),\n      nonce: crypto.randomUUID(),\n      auth: this.authToken,\n    };\n\n    this.socket.send(JSON.stringify(message));\n  }\n\n  async authenticate(credentials) {\n    const response = await fetch("/api/auth", {\n      method: "POST",\n      headers: { "Content-Type": "application/json" },\n      body: JSON.stringify(credentials),\n    });\n\n    const data = await response.json();\n    return data.token;\n  }\n\n  async getCSRFToken() {\n    const response = await fetch("/api/csrf-token");\n    const data = await response.json();\n    return data.token;\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"rate-limiting-and-ddos-protection",children:"Rate Limiting and DDoS Protection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class WebSocketRateLimiter {\n  constructor(options = {}) {\n    this.windowMs = options.windowMs || 60000; // 1 minute\n    this.maxRequests = options.maxRequests || 100;\n    this.clients = new Map();\n    this.cleanupInterval = setInterval(() => this.cleanup(), this.windowMs);\n  }\n\n  checkLimit(clientId) {\n    const now = Date.now();\n    const client = this.clients.get(clientId) || {\n      requests: [],\n      blocked: false,\n    };\n\n    // Remove old requests outside the window\n    client.requests = client.requests.filter(\n      (timestamp) => now - timestamp < this.windowMs\n    );\n\n    // Check if client is blocked\n    if (client.blocked && client.blockExpiry > now) {\n      return false;\n    }\n\n    // Check rate limit\n    if (client.requests.length >= this.maxRequests) {\n      client.blocked = true;\n      client.blockExpiry = now + this.windowMs;\n      this.clients.set(clientId, client);\n      return false;\n    }\n\n    // Add current request\n    client.requests.push(now);\n    client.blocked = false;\n    this.clients.set(clientId, client);\n\n    return true;\n  }\n\n  cleanup() {\n    const now = Date.now();\n    for (const [clientId, client] of this.clients.entries()) {\n      // Remove expired blocks and old request records\n      if (client.blocked && client.blockExpiry <= now) {\n        client.blocked = false;\n        client.requests = [];\n      }\n\n      // Remove clients with no recent activity\n      if (client.requests.length === 0 && !client.blocked) {\n        this.clients.delete(clientId);\n      }\n    }\n  }\n\n  destroy() {\n    clearInterval(this.cleanupInterval);\n  }\n}\n\n// Server integration\nconst rateLimiter = new WebSocketRateLimiter({\n  windowMs: 60000, // 1 minute\n  maxRequests: 50, // 50 requests per minute\n});\n\nserver.addMiddleware(async (connection, data) => {\n  const clientId = connection.metadata.ip;\n\n  if (!rateLimiter.checkLimit(clientId)) {\n    server.sendError(connection.socket, "Rate limit exceeded");\n    return false;\n  }\n\n  return true;\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(n.h3,{id:"connection-pooling-and-load-balancing",children:"Connection Pooling and Load Balancing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class WebSocketLoadBalancer {\n  constructor(servers) {\n    this.servers = servers.map((server, index) => ({\n      ...server,\n      id: index,\n      connections: 0,\n      healthy: true,\n    }));\n    this.currentIndex = 0;\n    this.healthCheckInterval = setInterval(() => this.healthCheck(), 30000);\n  }\n\n  getServer() {\n    // Round-robin with health check\n    const healthyServers = this.servers.filter((server) => server.healthy);\n\n    if (healthyServers.length === 0) {\n      throw new Error("No healthy servers available");\n    }\n\n    const server = healthyServers[this.currentIndex % healthyServers.length];\n    this.currentIndex = (this.currentIndex + 1) % healthyServers.length;\n\n    return server;\n  }\n\n  async healthCheck() {\n    for (const server of this.servers) {\n      try {\n        const response = await fetch(\n          `http://${server.host}:${server.port}/health`\n        );\n        server.healthy = response.ok;\n      } catch (error) {\n        server.healthy = false;\n      }\n    }\n  }\n\n  connect(url) {\n    const server = this.getServer();\n    const serverUrl = `ws://${server.host}:${server.port}${url}`;\n\n    const socket = new WebSocket(serverUrl);\n\n    socket.addEventListener("open", () => {\n      server.connections++;\n    });\n\n    socket.addEventListener("close", () => {\n      server.connections--;\n    });\n\n    return socket;\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"message-compression-and-batching",children:"Message Compression and Batching"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class WebSocketOptimizer {\n  constructor(socket, options = {}) {\n    this.socket = socket;\n    this.batchSize = options.batchSize || 10;\n    this.batchTimeout = options.batchTimeout || 100;\n    this.compressionThreshold = options.compressionThreshold || 1024;\n    this.messageQueue = [];\n    this.batchTimer = null;\n  }\n\n  send(data) {\n    this.messageQueue.push({\n      data,\n      timestamp: Date.now(),\n    });\n\n    if (this.messageQueue.length >= this.batchSize) {\n      this.flush();\n    } else if (!this.batchTimer) {\n      this.batchTimer = setTimeout(() => this.flush(), this.batchTimeout);\n    }\n  }\n\n  flush() {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = null;\n    }\n\n    if (this.messageQueue.length === 0) return;\n\n    const messages = this.messageQueue.splice(0);\n\n    if (messages.length === 1) {\n      this.sendSingle(messages[0].data);\n    } else {\n      this.sendBatch(messages.map((m) => m.data));\n    }\n  }\n\n  sendSingle(data) {\n    const serialized = JSON.stringify(data);\n\n    if (serialized.length > this.compressionThreshold) {\n      this.sendCompressed(serialized);\n    } else {\n      this.socket.send(serialized);\n    }\n  }\n\n  sendBatch(messages) {\n    const batchMessage = {\n      type: "batch",\n      messages,\n      count: messages.length,\n    };\n\n    this.sendSingle(batchMessage);\n  }\n\n  async sendCompressed(data) {\n    try {\n      // Use compression (browser CompressionStream API)\n      const stream = new CompressionStream("gzip");\n      const writer = stream.writable.getWriter();\n      const reader = stream.readable.getReader();\n\n      writer.write(new TextEncoder().encode(data));\n      writer.close();\n\n      const chunks = [];\n      let done = false;\n\n      while (!done) {\n        const { value, done: readerDone } = await reader.read();\n        done = readerDone;\n        if (value) chunks.push(value);\n      }\n\n      const compressed = new Uint8Array(\n        chunks.reduce((acc, chunk) => acc + chunk.length, 0)\n      );\n\n      let offset = 0;\n      for (const chunk of chunks) {\n        compressed.set(chunk, offset);\n        offset += chunk.length;\n      }\n\n      this.socket.send(compressed);\n    } catch (error) {\n      console.warn("Compression failed, sending uncompressed:", error);\n      this.socket.send(data);\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"real-world-implementation-examples",children:"Real-World Implementation Examples"}),"\n",(0,i.jsx)(n.h3,{id:"real-time-chat-application",children:"Real-Time Chat Application"}),"\n",(0,i.jsx)(n.p,{children:"This comprehensive chat application demonstrates practical WebSocket usage with advanced features like typing indicators, user presence, and room management. The implementation showcases real-world patterns and best practices for building production-ready chat systems."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Chat Application Features:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-Room Support"}),": Users can join different chat rooms"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Real-Time Messaging"}),": Instant message delivery and display"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"User Presence"}),": Track online users in each room"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Typing Indicators"}),": Show when users are typing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message History"}),": Maintain local message cache"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Connection Management"}),": Robust connection handling with reconnection"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Application Architecture:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Client-Side"}),": Manages UI, local state, and WebSocket communication"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message Types"}),": Structured message protocol for different actions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Event Handling"}),": Comprehensive event system for all chat features"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State Management"}),": Track users, messages, and room information"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Message Protocol:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"join"}),": User joins a chat room"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"message"}),": Text message in a room"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"typing"}),"/",(0,i.jsx)(n.code,{children:"stopTyping"}),": Typing indicator status"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"userJoined"}),"/",(0,i.jsx)(n.code,{children:"userLeft"}),": User presence updates"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Input:"})," Username, room name, and message content\n",(0,i.jsx)(n.strong,{children:"Output:"})," Real-time chat interface with live updates"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class ChatApplication {\n  constructor() {\n    this.socket = null; // WebSocket connection instance\n    this.messages = []; // Local message history cache\n    this.users = new Map(); // Active users in current room\n    this.currentRoom = null; // Currently active chat room\n    this.typing = new Set(); // Users currently typing\n  }\n\n  async connect(username, room) {\n    const socket = new WebSocketClient("ws://localhost:8080/chat");\n\n    socket.on("open", () => {\n      socket.send({\n        type: "join",\n        username,\n        room,\n      });\n    });\n\n    socket.on("message", (data) => {\n      this.handleMessage(data);\n    });\n\n    this.socket = socket;\n    await socket.connect();\n    this.currentRoom = room;\n  }\n\n  handleMessage(data) {\n    switch (data.type) {\n      case "message":\n        this.addMessage(data);\n        break;\n      case "userJoined":\n        this.addUser(data.user);\n        break;\n      case "userLeft":\n        this.removeUser(data.user);\n        break;\n      case "typing":\n        this.handleTyping(data);\n        break;\n      case "stopTyping":\n        this.handleStopTyping(data);\n        break;\n    }\n  }\n\n  sendMessage(content) {\n    const message = {\n      type: "message",\n      content,\n      room: this.currentRoom,\n      timestamp: Date.now(),\n    };\n\n    this.socket.send(message);\n  }\n\n  startTyping() {\n    this.socket.send({\n      type: "typing",\n      room: this.currentRoom,\n    });\n  }\n\n  stopTyping() {\n    this.socket.send({\n      type: "stopTyping",\n      room: this.currentRoom,\n    });\n  }\n\n  addMessage(message) {\n    this.messages.push(message);\n    this.renderMessage(message);\n  }\n\n  addUser(user) {\n    this.users.set(user.id, user);\n    this.updateUserList();\n  }\n\n  removeUser(user) {\n    this.users.delete(user.id);\n    this.updateUserList();\n  }\n\n  handleTyping(data) {\n    this.typing.add(data.user);\n    this.updateTypingIndicator();\n  }\n\n  handleStopTyping(data) {\n    this.typing.delete(data.user);\n    this.updateTypingIndicator();\n  }\n\n  renderMessage(message) {\n    const messagesContainer = document.getElementById("messages");\n    const messageElement = document.createElement("div");\n    messageElement.className = "message";\n    messageElement.innerHTML = `\n      <span class="username">${message.username}:</span>\n      <span class="content">${message.content}</span>\n      <span class="timestamp">${new Date(\n        message.timestamp\n      ).toLocaleTimeString()}</span>\n    `;\n    messagesContainer.appendChild(messageElement);\n    messagesContainer.scrollTop = messagesContainer.scrollHeight;\n  }\n\n  updateUserList() {\n    const userList = document.getElementById("userList");\n    userList.innerHTML = "";\n\n    this.users.forEach((user) => {\n      const userElement = document.createElement("div");\n      userElement.className = "user";\n      userElement.textContent = user.username;\n      userList.appendChild(userElement);\n    });\n  }\n\n  updateTypingIndicator() {\n    const indicator = document.getElementById("typingIndicator");\n\n    if (this.typing.size > 0) {\n      const users = Array.from(this.typing).join(", ");\n      indicator.textContent = `${users} ${\n        this.typing.size === 1 ? "is" : "are"\n      } typing...`;\n      indicator.style.display = "block";\n    } else {\n      indicator.style.display = "none";\n    }\n  }\n}\n\n// Initialize chat application\nconst chat = new ChatApplication();\n\ndocument.getElementById("joinButton").addEventListener("click", async () => {\n  const username = document.getElementById("username").value;\n  const room = document.getElementById("room").value;\n\n  if (username && room) {\n    await chat.connect(username, room);\n    document.getElementById("loginForm").style.display = "none";\n    document.getElementById("chatContainer").style.display = "block";\n  }\n});\n\ndocument.getElementById("messageInput").addEventListener("keypress", (e) => {\n  if (e.key === "Enter") {\n    const content = e.target.value.trim();\n    if (content) {\n      chat.sendMessage(content);\n      e.target.value = "";\n    }\n  }\n});\n\n// Typing indicators\nlet typingTimer;\ndocument.getElementById("messageInput").addEventListener("input", () => {\n  chat.startTyping();\n\n  clearTimeout(typingTimer);\n  typingTimer = setTimeout(() => {\n    chat.stopTyping();\n  }, 1000);\n});\n'})}),"\n",(0,i.jsx)(n.h2,{id:"error-handling-and-debugging",children:"Error Handling and Debugging"}),"\n",(0,i.jsx)(n.h3,{id:"comprehensive-error-handling",children:"Comprehensive Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class WebSocketErrorHandler {\n  constructor(socket) {\n    this.socket = socket;\n    this.errorCounts = new Map();\n    this.setupErrorHandlers();\n  }\n\n  setupErrorHandlers() {\n    this.socket.addEventListener("error", (event) => {\n      this.handleError("connection", event);\n    });\n\n    this.socket.addEventListener("close", (event) => {\n      if (!event.wasClean) {\n        this.handleError("close", event);\n      }\n    });\n\n    // Catch message parsing errors\n    const originalOnMessage = this.socket.onmessage;\n    this.socket.onmessage = (event) => {\n      try {\n        if (originalOnMessage) {\n          originalOnMessage.call(this.socket, event);\n        }\n      } catch (error) {\n        this.handleError("message", error, event.data);\n      }\n    };\n  }\n\n  handleError(type, error, context = null) {\n    const errorInfo = {\n      type,\n      error: error.message || error.toString(),\n      timestamp: Date.now(),\n      context,\n      stack: error.stack,\n    };\n\n    // Track error frequency\n    const key = `${type}:${error.message}`;\n    this.errorCounts.set(key, (this.errorCounts.get(key) || 0) + 1);\n\n    // Log error\n    console.error("WebSocket error:", errorInfo);\n\n    // Report to error tracking service\n    this.reportError(errorInfo);\n\n    // Handle specific error types\n    switch (type) {\n      case "connection":\n        this.handleConnectionError(error);\n        break;\n      case "close":\n        this.handleCloseError(error);\n        break;\n      case "message":\n        this.handleMessageError(error, context);\n        break;\n    }\n  }\n\n  handleConnectionError(error) {\n    // Implement connection error recovery\n    console.log("Attempting to recover from connection error");\n  }\n\n  handleCloseError(event) {\n    const closeReasons = {\n      1000: "Normal closure",\n      1001: "Going away",\n      1002: "Protocol error",\n      1003: "Unsupported data",\n      1004: "Reserved",\n      1005: "No status received",\n      1006: "Abnormal closure",\n      1007: "Invalid frame payload data",\n      1008: "Policy violation",\n      1009: "Message too big",\n      1010: "Missing extension",\n      1011: "Internal error",\n      1015: "TLS handshake failure",\n    };\n\n    const reason = closeReasons[event.code] || "Unknown reason";\n    console.log(`Connection closed: ${event.code} - ${reason}`);\n  }\n\n  handleMessageError(error, data) {\n    console.error("Failed to process message:", data, error);\n  }\n\n  reportError(errorInfo) {\n    // Send to error tracking service\n    if (window.errorTracker) {\n      window.errorTracker.captureException(errorInfo);\n    }\n  }\n\n  getErrorStats() {\n    return Object.fromEntries(this.errorCounts);\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"websocket-debugging-tools",children:"WebSocket Debugging Tools"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class WebSocketDebugger {\n  constructor(socket) {\n    this.socket = socket;\n    this.logs = [];\n    this.stats = {\n      messagesSent: 0,\n      messagesReceived: 0,\n      bytesSent: 0,\n      bytesReceived: 0,\n      connectTime: null,\n      lastActivity: null,\n    };\n\n    this.setupLogging();\n  }\n\n  setupLogging() {\n    const originalSend = this.socket.send.bind(this.socket);\n    this.socket.send = (data) => {\n      this.logMessage("sent", data);\n      this.stats.messagesSent++;\n      this.stats.bytesSent += this.getDataSize(data);\n      this.stats.lastActivity = Date.now();\n      return originalSend(data);\n    };\n\n    this.socket.addEventListener("open", (event) => {\n      this.stats.connectTime = Date.now();\n      this.logEvent("connected", event);\n    });\n\n    this.socket.addEventListener("message", (event) => {\n      this.logMessage("received", event.data);\n      this.stats.messagesReceived++;\n      this.stats.bytesReceived += this.getDataSize(event.data);\n      this.stats.lastActivity = Date.now();\n    });\n\n    this.socket.addEventListener("close", (event) => {\n      this.logEvent("closed", event);\n    });\n\n    this.socket.addEventListener("error", (event) => {\n      this.logEvent("error", event);\n    });\n  }\n\n  logMessage(direction, data) {\n    const entry = {\n      type: "message",\n      direction,\n      data: this.formatData(data),\n      size: this.getDataSize(data),\n      timestamp: Date.now(),\n    };\n\n    this.logs.push(entry);\n    this.trimLogs();\n\n    console.log(`WebSocket ${direction}:`, entry);\n  }\n\n  logEvent(type, event) {\n    const entry = {\n      type: "event",\n      event: type,\n      details: this.formatEvent(event),\n      timestamp: Date.now(),\n    };\n\n    this.logs.push(entry);\n    this.trimLogs();\n\n    console.log(`WebSocket ${type}:`, entry);\n  }\n\n  formatData(data) {\n    if (typeof data === "string") {\n      try {\n        return JSON.parse(data);\n      } catch {\n        return data;\n      }\n    }\n    return data;\n  }\n\n  formatEvent(event) {\n    return {\n      type: event.type,\n      code: event.code,\n      reason: event.reason,\n      wasClean: event.wasClean,\n    };\n  }\n\n  getDataSize(data) {\n    if (typeof data === "string") {\n      return new Blob([data]).size;\n    } else if (data instanceof ArrayBuffer) {\n      return data.byteLength;\n    } else if (data instanceof Blob) {\n      return data.size;\n    }\n    return 0;\n  }\n\n  trimLogs() {\n    if (this.logs.length > 1000) {\n      this.logs = this.logs.slice(-500);\n    }\n  }\n\n  exportLogs() {\n    return {\n      logs: this.logs,\n      stats: this.stats,\n      exportTime: Date.now(),\n    };\n  }\n\n  printStats() {\n    console.table(this.stats);\n  }\n}\n\n// Usage\nconst debugger = new WebSocketDebugger(socket);\n\n// Export logs for analysis\nconst logs = debugger.exportLogs();\nconsole.log("WebSocket debug data:", logs);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-and-common-pitfalls",children:"Best Practices and Common Pitfalls"}),"\n",(0,i.jsx)(n.h3,{id:"connection-management-best-practices",children:"Connection Management Best Practices"}),"\n",(0,i.jsx)(n.p,{children:"This section outlines essential best practices for WebSocket development and highlights common mistakes that can lead to unreliable connections, memory leaks, or security vulnerabilities. Following these patterns will ensure robust, production-ready WebSocket applications."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Best Practices:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Proper Lifecycle Management"}),": Handle all connection states gracefully"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Cleanup"}),": Always clean up timers, listeners, and references"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Implement comprehensive error handling and recovery"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Connection Timeouts"}),": Prevent hanging connections with timeouts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Graceful Shutdown"}),": Properly close connections with appropriate codes"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Common Pitfalls to Avoid:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Forgetting to handle connection errors and cleanup"}),"\n",(0,i.jsx)(n.li,{children:"Not implementing reconnection logic for production use"}),"\n",(0,i.jsx)(n.li,{children:"Missing proper event listener management"}),"\n",(0,i.jsx)(n.li,{children:"Inadequate message validation and error handling"}),"\n",(0,i.jsx)(n.li,{children:"Poor connection state management"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Comparison: Good vs Bad Practices"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// \u2705 GOOD: Proper connection lifecycle management\nclass RobustWebSocketClient {\n  constructor(url, options = {}) {\n    this.url = url; // Store connection parameters\n    this.options = options; // Configuration options\n    this.socket = null; // WebSocket instance reference\n    this.reconnectEnabled = true; // Control reconnection behavior\n    this.eventListeners = new Map(); // Track event listeners for cleanup\n  }\n\n  async connect() {\n    return new Promise((resolve, reject) => {\n      try {\n        this.socket = new WebSocket(this.url);\n\n        const timeout = setTimeout(() => {\n          this.socket.close();\n          reject(new Error("Connection timeout"));\n        }, 10000);\n\n        this.socket.onopen = () => {\n          clearTimeout(timeout);\n          resolve();\n        };\n\n        this.socket.onerror = (error) => {\n          clearTimeout(timeout);\n          reject(error);\n        };\n\n        this.setupEventHandlers();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  setupEventHandlers() {\n    this.socket.onclose = (event) => {\n      if (this.reconnectEnabled && !event.wasClean) {\n        this.handleReconnect();\n      }\n    };\n  }\n\n  disconnect() {\n    this.reconnectEnabled = false;\n    if (this.socket) {\n      this.socket.close(1000, "Normal closure");\n    }\n  }\n}\n\n// \u274c BAD: No error handling or connection management\nclass BadWebSocketClient {\n  constructor(url) {\n    this.socket = new WebSocket(url); // Can throw immediately - no try/catch\n    // Missing: Error handling, reconnection logic, state management\n    // Missing: Timeout protection, resource cleanup\n    // Missing: Proper event listener setup\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"message-handling-best-practices",children:"Message Handling Best Practices"}),"\n",(0,i.jsx)(n.p,{children:"Proper message handling is crucial for building reliable WebSocket applications. This section demonstrates the difference between robust message processing and common mistakes that can lead to application crashes or security vulnerabilities."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Message Handling Best Practices:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Input Validation"}),": Always validate message structure and content"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Isolation"}),": Catch and handle parsing errors gracefully"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Middleware Support"}),": Implement extensible message processing pipeline"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type Safety"}),": Ensure message types are properly defined and handled"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Async Processing"}),": Support asynchronous message handlers"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// \u2705 GOOD: Structured message handling with validation\nclass MessageHandler {\n  constructor() {\n    this.handlers = new Map(); // Message type to handler mapping\n    this.middleware = []; // Message processing middleware\n  }\n\n  addHandler(type, handler) {\n    this.handlers.set(type, handler);\n  }\n\n  async processMessage(rawData) {\n    try {\n      let message = this.parseMessage(rawData);\n\n      // Apply middleware\n      for (const middleware of this.middleware) {\n        message = await middleware(message);\n        if (!message) return; // Middleware rejected message\n      }\n\n      // Validate message structure\n      if (!this.validateMessage(message)) {\n        throw new Error("Invalid message structure");\n      }\n\n      // Handle message\n      const handler = this.handlers.get(message.type);\n      if (handler) {\n        await handler(message);\n      } else {\n        console.warn(`No handler for message type: ${message.type}`);\n      }\n    } catch (error) {\n      console.error("Message processing error:", error);\n    }\n  }\n\n  parseMessage(data) {\n    if (typeof data === "string") {\n      return JSON.parse(data);\n    }\n    return data;\n  }\n\n  validateMessage(message) {\n    return message && typeof message.type === "string";\n  }\n}\n\n// \u274c BAD: No error handling or validation\nclass BadMessageHandler {\n  handleMessage(data) {\n    const message = JSON.parse(data); // Can throw on invalid JSON\n    this.handlers[message.type](message); // Can be undefined - will crash\n    // Missing: Error handling, input validation, null checks\n    // Missing: Async support, middleware, proper error isolation\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"performance-optimization-tips",children:"Performance Optimization Tips"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// \u2705 Good: Efficient message batching and throttling\nclass OptimizedWebSocket {\n  constructor(socket) {\n    this.socket = socket;\n    this.messageQueue = [];\n    this.batchTimer = null;\n    this.lastSend = 0;\n    this.minInterval = 16; // ~60fps\n  }\n\n  send(data) {\n    const now = Date.now();\n\n    if (now - this.lastSend < this.minInterval) {\n      // Batch messages to avoid flooding\n      this.messageQueue.push(data);\n      this.scheduleBatch();\n    } else {\n      this.sendImmediate(data);\n    }\n  }\n\n  sendImmediate(data) {\n    this.socket.send(JSON.stringify(data));\n    this.lastSend = Date.now();\n  }\n\n  scheduleBatch() {\n    if (!this.batchTimer) {\n      this.batchTimer = setTimeout(() => {\n        this.flushBatch();\n      }, this.minInterval);\n    }\n  }\n\n  flushBatch() {\n    if (this.messageQueue.length > 0) {\n      const batch = {\n        type: "batch",\n        messages: this.messageQueue.splice(0),\n      };\n      this.sendImmediate(batch);\n    }\n    this.batchTimer = null;\n  }\n}\n\n// \u274c Bad: Sending messages without any throttling\nclass BadWebSocket {\n  send(data) {\n    this.socket.send(JSON.stringify(data)); // Can flood the connection\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"WebSockets provide a powerful foundation for real-time web applications, enabling efficient bidirectional communication between clients and servers. Understanding the underlying protocol, from the initial HTTP handshake to frame-level communication, is crucial for building robust applications."}),"\n",(0,i.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Protocol Understanding"}),": The WebSocket handshake process and frame structure enable efficient real-time communication while maintaining compatibility with existing web infrastructure."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Connection Management"}),": Proper connection lifecycle management, including reconnection strategies and heartbeat mechanisms, ensures reliable real-time communication."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Security Considerations"}),": Implementing proper authentication, rate limiting, and using secure connections (WSS) is essential for production applications."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Performance Optimization"}),": Message batching, compression, and efficient connection pooling can significantly improve application performance."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Comprehensive error handling and debugging tools are crucial for maintaining stable WebSocket connections in production environments."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"future-considerations",children:"Future Considerations"}),"\n",(0,i.jsx)(n.p,{children:"WebSocket technology continues to evolve with new standards like WebTransport providing enhanced capabilities for specific use cases. However, WebSockets remain the standard choice for most real-time web applications due to their widespread support and proven reliability."}),"\n",(0,i.jsx)(n.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API",children:"WebSocket API Documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc6455",children:"RFC 6455 - The WebSocket Protocol"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers",children:"WebSocket Security Considerations"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://socket.io/docs/",children:"Socket.IO Documentation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebTransport",children:"WebTransport API"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The WebSocket ecosystem continues to grow with libraries and frameworks that simplify development while providing advanced features like automatic reconnection, room management, and scaling solutions for production applications."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);