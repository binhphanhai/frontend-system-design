"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5942],{3669:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"project-detail/dexie-and-indexed-db","title":"Dexie.js and IndexedDB: Under the Hood","description":"Table of Contents","source":"@site/docs/project-detail/dexie-and-indexed-db.md","sourceDirName":"project-detail","slug":"/project-detail/dexie-and-indexed-db","permalink":"/frontend-system-design/docs/project-detail/dexie-and-indexed-db","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/dexie-and-indexed-db.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"React Native: Under the Hood","permalink":"/frontend-system-design/docs/project-detail/react-native"},"next":{"title":"WebSockets: Real-Time Communication Under the Hood","permalink":"/frontend-system-design/docs/project-detail/web-socket"}}');var a=r(4848),s=r(8453);const i={},o="Dexie.js and IndexedDB: Under the Hood",c={},d=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"IndexedDB Fundamentals",id:"indexeddb-fundamentals",level:2},{value:"What is IndexedDB?",id:"what-is-indexeddb",level:3},{value:"Core Concepts",id:"core-concepts",level:3},{value:"Database Hierarchy",id:"database-hierarchy",level:4},{value:"Data Storage Model",id:"data-storage-model",level:4},{value:"How IndexedDB Works Under the Hood",id:"how-indexeddb-works-under-the-hood",level:2},{value:"Browser Implementation Architecture",id:"browser-implementation-architecture",level:3},{value:"Chromium/Blink (Chrome, Edge)",id:"chromiumblink-chrome-edge",level:4},{value:"Firefox/Gecko",id:"firefoxgecko",level:4},{value:"Safari/WebKit",id:"safariwebkit",level:4},{value:"Data Storage Mechanisms",id:"data-storage-mechanisms",level:3},{value:"B+ Tree Indexing",id:"b-tree-indexing",level:4},{value:"Transaction Processing",id:"transaction-processing",level:4},{value:"Memory Management",id:"memory-management",level:3},{value:"Page-based Storage",id:"page-based-storage",level:4},{value:"Cache Management",id:"cache-management",level:4},{value:"Browser Storage Architecture",id:"browser-storage-architecture",level:2},{value:"Storage Partitioning",id:"storage-partitioning",level:3},{value:"Persistence Models",id:"persistence-models",level:3},{value:"Temporary Storage",id:"temporary-storage",level:4},{value:"Persistent Storage",id:"persistent-storage",level:4},{value:"Storage Limits and Quota Management",id:"storage-limits-and-quota-management",level:2},{value:"Browser-Specific Limits",id:"browser-specific-limits",level:3},{value:"Chrome/Chromium",id:"chromechromium",level:4},{value:"Firefox",id:"firefox",level:4},{value:"Safari",id:"safari",level:4},{value:"Quota API Usage",id:"quota-api-usage",level:3},{value:"Native IndexedDB API Deep Dive",id:"native-indexeddb-api-deep-dive",level:2},{value:"Database Connection Management",id:"database-connection-management",level:3},{value:"Transaction Management",id:"transaction-management",level:3},{value:"Cursor Operations",id:"cursor-operations",level:3},{value:"Dexie.js: The Wrapper Library",id:"dexiejs-the-wrapper-library",level:2},{value:"Architecture Overview",id:"architecture-overview",level:3},{value:"Core Design Principles",id:"core-design-principles",level:3},{value:"1. Promise-First API",id:"1-promise-first-api",level:4},{value:"2. Fluent Query Interface",id:"2-fluent-query-interface",level:4},{value:"3. Automatic Transaction Management",id:"3-automatic-transaction-management",level:4},{value:"How Dexie Wraps IndexedDB",id:"how-dexie-wraps-indexeddb",level:2},{value:"Promise Wrapper Implementation",id:"promise-wrapper-implementation",level:3},{value:"Query Engine Implementation",id:"query-engine-implementation",level:3},{value:"Transaction Context Management",id:"transaction-context-management",level:3},{value:"Dexie Source Code Analysis",id:"dexie-source-code-analysis",level:2},{value:"Schema Definition and Versioning",id:"schema-definition-and-versioning",level:3},{value:"Bulk Operations Optimization",id:"bulk-operations-optimization",level:3},{value:"Error Handling and Recovery",id:"error-handling-and-recovery",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Indexing Strategies",id:"indexing-strategies",level:3},{value:"Memory Management",id:"memory-management-1",level:3},{value:"Advanced Features and Patterns",id:"advanced-features-and-patterns",level:2},{value:"Live Queries with dexie-react-hooks",id:"live-queries-with-dexie-react-hooks",level:3},{value:"Database Synchronization Patterns",id:"database-synchronization-patterns",level:3},{value:"Custom Middleware and Hooks",id:"custom-middleware-and-hooks",level:3},{value:"Real-World Implementation Examples",id:"real-world-implementation-examples",level:2},{value:"E-commerce Application",id:"e-commerce-application",level:3},{value:"Collaborative Document Editor",id:"collaborative-document-editor",level:3},{value:"Debugging and Development Tools",id:"debugging-and-development-tools",level:2},{value:"Database Inspection Tools",id:"database-inspection-tools",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3},{value:"Best Practices and Gotchas",id:"best-practices-and-gotchas",level:2},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:3},{value:"1. Transaction Scope Issues",id:"1-transaction-scope-issues",level:4},{value:"2. Memory Leaks with Large Queries",id:"2-memory-leaks-with-large-queries",level:4},{value:"3. Index Design Mistakes",id:"3-index-design-mistakes",level:4},{value:"Production Deployment Checklist",id:"production-deployment-checklist",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Further Reading",id:"further-reading",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"dexiejs-and-indexeddb-under-the-hood",children:"Dexie.js and IndexedDB: Under the Hood"})}),"\n",(0,a.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#indexeddb-fundamentals",children:"IndexedDB Fundamentals"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#how-indexeddb-works-under-the-hood",children:"How IndexedDB Works Under the Hood"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#browser-storage-architecture",children:"Browser Storage Architecture"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#storage-limits-and-quota-management",children:"Storage Limits and Quota Management"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#native-indexeddb-api-deep-dive",children:"Native IndexedDB API Deep Dive"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#dexiejs-the-wrapper-library",children:"Dexie.js: The Wrapper Library"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#how-dexie-wraps-indexeddb",children:"How Dexie Wraps IndexedDB"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#dexie-source-code-analysis",children:"Dexie Source Code Analysis"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#performance-considerations",children:"Performance Considerations"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#advanced-features-and-patterns",children:"Advanced Features and Patterns"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#real-world-implementation-examples",children:"Real-World Implementation Examples"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#debugging-and-development-tools",children:"Debugging and Development Tools"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#best-practices-and-gotchas",children:"Best Practices and Gotchas"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"IndexedDB is the cornerstone of client-side storage in modern web browsers, providing a robust, transactional database system that can handle large amounts of structured data. While powerful, its native API can be complex and verbose. Dexie.js emerges as a sophisticated wrapper that simplifies IndexedDB interactions while preserving its full capabilities."}),"\n",(0,a.jsx)(n.p,{children:"This comprehensive guide explores both technologies from the ground up, examining their internal mechanisms, architectural decisions, and practical implementations."}),"\n",(0,a.jsx)(n.h2,{id:"indexeddb-fundamentals",children:"IndexedDB Fundamentals"}),"\n",(0,a.jsx)(n.h3,{id:"what-is-indexeddb",children:"What is IndexedDB?"}),"\n",(0,a.jsx)(n.p,{children:"IndexedDB is a low-level web API for client-side storage of significant amounts of structured data. Unlike simple key-value stores like localStorage, IndexedDB is a full-featured database system that supports:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Object-oriented storage"}),": Stores JavaScript objects directly"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Indexing"}),": Enables efficient queries on object properties"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Transactions"}),": Ensures data integrity through ACID properties"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Asynchronous operations"}),": Non-blocking database operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Large storage capacity"}),": Much larger limits than localStorage"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,a.jsx)(n.h4,{id:"database-hierarchy",children:"Database Hierarchy"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Database\n\u2514\u2500\u2500 Object Stores (like tables)\n    \u251c\u2500\u2500 Records (key-value pairs)\n    \u2514\u2500\u2500 Indexes (for efficient querying)\n"})}),"\n",(0,a.jsx)(n.h4,{id:"data-storage-model",children:"Data Storage Model"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Example object structure in IndexedDB\nconst userRecord = {\n  id: 1, // Primary key\n  name: "John Doe", // Indexed property\n  email: "john@example.com", // Unique indexed property\n  preferences: {\n    // Nested object (fully supported)\n    theme: "dark",\n    notifications: true,\n  },\n  lastLogin: new Date(), // Complex data types supported\n  avatar: blob, // Binary data supported\n};\n'})}),"\n",(0,a.jsx)(n.h2,{id:"how-indexeddb-works-under-the-hood",children:"How IndexedDB Works Under the Hood"}),"\n",(0,a.jsx)(n.h3,{id:"browser-implementation-architecture",children:"Browser Implementation Architecture"}),"\n",(0,a.jsx)(n.p,{children:"IndexedDB is implemented differently across browser engines, but they share common architectural patterns:"}),"\n",(0,a.jsx)(n.h4,{id:"chromiumblink-chrome-edge",children:"Chromium/Blink (Chrome, Edge)"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Storage Engine"}),": LevelDB (Google's key-value store)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"File Location"}),": ",(0,a.jsx)(n.code,{children:"{Profile}/IndexedDB/"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Internal Format"}),": Binary format with metadata"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Transaction Isolation"}),": Snapshot isolation"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"firefoxgecko",children:"Firefox/Gecko"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Storage Engine"}),": SQLite with custom schema"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"File Location"}),": ",(0,a.jsx)(n.code,{children:"{Profile}/storage/default/{origin}/idb/"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Internal Format"}),": SQLite database files"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Transaction Isolation"}),": Read committed with locks"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"safariwebkit",children:"Safari/WebKit"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Storage Engine"}),": SQLite-based implementation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"File Location"}),": ",(0,a.jsx)(n.code,{children:"~/Library/Safari/Databases/"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Internal Format"}),": SQLite with IndexedDB-specific schema"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"data-storage-mechanisms",children:"Data Storage Mechanisms"}),"\n",(0,a.jsx)(n.h4,{id:"b-tree-indexing",children:"B+ Tree Indexing"}),"\n",(0,a.jsx)(n.p,{children:"IndexedDB implementations typically use B+ tree structures for indexing:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"B+ Tree Example for User Index by Age:\n                [25, 50]\n               /    |    \\\n        [18,21,24] [30,35,40] [55,60,65]\n         |  |  |    |  |  |     |  |  |\n       data data data ...    data data data\n"})}),"\n",(0,a.jsx)(n.h4,{id:"transaction-processing",children:"Transaction Processing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Transaction lifecycle in IndexedDB\nconst transaction = db.transaction(["users"], "readwrite");\n\n// 1. Transaction creation - browser allocates resources\n// 2. Operation queueing - operations are queued, not executed immediately\ntransaction.objectStore("users").add(userData);\ntransaction.objectStore("users").get(1);\n\n// 3. Execution phase - browser processes queued operations\n// 4. Commit/Rollback - transaction completes atomically\ntransaction.oncomplete = () => console.log("Transaction committed");\ntransaction.onerror = () => console.log("Transaction rolled back");\n'})}),"\n",(0,a.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,a.jsx)(n.h4,{id:"page-based-storage",children:"Page-based Storage"}),"\n",(0,a.jsx)(n.p,{children:"IndexedDB stores data in pages (typically 4KB or 8KB), similar to traditional databases:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Page Structure:\n[Header][Record1][Record2][...][FreeSpace][PageFooter]\n"})}),"\n",(0,a.jsx)(n.h4,{id:"cache-management",children:"Cache Management"}),"\n",(0,a.jsx)(n.p,{children:"Browsers implement sophisticated caching strategies:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Buffer Pool"}),": In-memory cache of frequently accessed pages"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Write-Ahead Logging"}),": Ensures durability before commit"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Checkpoint Processing"}),": Periodic flushing of dirty pages to disk"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"browser-storage-architecture",children:"Browser Storage Architecture"}),"\n",(0,a.jsx)(n.h3,{id:"storage-partitioning",children:"Storage Partitioning"}),"\n",(0,a.jsx)(n.p,{children:"Modern browsers implement storage partitioning to enhance security and performance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Storage is partitioned by origin\nconst origin1 = "https://example.com"; // Separate storage\nconst origin2 = "https://subdomain.example.com"; // Separate storage\nconst origin3 = "http://example.com"; // Separate storage (different protocol)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"persistence-models",children:"Persistence Models"}),"\n",(0,a.jsx)(n.h4,{id:"temporary-storage",children:"Temporary Storage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Default behavior - subject to browser eviction\nnavigator.storage.estimate().then((estimate) => {\n  console.log("Available:", estimate.quota);\n  console.log("Used:", estimate.usage);\n});\n'})}),"\n",(0,a.jsx)(n.h4,{id:"persistent-storage",children:"Persistent Storage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Request persistent storage (won\'t be evicted)\nnavigator.storage.persist().then((persistent) => {\n  if (persistent) {\n    console.log("Storage will persist across browser sessions");\n  } else {\n    console.log("Storage may be evicted by the browser");\n  }\n});\n'})}),"\n",(0,a.jsx)(n.h2,{id:"storage-limits-and-quota-management",children:"Storage Limits and Quota Management"}),"\n",(0,a.jsx)(n.h3,{id:"browser-specific-limits",children:"Browser-Specific Limits"}),"\n",(0,a.jsx)(n.h4,{id:"chromechromium",children:"Chrome/Chromium"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Default Quota"}),": 60% of available disk space (shared across all origins)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Per-Origin Limit"}),": 20% of total quota"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Minimum Guarantee"}),": 1GB if available"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Eviction Policy"}),": LRU (Least Recently Used)"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"firefox",children:"Firefox"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Default Quota"}),": 50% of available disk space"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Per-Origin Limit"}),": 2GB initially, can grow"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Group Limit"}),": 20% of global quota per origin group"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Eviction Policy"}),": LRU with usage-based weighting"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"safari",children:"Safari"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Default Quota"}),": More conservative, around 1GB"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Per-Origin Limit"}),": Varies, typically 1GB"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"User Prompts"}),": May prompt user for additional storage"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Eviction Policy"}),": Strict LRU"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"quota-api-usage",children:"Quota API Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Check current storage usage and quota\nasync function checkStorageQuota() {\n  if ("storage" in navigator && "estimate" in navigator.storage) {\n    const estimate = await navigator.storage.estimate();\n\n    const usageInMB = (estimate.usage / (1024 * 1024)).toFixed(2);\n    const quotaInMB = (estimate.quota / (1024 * 1024)).toFixed(2);\n    const percentUsed = ((estimate.usage / estimate.quota) * 100).toFixed(2);\n\n    console.log(`Storage used: ${usageInMB} MB`);\n    console.log(`Storage quota: ${quotaInMB} MB`);\n    console.log(`Percentage used: ${percentUsed}%`);\n\n    // Check if we\'re approaching the limit\n    if (estimate.usage / estimate.quota > 0.8) {\n      console.warn("Storage usage is above 80% - consider cleanup");\n    }\n  }\n}\n\n// Handle quota exceeded errors\nfunction handleQuotaError(error) {\n  if (error.name === "QuotaExceededError") {\n    console.error("Storage quota exceeded");\n    // Implement cleanup logic\n    cleanupOldData();\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"native-indexeddb-api-deep-dive",children:"Native IndexedDB API Deep Dive"}),"\n",(0,a.jsx)(n.h3,{id:"database-connection-management",children:"Database Connection Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Advanced database opening with version control\nfunction openDatabase(name, version, upgradeCallback) {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(name, version);\n\n    request.onerror = () => {\n      reject(new Error(`Failed to open database: ${request.error}`));\n    };\n\n    request.onsuccess = () => {\n      const db = request.result;\n\n      // Set up global error handler\n      db.onerror = (event) => {\n        console.error("Database error:", event.target.error);\n      };\n\n      // Handle version change (another tab upgraded the database)\n      db.onversionchange = () => {\n        db.close();\n        console.warn("Database version changed by another tab");\n      };\n\n      resolve(db);\n    };\n\n    request.onupgradeneeded = (event) => {\n      const db = event.target.result;\n      const transaction = event.target.transaction;\n\n      // Call user-provided upgrade callback\n      if (upgradeCallback) {\n        upgradeCallback(db, transaction, event.oldVersion, event.newVersion);\n      }\n    };\n\n    request.onblocked = () => {\n      console.warn("Database upgrade blocked by other connections");\n    };\n  });\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"transaction-management",children:"Transaction Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Advanced transaction handling with retry logic\nclass TransactionManager {\n  constructor(db) {\n    this.db = db;\n  }\n\n  async executeWithRetry(storeNames, mode, operations, maxRetries = 3) {\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        return await this.executeTransaction(storeNames, mode, operations);\n      } catch (error) {\n        if (attempt === maxRetries || !this.isRetryableError(error)) {\n          throw error;\n        }\n\n        // Exponential backoff\n        await this.delay(Math.pow(2, attempt) * 100);\n      }\n    }\n  }\n\n  executeTransaction(storeNames, mode, operations) {\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction(storeNames, mode);\n      const results = {};\n\n      transaction.oncomplete = () => resolve(results);\n      transaction.onerror = () => reject(transaction.error);\n      transaction.onabort = () => reject(new Error("Transaction aborted"));\n\n      // Execute operations within transaction\n      operations(transaction, results);\n    });\n  }\n\n  isRetryableError(error) {\n    return (\n      error.name === "TransactionInactiveError" ||\n      error.name === "InvalidStateError"\n    );\n  }\n\n  delay(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"cursor-operations",children:"Cursor Operations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Advanced cursor usage for range queries and pagination\nclass CursorQuery {\n  constructor(objectStore) {\n    this.objectStore = objectStore;\n  }\n\n  // Paginated query with cursor\n  async paginate(pageSize = 20, startKey = null) {\n    return new Promise((resolve, reject) => {\n      const results = [];\n      let cursor;\n\n      // Create appropriate cursor based on start key\n      if (startKey) {\n        const range = IDBKeyRange.lowerBound(startKey, true); // exclusive\n        cursor = this.objectStore.openCursor(range);\n      } else {\n        cursor = this.objectStore.openCursor();\n      }\n\n      cursor.onsuccess = (event) => {\n        const cursor = event.target.result;\n\n        if (cursor && results.length < pageSize) {\n          results.push({\n            key: cursor.key,\n            value: cursor.value,\n          });\n          cursor.continue();\n        } else {\n          resolve({\n            results,\n            nextKey: cursor ? cursor.key : null,\n            hasMore: cursor !== null,\n          });\n        }\n      };\n\n      cursor.onerror = () => reject(cursor.error);\n    });\n  }\n\n  // Range query with filtering\n  async rangeQuery(lowerBound, upperBound, filter = null) {\n    return new Promise((resolve, reject) => {\n      const results = [];\n      const range = IDBKeyRange.bound(lowerBound, upperBound);\n      const cursor = this.objectStore.openCursor(range);\n\n      cursor.onsuccess = (event) => {\n        const cursor = event.target.result;\n\n        if (cursor) {\n          if (!filter || filter(cursor.value)) {\n            results.push(cursor.value);\n          }\n          cursor.continue();\n        } else {\n          resolve(results);\n        }\n      };\n\n      cursor.onerror = () => reject(cursor.error);\n    });\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"dexiejs-the-wrapper-library",children:"Dexie.js: The Wrapper Library"}),"\n",(0,a.jsx)(n.h3,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,a.jsx)(n.p,{children:"Dexie.js provides a sophisticated abstraction layer over IndexedDB while maintaining high performance and full feature access. Its architecture consists of several key components:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Dexie Architecture:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           User API Layer            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         Promise Wrapper             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       Transaction Manager           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         Query Engine                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       Schema Management             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         IndexedDB Core              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(n.h3,{id:"core-design-principles",children:"Core Design Principles"}),"\n",(0,a.jsx)(n.h4,{id:"1-promise-first-api",children:"1. Promise-First API"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Native IndexedDB (callback-based)\nconst request = objectStore.get(key);\nrequest.onsuccess = (event) => {\n  const result = event.target.result;\n  // Handle result\n};\nrequest.onerror = (event) => {\n  // Handle error\n};\n\n// Dexie (Promise-based)\nconst result = await db.table.get(key);\n"})}),"\n",(0,a.jsx)(n.h4,{id:"2-fluent-query-interface",children:"2. Fluent Query Interface"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Complex query in Dexie\nconst results = await db.users\n  .where("age")\n  .between(18, 65)\n  .and((user) => user.isActive)\n  .orderBy("name")\n  .limit(50)\n  .toArray();\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-automatic-transaction-management",children:"3. Automatic Transaction Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Dexie automatically manages transactions\nawait db.transaction("rw", db.users, db.orders, async () => {\n  const user = await db.users.add({ name: "John" });\n  await db.orders.add({ userId: user, total: 100 });\n  // Transaction commits automatically on success\n  // Rolls back automatically on error\n});\n'})}),"\n",(0,a.jsx)(n.h2,{id:"how-dexie-wraps-indexeddb",children:"How Dexie Wraps IndexedDB"}),"\n",(0,a.jsx)(n.h3,{id:"promise-wrapper-implementation",children:"Promise Wrapper Implementation"}),"\n",(0,a.jsx)(n.p,{children:"Dexie's promise wrapper is one of its most sophisticated features. Here's a simplified version of how it works:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Simplified Promise wrapper (based on Dexie source concepts)\nclass DexiePromise extends Promise {\n  constructor(executor) {\n    super(executor);\n    this._zone = getCurrentZone(); // Transaction context\n  }\n\n  then(onFulfilled, onRejected) {\n    return this._zone.run(() => {\n      return super.then(onFulfilled, onRejected);\n    });\n  }\n\n  catch(onRejected) {\n    return this._zone.run(() => {\n      return super.catch(onRejected);\n    });\n  }\n}\n\n// Zone implementation for transaction context\nclass Zone {\n  constructor(parent = null) {\n    this.parent = parent;\n    this.transaction = null;\n    this.props = {};\n  }\n\n  run(fn) {\n    const previousZone = currentZone;\n    currentZone = this;\n    try {\n      return fn();\n    } finally {\n      currentZone = previousZone;\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"query-engine-implementation",children:"Query Engine Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Dexie's Collection class (simplified)\nclass Collection {\n  constructor(table, where) {\n    this.table = table;\n    this.where = where;\n    this.filters = [];\n    this.ordering = null;\n    this.limitValue = null;\n  }\n\n  // Fluent query methods\n  and(filterFunction) {\n    return new Collection(this.table, this.where).addFilter(filterFunction);\n  }\n\n  orderBy(keyPath) {\n    const collection = this.clone();\n    collection.ordering = keyPath;\n    return collection;\n  }\n\n  limit(count) {\n    const collection = this.clone();\n    collection.limitValue = count;\n    return collection;\n  }\n\n  // Execute query\n  async toArray() {\n    const strategy = this.optimizeQuery();\n    return await strategy.execute();\n  }\n\n  // Query optimization\n  optimizeQuery() {\n    if (this.where && this.table.schema.hasIndex(this.where.keyPath)) {\n      return new IndexStrategy(this);\n    } else {\n      return new ScanStrategy(this);\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"transaction-context-management",children:"Transaction Context Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Dexie's transaction management (conceptual)\nclass Transaction {\n  constructor(mode, tables, db) {\n    this.mode = mode;\n    this.tables = tables;\n    this.db = db;\n    this.idbtrans = null;\n    this.active = false;\n  }\n\n  async execute(fn) {\n    this.idbtrans = this.db.idbdb.transaction(this.tables, this.mode);\n    this.active = true;\n\n    // Set up transaction event handlers\n    this.idbtrans.oncomplete = () => this.complete();\n    this.idbtrans.onerror = (event) => this.error(event);\n    this.idbtrans.onabort = () => this.abort();\n\n    try {\n      // Execute user function in transaction context\n      const result = await this.runInContext(fn);\n      return result;\n    } catch (error) {\n      this.idbtrans.abort();\n      throw error;\n    }\n  }\n\n  runInContext(fn) {\n    return new Zone(currentZone).run(() => {\n      currentZone.transaction = this;\n      return fn();\n    });\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"dexie-source-code-analysis",children:"Dexie Source Code Analysis"}),"\n",(0,a.jsx)(n.h3,{id:"schema-definition-and-versioning",children:"Schema Definition and Versioning"}),"\n",(0,a.jsx)(n.p,{children:"Looking at Dexie's source code, schema management is handled through a sophisticated versioning system:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// From Dexie source: Version class\nclass Version {\n  constructor(versionNumber) {\n    this._cfg = {\n      version: versionNumber,\n      storeNames: [],\n      dbschema: {},\n      tables: {},\n    };\n  }\n\n  stores(stores) {\n    Object.keys(stores).forEach((tableName) => {\n      const schema = stores[tableName];\n      this.parseStoreSchema(tableName, schema);\n    });\n    return this;\n  }\n\n  parseStoreSchema(tableName, schema) {\n    // Parse schema string like "++id,name,*tags"\n    const parts = schema.split(",").map((s) => s.trim());\n    const primKey = this.parsePrimaryKey(parts[0]);\n    const indexes = this.parseIndexes(parts.slice(1));\n\n    this._cfg.dbschema[tableName] = {\n      primKey,\n      indexes,\n      mappedClass: null,\n    };\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"bulk-operations-optimization",children:"Bulk Operations Optimization"}),"\n",(0,a.jsx)(n.p,{children:"Dexie implements sophisticated bulk operations that significantly outperform individual operations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// Dexie's bulk add implementation (conceptual)\nclass Table {\n  async bulkAdd(objects, keys) {\n    const trans = getCurrentTransaction();\n    const store = trans.objectStore(this.name);\n\n    // Use browser's native bulk capabilities when available\n    if (store.addAll) {\n      return await this.nativeBulkAdd(store, objects, keys);\n    }\n\n    // Fallback to optimized batch processing\n    return await this.batchAdd(store, objects, keys);\n  }\n\n  async batchAdd(store, objects, keys) {\n    const batchSize = 100; // Optimal batch size\n    const results = [];\n\n    for (let i = 0; i < objects.length; i += batchSize) {\n      const batch = objects.slice(i, i + batchSize);\n      const batchKeys = keys ? keys.slice(i, i + batchSize) : undefined;\n\n      const batchResults = await Promise.all(\n        batch.map((obj, idx) => {\n          const key = batchKeys ? batchKeys[idx] : undefined;\n          return this.promisifyRequest(store.add(obj, key));\n        })\n      );\n\n      results.push(...batchResults);\n    }\n\n    return results;\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"error-handling-and-recovery",children:"Error Handling and Recovery"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Dexie\'s error handling system\nclass DexieError extends Error {\n  constructor(name, message) {\n    super(message);\n    this.name = name;\n  }\n}\n\n// Specific error types\nclass QuotaExceededError extends DexieError {\n  constructor() {\n    super("QuotaExceededError", "Storage quota exceeded");\n  }\n}\n\nclass TransactionInactiveError extends DexieError {\n  constructor() {\n    super("TransactionInactiveError", "Transaction is no longer active");\n  }\n}\n\n// Error recovery mechanisms\nclass ErrorRecovery {\n  static async handleQuotaExceeded(operation) {\n    // Attempt to free up space\n    await this.cleanupExpiredData();\n\n    // Retry operation\n    try {\n      return await operation();\n    } catch (error) {\n      if (error.name === "QuotaExceededError") {\n        throw new Error("Storage quota exceeded even after cleanup");\n      }\n      throw error;\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.h3,{id:"indexing-strategies",children:"Indexing Strategies"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Optimal indexing for different query patterns\nconst db = new Dexie("PerformanceDB");\ndb.version(1).stores({\n  // Compound index for multi-column queries\n  orders:\n    "++id, [customerId+status], [createdAt+status], customerId, status, createdAt",\n\n  // Multientry index for array properties\n  products: "++id, name, *tags, categoryId",\n\n  // Case-insensitive search preparation\n  users: "++id, name, email, [lastName+firstName]",\n});\n\n// Query optimization examples\nasync function optimizedQueries() {\n  // Uses compound index [customerId+status]\n  const activeOrders = await db.orders\n    .where(["customerId", "status"])\n    .equals([123, "active"])\n    .toArray();\n\n  // Uses multientry index on tags\n  const taggedProducts = await db.products\n    .where("tags")\n    .anyOf(["electronics", "gadgets"])\n    .toArray();\n\n  // Range query with index\n  const recentOrders = await db.orders\n    .where("createdAt")\n    .above(Date.now() - 86400000) // Last 24 hours\n    .toArray();\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"memory-management-1",children:"Memory Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Efficient large dataset processing\nasync function processLargeDataset() {\n  let processed = 0;\n\n  await db.largeTable.each((record) => {\n    // Process each record individually\n    processRecord(record);\n    processed++;\n\n    if (processed % 1000 === 0) {\n      console.log(`Processed ${processed} records`);\n    }\n  });\n}\n\n// Pagination for large result sets\nasync function paginatedQuery(pageSize = 100) {\n  let lastKey = null;\n  let hasMore = true;\n\n  while (hasMore) {\n    const query = db.table.orderBy("id");\n\n    if (lastKey) {\n      query.where("id").above(lastKey);\n    }\n\n    const results = await query.limit(pageSize).toArray();\n\n    if (results.length < pageSize) {\n      hasMore = false;\n    } else {\n      lastKey = results[results.length - 1].id;\n    }\n\n    // Process current page\n    processBatch(results);\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-features-and-patterns",children:"Advanced Features and Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"live-queries-with-dexie-react-hooks",children:"Live Queries with dexie-react-hooks"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Real-time data synchronization\nimport { useLiveQuery } from "dexie-react-hooks";\n\nfunction UserList() {\n  // Automatically re-runs when data changes\n  const users = useLiveQuery(() =>\n    db.users.where("isActive").equals(true).sortBy("name")\n  );\n\n  if (!users) return <div>Loading...</div>;\n\n  return (\n    <ul>\n      {users.map((user) => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"database-synchronization-patterns",children:"Database Synchronization Patterns"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Offline-first sync pattern\nclass SyncManager {\n  constructor(db, apiClient) {\n    this.db = db;\n    this.api = apiClient;\n    this.syncQueue = [];\n  }\n\n  async syncToServer() {\n    // Get pending changes\n    const pendingChanges = await this.db.syncLog\n      .where("synced")\n      .equals(false)\n      .toArray();\n\n    for (const change of pendingChanges) {\n      try {\n        await this.applySyncChange(change);\n        await this.db.syncLog.update(change.id, { synced: true });\n      } catch (error) {\n        console.error("Sync failed for change:", change.id, error);\n      }\n    }\n  }\n\n  async applySyncChange(change) {\n    switch (change.operation) {\n      case "create":\n        await this.api.create(change.table, change.data);\n        break;\n      case "update":\n        await this.api.update(change.table, change.id, change.data);\n        break;\n      case "delete":\n        await this.api.delete(change.table, change.id);\n        break;\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"custom-middleware-and-hooks",children:"Custom Middleware and Hooks"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Dexie middleware for logging and validation\ndb.use({\n  name: "LoggingMiddleware",\n  create: function (down, ctx, table) {\n    return function (data) {\n      console.log(`Creating record in ${table}:`, data);\n      return down.create.call(this, data);\n    };\n  },\n  read: function (down, ctx, table) {\n    return function (key) {\n      console.log(`Reading from ${table} with key:`, key);\n      return down.read.call(this, key);\n    };\n  },\n  update: function (down, ctx, table) {\n    return function (data) {\n      console.log(`Updating record in ${table}:`, data);\n      return down.update.call(this, data);\n    };\n  },\n  delete: function (down, ctx, table) {\n    return function (key) {\n      console.log(`Deleting from ${table} with key:`, key);\n      return down.delete.call(this, key);\n    };\n  },\n});\n'})}),"\n",(0,a.jsx)(n.h2,{id:"real-world-implementation-examples",children:"Real-World Implementation Examples"}),"\n",(0,a.jsx)(n.h3,{id:"e-commerce-application",children:"E-commerce Application"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// E-commerce database schema\nconst ecommerceDB = new Dexie("EcommerceApp");\necommerceDB.version(1).stores({\n  products: "++id, name, price, categoryId, *tags, inStock",\n  categories: "++id, name, parentId",\n  cart: "++id, productId, quantity, addedAt",\n  orders: "++id, customerId, status, total, createdAt",\n  orderItems: "++id, orderId, productId, quantity, price",\n});\n\n// Shopping cart implementation\nclass ShoppingCart {\n  async addItem(productId, quantity = 1) {\n    const existingItem = await ecommerceDB.cart\n      .where("productId")\n      .equals(productId)\n      .first();\n\n    if (existingItem) {\n      await ecommerceDB.cart.update(existingItem.id, {\n        quantity: existingItem.quantity + quantity,\n      });\n    } else {\n      await ecommerceDB.cart.add({\n        productId,\n        quantity,\n        addedAt: new Date(),\n      });\n    }\n  }\n\n  async getCartTotal() {\n    const cartItems = await ecommerceDB.cart.toArray();\n    let total = 0;\n\n    for (const item of cartItems) {\n      const product = await ecommerceDB.products.get(item.productId);\n      total += product.price * item.quantity;\n    }\n\n    return total;\n  }\n\n  async checkout(customerId) {\n    return await ecommerceDB.transaction(\n      "rw",\n      ecommerceDB.cart,\n      ecommerceDB.orders,\n      ecommerceDB.orderItems,\n      async () => {\n        const cartItems = await ecommerceDB.cart.toArray();\n        const total = await this.getCartTotal();\n\n        // Create order\n        const orderId = await ecommerceDB.orders.add({\n          customerId,\n          status: "pending",\n          total,\n          createdAt: new Date(),\n        });\n\n        // Add order items\n        for (const item of cartItems) {\n          const product = await ecommerceDB.products.get(item.productId);\n          await ecommerceDB.orderItems.add({\n            orderId,\n            productId: item.productId,\n            quantity: item.quantity,\n            price: product.price,\n          });\n        }\n\n        // Clear cart\n        await ecommerceDB.cart.clear();\n\n        return orderId;\n      }\n    );\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"collaborative-document-editor",children:"Collaborative Document Editor"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Document editor with operational transformation\nconst docDB = new Dexie("DocumentEditor");\ndocDB.version(1).stores({\n  documents: "++id, title, content, lastModified, version",\n  operations: "++id, documentId, type, position, content, timestamp, userId",\n  conflicts: "++id, documentId, operationId, resolvedAt",\n});\n\nclass OperationalTransform {\n  async applyOperation(docId, operation) {\n    return await docDB.transaction(\n      "rw",\n      docDB.documents,\n      docDB.operations,\n      async () => {\n        // Get current document state\n        const doc = await docDB.documents.get(docId);\n\n        // Get all operations after this operation\'s base version\n        const laterOps = await docDB.operations\n          .where("documentId")\n          .equals(docId)\n          .and((op) => op.timestamp > operation.baseTimestamp)\n          .sortBy("timestamp");\n\n        // Transform operation against later operations\n        const transformedOp = this.transform(operation, laterOps);\n\n        // Apply transformed operation to document\n        const newContent = this.applyToContent(doc.content, transformedOp);\n\n        // Update document\n        await docDB.documents.update(docId, {\n          content: newContent,\n          lastModified: new Date(),\n          version: doc.version + 1,\n        });\n\n        // Store operation in log\n        await docDB.operations.add({\n          ...transformedOp,\n          documentId: docId,\n          timestamp: new Date(),\n        });\n      }\n    );\n  }\n\n  transform(operation, laterOperations) {\n    let transformedOp = { ...operation };\n\n    for (const laterOp of laterOperations) {\n      transformedOp = this.transformPair(transformedOp, laterOp);\n    }\n\n    return transformedOp;\n  }\n\n  transformPair(op1, op2) {\n    // Implement operational transformation logic\n    // This is a simplified version\n    if (op1.type === "insert" && op2.type === "insert") {\n      if (op2.position <= op1.position) {\n        return { ...op1, position: op1.position + op2.content.length };\n      }\n    }\n\n    return op1;\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"debugging-and-development-tools",children:"Debugging and Development Tools"}),"\n",(0,a.jsx)(n.h3,{id:"database-inspection-tools",children:"Database Inspection Tools"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Development utilities for debugging\nclass DexieDebugger {\n  static async inspectDatabase(db) {\n    console.group("Database Inspection");\n\n    // List all tables\n    const tables = db.tables.map((table) => table.name);\n    console.log("Tables:", tables);\n\n    // Count records in each table\n    for (const tableName of tables) {\n      const count = await db.table(tableName).count();\n      console.log(`${tableName}: ${count} records`);\n    }\n\n    // Check storage usage\n    if (navigator.storage && navigator.storage.estimate) {\n      const estimate = await navigator.storage.estimate();\n      console.log("Storage estimate:", estimate);\n    }\n\n    console.groupEnd();\n  }\n\n  static async exportData(db) {\n    const data = {};\n\n    for (const table of db.tables) {\n      data[table.name] = await table.toArray();\n    }\n\n    return JSON.stringify(data, null, 2);\n  }\n\n  static async importData(db, jsonData) {\n    const data = JSON.parse(jsonData);\n\n    await db.transaction("rw", db.tables, async () => {\n      // Clear all tables first\n      for (const table of db.tables) {\n        await table.clear();\n      }\n\n      // Import data\n      for (const [tableName, records] of Object.entries(data)) {\n        if (db[tableName]) {\n          await db[tableName].bulkAdd(records);\n        }\n      }\n    });\n  }\n\n  static enableQueryLogging(db) {\n    db.use({\n      name: "QueryLogger",\n      read: function (down, ctx, table) {\n        return function (...args) {\n          console.time(`Read from ${table}`);\n          return down.read.apply(this, args).finally(() => {\n            console.timeEnd(`Read from ${table}`);\n          });\n        };\n      },\n    });\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Performance monitoring utilities\nclass PerformanceMonitor {\n  constructor(db) {\n    this.db = db;\n    this.metrics = new Map();\n  }\n\n  startMonitoring() {\n    this.db.use({\n      name: "PerformanceMonitor",\n      create: this.wrapOperation("create"),\n      read: this.wrapOperation("read"),\n      update: this.wrapOperation("update"),\n      delete: this.wrapOperation("delete"),\n    });\n  }\n\n  wrapOperation(operation) {\n    return (down, ctx, table) => {\n      return function (...args) {\n        const start = performance.now();\n        const key = `${table}.${operation}`;\n\n        return down[operation].apply(this, args).finally(() => {\n          const duration = performance.now() - start;\n          this.recordMetric(key, duration);\n        });\n      }.bind(this);\n    };\n  }\n\n  recordMetric(operation, duration) {\n    if (!this.metrics.has(operation)) {\n      this.metrics.set(operation, []);\n    }\n\n    this.metrics.get(operation).push(duration);\n\n    // Keep only last 100 measurements\n    const measurements = this.metrics.get(operation);\n    if (measurements.length > 100) {\n      measurements.shift();\n    }\n  }\n\n  getStats() {\n    const stats = {};\n\n    for (const [operation, measurements] of this.metrics) {\n      const avg = measurements.reduce((a, b) => a + b, 0) / measurements.length;\n      const max = Math.max(...measurements);\n      const min = Math.min(...measurements);\n\n      stats[operation] = { avg, max, min, count: measurements.length };\n    }\n\n    return stats;\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices-and-gotchas",children:"Best Practices and Gotchas"}),"\n",(0,a.jsx)(n.h3,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,a.jsx)(n.h4,{id:"1-transaction-scope-issues",children:"1. Transaction Scope Issues"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// \u274c Wrong: Operations outside transaction scope\nasync function badExample() {\n  const transaction = db.transaction("rw", db.users, db.orders);\n\n  setTimeout(async () => {\n    // This will fail - transaction may already be committed\n    await db.users.add({ name: "John" });\n  }, 100);\n}\n\n// \u2705 Correct: Keep all operations synchronous within transaction\nasync function goodExample() {\n  await db.transaction("rw", db.users, db.orders, async () => {\n    await db.users.add({ name: "John" });\n    await db.orders.add({ userId: 1, total: 100 });\n    // All operations complete before transaction ends\n  });\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"2-memory-leaks-with-large-queries",children:"2. Memory Leaks with Large Queries"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// \u274c Wrong: Loading entire large dataset\nasync function memoryHog() {\n  const allRecords = await db.largeTable.toArray(); // Could be millions\n  return allRecords.filter((record) => record.isActive);\n}\n\n// \u2705 Correct: Use streaming or pagination\nasync function memoryEfficient() {\n  const activeRecords = [];\n\n  await db.largeTable\n    .where("isActive")\n    .equals(true)\n    .each((record) => {\n      activeRecords.push(record);\n    });\n\n  return activeRecords;\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-index-design-mistakes",children:"3. Index Design Mistakes"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// \u274c Wrong: Missing compound indexes for multi-column queries\ndb.version(1).stores({\n  orders: "++id, customerId, status, createdAt",\n});\n\n// This query will be slow\nawait db.orders\n  .where("customerId")\n  .equals(123)\n  .and((order) => order.status === "active")\n  .toArray();\n\n// \u2705 Correct: Add compound index\ndb.version(1).stores({\n  orders: "++id, [customerId+status], customerId, status, createdAt",\n});\n\n// This query will be fast\nawait db.orders\n  .where(["customerId", "status"])\n  .equals([123, "active"])\n  .toArray();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"production-deployment-checklist",children:"Production Deployment Checklist"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'// Production-ready Dexie setup\nclass ProductionDB {\n  constructor() {\n    this.db = new Dexie("ProductionApp");\n    this.setupSchema();\n    this.setupErrorHandling();\n    this.setupPerformanceMonitoring();\n  }\n\n  setupSchema() {\n    this.db.version(1).stores({\n      // Carefully designed schema with proper indexes\n      users: "++id, email, [lastName+firstName], lastActiveAt",\n      sessions: "++id, userId, token, expiresAt",\n      cache: "key, data, expiresAt",\n    });\n\n    // Handle schema upgrades gracefully\n    this.db\n      .version(2)\n      .stores({\n        users: "++id, email, [lastName+firstName], lastActiveAt, preferences",\n      })\n      .upgrade((trans) => {\n        return trans.users.toCollection().modify((user) => {\n          user.preferences = {};\n        });\n      });\n  }\n\n  setupErrorHandling() {\n    this.db.use({\n      name: "ErrorHandler",\n      stack: "dbcore",\n      create: this.handleOperation("create"),\n      read: this.handleOperation("read"),\n      update: this.handleOperation("update"),\n      delete: this.handleOperation("delete"),\n    });\n  }\n\n  handleOperation(operationType) {\n    return (req) => {\n      return new Promise((resolve, reject) => {\n        try {\n          const result = req.operation.apply(req, req.args);\n\n          if (result && typeof result.then === "function") {\n            result.then(resolve).catch((error) => {\n              this.logError(operationType, error, req);\n              reject(error);\n            });\n          } else {\n            resolve(result);\n          }\n        } catch (error) {\n          this.logError(operationType, error, req);\n          reject(error);\n        }\n      });\n    };\n  }\n\n  logError(operation, error, request) {\n    console.error("Database operation failed:", {\n      operation,\n      error: error.message,\n      table: request.objectStoreName,\n      stack: error.stack,\n    });\n\n    // Send to error reporting service\n    if (window.errorReporter) {\n      window.errorReporter.captureException(error, {\n        tags: { operation, table: request.objectStoreName },\n      });\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"IndexedDB and Dexie.js represent a powerful combination for client-side data storage in modern web applications. IndexedDB provides the robust, transactional foundation with its sophisticated storage engine, while Dexie.js offers an elegant, developer-friendly interface that doesn't sacrifice performance or capabilities."}),"\n",(0,a.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"IndexedDB Architecture"}),": Understanding the underlying B+ tree structures, transaction management, and browser storage mechanisms helps in making informed design decisions."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Dexie's Value Proposition"}),": The wrapper doesn't just simplify the API\u2014it provides transaction management, query optimization, and error handling that would be complex to implement correctly with raw IndexedDB."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Performance Considerations"}),": Proper indexing strategies, transaction scoping, and memory management are crucial for production applications."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Browser Differences"}),": While IndexedDB is standardized, browser implementations vary in storage limits, eviction policies, and performance characteristics."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Future-Proofing"}),": Both technologies continue to evolve, with new features like partitioned storage, improved quota management, and enhanced debugging tools."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The combination of IndexedDB's power and Dexie's elegance provides a robust foundation for building sophisticated offline-first web applications with complex data requirements. Whether you're building a simple cache or a full-featured collaborative application, understanding both the underlying mechanisms and the abstraction layer ensures you can build performant, reliable data storage solutions."}),"\n",(0,a.jsx)(n.h3,{id:"further-reading",children:"Further Reading"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://dexie.org",children:"Dexie.js Official Documentation"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API",children:"IndexedDB API Reference"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/dexie/Dexie.js",children:"Dexie.js GitHub Repository"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API",children:"Web Storage API Documentation"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://web.dev/storage-for-the-web/",children:"Storage for the Web"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(6540);const a={},s=t.createContext(a);function i(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);