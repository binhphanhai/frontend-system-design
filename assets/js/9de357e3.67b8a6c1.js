"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8904],{4230:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"frontend-system-design/pinterest-summary","title":"09-pinterest: Summary","description":"---","source":"@site/docs/frontend-system-design/09-pinterest-summary.md","sourceDirName":"frontend-system-design","slug":"/frontend-system-design/pinterest-summary","permalink":"/frontend-system-design/docs/frontend-system-design/pinterest-summary","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/frontend-system-design/09-pinterest-summary.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{},"sidebar":"summarySidebar","previous":{"title":"08-autocomplete: Summary","permalink":"/frontend-system-design/docs/frontend-system-design/autocomplete-summary"},"next":{"title":"10-rich-text-editor: Summary","permalink":"/frontend-system-design/docs/frontend-system-design/rich-text-editor-summary"}}');var r=i(4848),t=i(8453);const l={},o="09-pinterest: Summary",a={},d=[];function c(n){const e={blockquote:"blockquote",br:"br",h1:"h1",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"09-pinterest-summary",children:"09-pinterest: Summary"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Interviewer\u2019s Intention"}),(0,r.jsx)(e.br,{}),"\n","Goal: Assess your ability to design a Pinterest-style grid/gallery UI that is performant, scalable, and user-friendly."]}),"\n",(0,r.jsx)(e.p,{children:"Want to see:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"If you can break down the layout, data flow, and state management."}),"\n",(0,r.jsx)(e.li,{children:"How you handle infinite scroll, image loading, and responsiveness at scale."}),"\n",(0,r.jsx)(e.li,{children:"If you consider SSR, virtualization, accessibility, and UX tradeoffs."}),"\n",(0,r.jsx)(e.li,{children:"How you justify design decisions and communicate alternatives."}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsxs)(e.p,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Answer Framework"})]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Clarify Requirements"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Grid layout: masonry, fixed, or responsive columns?"}),"\n",(0,r.jsx)(e.li,{children:"Infinite scroll or pagination?"}),"\n",(0,r.jsx)(e.li,{children:"Image loading: lazy, progressive, CDN?"}),"\n",(0,r.jsx)(e.li,{children:"Error/loading states, offline support?"}),"\n",(0,r.jsx)(e.li,{children:"Accessibility (keyboard, ARIA, color contrast)?"}),"\n",(0,r.jsx)(e.li,{children:"SSR/SEO for public galleries?"}),"\n",(0,r.jsx)(e.li,{children:"Filtering, sorting, or pinning features?"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Component & Data Flow Breakdown"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Grid container (manages layout, fetches data)"}),"\n",(0,r.jsx)(e.li,{children:"Pin item (renders image, handles actions: like, save, share)"}),"\n",(0,r.jsx)(e.li,{children:"Loader/skeleton (for loading states)"}),"\n",(0,r.jsx)(e.li,{children:"Error message (for fetch failures)"}),"\n",(0,r.jsx)(e.li,{children:"State: pins, loading, error, selected pin, filters"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"State Management & Data Fetching"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Local state for UI (loading, error, selected pin)"}),"\n",(0,r.jsx)(e.li,{children:"Global state for pins if shared (Redux, Zustand, Context)"}),"\n",(0,r.jsx)(e.li,{children:"Cursor-based pagination for infinite scroll"}),"\n",(0,r.jsx)(e.li,{children:"Caching strategies (SWR, React Query, CDN for images)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Performance & Scalability Solutions"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Virtualization/windowing"})," (react-window, react-virtualized) for large grids"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Lazy loading"}),' images (Intersection Observer, native loading="lazy")']}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Responsive columns"})," (CSS grid, media queries)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"SSR/SSG"})," for SEO and fast initial load (Next.js, Gatsby)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Skeleton screens"})," for perceived performance"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Image CDN"})," for fast delivery and optimization"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Accessibility & Testing"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"ARIA roles for grid and items"}),"\n",(0,r.jsx)(e.li,{children:"Keyboard navigation for grid and actions"}),"\n",(0,r.jsx)(e.li,{children:"Alt text for images, color contrast checks"}),"\n",(0,r.jsx)(e.li,{children:"Unit/integration tests for rendering, loading, and actions"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Tradeoffs & Alternatives"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"CSS grid vs. flexbox: grid is more flexible for masonry layouts"}),"\n",(0,r.jsx)(e.li,{children:"Infinite scroll vs. pagination: infinite scroll is more engaging, pagination is better for navigation/history"}),"\n",(0,r.jsx)(e.li,{children:"SSR vs. CSR: SSR for SEO, CSR for dynamic filtering/sorting"}),"\n",(0,r.jsx)(e.li,{children:"Client vs. server rendering: server for SEO, client for interactivity"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsxs)(e.p,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Example Content / Model Answer"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"\u201cFor a Pinterest-style grid, I\u2019d use CSS grid for layout, lazy load images with Intersection Observer, and virtualize the grid for performance. I\u2019d fetch pins with cursor-based pagination for infinite scroll, use skeleton screens for loading, and SSR for SEO. Accessibility would be ensured with ARIA roles, keyboard navigation, and alt text. Tradeoff: infinite scroll is more engaging but harder for SEO; I\u2019d update the URL with the current cursor for deep linking.\u201d"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Pro Tips / Common Pitfalls"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Don\u2019t forget responsive design, accessibility, and image optimization."}),"\n",(0,r.jsx)(e.li,{children:"Optimize image loading and grid rendering for large datasets."}),"\n",(0,r.jsx)(e.li,{children:"Test with slow networks, large galleries, and screen readers."}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function l(n){const e=s.useContext(t);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:l(n.components),s.createElement(t.Provider,{value:e},n.children)}}}]);