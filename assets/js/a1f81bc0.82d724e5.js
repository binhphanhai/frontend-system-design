"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6023],{7394:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"project-detail/web-worker","title":"Web Workers: Background Threading in the Browser","description":"Table of Contents","source":"@site/docs/project-detail/web-worker.md","sourceDirName":"project-detail","slug":"/project-detail/web-worker","permalink":"/frontend-system-design/docs/project-detail/web-worker","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/web-worker.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"WebSockets: Real-Time Communication Under the Hood","permalink":"/frontend-system-design/docs/project-detail/web-socket"},"next":{"title":"Service Workers: The Gateway to Progressive Web Apps","permalink":"/frontend-system-design/docs/project-detail/service-worker"}}');var s=r(4848),a=r(8453);const o={},i="Web Workers: Background Threading in the Browser",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Benefits",id:"key-benefits",level:3},{value:"Common Use Cases",id:"common-use-cases",level:3},{value:"Getting Started with Web Workers",id:"getting-started-with-web-workers",level:2},{value:"Browser Support Check",id:"browser-support-check",level:3},{value:"Basic Worker Implementation",id:"basic-worker-implementation",level:3},{value:"Main Thread (app.js)",id:"main-thread-appjs",level:4},{value:"Worker Script (worker.js)",id:"worker-script-workerjs",level:4},{value:"Types of Web Workers",id:"types-of-web-workers",level:2},{value:"Dedicated Workers",id:"dedicated-workers",level:3},{value:"Shared Workers",id:"shared-workers",level:3},{value:"Shared Worker Script (shared-worker.js)",id:"shared-worker-script-shared-workerjs",level:4},{value:"Using Shared Workers",id:"using-shared-workers",level:4},{value:"Under the Hood: Threading Model",id:"under-the-hood-threading-model",level:2},{value:"Browser Threading Architecture",id:"browser-threading-architecture",level:3},{value:"Worker Global Scope",id:"worker-global-scope",level:3},{value:"Message Passing and Data Transfer",id:"message-passing-and-data-transfer",level:2},{value:"Structured Clone Algorithm",id:"structured-clone-algorithm",level:3},{value:"Transferable Objects for Performance",id:"transferable-objects-for-performance",level:3},{value:"Advanced Message Handler",id:"advanced-message-handler",level:3},{value:"Worker Lifecycle Management",id:"worker-lifecycle-management",level:2},{value:"Worker Pool Implementation",id:"worker-pool-implementation",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Fibonacci Calculation Example",id:"fibonacci-calculation-example",level:3},{value:"Usage with Performance Monitoring",id:"usage-with-performance-monitoring",level:3},{value:"Real-World Implementation Examples",id:"real-world-implementation-examples",level:2},{value:"Image Processing Worker",id:"image-processing-worker",level:3},{value:"Error Handling and Debugging",id:"error-handling-and-debugging",level:2},{value:"Comprehensive Error Handling",id:"comprehensive-error-handling",level:3},{value:"Best Practices and Limitations",id:"best-practices-and-limitations",level:2},{value:"Best Practices",id:"best-practices",level:3},{value:"Limitations and Considerations",id:"limitations-and-considerations",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"When to Use Web Workers",id:"when-to-use-web-workers",level:3},{value:"Further Resources",id:"further-resources",level:3}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"web-workers-background-threading-in-the-browser",children:"Web Workers: Background Threading in the Browser"})}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getting-started-with-web-workers",children:"Getting Started with Web Workers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#types-of-web-workers",children:"Types of Web Workers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#under-the-hood-threading-model",children:"Under the Hood: Threading Model"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#message-passing-and-data-transfer",children:"Message Passing and Data Transfer"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#worker-lifecycle-management",children:"Worker Lifecycle Management"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#advanced-features-and-patterns",children:"Advanced Features and Patterns"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#real-world-implementation-examples",children:"Real-World Implementation Examples"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#error-handling-and-debugging",children:"Error Handling and Debugging"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#best-practices-and-limitations",children:"Best Practices and Limitations"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"Web Workers provide a way to run JavaScript code in background threads, separate from the main execution thread of a web page. This enables true parallel processing in web applications, allowing intensive computations to be performed without blocking the user interface."}),"\n",(0,s.jsxs)(n.p,{children:["As outlined in the ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers",children:"MDN Web Workers documentation"}),", Web Workers solve the fundamental problem of JavaScript's single-threaded nature by providing isolated execution contexts that can communicate with the main thread through message passing."]}),"\n",(0,s.jsx)(n.h3,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Non-blocking Operations"}),": Heavy computations don't freeze the UI"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"True Parallelism"}),": Multiple workers can run simultaneously"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Isolated Execution"}),": Workers can't accidentally interfere with the main thread"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network Access"}),": Workers can make HTTP requests independently"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Shared Processing"}),": Multiple scripts can share worker resources"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Image/video processing"}),"\n",(0,s.jsx)(n.li,{children:"Cryptographic operations"}),"\n",(0,s.jsx)(n.li,{children:"Data parsing and analysis"}),"\n",(0,s.jsx)(n.li,{children:"Background data synchronization"}),"\n",(0,s.jsx)(n.li,{children:"Real-time data processing"}),"\n",(0,s.jsx)(n.li,{children:"Mathematical calculations"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"getting-started-with-web-workers",children:"Getting Started with Web Workers"}),"\n",(0,s.jsx)(n.h3,{id:"browser-support-check",children:"Browser Support Check"}),"\n",(0,s.jsx)(n.p,{children:"Before implementing Web Workers, it's crucial to check if the browser supports this feature. Not all browsers (especially older ones) support Web Workers, so feature detection is essential for graceful degradation."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What this code does:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Checks if the ",(0,s.jsx)(n.code,{children:"Worker"})," constructor is available in the global scope"]}),"\n",(0,s.jsx)(n.li,{children:"Provides a boolean result that can be used for conditional logic"}),"\n",(0,s.jsx)(n.li,{children:"Allows you to implement fallback strategies for unsupported browsers"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," None (feature detection function)",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Output:"})," Boolean indicating Web Worker support",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"When to use:"})," At the start of your application or before creating any workers"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Feature detection for Web Workers\n// This function checks if the browser supports the Worker API\nfunction supportsWebWorkers() {\n  // Check if Worker constructor exists and is not undefined\n  // typeof returns "function" for constructors, "undefined" for missing features\n  return typeof Worker !== "undefined";\n}\n\n// Use the detection function to conditionally enable worker features\nif (supportsWebWorkers()) {\n  console.log("Web Workers are supported");\n  // Safe to proceed with Web Worker implementation\n  // Initialize your worker-based features here\n} else {\n  console.log("Web Workers are not supported");\n  // Provide fallback functionality for older browsers\n  // Could use setTimeout for async operations, or process data synchronously\n  // Example fallback: use requestAnimationFrame for chunked processing\n}\n\n// Alternative: More comprehensive feature detection\nfunction checkWorkerSupport() {\n  const features = {\n    webWorkers: typeof Worker !== "undefined",\n    sharedWorkers: typeof SharedWorker !== "undefined",\n    serviceWorkers: "serviceWorker" in navigator,\n    transferableObjects: typeof ArrayBuffer !== "undefined",\n  };\n\n  console.log("Browser support:", features);\n  return features;\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"basic-worker-implementation",children:"Basic Worker Implementation"}),"\n",(0,s.jsx)(n.p,{children:"This example demonstrates the fundamental pattern for creating and communicating with a Web Worker. The implementation consists of two parts: the main thread code that creates and manages the worker, and the worker script that runs in the background."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What this implementation does:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Creates a worker that runs independently from the main UI thread"}),"\n",(0,s.jsx)(n.li,{children:"Sends computational tasks to the worker without blocking the user interface"}),"\n",(0,s.jsx)(n.li,{children:"Receives results back from the worker and updates the UI"}),"\n",(0,s.jsx)(n.li,{children:"Handles errors gracefully to prevent application crashes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Communication Flow:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Main thread creates worker and sends initial data"}),"\n",(0,s.jsx)(n.li,{children:"Worker receives data, processes it, and sends results back"}),"\n",(0,s.jsx)(n.li,{children:"Main thread receives results and updates the UI"}),"\n",(0,s.jsx)(n.li,{children:"Error handlers catch and manage any issues that occur"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"main-thread-appjs",children:"Main Thread (app.js)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," Array of numbers to process",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Output:"})," Processed result displayed in the UI",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Purpose:"})," Coordinates worker creation, data sending, and result handling"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Check for Web Worker support before attempting to create one\nif (window.Worker) {\n  // Step 1: Create a new worker instance\n  // The worker will load and execute the specified JavaScript file\n  const worker = new Worker("worker.js");\n\n  // Step 2: Send data to worker using postMessage\n  // The data is serialized using the structured clone algorithm\n  // This example sends a command object with task instructions and data array\n  worker.postMessage({\n    command: "start", // Task identifier for the worker\n    data: [1, 2, 3, 4, 5], // Array of numbers to process\n  });\n\n  // Step 3: Listen for messages from worker\n  // The worker will send results back using postMessage\n  worker.onmessage = function (event) {\n    console.log("Message from worker:", event.data);\n\n    // Update the UI with the processed result\n    // event.data contains the worker\'s response\n    const resultElement = document.getElementById("result");\n    if (resultElement) {\n      // Display the result (could be a number, object, or formatted string)\n      resultElement.textContent = JSON.stringify(event.data);\n    }\n  };\n\n  // Step 4: Handle worker runtime errors\n  // This catches errors that occur during worker execution\n  worker.onerror = function (error) {\n    console.error("Worker error:", {\n      message: error.message, // Error description\n      filename: error.filename, // File where error occurred\n      lineno: error.lineno, // Line number of error\n    });\n\n    // Optionally show user-friendly error message\n    const resultElement = document.getElementById("result");\n    if (resultElement) {\n      resultElement.textContent = "Processing failed. Please try again.";\n    }\n  };\n\n  // Step 5: Handle message serialization errors\n  // This occurs when data cannot be cloned between threads\n  worker.onmessageerror = function (event) {\n    console.error("Message serialization error:", event);\n    // This typically happens when trying to send functions or DOM elements\n  };\n\n  // Optional: Clean up worker when page unloads\n  window.addEventListener("beforeunload", () => {\n    worker.terminate(); // Immediately stop the worker\n  });\n} else {\n  console.log("Web Workers not supported");\n  // Fallback: Process data synchronously on main thread\n  processDataSynchronously([1, 2, 3, 4, 5]);\n}\n\n// Fallback function for browsers without Web Worker support\nfunction processDataSynchronously(data) {\n  const result = data.reduce((sum, num) => sum + num * num, 0);\n  document.getElementById("result").textContent = result;\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"worker-script-workerjs",children:"Worker Script (worker.js)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Runs computationally intensive tasks in background without blocking the UI",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Input:"})," Command objects with task instructions and data",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Output:"})," Processed results sent back to main thread",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Key Features:"})," Command routing, error handling, and self-termination capability"]}),"\n",(0,s.jsx)(n.p,{children:"This worker script demonstrates a command-based architecture that can handle multiple types of operations. It runs in the WorkerGlobalScope, which is isolated from the main thread and doesn't have access to DOM or window objects."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Worker global scope - isolated from main thread\n// No access to DOM, window, or parent objects\n// \'self\' refers to the WorkerGlobalScope\nconsole.log("Worker started and ready to receive commands");\n\n// Step 1: Set up message listener for communication with main thread\n// This is the primary way the worker receives instructions and data\nself.onmessage = function (event) {\n  console.log("Worker received message:", event.data);\n\n  // Extract command and data from the message object\n  // This uses destructuring to get specific properties\n  const { command, data } = event.data;\n\n  // Step 2: Route commands to appropriate handlers\n  // Using a switch statement for clear command routing\n  switch (command) {\n    case "start":\n      // Process the data and send result back to main thread\n      const result = processData(data);\n      self.postMessage(result);\n      break;\n\n    case "stop":\n      // Gracefully terminate the worker from inside\n      console.log("Worker stopping...");\n      self.close(); // This terminates the worker\n      break;\n\n    case "ping":\n      // Simple health check command\n      self.postMessage({ status: "alive", timestamp: Date.now() });\n      break;\n\n    default:\n      // Handle unknown commands gracefully\n      console.error("Unknown command received:", command);\n      self.postMessage({\n        error: `Unknown command: ${command}`,\n        availableCommands: ["start", "stop", "ping"],\n      });\n  }\n};\n\n// Step 3: Core data processing function\n// This simulates a CPU-intensive operation that would block the UI if run on main thread\nfunction processData(numbers) {\n  console.log(`Processing ${numbers.length} numbers...`);\n\n  // Validate input data\n  if (!Array.isArray(numbers)) {\n    throw new Error("Input must be an array of numbers");\n  }\n\n  // Start performance measurement\n  const startTime = performance.now();\n\n  // Simulate intensive computation: sum of squares\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    // Validate each number\n    if (typeof numbers[i] !== "number") {\n      throw new Error(`Invalid number at index ${i}: ${numbers[i]}`);\n    }\n\n    sum += numbers[i] * numbers[i];\n\n    // Simulate heavy computational work\n    // This would normally be your actual complex algorithm\n    for (let j = 0; j < 1000000; j++) {\n      Math.random(); // CPU-intensive operation\n    }\n\n    // Optional: Report progress for long operations\n    if (i % 10 === 0 && numbers.length > 10) {\n      self.postMessage({\n        type: "progress",\n        completed: i,\n        total: numbers.length,\n        percentage: Math.round((i / numbers.length) * 100),\n      });\n    }\n  }\n\n  // Calculate processing time\n  const endTime = performance.now();\n  const processingTime = endTime - startTime;\n\n  console.log(`Processing completed in ${processingTime.toFixed(2)}ms`);\n\n  // Return comprehensive result object\n  return {\n    type: "result",\n    result: sum,\n    processed: numbers.length,\n    processingTime: processingTime,\n    average: sum / numbers.length,\n    timestamp: Date.now(),\n  };\n}\n\n// Step 4: Global error handler for the worker\n// This catches any unhandled errors in the worker script\nself.onerror = function (error) {\n  console.error("Unhandled error in worker:", {\n    message: error.message,\n    filename: error.filename,\n    lineno: error.lineno,\n    colno: error.colno,\n  });\n\n  // Send error information back to main thread\n  self.postMessage({\n    type: "error",\n    error: error.message,\n    details: {\n      filename: error.filename,\n      line: error.lineno,\n      column: error.colno,\n    },\n  });\n};\n\n// Step 5: Handle unhandled promise rejections\n// Important for async operations within the worker\nself.addEventListener("unhandledrejection", function (event) {\n  console.error("Unhandled promise rejection in worker:", event.reason);\n\n  self.postMessage({\n    type: "error",\n    error: "Unhandled promise rejection",\n    details: event.reason,\n  });\n\n  // Prevent the default handling\n  event.preventDefault();\n});\n\n// Optional: Worker initialization code\n// This runs when the worker is first loaded\n(function initializeWorker() {\n  console.log("Worker initialized successfully");\n\n  // Send ready signal to main thread\n  self.postMessage({\n    type: "ready",\n    capabilities: ["start", "stop", "ping"],\n    workerInfo: {\n      userAgent: navigator.userAgent,\n      language: navigator.language,\n      onLine: navigator.onLine,\n    },\n  });\n})();\n'})}),"\n",(0,s.jsx)(n.h2,{id:"types-of-web-workers",children:"Types of Web Workers"}),"\n",(0,s.jsx)(n.h3,{id:"dedicated-workers",children:"Dedicated Workers"}),"\n",(0,s.jsx)(n.p,{children:"Dedicated workers are bound to a single script/context and provide isolated execution environments. Unlike shared workers, they can only communicate with the script that created them. This class-based approach provides a clean, Promise-based API for worker communication."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What this implementation provides:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Promise-based worker communication (async/await support)"}),"\n",(0,s.jsx)(n.li,{children:"Automatic message ID tracking to match requests with responses"}),"\n",(0,s.jsx)(n.li,{children:"Proper cleanup and error handling"}),"\n",(0,s.jsx)(n.li,{children:"Simplified API that abstracts away the complexity of worker messaging"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"CPU-intensive calculations for a specific component"}),"\n",(0,s.jsx)(n.li,{children:"Data processing tasks that need dedicated resources"}),"\n",(0,s.jsx)(n.li,{children:"Image/video processing workflows"}),"\n",(0,s.jsx)(n.li,{children:"Mathematical computations that shouldn't block the UI"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," Worker script path, commands, and data objects",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Output:"})," Promise-wrapped results from worker execution",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Key Features:"})," Message correlation, error propagation, resource cleanup"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Advanced worker manager with Promise-based API and message correlation\nclass DedicatedWorkerManager {\n  constructor(workerScript) {\n    // Initialize the worker with the specified script\n    this.worker = new Worker(workerScript);\n\n    // Message tracking for correlating requests with responses\n    this.messageId = 0; // Counter for unique message IDs\n    this.pendingMessages = new Map(); // Store Promise resolvers/rejectors\n\n    // Set up communication handlers\n    this.setupEventHandlers();\n\n    console.log(`Dedicated worker created: ${workerScript}`);\n  }\n\n  setupEventHandlers() {\n    // Handle messages from worker\n    this.worker.onmessage = (event) => {\n      const { messageId, result, error, type } = event.data;\n\n      // Handle different message types\n      if (type === "progress") {\n        // Handle progress updates (optional)\n        this.handleProgress(event.data);\n        return;\n      }\n\n      // Find the corresponding pending message\n      if (this.pendingMessages.has(messageId)) {\n        const { resolve, reject, timestamp } =\n          this.pendingMessages.get(messageId);\n\n        // Calculate response time for performance monitoring\n        const responseTime = Date.now() - timestamp;\n        console.log(`Worker response received in ${responseTime}ms`);\n\n        // Clean up the pending message\n        this.pendingMessages.delete(messageId);\n\n        // Resolve or reject the Promise based on worker response\n        if (error) {\n          reject(new Error(error));\n        } else {\n          resolve(result);\n        }\n      } else {\n        console.warn("Received message with unknown ID:", messageId);\n      }\n    };\n\n    // Handle worker runtime errors\n    this.worker.onerror = (error) => {\n      console.error("Worker runtime error:", {\n        message: error.message,\n        filename: error.filename,\n        lineno: error.lineno,\n      });\n\n      // Reject all pending messages since worker is in error state\n      this.rejectAllPending(new Error(`Worker error: ${error.message}`));\n    };\n\n    // Handle message serialization errors\n    this.worker.onmessageerror = (event) => {\n      console.error("Worker message serialization error:", event);\n      this.rejectAllPending(new Error("Message serialization failed"));\n    };\n  }\n\n  // Promise-based execution method\n  async execute(command, data, options = {}) {\n    return new Promise((resolve, reject) => {\n      // Generate unique message ID\n      const messageId = ++this.messageId;\n      const timestamp = Date.now();\n\n      // Store Promise resolvers for later use\n      this.pendingMessages.set(messageId, {\n        resolve,\n        reject,\n        timestamp,\n        command,\n        timeout: options.timeout || 30000, // Default 30 second timeout\n      });\n\n      // Set up timeout to prevent hanging promises\n      setTimeout(() => {\n        if (this.pendingMessages.has(messageId)) {\n          this.pendingMessages.delete(messageId);\n          reject(\n            new Error(`Worker timeout after ${options.timeout || 30000}ms`)\n          );\n        }\n      }, options.timeout || 30000);\n\n      // Send message to worker\n      this.worker.postMessage({\n        messageId, // For response correlation\n        command, // Operation to perform\n        data, // Data to process\n        options, // Additional options\n      });\n\n      console.log(`Sent command \'${command}\' to worker with ID ${messageId}`);\n    });\n  }\n\n  // Handle progress updates from worker\n  handleProgress(progressData) {\n    const { messageId, completed, total, percentage } = progressData;\n\n    if (this.pendingMessages.has(messageId)) {\n      // Emit progress event if listeners are set up\n      this.emit("progress", {\n        completed,\n        total,\n        percentage,\n        messageId,\n      });\n    }\n  }\n\n  // Utility method to reject all pending messages\n  rejectAllPending(error) {\n    this.pendingMessages.forEach(({ reject, command }, messageId) => {\n      console.log(`Rejecting pending command \'${command}\' (ID: ${messageId})`);\n      reject(error);\n    });\n    this.pendingMessages.clear();\n  }\n\n  // Clean shutdown of the worker\n  terminate() {\n    console.log("Terminating dedicated worker...");\n\n    // Reject all pending messages before termination\n    this.rejectAllPending(new Error("Worker terminated"));\n\n    // Terminate the worker\n    this.worker.terminate();\n\n    console.log("Worker terminated successfully");\n  }\n\n  // Check if worker has pending operations\n  hasPendingOperations() {\n    return this.pendingMessages.size > 0;\n  }\n\n  // Get statistics about worker usage\n  getStats() {\n    return {\n      pendingMessages: this.pendingMessages.size,\n      totalMessagesSent: this.messageId,\n      isActive: !!this.worker,\n    };\n  }\n\n  // Simple event emitter for progress updates\n  emit(event, data) {\n    if (this.listeners && this.listeners[event]) {\n      this.listeners[event].forEach((callback) => callback(data));\n    }\n  }\n\n  // Add event listener for progress updates\n  on(event, callback) {\n    if (!this.listeners) this.listeners = {};\n    if (!this.listeners[event]) this.listeners[event] = [];\n    this.listeners[event].push(callback);\n  }\n}\n\n// Example usage of the DedicatedWorkerManager\n/*\nconst workerManager = new DedicatedWorkerManager(\'math-worker.js\');\n\n// Listen for progress updates\nworkerManager.on(\'progress\', (progress) => {\n  console.log(`Progress: ${progress.percentage}%`);\n});\n\n// Execute commands with async/await\ntry {\n  const result = await workerManager.execute(\'fibonacci\', { n: 40 });\n  console.log(\'Fibonacci result:\', result);\n} catch (error) {\n  console.error(\'Worker execution failed:\', error);\n}\n\n// Clean up when done\nworkerManager.terminate();\n*/\n'})}),"\n",(0,s.jsx)(n.h3,{id:"shared-workers",children:"Shared Workers"}),"\n",(0,s.jsx)(n.p,{children:"Shared workers enable multiple browser contexts (tabs, iframes, windows) to communicate with a single worker instance. This is powerful for cross-tab communication, shared state management, and coordinating activities across multiple parts of a web application."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key advantages of Shared Workers:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Single worker instance shared across multiple browser contexts"}),"\n",(0,s.jsx)(n.li,{children:"Persistent state that survives tab navigation and closing"}),"\n",(0,s.jsx)(n.li,{children:"Real-time synchronization between different tabs/windows"}),"\n",(0,s.jsx)(n.li,{children:"Resource efficiency by avoiding duplicate worker instances"}),"\n",(0,s.jsx)(n.li,{children:"Central coordination hub for distributed web app features"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common use cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Live chat systems that sync across tabs"}),"\n",(0,s.jsx)(n.li,{children:"Real-time collaborative features (like Google Docs)"}),"\n",(0,s.jsx)(n.li,{children:"Cross-tab notification systems"}),"\n",(0,s.jsx)(n.li,{children:"Shared caching and data synchronization"}),"\n",(0,s.jsx)(n.li,{children:"Multi-tab shopping cart management"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"shared-worker-script-shared-workerjs",children:"Shared Worker Script (shared-worker.js)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Central hub that manages connections from multiple browser contexts",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Input:"})," Action-based messages from connected ports",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Output:"})," Broadcasted updates to all connected contexts",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"State Management:"})," Persistent shared data across all connections"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Shared worker maintains connections and shared state\nconst connections = []; // Array to track all active port connections\nlet sharedData = {\n  // Centralized data shared across all contexts\n  counter: 0, // Example counter that all tabs can modify\n  messages: [], // Chat-like message system\n  activeUsers: new Set(), // Track active users across tabs\n  lastActivity: Date.now(), // Track when worker was last active\n};\n\n// Handle new connections from browser contexts (tabs, iframes, etc.)\nself.onconnect = function (event) {\n  // Get the MessagePort for this new connection\n  const port = event.ports[0];\n\n  // Generate unique connection ID for tracking\n  const connectionId = `conn_${Date.now()}_${Math.random()\n    .toString(36)\n    .substr(2, 9)}`;\n\n  // Store connection with metadata\n  const connectionInfo = {\n    port: port,\n    id: connectionId,\n    connectedAt: Date.now(),\n    lastSeen: Date.now(),\n    userAgent: "unknown", // Could be passed from client\n  };\n\n  connections.push(connectionInfo);\n  console.log(\n    `New connection established: ${connectionId} (Total: ${connections.length})`\n  );\n\n  // Set up message handler for this specific port\n  port.onmessage = function (event) {\n    const { action, data, userId } = event.data;\n\n    // Update last seen timestamp for this connection\n    connectionInfo.lastSeen = Date.now();\n    sharedData.lastActivity = Date.now();\n\n    // Route actions to appropriate handlers\n    switch (action) {\n      case "increment":\n        // Increment shared counter and broadcast to all connected tabs\n        sharedData.counter++;\n        console.log(\n          `Counter incremented to ${sharedData.counter} by ${connectionId}`\n        );\n\n        broadcastToAllPorts({\n          type: "counter",\n          value: sharedData.counter,\n          updatedBy: connectionId,\n          timestamp: Date.now(),\n        });\n        break;\n\n      case "addMessage":\n        // Add message to shared chat and broadcast to all tabs\n        const message = {\n          id: `msg_${Date.now()}`,\n          content: data,\n          author: userId || "Anonymous",\n          timestamp: Date.now(),\n          connectionId: connectionId,\n        };\n\n        sharedData.messages.push(message);\n        console.log(`New message added: ${message.content}`);\n\n        // Limit message history to prevent memory growth\n        if (sharedData.messages.length > 100) {\n          sharedData.messages = sharedData.messages.slice(-50); // Keep last 50\n        }\n\n        broadcastToAllPorts({\n          type: "newMessage",\n          message: message,\n        });\n        break;\n\n      case "getData":\n        // Send current shared data only to requesting port\n        port.postMessage({\n          type: "data",\n          data: sharedData,\n          connectionInfo: {\n            id: connectionId,\n            totalConnections: connections.length,\n          },\n        });\n        break;\n\n      case "setUser":\n        // Track active users across tabs\n        if (data.userId) {\n          sharedData.activeUsers.add(data.userId);\n          connectionInfo.userId = data.userId;\n\n          broadcastToAllPorts({\n            type: "userUpdate",\n            activeUsers: Array.from(sharedData.activeUsers),\n            action: "joined",\n            userId: data.userId,\n          });\n        }\n        break;\n\n      case "ping":\n        // Health check - respond only to sender\n        port.postMessage({\n          type: "pong",\n          timestamp: Date.now(),\n          connectionId: connectionId,\n        });\n        break;\n\n      default:\n        console.warn(`Unknown action received: ${action}`);\n        port.postMessage({\n          type: "error",\n          error: `Unknown action: ${action}`,\n          availableActions: [\n            "increment",\n            "addMessage",\n            "getData",\n            "setUser",\n            "ping",\n          ],\n        });\n    }\n  };\n\n  // Handle port disconnection\n  port.onmessageerror = function (event) {\n    console.error(`Message error on connection ${connectionId}:`, event);\n    removeConnection(connectionId);\n  };\n\n  // Start the port communication\n  port.start();\n\n  // Send initial connection confirmation with current state\n  port.postMessage({\n    type: "connected",\n    data: sharedData,\n    connectionId: connectionId,\n    totalConnections: connections.length,\n  });\n};\n\n// Broadcast message to all connected ports\nfunction broadcastToAllPorts(message) {\n  console.log(\n    `Broadcasting to ${connections.length} connections:`,\n    message.type\n  );\n\n  // Iterate through all connections and send message\n  connections.forEach((connectionInfo, index) => {\n    try {\n      connectionInfo.port.postMessage(message);\n    } catch (error) {\n      // Port might be closed - remove it from connections\n      console.warn(\n        `Failed to send message to connection ${connectionInfo.id}:`,\n        error\n      );\n      connections.splice(index, 1);\n\n      // Clean up user data if connection had a user\n      if (connectionInfo.userId) {\n        sharedData.activeUsers.delete(connectionInfo.userId);\n\n        // Notify other connections about user leaving\n        broadcastToAllPorts({\n          type: "userUpdate",\n          activeUsers: Array.from(sharedData.activeUsers),\n          action: "left",\n          userId: connectionInfo.userId,\n        });\n      }\n    }\n  });\n}\n\n// Remove specific connection\nfunction removeConnection(connectionId) {\n  const index = connections.findIndex((conn) => conn.id === connectionId);\n  if (index !== -1) {\n    const removedConnection = connections.splice(index, 1)[0];\n    console.log(`Connection removed: ${connectionId}`);\n\n    // Clean up associated user data\n    if (removedConnection.userId) {\n      sharedData.activeUsers.delete(removedConnection.userId);\n    }\n  }\n}\n\n// Periodic cleanup of stale connections (every 30 seconds)\nsetInterval(() => {\n  const now = Date.now();\n  const staleThreshold = 60000; // 1 minute\n\n  const staleConnections = connections.filter(\n    (conn) => now - conn.lastSeen > staleThreshold\n  );\n\n  staleConnections.forEach((conn) => {\n    console.log(`Removing stale connection: ${conn.id}`);\n    removeConnection(conn.id);\n  });\n\n  if (staleConnections.length > 0) {\n    console.log(`Cleaned up ${staleConnections.length} stale connections`);\n  }\n}, 30000);\n\n// Log worker status periodically\nsetInterval(() => {\n  console.log(\n    `Shared Worker Status: ${connections.length} active connections, ${sharedData.activeUsers.size} active users`\n  );\n}, 60000);\n'})}),"\n",(0,s.jsx)(n.h4,{id:"using-shared-workers",children:"Using Shared Workers"}),"\n",(0,s.jsx)(n.p,{children:"This client class provides a clean interface for connecting to and communicating with shared workers. Multiple instances of this class (across different tabs/windows) will all connect to the same shared worker instance, enabling real-time cross-tab synchronization."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What this client provides:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Clean API for shared worker communication"}),"\n",(0,s.jsx)(n.li,{children:"Automatic reconnection handling"}),"\n",(0,s.jsx)(n.li,{children:"Event-driven architecture for real-time updates"}),"\n",(0,s.jsx)(n.li,{children:"Type-safe message handling"}),"\n",(0,s.jsx)(n.li,{children:"Connection lifecycle management"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," User actions and data from the browser context",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Output:"})," UI updates based on shared worker state changes",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Key Features:"})," Real-time synchronization, connection management, error recovery"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Client class for connecting to and communicating with shared workers\nclass SharedWorkerClient {\n  constructor(userId = null) {\n    this.userId =\n      userId || `user_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;\n    this.connectionId = null;\n    this.isConnected = false;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000; // Start with 1 second delay\n\n    this.initializeWorker();\n  }\n\n  initializeWorker() {\n    try {\n      // Create connection to shared worker\n      this.worker = new SharedWorker("shared-worker.js");\n      this.port = this.worker.port;\n\n      // Set up event handlers\n      this.setupEventHandlers();\n\n      console.log("Attempting to connect to shared worker...");\n    } catch (error) {\n      console.error("Failed to create shared worker:", error);\n      this.handleConnectionError(error);\n    }\n  }\n\n  setupEventHandlers() {\n    // Handle messages from shared worker\n    this.port.onmessage = (event) => {\n      const { type, data, value, message, connectionId, totalConnections } =\n        event.data;\n\n      // Handle different message types from shared worker\n      switch (type) {\n        case "connected":\n          // Successfully connected to shared worker\n          this.connectionId = connectionId;\n          this.isConnected = true;\n          this.reconnectAttempts = 0;\n\n          console.log(`Connected to shared worker as ${connectionId}`);\n          console.log(`Total connections: ${totalConnections}`);\n          console.log("Initial shared data:", data);\n\n          // Initialize UI with current state\n          this.initializeUI(data);\n\n          // Register this user with the shared worker\n          this.setUser(this.userId);\n          break;\n\n        case "counter":\n          // Counter value updated by another tab\n          console.log(`Counter updated to ${value} by ${event.data.updatedBy}`);\n          this.updateCounter(value);\n\n          // Visual feedback for updates from other tabs\n          if (event.data.updatedBy !== this.connectionId) {\n            this.showUpdateNotification("Counter updated by another tab");\n          }\n          break;\n\n        case "newMessage":\n          // New message added by any connected tab\n          console.log("New message received:", message);\n          this.displayMessage(message);\n\n          // Show notification if message is from another tab\n          if (message.connectionId !== this.connectionId) {\n            this.showUpdateNotification(`New message from ${message.author}`);\n          }\n          break;\n\n        case "userUpdate":\n          // Active users list updated\n          console.log(`User ${event.data.action}: ${event.data.userId}`);\n          this.updateActiveUsers(event.data.activeUsers);\n          break;\n\n        case "data":\n          // Response to getData request\n          console.log("Received current shared data:", data);\n          this.updateAllUI(data);\n          break;\n\n        case "pong":\n          // Health check response\n          console.log(\n            `Health check OK (${Date.now() - event.data.timestamp}ms)`\n          );\n          break;\n\n        case "error":\n          // Error from shared worker\n          console.error("Shared worker error:", event.data.error);\n          this.handleWorkerError(event.data.error);\n          break;\n\n        default:\n          console.warn("Unknown message type:", type);\n      }\n    };\n\n    // Handle connection errors\n    this.port.onmessageerror = (event) => {\n      console.error("Port message error:", event);\n      this.handleConnectionError(event);\n    };\n\n    // Start the port communication\n    this.port.start();\n  }\n\n  // Initialize UI elements with current shared state\n  initializeUI(data) {\n    this.updateCounter(data.counter);\n\n    // Display existing messages\n    data.messages.forEach((message) => {\n      this.displayMessage(message);\n    });\n\n    // Update active users\n    this.updateActiveUsers(Array.from(data.activeUsers));\n  }\n\n  // Update entire UI with fresh data\n  updateAllUI(data) {\n    // Clear existing messages\n    const messagesList = document.getElementById("messages");\n    if (messagesList) {\n      messagesList.innerHTML = "";\n    }\n\n    // Reinitialize with fresh data\n    this.initializeUI(data);\n  }\n\n  // Send increment command to shared worker\n  increment() {\n    if (!this.isConnected) {\n      console.warn("Not connected to shared worker");\n      return;\n    }\n\n    console.log("Sending increment command");\n    this.port.postMessage({ action: "increment" });\n  }\n\n  // Send new message to shared worker\n  addMessage(messageContent) {\n    if (!this.isConnected) {\n      console.warn("Not connected to shared worker");\n      return;\n    }\n\n    if (!messageContent.trim()) {\n      console.warn("Cannot send empty message");\n      return;\n    }\n\n    console.log("Sending new message:", messageContent);\n    this.port.postMessage({\n      action: "addMessage",\n      data: messageContent,\n      userId: this.userId,\n    });\n  }\n\n  // Request current data from shared worker\n  getData() {\n    if (!this.isConnected) {\n      console.warn("Not connected to shared worker");\n      return;\n    }\n\n    console.log("Requesting current data");\n    this.port.postMessage({ action: "getData" });\n  }\n\n  // Register user with shared worker\n  setUser(userId) {\n    this.userId = userId;\n    this.port.postMessage({\n      action: "setUser",\n      data: { userId: userId },\n    });\n  }\n\n  // Health check\n  ping() {\n    if (!this.isConnected) {\n      console.warn("Not connected to shared worker");\n      return;\n    }\n\n    this.port.postMessage({ action: "ping" });\n  }\n\n  // UI update methods\n  updateCounter(value) {\n    const counterElement = document.getElementById("counter");\n    if (counterElement) {\n      counterElement.textContent = value;\n\n      // Add visual feedback for updates\n      counterElement.classList.add("updated");\n      setTimeout(() => counterElement.classList.remove("updated"), 500);\n    }\n  }\n\n  displayMessage(message) {\n    const messagesList = document.getElementById("messages");\n    if (!messagesList) return;\n\n    // Create message element\n    const messageElement = document.createElement("div");\n    messageElement.className = "message";\n\n    // Style differently if it\'s from current tab\n    if (message.connectionId === this.connectionId) {\n      messageElement.classList.add("own-message");\n    }\n\n    // Format message content\n    messageElement.innerHTML = `\n      <div class="message-header">\n        <span class="author">${message.author}</span>\n        <span class="timestamp">${new Date(\n          message.timestamp\n        ).toLocaleTimeString()}</span>\n      </div>\n      <div class="message-content">${message.content}</div>\n    `;\n\n    messagesList.appendChild(messageElement);\n    messagesList.scrollTop = messagesList.scrollHeight; // Auto-scroll to bottom\n  }\n\n  updateActiveUsers(users) {\n    const usersElement = document.getElementById("active-users");\n    if (usersElement) {\n      usersElement.innerHTML = `Active users: ${users.join(", ")}`;\n    }\n  }\n\n  showUpdateNotification(message) {\n    // Simple notification system\n    const notification = document.createElement("div");\n    notification.className = "notification";\n    notification.textContent = message;\n\n    document.body.appendChild(notification);\n\n    // Auto-remove after 3 seconds\n    setTimeout(() => {\n      document.body.removeChild(notification);\n    }, 3000);\n  }\n\n  // Error handling and reconnection\n  handleConnectionError(error) {\n    console.error("Connection error:", error);\n    this.isConnected = false;\n\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      const delay =\n        this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1); // Exponential backoff\n\n      console.log(\n        `Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`\n      );\n\n      setTimeout(() => {\n        this.initializeWorker();\n      }, delay);\n    } else {\n      console.error(\n        "Max reconnection attempts reached. Please refresh the page."\n      );\n      this.showUpdateNotification("Connection lost. Please refresh the page.");\n    }\n  }\n\n  handleWorkerError(error) {\n    console.error("Worker error:", error);\n    this.showUpdateNotification("Worker error occurred");\n  }\n\n  // Clean disconnect\n  disconnect() {\n    if (this.port) {\n      this.port.close();\n    }\n    this.isConnected = false;\n    console.log("Disconnected from shared worker");\n  }\n\n  // Get connection status\n  getStatus() {\n    return {\n      isConnected: this.isConnected,\n      connectionId: this.connectionId,\n      userId: this.userId,\n      reconnectAttempts: this.reconnectAttempts,\n    };\n  }\n}\n\n// Example usage and initialization\n/*\n// Create client instance with optional user ID\nconst sharedClient = new SharedWorkerClient(\'user123\');\n\n// Set up UI event handlers\ndocument.getElementById(\'increment-btn\').addEventListener(\'click\', () => {\n  sharedClient.increment();\n});\n\ndocument.getElementById(\'send-message-btn\').addEventListener(\'click\', () => {\n  const input = document.getElementById(\'message-input\');\n  if (input.value.trim()) {\n    sharedClient.addMessage(input.value);\n    input.value = \'\';\n  }\n});\n\n// Refresh data button\ndocument.getElementById(\'refresh-btn\').addEventListener(\'click\', () => {\n  sharedClient.getData();\n});\n\n// Health check button\ndocument.getElementById(\'ping-btn\').addEventListener(\'click\', () => {\n  sharedClient.ping();\n});\n\n// Clean up on page unload\nwindow.addEventListener(\'beforeunload\', () => {\n  sharedClient.disconnect();\n});\n*/\n'})}),"\n",(0,s.jsx)(n.h2,{id:"under-the-hood-threading-model",children:"Under the Hood: Threading Model"}),"\n",(0,s.jsx)(n.h3,{id:"browser-threading-architecture",children:"Browser Threading Architecture"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Browser Process                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Main Thread              \u2502      Worker Threads         \u2502\n\u2502  \u251c\u2500\u2500\u2500 DOM Manipulation    \u2502      \u251c\u2500\u2500\u2500 Worker 1          \u2502\n\u2502  \u251c\u2500\u2500\u2500 Event Handling      \u2502      \u251c\u2500\u2500\u2500 Worker 2          \u2502\n\u2502  \u251c\u2500\u2500\u2500 JavaScript Engine   \u2502      \u251c\u2500\u2500\u2500 Worker N          \u2502\n\u2502  \u2514\u2500\u2500\u2500 Rendering Pipeline  \u2502      \u2514\u2500\u2500\u2500 Shared Workers    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502              Message Passing Layer                      \u2502\n\u2502              (Structured Clone Algorithm)               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h3,{id:"worker-global-scope",children:"Worker Global Scope"}),"\n",(0,s.jsx)(n.p,{children:"Workers run in a different global context than the main thread:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// In worker context - these are available\nconsole.log(self); // WorkerGlobalScope\nconsole.log(location); // WorkerLocation\nconsole.log(navigator); // WorkerNavigator\n\n// These are NOT available in workers\n// console.log(window); // undefined\n// console.log(document); // undefined\n// console.log(parent); // undefined\n\n// Worker-specific APIs available\nimportScripts("https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js");\n\n// Network requests are available\nfetch("/api/data")\n  .then((response) => response.json())\n  .then((data) => {\n    self.postMessage({ type: "dataLoaded", data });\n  });\n\n// IndexedDB is available for storage\nconst request = indexedDB.open("WorkerDB", 1);\nrequest.onsuccess = (event) => {\n  const db = event.target.result;\n  // Use IndexedDB in worker\n};\n'})}),"\n",(0,s.jsx)(n.h2,{id:"message-passing-and-data-transfer",children:"Message Passing and Data Transfer"}),"\n",(0,s.jsx)(n.h3,{id:"structured-clone-algorithm",children:"Structured Clone Algorithm"}),"\n",(0,s.jsx)(n.p,{children:"The structured clone algorithm is the browser's mechanism for safely transferring data between different execution contexts (like main thread to worker). Understanding what can and cannot be transferred is crucial for effective worker communication."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Creates a deep copy of the data structure"}),"\n",(0,s.jsx)(n.li,{children:"Maintains object references and circular dependencies"}),"\n",(0,s.jsx)(n.li,{children:"Preserves most built-in JavaScript types"}),"\n",(0,s.jsx)(n.li,{children:"Throws errors for non-cloneable data types"}),"\n",(0,s.jsx)(n.li,{children:"More robust than JSON.stringify/parse for complex objects"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance considerations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cloning large objects can be expensive"}),"\n",(0,s.jsx)(n.li,{children:"Complex nested structures take longer to clone"}),"\n",(0,s.jsx)(n.li,{children:"Use transferable objects for large binary data"}),"\n",(0,s.jsx)(n.li,{children:"Consider sending only necessary data to minimize clone overhead"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," Any cloneable JavaScript value",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Output:"})," Deep copy of the input in the target context",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Limitations:"})," Cannot clone functions, DOM elements, or other non-serializable objects"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Comprehensive example of data types and their cloning behavior\nconst transferableData = {\n  // \u2705 Primitive types - these clone perfectly\n  string: "Hello World",\n  number: 42,\n  bigint: 123n, // BigInt support varies by browser\n  boolean: true,\n  null: null,\n  undefined: undefined,\n\n  // \u2705 Basic objects and arrays\n  object: {\n    key: "value",\n    nested: {\n      data: true,\n      deepNesting: {\n        level3: "works fine",\n      },\n    },\n  },\n  array: [1, 2, 3, { nested: "array" }],\n  mixedArray: ["string", 42, true, { object: "in array" }],\n\n  // \u2705 Date objects\n  date: new Date(),\n  specificDate: new Date("2023-01-01"),\n\n  // \u2705 Regular expressions\n  regexp: /pattern/gi,\n  complexRegexp: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\n\n  // \u2705 Binary data types\n  arrayBuffer: new ArrayBuffer(8),\n  int8Array: new Int8Array([1, 2, 3, 4]),\n  uint8Array: new Uint8Array([1, 2, 3, 4]),\n  uint8ClampedArray: new Uint8ClampedArray([255, 0, 128]),\n  int16Array: new Int16Array([1000, 2000]),\n  uint16Array: new Uint16Array([1000, 2000]),\n  int32Array: new Int32Array([100000, 200000]),\n  uint32Array: new Uint32Array([100000, 200000]),\n  float32Array: new Float32Array([1.5, 2.7, 3.14]),\n  float64Array: new Float64Array([1.5, 2.7, 3.14159265359]),\n\n  // \u2705 Complex built-in objects\n  map: new Map([\n    ["key1", "value1"],\n    ["key2", { nested: "object" }],\n    [42, "number key"],\n  ]),\n  set: new Set([1, 2, 3, "string", { object: "in set" }]),\n\n  // \u2705 Error objects (with limitations)\n  error: new Error("This error can be cloned"),\n  typeError: new TypeError("Type errors work too"),\n\n  // \u2705 Circular references are handled correctly\n  // Note: We\'ll create this below to avoid issues in static definition\n};\n\n// Add circular reference example\ntransferableData.circular = { reference: transferableData };\n\n// Examples of data that CANNOT be transferred (will cause DataCloneError)\nconst nonTransferableData = {\n  // \u274c Functions of any kind\n  // regularFunction: function() { return "hello"; },\n  // arrowFunction: () => "hello",\n  // asyncFunction: async () => "hello",\n  // generatorFunction: function*() { yield 1; },\n  // \u274c DOM elements and nodes\n  // domElement: document.createElement(\'div\'),\n  // textNode: document.createTextNode(\'text\'),\n  // documentFragment: document.createDocumentFragment(),\n  // \u274c Symbols\n  // symbol: Symbol(\'test\'),\n  // symbolFor: Symbol.for(\'global\'),\n  // \u274c Window and other global objects\n  // windowObject: window,\n  // documentObject: document,\n  // \u274c Objects with non-cloneable properties\n  // objectWithFunction: {\n  //   data: "this is fine",\n  //   method: function() { return "this breaks cloning"; }\n  // },\n  // \u274c Promises and other async objects\n  // promise: Promise.resolve("value"),\n  // proxy: new Proxy({}, {}),\n  // \u274c WeakMap and WeakSet\n  // weakMap: new WeakMap(),\n  // weakSet: new WeakSet()\n};\n\n// Safe worker communication with error handling\nfunction sendToWorker(worker, data) {\n  try {\n    // Attempt to send data - this will throw if data is not cloneable\n    worker.postMessage(data);\n    console.log("Data sent successfully:", data);\n  } catch (error) {\n    if (error.name === "DataCloneError") {\n      console.error("Data cloning failed:", error.message);\n      console.error("The data contains non-cloneable objects");\n\n      // Try to send a sanitized version\n      const sanitizedData = sanitizeForCloning(data);\n      worker.postMessage(sanitizedData);\n    } else {\n      console.error("Unexpected error:", error);\n    }\n  }\n}\n\n// Helper function to sanitize data for cloning\nfunction sanitizeForCloning(data) {\n  return JSON.parse(\n    JSON.stringify(data, (key, value) => {\n      // Handle functions\n      if (typeof value === "function") {\n        return `[Function: ${value.name || "anonymous"}]`;\n      }\n\n      // Handle symbols\n      if (typeof value === "symbol") {\n        return `[Symbol: ${value.toString()}]`;\n      }\n\n      // Handle DOM elements\n      if (value instanceof Element) {\n        return `[Element: ${value.tagName}]`;\n      }\n\n      // Handle other non-cloneable types\n      if (value instanceof Promise) {\n        return "[Promise]";\n      }\n\n      if (value instanceof WeakMap || value instanceof WeakSet) {\n        return `[${value.constructor.name}]`;\n      }\n\n      return value;\n    })\n  );\n}\n\n// Example usage\nconst worker = new Worker("worker.js");\n\n// This will work fine\nsendToWorker(worker, transferableData);\n\n// This would normally fail, but our helper handles it\n// sendToWorker(worker, nonTransferableData);\n\n// Performance testing for large data structures\nfunction testCloningPerformance() {\n  const largeArray = new Array(100000).fill(0).map((_, i) => ({\n    id: i,\n    data: `Item ${i}`,\n    nested: {\n      value: Math.random(),\n      timestamp: Date.now(),\n    },\n  }));\n\n  console.time("Large data cloning");\n\n  try {\n    worker.postMessage({\n      type: "performance-test",\n      data: largeArray,\n    });\n    console.timeEnd("Large data cloning");\n  } catch (error) {\n    console.timeEnd("Large data cloning");\n    console.error("Cloning failed:", error);\n  }\n}\n\n// Run performance test\n// testCloningPerformance();\n'})}),"\n",(0,s.jsx)(n.h3,{id:"transferable-objects-for-performance",children:"Transferable Objects for Performance"}),"\n",(0,s.jsx)(n.p,{children:"Transferable objects provide a zero-copy mechanism for moving large binary data between threads. Instead of cloning the data (which can be expensive), ownership is transferred from one context to another. This is crucial for performance when dealing with large datasets like images, audio, or video data."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Zero-copy transfer for maximum performance"}),"\n",(0,s.jsx)(n.li,{children:"Ideal for large binary data (ArrayBuffers, ImageData, etc.)"}),"\n",(0,s.jsx)(n.li,{children:"Reduces memory usage by avoiding duplication"}),"\n",(0,s.jsx)(n.li,{children:"Essential for real-time applications with large data flows"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Important considerations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Original object becomes "neutered" (unusable) after transfer'}),"\n",(0,s.jsx)(n.li,{children:"Only specific object types can be transferred"}),"\n",(0,s.jsx)(n.li,{children:"Transfer is one-way - data cannot be easily sent back"}),"\n",(0,s.jsx)(n.li,{children:"Planning data flow is crucial in transferable object architecture"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Transferable object types:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ArrayBuffer and its views (Uint8Array, Float32Array, etc.)"}),"\n",(0,s.jsx)(n.li,{children:"MessagePort objects"}),"\n",(0,s.jsx)(n.li,{children:"ImageData objects"}),"\n",(0,s.jsx)(n.li,{children:"OffscreenCanvas (in supported browsers)"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Input:"})," ArrayBuffer or other transferable objects",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Output:"})," Zero-copy transfer with original object neutered",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Performance:"})," Dramatically faster than cloning for large data"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Comprehensive example of transferable objects usage\n\n// Example 1: Basic ArrayBuffer transfer\nfunction demonstrateBasicTransfer() {\n  console.log("=== Basic ArrayBuffer Transfer ===");\n\n  // Create a large buffer (1MB) in main thread\n  const largeBuffer = new ArrayBuffer(1024 * 1024); // 1MB\n  const uint8View = new Uint8Array(largeBuffer);\n\n  // Fill buffer with some pattern data\n  console.log("Filling buffer with data...");\n  for (let i = 0; i < uint8View.length; i++) {\n    uint8View[i] = i % 256; // Create a repeating pattern\n  }\n\n  console.log(`Buffer created: ${largeBuffer.byteLength} bytes`);\n  console.log(`First few values: ${uint8View.slice(0, 10)}`);\n\n  // Transfer ownership to worker (zero-copy operation)\n  console.log("Transferring buffer to worker...");\n  worker.postMessage(\n    {\n      command: "processLargeData",\n      buffer: largeBuffer,\n      metadata: {\n        originalSize: largeBuffer.byteLength,\n        pattern: "incremental",\n        timestamp: Date.now(),\n      },\n    },\n    [largeBuffer] // Transferable objects list - this is the key!\n  );\n\n  // Note: largeBuffer is now neutered and unusable in main thread\n  console.log(`Buffer after transfer: ${largeBuffer.byteLength} bytes`); // 0\n  console.log("Buffer has been neutered - ownership transferred to worker");\n\n  // Attempting to use the buffer will now fail\n  try {\n    const failedView = new Uint8Array(largeBuffer);\n    console.log("This won\'t execute");\n  } catch (error) {\n    console.log("Expected error - buffer is neutered:", error.message);\n  }\n}\n\n// Example 2: Multiple buffer transfer\nfunction transferMultipleBuffers() {\n  console.log("\\n=== Multiple Buffer Transfer ===");\n\n  // Create multiple buffers for different data types\n  const imageData = new ArrayBuffer(1920 * 1080 * 4); // RGBA image data\n  const audioData = new ArrayBuffer(44100 * 2 * 4); // 1 second of stereo audio\n  const metaData = new ArrayBuffer(1024); // Small metadata buffer\n\n  // Fill with different patterns\n  new Uint8Array(imageData).fill(128); // Gray image\n  new Int16Array(audioData).fill(0); // Silent audio\n  new Uint8Array(metaData).fill(255); // Metadata\n\n  console.log(`Transferring:\n    - Image data: ${imageData.byteLength} bytes\n    - Audio data: ${audioData.byteLength} bytes  \n    - Meta data: ${metaData.byteLength} bytes\n    - Total: ${\n      (imageData.byteLength + audioData.byteLength + metaData.byteLength) /\n      1024 /\n      1024\n    } MB`);\n\n  // Transfer all buffers at once\n  worker.postMessage(\n    {\n      command: "processMultipleBuffers",\n      buffers: {\n        image: imageData,\n        audio: audioData,\n        meta: metaData,\n      },\n      info: {\n        imageFormat: "RGBA",\n        audioFormat: "16-bit stereo",\n        sampleRate: 44100,\n      },\n    },\n    [imageData, audioData, metaData]\n  ); // All buffers in transferable list\n\n  // All buffers are now neutered\n  console.log("All buffers transferred and neutered");\n}\n\n// Example 3: TypedArray transfer (transfers underlying ArrayBuffer)\nfunction transferTypedArrays() {\n  console.log("\\n=== TypedArray Transfer ===");\n\n  // Create different typed arrays\n  const floatData = new Float32Array(100000);\n  const intData = new Int32Array(50000);\n\n  // Fill with computed values\n  for (let i = 0; i < floatData.length; i++) {\n    floatData[i] = Math.sin(i * 0.01); // Sine wave\n  }\n\n  for (let i = 0; i < intData.length; i++) {\n    intData[i] = i * i; // Square numbers\n  }\n\n  console.log(\n    `Float data: ${floatData.length} elements (${floatData.buffer.byteLength} bytes)`\n  );\n  console.log(\n    `Int data: ${intData.length} elements (${intData.buffer.byteLength} bytes)`\n  );\n\n  // Transfer the underlying ArrayBuffers\n  worker.postMessage(\n    {\n      command: "processTypedArrays",\n      data: {\n        floats: floatData,\n        integers: intData,\n      },\n      info: {\n        floatType: "Float32Array",\n        intType: "Int32Array",\n      },\n    },\n    [floatData.buffer, intData.buffer]\n  ); // Transfer underlying buffers\n\n  // TypedArrays are now unusable (their buffers were transferred)\n  console.log(\n    `Float buffer after transfer: ${floatData.buffer.byteLength} bytes`\n  ); // 0\n  console.log(`Int buffer after transfer: ${intData.buffer.byteLength} bytes`); // 0\n}\n\n// Example 4: Error handling for non-transferable objects\nfunction demonstrateTransferErrors() {\n  console.log("\\n=== Transfer Error Handling ===");\n\n  const validBuffer = new ArrayBuffer(1024);\n  const invalidObject = { data: "this cannot be transferred" };\n\n  try {\n    // This will fail because regular objects are not transferable\n    worker.postMessage(\n      {\n        command: "test",\n        data: invalidObject,\n      },\n      [invalidObject]\n    ); // This will throw an error\n  } catch (error) {\n    console.error("Expected error for non-transferable object:", error.message);\n  }\n\n  try {\n    // This will work\n    worker.postMessage(\n      {\n        command: "test",\n        data: validBuffer,\n      },\n      [validBuffer]\n    );\n\n    console.log("Valid buffer transferred successfully");\n  } catch (error) {\n    console.error("Unexpected error:", error);\n  }\n}\n\n// Example 5: Performance comparison\nfunction compareTransferMethods() {\n  console.log("\\n=== Performance Comparison ===");\n\n  const dataSize = 10 * 1024 * 1024; // 10MB\n  const testData = new ArrayBuffer(dataSize);\n  new Uint8Array(testData).fill(42);\n\n  // Test 1: Regular cloning (will clone the data)\n  console.time("Regular cloning");\n  worker.postMessage({\n    command: "performanceTest",\n    method: "clone",\n    data: testData.slice(), // Create a copy to avoid neutering original\n  });\n  console.timeEnd("Regular cloning");\n\n  // Test 2: Transferable object (zero-copy)\n  console.time("Transferable object");\n  worker.postMessage(\n    {\n      command: "performanceTest",\n      method: "transfer",\n      data: testData, // This will be transferred\n    },\n    [testData]\n  );\n  console.timeEnd("Transferable object");\n\n  console.log(\n    "Note: Transferable objects are significantly faster for large data"\n  );\n}\n\n// Example 6: Practical image processing setup\nfunction setupImageProcessingTransfer() {\n  console.log("\\n=== Image Processing Setup ===");\n\n  // Simulate getting ImageData from a canvas\n  const canvas = document.createElement("canvas");\n  canvas.width = 1920;\n  canvas.height = 1080;\n  const ctx = canvas.getContext("2d");\n\n  // Fill with gradient for testing\n  const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);\n  gradient.addColorStop(0, "red");\n  gradient.addColorStop(1, "blue");\n  ctx.fillStyle = gradient;\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  // Get image data\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n  console.log(\n    `Image data: ${imageData.width}x${imageData.height}, ${imageData.data.byteLength} bytes`\n  );\n\n  // Transfer ImageData to worker for processing\n  worker.postMessage(\n    {\n      command: "processImage",\n      imageData: imageData,\n      operations: ["grayscale", "blur"],\n      settings: {\n        blurRadius: 2,\n        preserveAlpha: true,\n      },\n    },\n    [imageData.data.buffer]\n  ); // Transfer the underlying buffer\n\n  console.log("Image data transferred to worker for processing");\n}\n\n// Example usage - uncomment to run individual examples\nconst worker = new Worker("processing-worker.js");\n\n// demonstrateBasicTransfer();\n// transferMultipleBuffers();\n// transferTypedArrays();\n// demonstrateTransferErrors();\n// compareTransferMethods();\n// setupImageProcessingTransfer();\n\n// Utility function to check if an object is transferable\nfunction isTransferable(obj) {\n  const transferableTypes = [\n    "ArrayBuffer",\n    "MessagePort",\n    "ImageData",\n    "OffscreenCanvas",\n  ];\n\n  return transferableTypes.some((type) => {\n    try {\n      return obj instanceof globalThis[type];\n    } catch {\n      return false;\n    }\n  });\n}\n\n// Helper to safely transfer objects\nfunction safeTransfer(worker, data, transferables = []) {\n  // Validate transferable objects\n  const validTransferables = transferables.filter((obj) => {\n    if (isTransferable(obj)) {\n      return true;\n    } else {\n      console.warn("Non-transferable object found:", obj);\n      return false;\n    }\n  });\n\n  try {\n    worker.postMessage(data, validTransferables);\n    console.log(\n      `Transferred ${validTransferables.length} objects successfully`\n    );\n  } catch (error) {\n    console.error("Transfer failed:", error);\n    // Fallback to regular cloning\n    worker.postMessage(data);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-message-handler",children:"Advanced Message Handler"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WorkerMessageHandler {\n  constructor(worker) {\n    this.worker = worker;\n    this.messageQueue = [];\n    this.isProcessing = false;\n    this.responseTimeout = 30000; // 30 seconds\n    this.setupMessageHandling();\n  }\n\n  setupMessageHandling() {\n    this.worker.onmessage = (event) => {\n      this.handleMessage(event.data);\n    };\n  }\n\n  async sendMessage(message, transferable = []) {\n    return new Promise((resolve, reject) => {\n      const messageId = this.generateMessageId();\n      const timeoutId = setTimeout(() => {\n        reject(new Error("Message timeout"));\n      }, this.responseTimeout);\n\n      const messageData = {\n        id: messageId,\n        payload: message,\n        timestamp: Date.now(),\n        resolve: (result) => {\n          clearTimeout(timeoutId);\n          resolve(result);\n        },\n        reject: (error) => {\n          clearTimeout(timeoutId);\n          reject(error);\n        },\n      };\n\n      this.messageQueue.push(messageData);\n\n      this.worker.postMessage(\n        {\n          id: messageId,\n          payload: message,\n          timestamp: Date.now(),\n        },\n        transferable\n      );\n    });\n  }\n\n  handleMessage(data) {\n    const { id, result, error } = data;\n    const message = this.messageQueue.find((msg) => msg.id === id);\n\n    if (message) {\n      this.messageQueue = this.messageQueue.filter((msg) => msg.id !== id);\n\n      if (error) {\n        message.reject(new Error(error));\n      } else {\n        message.resolve(result);\n      }\n    }\n  }\n\n  generateMessageId() {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getQueueLength() {\n    return this.messageQueue.length;\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"worker-lifecycle-management",children:"Worker Lifecycle Management"}),"\n",(0,s.jsx)(n.h3,{id:"worker-pool-implementation",children:"Worker Pool Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class WorkerPool {\n  constructor(workerScript, poolSize = navigator.hardwareConcurrency || 4) {\n    this.workerScript = workerScript;\n    this.poolSize = poolSize;\n    this.workers = [];\n    this.availableWorkers = [];\n    this.taskQueue = [];\n    this.activeTasksCount = 0;\n\n    this.initializePool();\n  }\n\n  initializePool() {\n    for (let i = 0; i < this.poolSize; i++) {\n      const worker = new Worker(this.workerScript);\n      const workerWrapper = {\n        id: i,\n        worker: worker,\n        busy: false,\n        currentTask: null,\n      };\n\n      worker.onmessage = (event) => {\n        this.handleWorkerMessage(workerWrapper, event);\n      };\n\n      worker.onerror = (error) => {\n        this.handleWorkerError(workerWrapper, error);\n      };\n\n      this.workers.push(workerWrapper);\n      this.availableWorkers.push(workerWrapper);\n    }\n  }\n\n  async execute(task, transferable = []) {\n    return new Promise((resolve, reject) => {\n      const taskData = {\n        id: this.generateTaskId(),\n        task,\n        transferable,\n        resolve,\n        reject,\n        createdAt: Date.now(),\n      };\n\n      if (this.availableWorkers.length > 0) {\n        this.assignTaskToWorker(taskData);\n      } else {\n        this.taskQueue.push(taskData);\n      }\n    });\n  }\n\n  assignTaskToWorker(taskData) {\n    const workerWrapper = this.availableWorkers.shift();\n    workerWrapper.busy = true;\n    workerWrapper.currentTask = taskData;\n    this.activeTasksCount++;\n\n    workerWrapper.worker.postMessage(\n      {\n        taskId: taskData.id,\n        ...taskData.task,\n      },\n      taskData.transferable\n    );\n  }\n\n  handleWorkerMessage(workerWrapper, event) {\n    const { taskId, result, error } = event.data;\n    const task = workerWrapper.currentTask;\n\n    if (task && task.id === taskId) {\n      workerWrapper.busy = false;\n      workerWrapper.currentTask = null;\n      this.activeTasksCount--;\n      this.availableWorkers.push(workerWrapper);\n\n      if (error) {\n        task.reject(new Error(error));\n      } else {\n        task.resolve(result);\n      }\n\n      // Process next task in queue\n      if (this.taskQueue.length > 0) {\n        const nextTask = this.taskQueue.shift();\n        this.assignTaskToWorker(nextTask);\n      }\n    }\n  }\n\n  handleWorkerError(workerWrapper, error) {\n    console.error(`Worker ${workerWrapper.id} error:`, error);\n\n    if (workerWrapper.currentTask) {\n      workerWrapper.currentTask.reject(error);\n    }\n\n    // Restart the worker\n    this.restartWorker(workerWrapper);\n  }\n\n  restartWorker(workerWrapper) {\n    workerWrapper.worker.terminate();\n\n    const newWorker = new Worker(this.workerScript);\n    workerWrapper.worker = newWorker;\n    workerWrapper.busy = false;\n    workerWrapper.currentTask = null;\n\n    newWorker.onmessage = (event) => {\n      this.handleWorkerMessage(workerWrapper, event);\n    };\n\n    newWorker.onerror = (error) => {\n      this.handleWorkerError(workerWrapper, error);\n    };\n  }\n\n  generateTaskId() {\n    return `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getStats() {\n    return {\n      poolSize: this.poolSize,\n      activeWorkers: this.workers.filter((w) => w.busy).length,\n      availableWorkers: this.availableWorkers.length,\n      queuedTasks: this.taskQueue.length,\n      activeTasks: this.activeTasksCount,\n    };\n  }\n\n  terminate() {\n    this.workers.forEach((workerWrapper) => {\n      workerWrapper.worker.terminate();\n    });\n\n    this.workers = [];\n    this.availableWorkers = [];\n    this.taskQueue = [];\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"fibonacci-calculation-example",children:"Fibonacci Calculation Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Optimized worker for mathematical calculations\n// fibonacci-worker.js\nconst fibonacciCache = new Map();\n\nself.onmessage = function (event) {\n  const { taskId, command, data } = event.data;\n\n  try {\n    let result;\n\n    switch (command) {\n      case "fibonacci":\n        result = calculateFibonacci(data.n);\n        break;\n      case "fibonacciSequence":\n        result = calculateFibonacciSequence(data.start, data.end);\n        break;\n      case "clearCache":\n        fibonacciCache.clear();\n        result = "Cache cleared";\n        break;\n      default:\n        throw new Error(`Unknown command: ${command}`);\n    }\n\n    self.postMessage({ taskId, result });\n  } catch (error) {\n    self.postMessage({ taskId, error: error.message });\n  }\n};\n\nfunction calculateFibonacci(n) {\n  if (n < 0) throw new Error("Negative numbers not supported");\n  if (n <= 1) return n;\n\n  if (fibonacciCache.has(n)) {\n    return fibonacciCache.get(n);\n  }\n\n  let a = 0,\n    b = 1;\n  for (let i = 2; i <= n; i++) {\n    [a, b] = [b, a + b];\n  }\n\n  fibonacciCache.set(n, b);\n  return b;\n}\n\nfunction calculateFibonacciSequence(start, end) {\n  const sequence = [];\n  for (let i = start; i <= end; i++) {\n    sequence.push(calculateFibonacci(i));\n  }\n  return sequence;\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"usage-with-performance-monitoring",children:"Usage with Performance Monitoring"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class FibonacciCalculator {\n  constructor() {\n    this.workerPool = new WorkerPool("fibonacci-worker.js", 2);\n  }\n\n  async calculateFibonacci(n) {\n    const startTime = performance.now();\n\n    try {\n      const result = await this.workerPool.execute({\n        command: "fibonacci",\n        data: { n },\n      });\n\n      const endTime = performance.now();\n      console.log(\n        `Fibonacci(${n}) = ${result} (took ${endTime - startTime}ms)`\n      );\n\n      return result;\n    } catch (error) {\n      console.error("Fibonacci calculation failed:", error);\n      throw error;\n    }\n  }\n\n  async calculateSequence(start, end) {\n    const startTime = performance.now();\n\n    try {\n      const result = await this.workerPool.execute({\n        command: "fibonacciSequence",\n        data: { start, end },\n      });\n\n      const endTime = performance.now();\n      console.log(\n        `Fibonacci sequence [${start}-${end}] calculated in ${\n          endTime - startTime\n        }ms`\n      );\n\n      return result;\n    } catch (error) {\n      console.error("Fibonacci sequence calculation failed:", error);\n      throw error;\n    }\n  }\n}\n\n// Usage\nconst calculator = new FibonacciCalculator();\n\n// Calculate individual Fibonacci numbers\ncalculator.calculateFibonacci(40).then(console.log);\n\n// Calculate sequence\ncalculator.calculateSequence(10, 20).then(console.log);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-implementation-examples",children:"Real-World Implementation Examples"}),"\n",(0,s.jsx)(n.h3,{id:"image-processing-worker",children:"Image Processing Worker"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// image-processor-worker.js\nself.onmessage = function (event) {\n  const { taskId, command, imageData, options } = event.data;\n\n  try {\n    let result;\n\n    switch (command) {\n      case "grayscale":\n        result = applyGrayscale(imageData);\n        break;\n      case "blur":\n        result = applyBlur(imageData, options.radius || 1);\n        break;\n      case "brightness":\n        result = adjustBrightness(imageData, options.factor || 1);\n        break;\n      default:\n        throw new Error(`Unknown command: ${command}`);\n    }\n\n    self.postMessage({ taskId, result }, [result.data.buffer]);\n  } catch (error) {\n    self.postMessage({ taskId, error: error.message });\n  }\n};\n\nfunction applyGrayscale(imageData) {\n  const data = new Uint8ClampedArray(imageData.data);\n\n  for (let i = 0; i < data.length; i += 4) {\n    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];\n    data[i] = gray; // Red\n    data[i + 1] = gray; // Green\n    data[i + 2] = gray; // Blue\n    // Alpha channel (data[i + 3]) remains unchanged\n  }\n\n  return new ImageData(data, imageData.width, imageData.height);\n}\n\nfunction applyBlur(imageData, radius) {\n  const data = new Uint8ClampedArray(imageData.data);\n  const width = imageData.width;\n  const height = imageData.height;\n  const output = new Uint8ClampedArray(data.length);\n\n  // Simple box blur implementation\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let r = 0,\n        g = 0,\n        b = 0,\n        a = 0,\n        count = 0;\n\n      for (let dy = -radius; dy <= radius; dy++) {\n        for (let dx = -radius; dx <= radius; dx++) {\n          const ny = y + dy;\n          const nx = x + dx;\n\n          if (ny >= 0 && ny < height && nx >= 0 && nx < width) {\n            const idx = (ny * width + nx) * 4;\n            r += data[idx];\n            g += data[idx + 1];\n            b += data[idx + 2];\n            a += data[idx + 3];\n            count++;\n          }\n        }\n      }\n\n      const idx = (y * width + x) * 4;\n      output[idx] = r / count;\n      output[idx + 1] = g / count;\n      output[idx + 2] = b / count;\n      output[idx + 3] = a / count;\n    }\n  }\n\n  return new ImageData(output, width, height);\n}\n\nfunction adjustBrightness(imageData, factor) {\n  const data = new Uint8ClampedArray(imageData.data);\n\n  for (let i = 0; i < data.length; i += 4) {\n    data[i] = Math.min(255, data[i] * factor); // Red\n    data[i + 1] = Math.min(255, data[i + 1] * factor); // Green\n    data[i + 2] = Math.min(255, data[i + 2] * factor); // Blue\n    // Alpha channel remains unchanged\n  }\n\n  return new ImageData(data, imageData.width, imageData.height);\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling-and-debugging",children:"Error Handling and Debugging"}),"\n",(0,s.jsx)(n.h3,{id:"comprehensive-error-handling",children:"Comprehensive Error Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class RobustWorkerManager {\n  constructor(workerScript) {\n    this.workerScript = workerScript;\n    this.worker = null;\n    this.isTerminated = false;\n    this.retryCount = 0;\n    this.maxRetries = 3;\n    this.retryDelay = 1000;\n\n    this.initializeWorker();\n  }\n\n  initializeWorker() {\n    try {\n      this.worker = new Worker(this.workerScript);\n      this.setupEventHandlers();\n      this.retryCount = 0;\n    } catch (error) {\n      console.error("Failed to create worker:", error);\n      this.handleWorkerCreationError(error);\n    }\n  }\n\n  setupEventHandlers() {\n    this.worker.onmessage = (event) => {\n      this.handleMessage(event);\n    };\n\n    this.worker.onerror = (error) => {\n      console.error("Worker runtime error:", error);\n      this.handleWorkerError(error);\n    };\n\n    this.worker.onmessageerror = (event) => {\n      console.error("Worker message error:", event);\n      this.handleMessageError(event);\n    };\n  }\n\n  handleWorkerCreationError(error) {\n    if (this.retryCount < this.maxRetries) {\n      this.retryCount++;\n      console.log(\n        `Retrying worker creation (${this.retryCount}/${this.maxRetries})`\n      );\n\n      setTimeout(() => {\n        this.initializeWorker();\n      }, this.retryDelay * this.retryCount);\n    } else {\n      console.error("Max retries reached. Worker creation failed permanently.");\n    }\n  }\n\n  handleWorkerError(error) {\n    console.error("Worker error occurred:", {\n      message: error.message,\n      filename: error.filename,\n      lineno: error.lineno,\n      colno: error.colno,\n    });\n\n    // Attempt to restart worker\n    this.restartWorker();\n  }\n\n  handleMessageError(event) {\n    console.error("Message serialization error:", event);\n    // Handle cases where message couldn\'t be cloned\n  }\n\n  restartWorker() {\n    if (!this.isTerminated && this.retryCount < this.maxRetries) {\n      console.log("Restarting worker...");\n      this.terminate();\n      this.initializeWorker();\n    }\n  }\n\n  terminate() {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n    }\n    this.isTerminated = true;\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-and-limitations",children:"Best Practices and Limitations"}),"\n",(0,s.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// \u2705 Good: Minimize data transfer\nclass EfficientWorkerManager {\n  constructor() {\n    this.worker = new Worker("worker.js");\n    this.cache = new Map();\n  }\n\n  async processLargeDataset(data) {\n    // Send only necessary data\n    const essentialData = data.map((item) => ({\n      id: item.id,\n      value: item.computeValue,\n    }));\n\n    return await this.sendMessage({\n      command: "process",\n      data: essentialData,\n    });\n  }\n\n  // \u2705 Good: Reuse workers\n  async batchProcess(tasks) {\n    const results = [];\n\n    for (const task of tasks) {\n      results.push(await this.processTask(task));\n    }\n\n    return results;\n  }\n}\n\n// \u274c Bad: Creating new workers for each task\nclass InefficientWorkerManager {\n  async processTask(data) {\n    const worker = new Worker("worker.js"); // Don\'t do this\n\n    return new Promise((resolve) => {\n      worker.postMessage(data);\n      worker.onmessage = (event) => {\n        resolve(event.data);\n        worker.terminate(); // Wasteful\n      };\n    });\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"limitations-and-considerations",children:"Limitations and Considerations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Worker limitations demonstration\n// worker-limitations.js\n\n// \u274c These will cause errors in workers:\ntry {\n  // DOM access not allowed\n  document.getElementById("test");\n} catch (error) {\n  console.error("DOM access failed:", error.message);\n}\n\ntry {\n  // Window object not available\n  window.alert("Hello");\n} catch (error) {\n  console.error("Window access failed:", error.message);\n}\n\ntry {\n  // Parent object not available\n  parent.postMessage("test");\n} catch (error) {\n  console.error("Parent access failed:", error.message);\n}\n\n// \u2705 These work in workers:\nconsole.log("Console works");\nsetTimeout(() => console.log("Timers work"), 1000);\nfetch("/api/data").then((response) => console.log("Fetch works"));\n\n// Import external scripts\nimportScripts("/lib/utility.js");\n\n// Use Web APIs available to workers\nconst db = indexedDB.open("WorkerDB");\nconst cache = caches.open("worker-cache");\n'})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Web Workers provide a powerful mechanism for achieving true parallelism in web applications, enabling developers to perform intensive computations without blocking the main thread. By understanding their threading model, message passing mechanisms, and best practices, developers can create responsive applications that effectively utilize modern multi-core processors."}),"\n",(0,s.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Threading Model"}),": Web Workers run in isolated contexts with their own global scope, providing true parallel execution."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message Passing"}),": The structured clone algorithm enables efficient data transfer, while transferable objects provide zero-copy transfers for large data."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Worker Types"}),": Dedicated workers serve single scripts, while shared workers enable cross-context communication."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": Proper worker pool management and data transfer optimization are crucial for performance."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Limitations"}),": Workers cannot access DOM or window objects, requiring careful architecture planning."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"when-to-use-web-workers",children:"When to Use Web Workers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"CPU-intensive calculations that would block the UI"}),"\n",(0,s.jsx)(n.li,{children:"Data processing tasks that can run independently"}),"\n",(0,s.jsx)(n.li,{children:"Background data synchronization"}),"\n",(0,s.jsx)(n.li,{children:"Image/video processing"}),"\n",(0,s.jsx)(n.li,{children:"Cryptographic operations"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Web Workers represent a fundamental shift toward multi-threaded web applications, enabling developers to build more responsive and capable web experiences. As outlined in the ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers",children:"MDN documentation"}),", proper implementation of Web Workers can significantly improve application performance and user experience."]}),"\n",(0,s.jsx)(n.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers",children:"MDN Web Workers API Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://html.spec.whatwg.org/multipage/workers.html",children:"HTML Living Standard - Web Workers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://caniuse.com/webworkers",children:"Can I Use - Web Workers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://worker-playground.glitch.me/",children:"Worker Playground - Test Worker APIs"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var t=r(6540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);