"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2825],{7820:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"project-detail/react-virtuoso","title":"React Virtuoso: Deep Dive into Virtual Scrolling","description":"Master React Virtuoso\'s virtualization engine, covering implementation details, offset management, variable height handling, and performance optimization strategies for building high-performance lists","source":"@site/docs/project-detail/react-virtuoso.md","sourceDirName":"project-detail","slug":"/project-detail/react-virtuoso","permalink":"/frontend-system-design/docs/project-detail/react-virtuoso","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/react-virtuoso.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Tech Stack Cheatsheet: affiliate-framework-fe-bo","permalink":"/frontend-system-design/docs/project-detail/affiliate-framework-bo"},"next":{"title":"React Native: Under the Hood","permalink":"/frontend-system-design/docs/project-detail/react-native"}}');var i=r(4848),s=r(8453);const o={},a="React Virtuoso: Deep Dive into Virtual Scrolling",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Core Virtualization Concepts",id:"core-virtualization-concepts",level:2},{value:"What is Virtualization?",id:"what-is-virtualization",level:3},{value:"Key Benefits",id:"key-benefits",level:3},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Core Components",id:"core-components",level:3},{value:"State Management System",id:"state-management-system",level:3},{value:"Viewport Management",id:"viewport-management",level:2},{value:"Visible Range Calculation",id:"visible-range-calculation",level:3},{value:"Overscan (Buffer) Management",id:"overscan-buffer-management",level:3},{value:"Offset Calculation &amp; Management",id:"offset-calculation--management",level:2},{value:"Height-Based Offset System",id:"height-based-offset-system",level:3},{value:"Efficient Offset Updates",id:"efficient-offset-updates",level:3},{value:"Variable Height Item Handling",id:"variable-height-item-handling",level:2},{value:"Automatic Height Measurement",id:"automatic-height-measurement",level:3},{value:"Dynamic Height Estimation",id:"dynamic-height-estimation",level:3},{value:"Handling Content Loading",id:"handling-content-loading",level:3},{value:"Scroll Synchronization",id:"scroll-synchronization",level:2},{value:"Scroll Event Handling",id:"scroll-event-handling",level:3},{value:"Scroll Position Preservation",id:"scroll-position-preservation",level:3},{value:"Programmatic Scrolling",id:"programmatic-scrolling",level:3},{value:"Performance Optimization Strategies",id:"performance-optimization-strategies",level:2},{value:"Memoization and React.memo",id:"memoization-and-reactmemo",level:3},{value:"Overscan Tuning",id:"overscan-tuning",level:3},{value:"CSS Optimization",id:"css-optimization",level:3},{value:"Component Variants",id:"component-variants",level:2},{value:"Virtuoso (Basic List)",id:"virtuoso-basic-list",level:3},{value:"GroupedVirtuoso (Grouped Lists)",id:"groupedvirtuoso-grouped-lists",level:3},{value:"VirtuosoGrid (Grid Layout)",id:"virtuosogrid-grid-layout",level:3},{value:"TableVirtuoso (Table Virtualization)",id:"tablevirtuoso-table-virtualization",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Message List for Chat Applications",id:"message-list-for-chat-applications",level:3},{value:"Infinite Scrolling",id:"infinite-scrolling",level:3},{value:"Custom Scrollbars",id:"custom-scrollbars",level:3},{value:"Common Patterns &amp; Best Practices",id:"common-patterns--best-practices",level:2},{value:"Error Boundaries",id:"error-boundaries",level:3},{value:"Testing Strategies",id:"testing-strategies",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3},{value:"Accessibility Considerations",id:"accessibility-considerations",level:3},{value:"How React Virtuoso Handles and Renders Items to the DOM",id:"how-react-virtuoso-handles-and-renders-items-to-the-dom",level:2},{value:"Visualizing the DOM Lifecycle",id:"visualizing-the-dom-lifecycle",level:3},{value:"Example: DOM Node Recycling and Buffer Management",id:"example-dom-node-recycling-and-buffer-management",level:3},{value:"Internal Buffer and Recycling Logic (Pseudocode)",id:"internal-buffer-and-recycling-logic-pseudocode",level:3},{value:"1. <strong>Viewport-Driven Rendering</strong>",id:"1-viewport-driven-rendering",level:3},{value:"2. <strong>DOM Recycling and Element Lifecycle</strong>",id:"2-dom-recycling-and-element-lifecycle",level:3},{value:"3. <strong>Dynamic Measurement and Positioning</strong>",id:"3-dynamic-measurement-and-positioning",level:3},{value:"4. <strong>Rendering Pipeline</strong>",id:"4-rendering-pipeline",level:3},{value:"5. <strong>Performance and Best Practices</strong>",id:"5-performance-and-best-practices",level:3},{value:"6. <strong>Example: DOM Rendering Lifecycle</strong>",id:"6-example-dom-rendering-lifecycle",level:3},{value:"Visual Example: What the DOM Looks Like During Virtualization",id:"visual-example-what-the-dom-looks-like-during-virtualization",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"react-virtuoso-deep-dive-into-virtual-scrolling",children:"React Virtuoso: Deep Dive into Virtual Scrolling"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Master React Virtuoso's virtualization engine, covering implementation details, offset management, variable height handling, and performance optimization strategies for building high-performance lists"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso is the most powerful virtual list component for React, providing efficient rendering of large datasets through sophisticated virtualization techniques. Unlike traditional approaches that render all items at once, Virtuoso renders only visible items plus a configurable buffer, dramatically improving performance and memory usage. This guide explores how React Virtuoso works under the hood, examining its core algorithms, offset management, variable height handling, and optimization strategies."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#core-virtualization-concepts",children:"Core Virtualization Concepts"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#architecture-overview",children:"Architecture Overview"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#viewport-management",children:"Viewport Management"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#offset-calculation--management",children:"Offset Calculation & Management"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#variable-height-item-handling",children:"Variable Height Item Handling"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#scroll-synchronization",children:"Scroll Synchronization"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#performance-optimization-strategies",children:"Performance Optimization Strategies"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#component-variants",children:"Component Variants"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#advanced-features",children:"Advanced Features"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#common-patterns--best-practices",children:"Common Patterns & Best Practices"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"core-virtualization-concepts",children:"Core Virtualization Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"what-is-virtualization",children:"What is Virtualization?"}),"\n",(0,i.jsx)(n.p,{children:"Virtualization is a rendering optimization technique that renders only the items currently visible in the viewport, plus a small buffer of items above and below for smooth scrolling. This approach transforms O(n) rendering complexity to O(1) relative to the total dataset size."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// Traditional approach - renders ALL items (performance killer)\r\nfunction TraditionalList({ items }) {\r\n  return (\r\n    <div style={{ height: "400px", overflow: "auto" }}>\r\n      {items.map((item, index) => (\r\n        <div key={index}>{item.content}</div>\r\n      ))}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Virtualized approach - renders ONLY visible items\r\nimport { Virtuoso } from "react-virtuoso";\r\n\r\nfunction VirtualizedList({ items }) {\r\n  return (\r\n    <Virtuoso\r\n      style={{ height: "400px" }}\r\n      totalCount={items.length}\r\n      itemContent={(index) => <div>{items[index].content}</div>}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Efficiency"}),": DOM contains only visible items (~10-50 elements instead of thousands)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistent Performance"}),": Rendering time remains constant regardless of dataset size"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Smooth Scrolling"}),": Optimized rendering pipeline prevents janky scroll behavior"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Variable Heights"}),": Automatic measurement and adjustment for dynamic content"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso's architecture consists of several interconnected systems working together to provide seamless virtualization:"}),"\n",(0,i.jsx)(n.h3,{id:"core-components",children:"Core Components"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:"graph TD\r\n    A[Virtuoso Container] --\x3e B[Viewport Manager]\r\n    A --\x3e C[Item Renderer]\r\n    A --\x3e D[Scroller System]\r\n\r\n    B --\x3e E[Visible Range Calculator]\r\n    B --\x3e F[Offset Manager]\r\n\r\n    C --\x3e G[Item Measurement]\r\n    C --\x3e H[DOM Recycling]\r\n\r\n    D --\x3e I[Scroll Event Handler]\r\n    D --\x3e J[Position Synchronizer]\r\n\r\n    E --\x3e K[Buffer Management]\r\n    F --\x3e L[Height Estimation]\r\n    G --\x3e M[ResizeObserver]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"state-management-system",children:"State Management System"}),"\n",(0,i.jsx)(n.p,{children:"Virtuoso uses a reactive state management system that efficiently updates only necessary parts when data changes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Simplified internal state structure\r\nconst virtuosoState = {\r\n  // Viewport dimensions\r\n  viewportHeight: 400,\r\n  scrollTop: 0,\r\n\r\n  // Item management\r\n  totalCount: 10000,\r\n  visibleRange: { start: 45, end: 65 },\r\n  overscan: { start: 40, end: 70 },\r\n\r\n  // Height tracking\r\n  itemHeights: new Map(), // Measured heights\r\n  estimatedItemHeight: 50,\r\n  totalHeight: 500000,\r\n\r\n  // Offset calculations\r\n  itemOffsets: new Map(), // Cached positions\r\n  scrollOffset: 2250,\r\n};\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"viewport-management",children:"Viewport Management"}),"\n",(0,i.jsx)(n.h3,{id:"visible-range-calculation",children:"Visible Range Calculation"}),"\n",(0,i.jsx)(n.p,{children:"The viewport manager determines which items should be rendered based on scroll position and container dimensions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Simplified visible range calculation algorithm\r\nfunction calculateVisibleRange(\r\n  scrollTop,\r\n  viewportHeight,\r\n  itemOffsets,\r\n  totalCount\r\n) {\r\n  // Find first visible item using binary search for efficiency\r\n  const startIndex = binarySearchFirstVisible(scrollTop, itemOffsets);\r\n\r\n  // Calculate end index based on viewport height\r\n  let endIndex = startIndex;\r\n  let accumulatedHeight = 0;\r\n\r\n  while (endIndex < totalCount && accumulatedHeight < viewportHeight) {\r\n    accumulatedHeight += getItemHeight(endIndex, itemOffsets);\r\n    endIndex++;\r\n  }\r\n\r\n  return { start: startIndex, end: endIndex };\r\n}\r\n\r\nfunction binarySearchFirstVisible(scrollTop, itemOffsets) {\r\n  let left = 0;\r\n  let right = itemOffsets.size - 1;\r\n\r\n  while (left < right) {\r\n    const mid = Math.floor((left + right) / 2);\r\n    const offset = itemOffsets.get(mid) || 0;\r\n\r\n    if (offset < scrollTop) {\r\n      left = mid + 1;\r\n    } else {\r\n      right = mid;\r\n    }\r\n  }\r\n\r\n  return left;\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"overscan-buffer-management",children:"Overscan (Buffer) Management"}),"\n",(0,i.jsx)(n.p,{children:"Virtuoso renders additional items outside the visible area to ensure smooth scrolling:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Overscan configuration affects performance vs smoothness trade-off\r\n<Virtuoso\r\n  totalCount={10000}\r\n  itemContent={(index) => <Item key={index} />}\r\n  // Render 5 extra items above and below visible area\r\n  increaseViewportBy={{ top: 200, bottom: 200 }}\r\n  // Alternative: specify item count\r\n  overscan={5}\r\n/>\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Overscan Strategy:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Small overscan"})," (2-5 items): Better performance, potential scroll stuttering"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Large overscan"})," (10-20 items): Smoother scrolling, higher memory usage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic overscan"}),": Adjusts based on scroll velocity"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"offset-calculation--management",children:"Offset Calculation & Management"}),"\n",(0,i.jsx)(n.h3,{id:"height-based-offset-system",children:"Height-Based Offset System"}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso maintains a sophisticated offset calculation system that tracks the position of each item:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Internal offset management system\r\nclass OffsetManager {\r\n  constructor() {\r\n    this.itemHeights = new Map();\r\n    this.itemOffsets = new Map();\r\n    this.totalHeight = 0;\r\n    this.estimatedItemHeight = 50;\r\n  }\r\n\r\n  // Calculate offset for a specific item\r\n  getItemOffset(index) {\r\n    if (this.itemOffsets.has(index)) {\r\n      return this.itemOffsets.get(index);\r\n    }\r\n\r\n    // Calculate offset based on previous items\r\n    let offset = 0;\r\n    for (let i = 0; i < index; i++) {\r\n      offset += this.getItemHeight(i);\r\n    }\r\n\r\n    this.itemOffsets.set(index, offset);\r\n    return offset;\r\n  }\r\n\r\n  // Get item height (measured or estimated)\r\n  getItemHeight(index) {\r\n    return this.itemHeights.get(index) || this.estimatedItemHeight;\r\n  }\r\n\r\n  // Update height and recalculate offsets\r\n  setItemHeight(index, height) {\r\n    const oldHeight = this.getItemHeight(index);\r\n    this.itemHeights.set(index, height);\r\n\r\n    // Invalidate cached offsets for items after this one\r\n    this.invalidateOffsetsAfter(index);\r\n\r\n    // Update total height\r\n    this.totalHeight += height - oldHeight;\r\n  }\r\n\r\n  invalidateOffsetsAfter(index) {\r\n    for (let i = index + 1; i < this.totalCount; i++) {\r\n      this.itemOffsets.delete(i);\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"efficient-offset-updates",children:"Efficient Offset Updates"}),"\n",(0,i.jsx)(n.p,{children:"When item heights change, Virtuoso efficiently updates only affected offsets:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Example: Item height changes from 100px to 150px at index 25\r\n// Before: [0, 100, 200, 300, ..., 2500, 2600, ...]\r\n// After:  [0, 100, 200, 300, ..., 2500, 2650, ...] (+50px offset for items after 25)\r\n\r\nfunction handleHeightChange(index, newHeight, oldHeight) {\r\n  const heightDelta = newHeight - oldHeight;\r\n\r\n  // Update stored height\r\n  this.itemHeights.set(index, newHeight);\r\n\r\n  // Efficiently update subsequent offsets\r\n  for (let i = index + 1; i < this.totalCount; i++) {\r\n    if (this.itemOffsets.has(i)) {\r\n      const currentOffset = this.itemOffsets.get(i);\r\n      this.itemOffsets.set(i, currentOffset + heightDelta);\r\n    }\r\n  }\r\n\r\n  // Update total scrollable height\r\n  this.totalHeight += heightDelta;\r\n\r\n  // Adjust scroll position if necessary to maintain view stability\r\n  this.adjustScrollPosition(index, heightDelta);\r\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"variable-height-item-handling",children:"Variable Height Item Handling"}),"\n",(0,i.jsx)(n.h3,{id:"automatic-height-measurement",children:"Automatic Height Measurement"}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso automatically measures item heights using the ResizeObserver API:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Simplified height measurement system\r\nfunction ItemRenderer({ index, style, data }) {\r\n  const itemRef = useRef(null);\r\n  const measureHeight = useCallback(() => {\r\n    if (itemRef.current) {\r\n      const height = itemRef.current.getBoundingClientRect().height;\r\n      // Report height back to Virtuoso's measurement system\r\n      reportItemHeight(index, height);\r\n    }\r\n  }, [index]);\r\n\r\n  useEffect(() => {\r\n    // Initial measurement\r\n    measureHeight();\r\n\r\n    // Set up ResizeObserver for dynamic content\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      for (const entry of entries) {\r\n        const height = entry.borderBoxSize[0].blockSize;\r\n        reportItemHeight(index, height);\r\n      }\r\n    });\r\n\r\n    if (itemRef.current) {\r\n      resizeObserver.observe(itemRef.current);\r\n    }\r\n\r\n    return () => resizeObserver.disconnect();\r\n  }, [measureHeight]);\r\n\r\n  return (\r\n    <div ref={itemRef} style={style}>\r\n      {data[index].content}\r\n    </div>\r\n  );\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"dynamic-height-estimation",children:"Dynamic Height Estimation"}),"\n",(0,i.jsx)(n.p,{children:"For unmeasured items, Virtuoso uses intelligent height estimation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Height estimation strategies\r\nclass HeightEstimator {\r\n  constructor() {\r\n    this.measuredHeights = [];\r\n    this.estimatedHeight = 50; // Initial estimate\r\n  }\r\n\r\n  // Update estimation based on measured items\r\n  updateEstimation(newHeight) {\r\n    this.measuredHeights.push(newHeight);\r\n\r\n    // Use different strategies based on data availability\r\n    if (this.measuredHeights.length < 10) {\r\n      // Simple average for small samples\r\n      this.estimatedHeight = this.calculateSimpleAverage();\r\n    } else {\r\n      // Weighted average favoring recent measurements\r\n      this.estimatedHeight = this.calculateWeightedAverage();\r\n    }\r\n  }\r\n\r\n  calculateWeightedAverage() {\r\n    const recentHeights = this.measuredHeights.slice(-20); // Last 20 measurements\r\n    const weights = recentHeights.map((_, i) => i + 1); // Newer items get higher weight\r\n\r\n    const weightedSum = recentHeights.reduce(\r\n      (sum, height, i) => sum + height * weights[i],\r\n      0\r\n    );\r\n    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);\r\n\r\n    return weightedSum / totalWeight;\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"handling-content-loading",children:"Handling Content Loading"}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso gracefully handles scenarios where content loads asynchronously:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// Example: Images loading in list items\r\nfunction ImageListItem({ index, data }) {\r\n  const [imageLoaded, setImageLoaded] = useState(false);\r\n  const itemRef = useRef(null);\r\n\r\n  // Re-measure when image loads\r\n  const handleImageLoad = useCallback(() => {\r\n    setImageLoaded(true);\r\n    // Trigger re-measurement\r\n    if (itemRef.current) {\r\n      const height = itemRef.current.offsetHeight;\r\n      // This will trigger Virtuoso\'s height update system\r\n      requestAnimationFrame(() => {\r\n        reportHeightChange(index, height);\r\n      });\r\n    }\r\n  }, [index]);\r\n\r\n  return (\r\n    <div ref={itemRef}>\r\n      <h3>{data[index].title}</h3>\r\n      <img\r\n        src={data[index].imageUrl}\r\n        onLoad={handleImageLoad}\r\n        style={{\r\n          width: "100%",\r\n          height: imageLoaded ? "auto" : "200px",\r\n          backgroundColor: imageLoaded ? "transparent" : "#f0f0f0",\r\n        }}\r\n        alt={data[index].title}\r\n      />\r\n      <p>{data[index].description}</p>\r\n    </div>\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"scroll-synchronization",children:"Scroll Synchronization"}),"\n",(0,i.jsx)(n.h3,{id:"scroll-event-handling",children:"Scroll Event Handling"}),"\n",(0,i.jsx)(n.p,{children:"Virtuoso optimizes scroll event handling using requestAnimationFrame and throttling:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Optimized scroll handling system\r\nclass ScrollManager {\r\n  constructor() {\r\n    this.isScrolling = false;\r\n    this.scrollRaf = null;\r\n    this.lastScrollTime = 0;\r\n  }\r\n\r\n  handleScroll = (event) => {\r\n    const now = performance.now();\r\n\r\n    // Throttle scroll events for performance\r\n    if (now - this.lastScrollTime < 16) {\r\n      // ~60fps\r\n      return;\r\n    }\r\n\r\n    this.lastScrollTime = now;\r\n\r\n    // Cancel previous frame if still pending\r\n    if (this.scrollRaf) {\r\n      cancelAnimationFrame(this.scrollRaf);\r\n    }\r\n\r\n    // Schedule update for next frame\r\n    this.scrollRaf = requestAnimationFrame(() => {\r\n      this.updateScrollPosition(event.target.scrollTop);\r\n      this.scrollRaf = null;\r\n    });\r\n  };\r\n\r\n  updateScrollPosition(scrollTop) {\r\n    // Update visible range\r\n    const newVisibleRange = this.calculateVisibleRange(scrollTop);\r\n\r\n    // Only update if range actually changed\r\n    if (!this.rangesEqual(newVisibleRange, this.currentVisibleRange)) {\r\n      this.currentVisibleRange = newVisibleRange;\r\n      this.notifyRangeChange(newVisibleRange);\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"scroll-position-preservation",children:"Scroll Position Preservation"}),"\n",(0,i.jsx)(n.p,{children:"When items change height, Virtuoso maintains scroll position relative to content:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Scroll position preservation during height changes\r\nfunction preserveScrollPosition(heightChanges) {\r\n  const currentScrollTop = this.scrollContainer.scrollTop;\r\n  const currentFirstVisibleIndex = this.findFirstVisibleIndex(currentScrollTop);\r\n\r\n  // Apply height changes and recalculate offsets\r\n  this.applyHeightChanges(heightChanges);\r\n\r\n  // Calculate new scroll position to maintain visual stability\r\n  const newScrollTop = this.getItemOffset(currentFirstVisibleIndex);\r\n\r\n  // Smoothly adjust scroll position\r\n  this.scrollContainer.scrollTop = newScrollTop;\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"programmatic-scrolling",children:"Programmatic Scrolling"}),"\n",(0,i.jsx)(n.p,{children:"Virtuoso provides methods for programmatic scrolling with smooth animations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// Scroll to specific item with options\r\n<Virtuoso\r\n  ref={virtuosoRef}\r\n  totalCount={items.length}\r\n  itemContent={(index) => <Item data={items[index]} />}\r\n/>;\r\n\r\n// Usage examples\r\nfunction scrollToItem() {\r\n  // Instant scroll to item 100\r\n  virtuosoRef.current?.scrollToIndex({\r\n    index: 100,\r\n    align: "start", // \'start\' | \'center\' | \'end\'\r\n  });\r\n\r\n  // Smooth scroll to item 500\r\n  virtuosoRef.current?.scrollToIndex({\r\n    index: 500,\r\n    align: "center",\r\n    behavior: "smooth",\r\n  });\r\n\r\n  // Scroll to item only if not already visible\r\n  virtuosoRef.current?.scrollIntoView({\r\n    index: 250,\r\n    done: () => console.log("Scroll completed"),\r\n  });\r\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"performance-optimization-strategies",children:"Performance Optimization Strategies"}),"\n",(0,i.jsx)(n.h3,{id:"memoization-and-reactmemo",children:"Memoization and React.memo"}),"\n",(0,i.jsx)(n.p,{children:"Optimize item rendering using React.memo and proper dependency management:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// Optimized item component with memoization\r\nconst ListItem = React.memo(function ListItem({\r\n  index,\r\n  data,\r\n  isSelected,\r\n  onSelect,\r\n}) {\r\n  const item = data[index];\r\n\r\n  // Memoize click handler to prevent unnecessary re-renders\r\n  const handleClick = useCallback(() => {\r\n    onSelect(item.id);\r\n  }, [item.id, onSelect]);\r\n\r\n  // Memoize computed styles\r\n  const itemStyle = useMemo(\r\n    () => ({\r\n      padding: "12px",\r\n      borderBottom: "1px solid #eee",\r\n      backgroundColor: isSelected ? "#e3f2fd" : "transparent",\r\n      cursor: "pointer",\r\n    }),\r\n    [isSelected]\r\n  );\r\n\r\n  return (\r\n    <div style={itemStyle} onClick={handleClick}>\r\n      <h4>{item.title}</h4>\r\n      <p>{item.description}</p>\r\n    </div>\r\n  );\r\n});\r\n\r\n// Usage with proper prop comparison\r\nfunction App() {\r\n  const [selectedId, setSelectedId] = useState(null);\r\n\r\n  // Memoize selection handler\r\n  const handleSelect = useCallback((id) => {\r\n    setSelectedId(id);\r\n  }, []);\r\n\r\n  return (\r\n    <Virtuoso\r\n      totalCount={items.length}\r\n      itemContent={(index) => (\r\n        <ListItem\r\n          index={index}\r\n          data={items}\r\n          isSelected={items[index].id === selectedId}\r\n          onSelect={handleSelect}\r\n        />\r\n      )}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"overscan-tuning",children:"Overscan Tuning"}),"\n",(0,i.jsx)(n.p,{children:"Balance performance vs. smoothness by adjusting overscan parameters:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Performance-focused configuration (minimal overscan)\r\n<Virtuoso\r\n  totalCount={items.length}\r\n  itemContent={renderItem}\r\n  overscan={2} // Minimal buffer for better performance\r\n/>\r\n\r\n// Smoothness-focused configuration (larger overscan)\r\n<Virtuoso\r\n  totalCount={items.length}\r\n  itemContent={renderItem}\r\n  increaseViewportBy={{\r\n    top: 300,    // Render 300px worth of items above viewport\r\n    bottom: 300  // Render 300px worth of items below viewport\r\n  }}\r\n/>\r\n\r\n// Dynamic overscan based on scroll velocity\r\n<Virtuoso\r\n  totalCount={items.length}\r\n  itemContent={renderItem}\r\n  overscan={(velocity) => {\r\n    // More overscan for faster scrolling\r\n    return Math.min(Math.floor(Math.abs(velocity) / 100), 20);\r\n  }}\r\n/>\n"})}),"\n",(0,i.jsx)(n.h3,{id:"css-optimization",children:"CSS Optimization"}),"\n",(0,i.jsx)(n.p,{children:"Optimize CSS to work well with virtualization:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:"/* Avoid margins on items - use padding instead */\r\n.list-item {\r\n  padding: 12px; /* \u2705 Good - doesn't interfere with measurements */\r\n  /* margin: 12px; \u274c Bad - can cause measurement issues */\r\n}\r\n\r\n/* Use transform for positioning when possible */\r\n.item-container {\r\n  will-change: transform; /* Optimize for frequent changes */\r\n  contain: layout style paint; /* CSS containment for better performance */\r\n}\r\n\r\n/* Optimize for GPU acceleration */\r\n.smooth-item {\r\n  transform: translateZ(0); /* Force GPU layer */\r\n  backface-visibility: hidden;\r\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"component-variants",children:"Component Variants"}),"\n",(0,i.jsx)(n.h3,{id:"virtuoso-basic-list",children:"Virtuoso (Basic List)"}),"\n",(0,i.jsx)(n.p,{children:"The standard virtualized list component:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { Virtuoso } from "react-virtuoso";\r\n\r\nfunction BasicList({ items }) {\r\n  return (\r\n    <Virtuoso\r\n      style={{ height: "400px" }}\r\n      totalCount={items.length}\r\n      itemContent={(index) => (\r\n        <div style={{ padding: "12px", borderBottom: "1px solid #eee" }}>\r\n          {items[index].content}\r\n        </div>\r\n      )}\r\n      // Optional customizations\r\n      components={{\r\n        Header: () => <div>List Header</div>,\r\n        Footer: () => <div>List Footer</div>,\r\n        EmptyPlaceholder: () => <div>No items found</div>,\r\n      }}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"groupedvirtuoso-grouped-lists",children:"GroupedVirtuoso (Grouped Lists)"}),"\n",(0,i.jsx)(n.p,{children:"For lists with group headers and categorized content:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { GroupedVirtuoso } from "react-virtuoso";\r\n\r\nfunction GroupedList({ groups }) {\r\n  // Group structure: [{ title: \'Group 1\', items: [...] }, ...]\r\n  const groupCounts = groups.map((group) => group.items.length);\r\n\r\n  return (\r\n    <GroupedVirtuoso\r\n      style={{ height: "400px" }}\r\n      groupCounts={groupCounts}\r\n      groupContent={(index) => (\r\n        <div\r\n          style={{\r\n            padding: "8px 12px",\r\n            backgroundColor: "#f5f5f5",\r\n            fontWeight: "bold",\r\n            position: "sticky",\r\n            top: 0,\r\n            zIndex: 1,\r\n          }}\r\n        >\r\n          {groups[index].title}\r\n        </div>\r\n      )}\r\n      itemContent={(index, groupIndex) => (\r\n        <div style={{ padding: "12px", borderBottom: "1px solid #eee" }}>\r\n          {groups[groupIndex].items[index].content}\r\n        </div>\r\n      )}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"virtuosogrid-grid-layout",children:"VirtuosoGrid (Grid Layout)"}),"\n",(0,i.jsx)(n.p,{children:"For responsive grid layouts with equal-sized items:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"import { VirtuosoGrid } from 'react-virtuoso';\r\n\r\nfunction ResponsiveGrid({ items }) {\r\n  return (\r\n    <VirtuosoGrid\r\n      style={{ height: '400px' }}\r\n      totalCount={items.length}\r\n      itemContent={index => (\r\n        <div style={{\r\n          padding: '8px',\r\n          border: '1px solid #ddd',\r\n          borderRadius: '4px',\r\n          height: '200px' // Fixed height for grid items\r\n        }}>\r\n          <img src={items[index].image} alt={items[index].title} />\r\n          <h4>{items[index].title}</h4>\r\n        </div>\r\n      )}\r\n      listClassName=\"grid-container\"\r\n    />\r\n  );\r\n}\r\n\r\n/* CSS for responsive grid */\r\n.grid-container {\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\r\n  gap: 16px;\r\n  padding: 16px;\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"tablevirtuoso-table-virtualization",children:"TableVirtuoso (Table Virtualization)"}),"\n",(0,i.jsx)(n.p,{children:"For large tables with virtualized rows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { TableVirtuoso } from "react-virtuoso";\r\n\r\nfunction VirtualizedTable({ data, columns }) {\r\n  return (\r\n    <TableVirtuoso\r\n      style={{ height: "400px" }}\r\n      data={data}\r\n      components={{\r\n        Table: (props) => (\r\n          <table {...props} style={{ borderCollapse: "collapse" }} />\r\n        ),\r\n        TableHead: React.forwardRef((props, ref) => (\r\n          <thead {...props} ref={ref} />\r\n        )),\r\n        TableRow: (props) => (\r\n          <tr {...props} style={{ borderBottom: "1px solid #ddd" }} />\r\n        ),\r\n        TableBody: React.forwardRef((props, ref) => (\r\n          <tbody {...props} ref={ref} />\r\n        )),\r\n      }}\r\n      fixedHeaderContent={() => (\r\n        <tr>\r\n          {columns.map((col) => (\r\n            <th\r\n              key={col.key}\r\n              style={{\r\n                padding: "12px",\r\n                backgroundColor: "#f5f5f5",\r\n                position: "sticky",\r\n                top: 0,\r\n              }}\r\n            >\r\n              {col.title}\r\n            </th>\r\n          ))}\r\n        </tr>\r\n      )}\r\n      itemContent={(index, item) => (\r\n        <>\r\n          {columns.map((col) => (\r\n            <td key={col.key} style={{ padding: "12px" }}>\r\n              {item[col.key]}\r\n            </td>\r\n          ))}\r\n        </>\r\n      )}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,i.jsx)(n.h3,{id:"message-list-for-chat-applications",children:"Message List for Chat Applications"}),"\n",(0,i.jsx)(n.p,{children:"Specialized component for chat/message interfaces:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { VirtuosoMessageList } from "@virtuoso.dev/message-list";\r\n\r\nfunction ChatInterface() {\r\n  const [messages, setMessages] = useState([]);\r\n\r\n  return (\r\n    <VirtuosoMessageList\r\n      initialData={messages}\r\n      itemContent={(index, message) => (\r\n        <div\r\n          style={{\r\n            padding: "8px 12px",\r\n            maxWidth: "70%",\r\n            marginLeft: message.isOwn ? "auto" : "0",\r\n            marginRight: message.isOwn ? "0" : "auto",\r\n            backgroundColor: message.isOwn ? "#007bff" : "#e9ecef",\r\n            color: message.isOwn ? "white" : "black",\r\n            borderRadius: "12px",\r\n            marginBottom: "4px",\r\n          }}\r\n        >\r\n          {message.text}\r\n        </div>\r\n      )}\r\n      // Auto-scroll to bottom for new messages\r\n      followOutput="smooth"\r\n      // Handle loading older messages\r\n      startReached={() => loadOlderMessages()}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"infinite-scrolling",children:"Infinite Scrolling"}),"\n",(0,i.jsx)(n.p,{children:"Implement infinite scrolling with data loading:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'function InfiniteScrollList() {\r\n  const [items, setItems] = useState([]);\r\n  const [loading, setLoading] = useState(false);\r\n  const [hasMore, setHasMore] = useState(true);\r\n\r\n  const loadMore = useCallback(async () => {\r\n    if (loading || !hasMore) return;\r\n\r\n    setLoading(true);\r\n    try {\r\n      const newItems = await fetchMoreData(items.length);\r\n      setItems((prev) => [...prev, ...newItems]);\r\n      setHasMore(newItems.length > 0);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [items.length, loading, hasMore]);\r\n\r\n  return (\r\n    <Virtuoso\r\n      style={{ height: "400px" }}\r\n      totalCount={hasMore ? items.length + 1 : items.length}\r\n      itemContent={(index) => {\r\n        if (index === items.length) {\r\n          return (\r\n            <div style={{ padding: "20px", textAlign: "center" }}>\r\n              {loading ? "Loading..." : "Load More"}\r\n            </div>\r\n          );\r\n        }\r\n        return <Item data={items[index]} />;\r\n      }}\r\n      endReached={loadMore}\r\n      // Preload when user is near the end\r\n      overscan={5}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"custom-scrollbars",children:"Custom Scrollbars"}),"\n",(0,i.jsx)(n.p,{children:"Implement custom scrollbar styling:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"<Virtuoso\r\n  style={{ height: '400px' }}\r\n  totalCount={items.length}\r\n  itemContent={renderItem}\r\n  components={{\r\n    Scroller: React.forwardRef((props, ref) => (\r\n      <div\r\n        {...props}\r\n        ref={ref}\r\n        style={{\r\n          ...props.style,\r\n          // Custom scrollbar styles\r\n          scrollbarWidth: 'thin',\r\n          scrollbarColor: '#888 #f1f1f1'\r\n        }}\r\n        className=\"custom-scrollbar\"\r\n      />\r\n    ))\r\n  }}\r\n/>\r\n\r\n/* CSS for webkit browsers */\r\n.custom-scrollbar::-webkit-scrollbar {\r\n  width: 8px;\r\n}\r\n\r\n.custom-scrollbar::-webkit-scrollbar-track {\r\n  background: #f1f1f1;\r\n  border-radius: 4px;\r\n}\r\n\r\n.custom-scrollbar::-webkit-scrollbar-thumb {\r\n  background: #888;\r\n  border-radius: 4px;\r\n}\r\n\r\n.custom-scrollbar::-webkit-scrollbar-thumb:hover {\r\n  background: #555;\r\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"common-patterns--best-practices",children:"Common Patterns & Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"error-boundaries",children:"Error Boundaries"}),"\n",(0,i.jsx)(n.p,{children:"Wrap virtualized lists with error boundaries:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'class VirtuosoErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { hasError: false };\r\n  }\r\n\r\n  static getDerivedStateFromError(error) {\r\n    return { hasError: true };\r\n  }\r\n\r\n  componentDidCatch(error, errorInfo) {\r\n    console.error("Virtuoso error:", error, errorInfo);\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return (\r\n        <div style={{ padding: "20px", textAlign: "center" }}>\r\n          <h3>Something went wrong rendering the list</h3>\r\n          <button onClick={() => this.setState({ hasError: false })}>\r\n            Try Again\r\n          </button>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\n// Usage\r\nfunction App() {\r\n  return (\r\n    <VirtuosoErrorBoundary>\r\n      <Virtuoso totalCount={items.length} itemContent={renderItem} />\r\n    </VirtuosoErrorBoundary>\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,i.jsx)(n.p,{children:"Test virtualized components effectively:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { render, screen } from "@testing-library/react";\r\nimport { Virtuoso } from "react-virtuoso";\r\n\r\n// Mock intersection observer for tests\r\nbeforeAll(() => {\r\n  global.IntersectionObserver = jest.fn(() => ({\r\n    observe: jest.fn(),\r\n    disconnect: jest.fn(),\r\n    unobserve: jest.fn(),\r\n  }));\r\n});\r\n\r\ntest("renders visible items correctly", async () => {\r\n  const items = Array.from({ length: 1000 }, (_, i) => ({\r\n    id: i,\r\n    content: `Item ${i}`,\r\n  }));\r\n\r\n  render(\r\n    <Virtuoso\r\n      style={{ height: "400px" }}\r\n      totalCount={items.length}\r\n      itemContent={(index) => (\r\n        <div data-testid={`item-${index}`}>{items[index].content}</div>\r\n      )}\r\n    />\r\n  );\r\n\r\n  // Only visible items should be rendered\r\n  expect(screen.queryByTestId("item-0")).toBeInTheDocument();\r\n  expect(screen.queryByTestId("item-999")).not.toBeInTheDocument();\r\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,i.jsx)(n.p,{children:"Monitor virtualization performance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"function useVirtuosoPerformance() {\r\n  const [metrics, setMetrics] = useState({});\r\n\r\n  const onScroll = useCallback((scrollTop) => {\r\n    const start = performance.now();\r\n\r\n    // Measure scroll handling time\r\n    requestAnimationFrame(() => {\r\n      const duration = performance.now() - start;\r\n      setMetrics((prev) => ({\r\n        ...prev,\r\n        scrollHandlingTime: duration,\r\n        lastScrollTop: scrollTop,\r\n      }));\r\n    });\r\n  }, []);\r\n\r\n  return { metrics, onScroll };\r\n}\r\n\r\n// Usage\r\nfunction MonitoredList() {\r\n  const { metrics, onScroll } = useVirtuosoPerformance();\r\n\r\n  return (\r\n    <>\r\n      <div>Scroll handling: {metrics.scrollHandlingTime?.toFixed(2)}ms</div>\r\n      <Virtuoso\r\n        totalCount={items.length}\r\n        itemContent={renderItem}\r\n        onScroll={onScroll}\r\n      />\r\n    </>\r\n  );\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"accessibility-considerations",children:"Accessibility Considerations"}),"\n",(0,i.jsx)(n.p,{children:"Ensure virtualized lists are accessible:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'<Virtuoso\r\n  style={{ height: "400px" }}\r\n  totalCount={items.length}\r\n  itemContent={(index) => (\r\n    <div\r\n      role="listitem"\r\n      aria-setsize={items.length}\r\n      aria-posinset={index + 1}\r\n      tabIndex={0}\r\n      onKeyDown={(e) => {\r\n        if (e.key === "Enter" || e.key === " ") {\r\n          handleItemSelect(index);\r\n        }\r\n      }}\r\n    >\r\n      {items[index].content}\r\n    </div>\r\n  )}\r\n  components={{\r\n    List: React.forwardRef((props, ref) => (\r\n      <div\r\n        {...props}\r\n        ref={ref}\r\n        role="list"\r\n        aria-label="Virtualized item list"\r\n      />\r\n    )),\r\n  }}\r\n/>\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"how-react-virtuoso-handles-and-renders-items-to-the-dom",children:"How React Virtuoso Handles and Renders Items to the DOM"}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso employs a highly optimized approach to DOM rendering, ensuring that only the necessary elements are present in the DOM at any given time, regardless of the total dataset size. Here\u2019s a detailed look at how Virtuoso manages this process:"}),"\n",(0,i.jsx)(n.h3,{id:"visualizing-the-dom-lifecycle",children:"Visualizing the DOM Lifecycle"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:"graph LR\r\n  A[Initial Render: Items 0-19 in DOM] -- Scroll Down --\x3e B[Scroll: Items 10-29 in DOM]\r\n  B -- Scroll Down --\x3e C[Scroll: Items 20-39 in DOM]\r\n  C -- Scroll Up --\x3e B\r\n  B -- Scroll Up --\x3e A\r\n  A -. Items 20+ unmounted .-> C\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"A"}),": Only the first 20 items are rendered."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"B"}),": As you scroll, the DOM updates to show the next 20 items, unmounting those that left the buffer."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"C"}),": Further scrolling continues this process, always keeping the DOM size small."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-dom-node-recycling-and-buffer-management",children:"Example: DOM Node Recycling and Buffer Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { Virtuoso } from "react-virtuoso";\r\n\r\nfunction LoggingList({ items }) {\r\n  // This ref logs when items mount/unmount\r\n  const Item = ({ index }) => {\r\n    useEffect(() => {\r\n      console.log(`MOUNT: Item ${index}`);\r\n      return () => console.log(`UNMOUNT: Item ${index}`);\r\n    }, [index]);\r\n    return <div>Item {index}: {items[index].content}</div>;\r\n  };\r\n\r\n  return (\r\n    <Virtuoso\r\n      style={{ height: 300 }}\r\n      totalCount={items.length}\r\n      itemContent={index => <Item index={index} />}\r\n      overscan={5} // buffer of 5 items above/below\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Console Output Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"MOUNT: Item 0\r\nMOUNT: Item 1\r\n...\r\nMOUNT: Item 19\r\n// User scrolls down\r\nUNMOUNT: Item 0\r\nMOUNT: Item 20\r\n...\n"})}),"\n",(0,i.jsx)(n.p,{children:"This shows how Virtuoso mounts only visible/buffered items and unmounts those that leave the buffer, keeping the DOM light."}),"\n",(0,i.jsx)(n.h3,{id:"internal-buffer-and-recycling-logic-pseudocode",children:"Internal Buffer and Recycling Logic (Pseudocode)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function updateVisibleItems(scrollTop, viewportHeight, buffer, totalCount) {\r\n  const start = Math.max(0, findFirstVisible(scrollTop) - buffer);\r\n  const end = Math.min(totalCount, findLastVisible(scrollTop, viewportHeight) + buffer);\r\n  // Only items in [start, end) are mounted\r\n  return { start, end };\r\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"1-viewport-driven-rendering",children:["1. ",(0,i.jsx)(n.strong,{children:"Viewport-Driven Rendering"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visible Range Calculation:"})," Virtuoso continuously calculates which items are visible in the viewport based on the current scroll position and container height. This is achieved using efficient algorithms (like binary search) to quickly determine the first and last visible items."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Buffer/Overscan:"})," To ensure smooth scrolling, Virtuoso renders a configurable buffer (overscan) of items above and below the visible range. This prevents blank spaces during fast scrolls and allows for seamless user experience."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"2-dom-recycling-and-element-lifecycle",children:["2. ",(0,i.jsx)(n.strong,{children:"DOM Recycling and Element Lifecycle"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Minimal DOM Nodes:"})," Only the items within the visible range (plus buffer) are mounted in the DOM. For example, in a list of 10,000 items, the DOM might only contain 20-50 elements at any time."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Element Reuse:"})," As the user scrolls, Virtuoso reuses existing DOM nodes for new data, minimizing mounting/unmounting overhead. This recycling is managed internally, so React\u2019s reconciliation is optimized for performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unmounting:"})," Items that scroll out of the overscan buffer are unmounted, freeing up memory and reducing layout/repaint costs."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"3-dynamic-measurement-and-positioning",children:["3. ",(0,i.jsx)(n.strong,{children:"Dynamic Measurement and Positioning"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automatic Height Measurement:"})," Virtuoso uses the ResizeObserver API to measure the height of each rendered item. This allows it to handle variable-height content without manual configuration."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Offset Calculation:"})," The measured heights are used to calculate the offset (distance from the top) for each item. This ensures that each item is positioned accurately within the scrollable container, even as heights change dynamically."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Efficient Updates:"})," When an item\u2019s height changes (e.g., due to image loading), only the affected offsets and DOM nodes are updated, preserving scroll position and visual stability."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"4-rendering-pipeline",children:["4. ",(0,i.jsx)(n.strong,{children:"Rendering Pipeline"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Render Pass:"})," On each scroll event (throttled and optimized with requestAnimationFrame), Virtuoso determines the new visible range and updates the DOM accordingly."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State Synchronization:"})," The internal state tracks which items are currently rendered, their heights, and their offsets. This state is updated reactively, ensuring that only necessary changes trigger re-renders."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Programmatic Control:"})," Developers can programmatically scroll to specific items, and Virtuoso will ensure the correct DOM nodes are rendered and positioned."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"5-performance-and-best-practices",children:["5. ",(0,i.jsx)(n.strong,{children:"Performance and Best Practices"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"O(1) Rendering Complexity:"})," The number of DOM nodes remains constant regardless of list size, transforming rendering complexity from O(n) to O(1)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CSS Optimization:"})," Virtuoso recommends using padding instead of margins for item spacing, and leveraging CSS containment and GPU acceleration for optimal performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Boundaries:"})," Wrapping Virtuoso in an error boundary ensures that rendering errors do not crash the entire app."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"6-example-dom-rendering-lifecycle",children:["6. ",(0,i.jsx)(n.strong,{children:"Example: DOM Rendering Lifecycle"})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initial Render:"})," Only the items visible in the viewport (plus buffer) are rendered to the DOM."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scroll Event:"})," As the user scrolls, Virtuoso calculates the new visible range and updates the DOM, recycling nodes as needed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Height Change:"})," If an item\u2019s height changes, Virtuoso re-measures and updates offsets, adjusting the scroll position if necessary to maintain visual stability."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unmounting:"})," Items that move out of the overscan buffer are unmounted from the DOM."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"visual-example-what-the-dom-looks-like-during-virtualization",children:"Visual Example: What the DOM Looks Like During Virtualization"}),"\n",(0,i.jsx)(n.p,{children:"When Virtuoso renders a large list, the DOM structure looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'<div class="virtuoso-scroller" style="overflow: auto; height: 400px;">\r\n  <div class="virtuoso-item-list" style="position: relative;">\r\n    \r\n    \x3c!-- Top spacer for items 0\u201349 --\x3e\r\n    <div style="height: 2400px;"></div>\r\n    \r\n    \x3c!-- Rendered items (50\u201360) --\x3e\r\n    <div style="position: absolute; top: 2400px; height: 48px;">Item 50</div>\r\n    <div style="position: absolute; top: 2448px; height: 48px;">Item 51</div>\r\n    <div style="position: absolute; top: 2496px; height: 48px;">Item 52</div>\r\n    ...\r\n    <div style="position: absolute; top: 2928px; height: 48px;">Item 60</div>\r\n    \r\n    \x3c!-- Bottom spacer for items after 60 --\x3e\r\n    <div style="height: 1000px;"></div>\r\n  </div>\r\n</div>\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.strong,{children:"top spacer"})," simulates the space taken by all items above the visible window (items 0\u201349)."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.strong,{children:"rendered items"})," (50\u201360) are absolutely positioned at their calculated offsets."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.strong,{children:"bottom spacer"})," simulates the space for all items after the rendered window."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This structure allows the scroll bar to reflect the full list height, while only a small subset of items are actually in the DOM."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["For a more in-depth technical breakdown, see the ",(0,i.jsx)(n.a,{href:"https://chatgpt.com/share/689a2e39-c320-8007-bd6b-b194996873cb",children:"shared ChatGPT resource"})," and the ",(0,i.jsx)(n.a,{href:"https://virtuoso.dev/",children:"official documentation"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso represents a sophisticated approach to handling large datasets in React applications. Its automatic height measurement, efficient offset management, and smooth scrolling capabilities make it an excellent choice for performance-critical applications. By understanding its internal mechanisms\u2014from viewport management to variable height handling\u2014developers can leverage its full potential while avoiding common pitfalls."}),"\n",(0,i.jsx)(n.p,{children:"Key takeaways:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Virtualization transforms O(n) to O(1)"})," rendering complexity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automatic height measurement"})," eliminates manual configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Smart offset calculation"})," maintains scroll position accuracy"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Proper memoization"})," is crucial for optimal performance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Component variants"})," address different use cases efficiently"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Whether building chat interfaces, data tables, or image galleries, React Virtuoso provides the tools needed to create smooth, performant user experiences at any scale."}),"\n",(0,i.jsxs)(n.p,{children:["Further reading: ",(0,i.jsx)(n.a,{href:"https://virtuoso.dev/",children:"React Virtuoso Documentation"})," | ",(0,i.jsx)(n.a,{href:"https://github.com/petyosi/react-virtuoso",children:"GitHub Repository"})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(6540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);