"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6023],{7394:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"project-detail/web-worker","title":"Web Workers: Background Threading in the Browser","description":"Table of Contents","source":"@site/docs/project-detail/web-worker.md","sourceDirName":"project-detail","slug":"/project-detail/web-worker","permalink":"/frontend-system-design/docs/project-detail/web-worker","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/web-worker.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"WebSockets: Real-Time Communication Under the Hood","permalink":"/frontend-system-design/docs/project-detail/web-socket"},"next":{"title":"Service Workers: The Gateway to Progressive Web Apps","permalink":"/frontend-system-design/docs/project-detail/service-worker"}}');var s=r(4848),t=r(8453);const o={},i="Web Workers: Background Threading in the Browser",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Benefits",id:"key-benefits",level:3},{value:"Common Use Cases",id:"common-use-cases",level:3},{value:"Getting Started with Web Workers",id:"getting-started-with-web-workers",level:2},{value:"Browser Support Check",id:"browser-support-check",level:3},{value:"Basic Worker Implementation",id:"basic-worker-implementation",level:3},{value:"Main Thread (app.js)",id:"main-thread-appjs",level:4},{value:"Worker Script (worker.js)",id:"worker-script-workerjs",level:4},{value:"Types of Web Workers",id:"types-of-web-workers",level:2},{value:"Dedicated Workers",id:"dedicated-workers",level:3},{value:"Shared Workers",id:"shared-workers",level:3},{value:"Shared Worker Script (shared-worker.js)",id:"shared-worker-script-shared-workerjs",level:4},{value:"Using Shared Workers",id:"using-shared-workers",level:4},{value:"Under the Hood: Threading Model",id:"under-the-hood-threading-model",level:2},{value:"Browser Threading Architecture",id:"browser-threading-architecture",level:3},{value:"Worker Global Scope",id:"worker-global-scope",level:3},{value:"Message Passing and Data Transfer",id:"message-passing-and-data-transfer",level:2},{value:"Structured Clone Algorithm",id:"structured-clone-algorithm",level:3},{value:"Transferable Objects for Performance",id:"transferable-objects-for-performance",level:3},{value:"Advanced Message Handler",id:"advanced-message-handler",level:3},{value:"Worker Lifecycle Management",id:"worker-lifecycle-management",level:2},{value:"Worker Pool Implementation",id:"worker-pool-implementation",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Fibonacci Calculation Example",id:"fibonacci-calculation-example",level:3},{value:"Usage with Performance Monitoring",id:"usage-with-performance-monitoring",level:3},{value:"Real-World Implementation Examples",id:"real-world-implementation-examples",level:2},{value:"Image Processing Worker",id:"image-processing-worker",level:3},{value:"Error Handling and Debugging",id:"error-handling-and-debugging",level:2},{value:"Comprehensive Error Handling",id:"comprehensive-error-handling",level:3},{value:"Best Practices and Limitations",id:"best-practices-and-limitations",level:2},{value:"Best Practices",id:"best-practices",level:3},{value:"Limitations and Considerations",id:"limitations-and-considerations",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"When to Use Web Workers",id:"when-to-use-web-workers",level:3},{value:"Further Resources",id:"further-resources",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"web-workers-background-threading-in-the-browser",children:"Web Workers: Background Threading in the Browser"})}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getting-started-with-web-workers",children:"Getting Started with Web Workers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#types-of-web-workers",children:"Types of Web Workers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#under-the-hood-threading-model",children:"Under the Hood: Threading Model"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#message-passing-and-data-transfer",children:"Message Passing and Data Transfer"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#worker-lifecycle-management",children:"Worker Lifecycle Management"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#advanced-features-and-patterns",children:"Advanced Features and Patterns"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#real-world-implementation-examples",children:"Real-World Implementation Examples"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#error-handling-and-debugging",children:"Error Handling and Debugging"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#best-practices-and-limitations",children:"Best Practices and Limitations"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"Web Workers provide a way to run JavaScript code in background threads, separate from the main execution thread of a web page. This enables true parallel processing in web applications, allowing intensive computations to be performed without blocking the user interface."}),"\n",(0,s.jsxs)(n.p,{children:["As outlined in the ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers",children:"MDN Web Workers documentation"}),", Web Workers solve the fundamental problem of JavaScript's single-threaded nature by providing isolated execution contexts that can communicate with the main thread through message passing."]}),"\n",(0,s.jsx)(n.h3,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Non-blocking Operations"}),": Heavy computations don't freeze the UI"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"True Parallelism"}),": Multiple workers can run simultaneously"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Isolated Execution"}),": Workers can't accidentally interfere with the main thread"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network Access"}),": Workers can make HTTP requests independently"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Shared Processing"}),": Multiple scripts can share worker resources"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Image/video processing"}),"\n",(0,s.jsx)(n.li,{children:"Cryptographic operations"}),"\n",(0,s.jsx)(n.li,{children:"Data parsing and analysis"}),"\n",(0,s.jsx)(n.li,{children:"Background data synchronization"}),"\n",(0,s.jsx)(n.li,{children:"Real-time data processing"}),"\n",(0,s.jsx)(n.li,{children:"Mathematical calculations"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"getting-started-with-web-workers",children:"Getting Started with Web Workers"}),"\n",(0,s.jsx)(n.h3,{id:"browser-support-check",children:"Browser Support Check"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Feature detection for Web Workers\nfunction supportsWebWorkers() {\n  return typeof Worker !== "undefined";\n}\n\nif (supportsWebWorkers()) {\n  console.log("Web Workers are supported");\n} else {\n  console.log("Web Workers are not supported");\n  // Provide fallback functionality\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"basic-worker-implementation",children:"Basic Worker Implementation"}),"\n",(0,s.jsx)(n.h4,{id:"main-thread-appjs",children:"Main Thread (app.js)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Check for Web Worker support\nif (window.Worker) {\n  // Create a new worker\n  const worker = new Worker("worker.js");\n\n  // Send data to worker\n  worker.postMessage({ command: "start", data: [1, 2, 3, 4, 5] });\n\n  // Listen for messages from worker\n  worker.onmessage = function (event) {\n    console.log("Message from worker:", event.data);\n    document.getElementById("result").textContent = event.data;\n  };\n\n  // Handle worker errors\n  worker.onerror = function (error) {\n    console.error("Worker error:", error);\n  };\n\n  // Optional: Handle worker termination\n  worker.onmessageerror = function (event) {\n    console.error("Message error:", event);\n  };\n} else {\n  console.log("Web Workers not supported");\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"worker-script-workerjs",children:"Worker Script (worker.js)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Worker global scope - no access to DOM or window object\nconsole.log("Worker started");\n\n// Listen for messages from main thread\nself.onmessage = function (event) {\n  console.log("Worker received:", event.data);\n\n  const { command, data } = event.data;\n\n  switch (command) {\n    case "start":\n      const result = processData(data);\n      self.postMessage(result);\n      break;\n    case "stop":\n      self.close(); // Terminate worker from inside\n      break;\n    default:\n      self.postMessage({ error: "Unknown command" });\n  }\n};\n\n// Function to process data\nfunction processData(numbers) {\n  // Simulate intensive computation\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * numbers[i];\n\n    // Simulate heavy work\n    for (let j = 0; j < 1000000; j++) {\n      Math.random();\n    }\n  }\n\n  return { result: sum, processed: numbers.length };\n}\n\n// Handle errors in worker\nself.onerror = function (error) {\n  console.error("Error in worker:", error);\n  self.postMessage({ error: error.message });\n};\n'})}),"\n",(0,s.jsx)(n.h2,{id:"types-of-web-workers",children:"Types of Web Workers"}),"\n",(0,s.jsx)(n.h3,{id:"dedicated-workers",children:"Dedicated Workers"}),"\n",(0,s.jsx)(n.p,{children:"Dedicated workers are tied to a single script and provide isolated execution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class DedicatedWorkerManager {\n  constructor(workerScript) {\n    this.worker = new Worker(workerScript);\n    this.messageId = 0;\n    this.pendingMessages = new Map();\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.worker.onmessage = (event) => {\n      const { messageId, result, error } = event.data;\n\n      if (this.pendingMessages.has(messageId)) {\n        const { resolve, reject } = this.pendingMessages.get(messageId);\n        this.pendingMessages.delete(messageId);\n\n        if (error) {\n          reject(new Error(error));\n        } else {\n          resolve(result);\n        }\n      }\n    };\n\n    this.worker.onerror = (error) => {\n      console.error("Worker error:", error);\n    };\n  }\n\n  async execute(command, data) {\n    return new Promise((resolve, reject) => {\n      const messageId = ++this.messageId;\n      this.pendingMessages.set(messageId, { resolve, reject });\n\n      this.worker.postMessage({\n        messageId,\n        command,\n        data,\n      });\n    });\n  }\n\n  terminate() {\n    this.worker.terminate();\n    this.pendingMessages.clear();\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"shared-workers",children:"Shared Workers"}),"\n",(0,s.jsx)(n.p,{children:"Shared workers can be accessed by multiple scripts across different contexts:"}),"\n",(0,s.jsx)(n.h4,{id:"shared-worker-script-shared-workerjs",children:"Shared Worker Script (shared-worker.js)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const connections = [];\nlet sharedData = { counter: 0, messages: [] };\n\nself.onconnect = function (event) {\n  const port = event.ports[0];\n  connections.push(port);\n\n  console.log("New connection to shared worker");\n\n  port.onmessage = function (event) {\n    const { action, data } = event.data;\n\n    switch (action) {\n      case "increment":\n        sharedData.counter++;\n        broadcastToAllPorts({ type: "counter", value: sharedData.counter });\n        break;\n\n      case "addMessage":\n        sharedData.messages.push(data);\n        broadcastToAllPorts({ type: "newMessage", message: data });\n        break;\n\n      case "getData":\n        port.postMessage({ type: "data", data: sharedData });\n        break;\n    }\n  };\n\n  port.start();\n\n  // Send initial data\n  port.postMessage({ type: "connected", data: sharedData });\n};\n\nfunction broadcastToAllPorts(message) {\n  connections.forEach((port) => {\n    try {\n      port.postMessage(message);\n    } catch (error) {\n      // Port might be closed\n      console.warn("Failed to send message to port:", error);\n    }\n  });\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"using-shared-workers",children:"Using Shared Workers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Multiple scripts can connect to the same shared worker\nclass SharedWorkerClient {\n  constructor() {\n    this.worker = new SharedWorker("shared-worker.js");\n    this.port = this.worker.port;\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.port.onmessage = (event) => {\n      const { type, data, value, message } = event.data;\n\n      switch (type) {\n        case "connected":\n          console.log("Connected to shared worker:", data);\n          break;\n        case "counter":\n          this.updateCounter(value);\n          break;\n        case "newMessage":\n          this.displayMessage(message);\n          break;\n      }\n    };\n\n    this.port.start();\n  }\n\n  increment() {\n    this.port.postMessage({ action: "increment" });\n  }\n\n  addMessage(message) {\n    this.port.postMessage({ action: "addMessage", data: message });\n  }\n\n  getData() {\n    this.port.postMessage({ action: "getData" });\n  }\n\n  updateCounter(value) {\n    document.getElementById("counter").textContent = value;\n  }\n\n  displayMessage(message) {\n    const messagesList = document.getElementById("messages");\n    const messageElement = document.createElement("div");\n    messageElement.textContent = message;\n    messagesList.appendChild(messageElement);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"under-the-hood-threading-model",children:"Under the Hood: Threading Model"}),"\n",(0,s.jsx)(n.h3,{id:"browser-threading-architecture",children:"Browser Threading Architecture"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Browser Process                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Main Thread              \u2502      Worker Threads         \u2502\n\u2502  \u251c\u2500\u2500\u2500 DOM Manipulation    \u2502      \u251c\u2500\u2500\u2500 Worker 1          \u2502\n\u2502  \u251c\u2500\u2500\u2500 Event Handling      \u2502      \u251c\u2500\u2500\u2500 Worker 2          \u2502\n\u2502  \u251c\u2500\u2500\u2500 JavaScript Engine   \u2502      \u251c\u2500\u2500\u2500 Worker N          \u2502\n\u2502  \u2514\u2500\u2500\u2500 Rendering Pipeline  \u2502      \u2514\u2500\u2500\u2500 Shared Workers    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502              Message Passing Layer                      \u2502\n\u2502              (Structured Clone Algorithm)               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h3,{id:"worker-global-scope",children:"Worker Global Scope"}),"\n",(0,s.jsx)(n.p,{children:"Workers run in a different global context than the main thread:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// In worker context - these are available\nconsole.log(self); // WorkerGlobalScope\nconsole.log(location); // WorkerLocation\nconsole.log(navigator); // WorkerNavigator\n\n// These are NOT available in workers\n// console.log(window); // undefined\n// console.log(document); // undefined\n// console.log(parent); // undefined\n\n// Worker-specific APIs available\nimportScripts("https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js");\n\n// Network requests are available\nfetch("/api/data")\n  .then((response) => response.json())\n  .then((data) => {\n    self.postMessage({ type: "dataLoaded", data });\n  });\n\n// IndexedDB is available for storage\nconst request = indexedDB.open("WorkerDB", 1);\nrequest.onsuccess = (event) => {\n  const db = event.target.result;\n  // Use IndexedDB in worker\n};\n'})}),"\n",(0,s.jsx)(n.h2,{id:"message-passing-and-data-transfer",children:"Message Passing and Data Transfer"}),"\n",(0,s.jsx)(n.h3,{id:"structured-clone-algorithm",children:"Structured Clone Algorithm"}),"\n",(0,s.jsx)(n.p,{children:"The browser uses the structured clone algorithm to transfer data between threads:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Data types that can be transferred\nconst transferableData = {\n  // Primitives\n  string: "Hello",\n  number: 42,\n  boolean: true,\n  null: null,\n  undefined: undefined,\n\n  // Objects\n  object: { key: "value", nested: { data: true } },\n  array: [1, 2, 3, { nested: "array" }],\n  date: new Date(),\n  regexp: /pattern/gi,\n\n  // Binary data\n  arrayBuffer: new ArrayBuffer(8),\n  typedArray: new Uint8Array([1, 2, 3, 4]),\n\n  // Complex objects\n  map: new Map([["key", "value"]]),\n  set: new Set([1, 2, 3]),\n\n  // Not transferable (will cause errors)\n  // functions: () => {},\n  // domElements: document.createElement(\'div\'),\n  // symbols: Symbol(\'test\')\n};\n\nworker.postMessage(transferableData);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"transferable-objects-for-performance",children:"Transferable Objects for Performance"}),"\n",(0,s.jsx)(n.p,{children:"For large data, use transferable objects to avoid copying:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Main thread\nconst largeBuffer = new ArrayBuffer(1024 * 1024); // 1MB\nconst uint8View = new Uint8Array(largeBuffer);\n\n// Fill with data\nfor (let i = 0; i < uint8View.length; i++) {\n  uint8View[i] = i % 256;\n}\n\n// Transfer ownership to worker (zero-copy)\nworker.postMessage(\n  { command: "processLargeData", buffer: largeBuffer },\n  [largeBuffer] // Transferable objects list\n);\n\n// Note: largeBuffer is now neutered and unusable in main thread\nconsole.log(largeBuffer.byteLength); // 0\n'})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-message-handler",children:"Advanced Message Handler"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WorkerMessageHandler {\n  constructor(worker) {\n    this.worker = worker;\n    this.messageQueue = [];\n    this.isProcessing = false;\n    this.responseTimeout = 30000; // 30 seconds\n    this.setupMessageHandling();\n  }\n\n  setupMessageHandling() {\n    this.worker.onmessage = (event) => {\n      this.handleMessage(event.data);\n    };\n  }\n\n  async sendMessage(message, transferable = []) {\n    return new Promise((resolve, reject) => {\n      const messageId = this.generateMessageId();\n      const timeoutId = setTimeout(() => {\n        reject(new Error("Message timeout"));\n      }, this.responseTimeout);\n\n      const messageData = {\n        id: messageId,\n        payload: message,\n        timestamp: Date.now(),\n        resolve: (result) => {\n          clearTimeout(timeoutId);\n          resolve(result);\n        },\n        reject: (error) => {\n          clearTimeout(timeoutId);\n          reject(error);\n        },\n      };\n\n      this.messageQueue.push(messageData);\n\n      this.worker.postMessage(\n        {\n          id: messageId,\n          payload: message,\n          timestamp: Date.now(),\n        },\n        transferable\n      );\n    });\n  }\n\n  handleMessage(data) {\n    const { id, result, error } = data;\n    const message = this.messageQueue.find((msg) => msg.id === id);\n\n    if (message) {\n      this.messageQueue = this.messageQueue.filter((msg) => msg.id !== id);\n\n      if (error) {\n        message.reject(new Error(error));\n      } else {\n        message.resolve(result);\n      }\n    }\n  }\n\n  generateMessageId() {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getQueueLength() {\n    return this.messageQueue.length;\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"worker-lifecycle-management",children:"Worker Lifecycle Management"}),"\n",(0,s.jsx)(n.h3,{id:"worker-pool-implementation",children:"Worker Pool Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class WorkerPool {\n  constructor(workerScript, poolSize = navigator.hardwareConcurrency || 4) {\n    this.workerScript = workerScript;\n    this.poolSize = poolSize;\n    this.workers = [];\n    this.availableWorkers = [];\n    this.taskQueue = [];\n    this.activeTasksCount = 0;\n\n    this.initializePool();\n  }\n\n  initializePool() {\n    for (let i = 0; i < this.poolSize; i++) {\n      const worker = new Worker(this.workerScript);\n      const workerWrapper = {\n        id: i,\n        worker: worker,\n        busy: false,\n        currentTask: null,\n      };\n\n      worker.onmessage = (event) => {\n        this.handleWorkerMessage(workerWrapper, event);\n      };\n\n      worker.onerror = (error) => {\n        this.handleWorkerError(workerWrapper, error);\n      };\n\n      this.workers.push(workerWrapper);\n      this.availableWorkers.push(workerWrapper);\n    }\n  }\n\n  async execute(task, transferable = []) {\n    return new Promise((resolve, reject) => {\n      const taskData = {\n        id: this.generateTaskId(),\n        task,\n        transferable,\n        resolve,\n        reject,\n        createdAt: Date.now(),\n      };\n\n      if (this.availableWorkers.length > 0) {\n        this.assignTaskToWorker(taskData);\n      } else {\n        this.taskQueue.push(taskData);\n      }\n    });\n  }\n\n  assignTaskToWorker(taskData) {\n    const workerWrapper = this.availableWorkers.shift();\n    workerWrapper.busy = true;\n    workerWrapper.currentTask = taskData;\n    this.activeTasksCount++;\n\n    workerWrapper.worker.postMessage(\n      {\n        taskId: taskData.id,\n        ...taskData.task,\n      },\n      taskData.transferable\n    );\n  }\n\n  handleWorkerMessage(workerWrapper, event) {\n    const { taskId, result, error } = event.data;\n    const task = workerWrapper.currentTask;\n\n    if (task && task.id === taskId) {\n      workerWrapper.busy = false;\n      workerWrapper.currentTask = null;\n      this.activeTasksCount--;\n      this.availableWorkers.push(workerWrapper);\n\n      if (error) {\n        task.reject(new Error(error));\n      } else {\n        task.resolve(result);\n      }\n\n      // Process next task in queue\n      if (this.taskQueue.length > 0) {\n        const nextTask = this.taskQueue.shift();\n        this.assignTaskToWorker(nextTask);\n      }\n    }\n  }\n\n  handleWorkerError(workerWrapper, error) {\n    console.error(`Worker ${workerWrapper.id} error:`, error);\n\n    if (workerWrapper.currentTask) {\n      workerWrapper.currentTask.reject(error);\n    }\n\n    // Restart the worker\n    this.restartWorker(workerWrapper);\n  }\n\n  restartWorker(workerWrapper) {\n    workerWrapper.worker.terminate();\n\n    const newWorker = new Worker(this.workerScript);\n    workerWrapper.worker = newWorker;\n    workerWrapper.busy = false;\n    workerWrapper.currentTask = null;\n\n    newWorker.onmessage = (event) => {\n      this.handleWorkerMessage(workerWrapper, event);\n    };\n\n    newWorker.onerror = (error) => {\n      this.handleWorkerError(workerWrapper, error);\n    };\n  }\n\n  generateTaskId() {\n    return `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getStats() {\n    return {\n      poolSize: this.poolSize,\n      activeWorkers: this.workers.filter((w) => w.busy).length,\n      availableWorkers: this.availableWorkers.length,\n      queuedTasks: this.taskQueue.length,\n      activeTasks: this.activeTasksCount,\n    };\n  }\n\n  terminate() {\n    this.workers.forEach((workerWrapper) => {\n      workerWrapper.worker.terminate();\n    });\n\n    this.workers = [];\n    this.availableWorkers = [];\n    this.taskQueue = [];\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"fibonacci-calculation-example",children:"Fibonacci Calculation Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Optimized worker for mathematical calculations\n// fibonacci-worker.js\nconst fibonacciCache = new Map();\n\nself.onmessage = function (event) {\n  const { taskId, command, data } = event.data;\n\n  try {\n    let result;\n\n    switch (command) {\n      case "fibonacci":\n        result = calculateFibonacci(data.n);\n        break;\n      case "fibonacciSequence":\n        result = calculateFibonacciSequence(data.start, data.end);\n        break;\n      case "clearCache":\n        fibonacciCache.clear();\n        result = "Cache cleared";\n        break;\n      default:\n        throw new Error(`Unknown command: ${command}`);\n    }\n\n    self.postMessage({ taskId, result });\n  } catch (error) {\n    self.postMessage({ taskId, error: error.message });\n  }\n};\n\nfunction calculateFibonacci(n) {\n  if (n < 0) throw new Error("Negative numbers not supported");\n  if (n <= 1) return n;\n\n  if (fibonacciCache.has(n)) {\n    return fibonacciCache.get(n);\n  }\n\n  let a = 0,\n    b = 1;\n  for (let i = 2; i <= n; i++) {\n    [a, b] = [b, a + b];\n  }\n\n  fibonacciCache.set(n, b);\n  return b;\n}\n\nfunction calculateFibonacciSequence(start, end) {\n  const sequence = [];\n  for (let i = start; i <= end; i++) {\n    sequence.push(calculateFibonacci(i));\n  }\n  return sequence;\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"usage-with-performance-monitoring",children:"Usage with Performance Monitoring"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class FibonacciCalculator {\n  constructor() {\n    this.workerPool = new WorkerPool("fibonacci-worker.js", 2);\n  }\n\n  async calculateFibonacci(n) {\n    const startTime = performance.now();\n\n    try {\n      const result = await this.workerPool.execute({\n        command: "fibonacci",\n        data: { n },\n      });\n\n      const endTime = performance.now();\n      console.log(\n        `Fibonacci(${n}) = ${result} (took ${endTime - startTime}ms)`\n      );\n\n      return result;\n    } catch (error) {\n      console.error("Fibonacci calculation failed:", error);\n      throw error;\n    }\n  }\n\n  async calculateSequence(start, end) {\n    const startTime = performance.now();\n\n    try {\n      const result = await this.workerPool.execute({\n        command: "fibonacciSequence",\n        data: { start, end },\n      });\n\n      const endTime = performance.now();\n      console.log(\n        `Fibonacci sequence [${start}-${end}] calculated in ${\n          endTime - startTime\n        }ms`\n      );\n\n      return result;\n    } catch (error) {\n      console.error("Fibonacci sequence calculation failed:", error);\n      throw error;\n    }\n  }\n}\n\n// Usage\nconst calculator = new FibonacciCalculator();\n\n// Calculate individual Fibonacci numbers\ncalculator.calculateFibonacci(40).then(console.log);\n\n// Calculate sequence\ncalculator.calculateSequence(10, 20).then(console.log);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-implementation-examples",children:"Real-World Implementation Examples"}),"\n",(0,s.jsx)(n.h3,{id:"image-processing-worker",children:"Image Processing Worker"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// image-processor-worker.js\nself.onmessage = function (event) {\n  const { taskId, command, imageData, options } = event.data;\n\n  try {\n    let result;\n\n    switch (command) {\n      case "grayscale":\n        result = applyGrayscale(imageData);\n        break;\n      case "blur":\n        result = applyBlur(imageData, options.radius || 1);\n        break;\n      case "brightness":\n        result = adjustBrightness(imageData, options.factor || 1);\n        break;\n      default:\n        throw new Error(`Unknown command: ${command}`);\n    }\n\n    self.postMessage({ taskId, result }, [result.data.buffer]);\n  } catch (error) {\n    self.postMessage({ taskId, error: error.message });\n  }\n};\n\nfunction applyGrayscale(imageData) {\n  const data = new Uint8ClampedArray(imageData.data);\n\n  for (let i = 0; i < data.length; i += 4) {\n    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];\n    data[i] = gray; // Red\n    data[i + 1] = gray; // Green\n    data[i + 2] = gray; // Blue\n    // Alpha channel (data[i + 3]) remains unchanged\n  }\n\n  return new ImageData(data, imageData.width, imageData.height);\n}\n\nfunction applyBlur(imageData, radius) {\n  const data = new Uint8ClampedArray(imageData.data);\n  const width = imageData.width;\n  const height = imageData.height;\n  const output = new Uint8ClampedArray(data.length);\n\n  // Simple box blur implementation\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let r = 0,\n        g = 0,\n        b = 0,\n        a = 0,\n        count = 0;\n\n      for (let dy = -radius; dy <= radius; dy++) {\n        for (let dx = -radius; dx <= radius; dx++) {\n          const ny = y + dy;\n          const nx = x + dx;\n\n          if (ny >= 0 && ny < height && nx >= 0 && nx < width) {\n            const idx = (ny * width + nx) * 4;\n            r += data[idx];\n            g += data[idx + 1];\n            b += data[idx + 2];\n            a += data[idx + 3];\n            count++;\n          }\n        }\n      }\n\n      const idx = (y * width + x) * 4;\n      output[idx] = r / count;\n      output[idx + 1] = g / count;\n      output[idx + 2] = b / count;\n      output[idx + 3] = a / count;\n    }\n  }\n\n  return new ImageData(output, width, height);\n}\n\nfunction adjustBrightness(imageData, factor) {\n  const data = new Uint8ClampedArray(imageData.data);\n\n  for (let i = 0; i < data.length; i += 4) {\n    data[i] = Math.min(255, data[i] * factor); // Red\n    data[i + 1] = Math.min(255, data[i + 1] * factor); // Green\n    data[i + 2] = Math.min(255, data[i + 2] * factor); // Blue\n    // Alpha channel remains unchanged\n  }\n\n  return new ImageData(data, imageData.width, imageData.height);\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling-and-debugging",children:"Error Handling and Debugging"}),"\n",(0,s.jsx)(n.h3,{id:"comprehensive-error-handling",children:"Comprehensive Error Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class RobustWorkerManager {\n  constructor(workerScript) {\n    this.workerScript = workerScript;\n    this.worker = null;\n    this.isTerminated = false;\n    this.retryCount = 0;\n    this.maxRetries = 3;\n    this.retryDelay = 1000;\n\n    this.initializeWorker();\n  }\n\n  initializeWorker() {\n    try {\n      this.worker = new Worker(this.workerScript);\n      this.setupEventHandlers();\n      this.retryCount = 0;\n    } catch (error) {\n      console.error("Failed to create worker:", error);\n      this.handleWorkerCreationError(error);\n    }\n  }\n\n  setupEventHandlers() {\n    this.worker.onmessage = (event) => {\n      this.handleMessage(event);\n    };\n\n    this.worker.onerror = (error) => {\n      console.error("Worker runtime error:", error);\n      this.handleWorkerError(error);\n    };\n\n    this.worker.onmessageerror = (event) => {\n      console.error("Worker message error:", event);\n      this.handleMessageError(event);\n    };\n  }\n\n  handleWorkerCreationError(error) {\n    if (this.retryCount < this.maxRetries) {\n      this.retryCount++;\n      console.log(\n        `Retrying worker creation (${this.retryCount}/${this.maxRetries})`\n      );\n\n      setTimeout(() => {\n        this.initializeWorker();\n      }, this.retryDelay * this.retryCount);\n    } else {\n      console.error("Max retries reached. Worker creation failed permanently.");\n    }\n  }\n\n  handleWorkerError(error) {\n    console.error("Worker error occurred:", {\n      message: error.message,\n      filename: error.filename,\n      lineno: error.lineno,\n      colno: error.colno,\n    });\n\n    // Attempt to restart worker\n    this.restartWorker();\n  }\n\n  handleMessageError(event) {\n    console.error("Message serialization error:", event);\n    // Handle cases where message couldn\'t be cloned\n  }\n\n  restartWorker() {\n    if (!this.isTerminated && this.retryCount < this.maxRetries) {\n      console.log("Restarting worker...");\n      this.terminate();\n      this.initializeWorker();\n    }\n  }\n\n  terminate() {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n    }\n    this.isTerminated = true;\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-and-limitations",children:"Best Practices and Limitations"}),"\n",(0,s.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// \u2705 Good: Minimize data transfer\nclass EfficientWorkerManager {\n  constructor() {\n    this.worker = new Worker("worker.js");\n    this.cache = new Map();\n  }\n\n  async processLargeDataset(data) {\n    // Send only necessary data\n    const essentialData = data.map((item) => ({\n      id: item.id,\n      value: item.computeValue,\n    }));\n\n    return await this.sendMessage({\n      command: "process",\n      data: essentialData,\n    });\n  }\n\n  // \u2705 Good: Reuse workers\n  async batchProcess(tasks) {\n    const results = [];\n\n    for (const task of tasks) {\n      results.push(await this.processTask(task));\n    }\n\n    return results;\n  }\n}\n\n// \u274c Bad: Creating new workers for each task\nclass InefficientWorkerManager {\n  async processTask(data) {\n    const worker = new Worker("worker.js"); // Don\'t do this\n\n    return new Promise((resolve) => {\n      worker.postMessage(data);\n      worker.onmessage = (event) => {\n        resolve(event.data);\n        worker.terminate(); // Wasteful\n      };\n    });\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"limitations-and-considerations",children:"Limitations and Considerations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Worker limitations demonstration\n// worker-limitations.js\n\n// \u274c These will cause errors in workers:\ntry {\n  // DOM access not allowed\n  document.getElementById("test");\n} catch (error) {\n  console.error("DOM access failed:", error.message);\n}\n\ntry {\n  // Window object not available\n  window.alert("Hello");\n} catch (error) {\n  console.error("Window access failed:", error.message);\n}\n\ntry {\n  // Parent object not available\n  parent.postMessage("test");\n} catch (error) {\n  console.error("Parent access failed:", error.message);\n}\n\n// \u2705 These work in workers:\nconsole.log("Console works");\nsetTimeout(() => console.log("Timers work"), 1000);\nfetch("/api/data").then((response) => console.log("Fetch works"));\n\n// Import external scripts\nimportScripts("/lib/utility.js");\n\n// Use Web APIs available to workers\nconst db = indexedDB.open("WorkerDB");\nconst cache = caches.open("worker-cache");\n'})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Web Workers provide a powerful mechanism for achieving true parallelism in web applications, enabling developers to perform intensive computations without blocking the main thread. By understanding their threading model, message passing mechanisms, and best practices, developers can create responsive applications that effectively utilize modern multi-core processors."}),"\n",(0,s.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Threading Model"}),": Web Workers run in isolated contexts with their own global scope, providing true parallel execution."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message Passing"}),": The structured clone algorithm enables efficient data transfer, while transferable objects provide zero-copy transfers for large data."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Worker Types"}),": Dedicated workers serve single scripts, while shared workers enable cross-context communication."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": Proper worker pool management and data transfer optimization are crucial for performance."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Limitations"}),": Workers cannot access DOM or window objects, requiring careful architecture planning."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"when-to-use-web-workers",children:"When to Use Web Workers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"CPU-intensive calculations that would block the UI"}),"\n",(0,s.jsx)(n.li,{children:"Data processing tasks that can run independently"}),"\n",(0,s.jsx)(n.li,{children:"Background data synchronization"}),"\n",(0,s.jsx)(n.li,{children:"Image/video processing"}),"\n",(0,s.jsx)(n.li,{children:"Cryptographic operations"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Web Workers represent a fundamental shift toward multi-threaded web applications, enabling developers to build more responsive and capable web experiences. As outlined in the ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers",children:"MDN documentation"}),", proper implementation of Web Workers can significantly improve application performance and user experience."]}),"\n",(0,s.jsx)(n.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers",children:"MDN Web Workers API Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://html.spec.whatwg.org/multipage/workers.html",children:"HTML Living Standard - Web Workers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://caniuse.com/webworkers",children:"Can I Use - Web Workers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://worker-playground.glitch.me/",children:"Worker Playground - Test Worker APIs"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var a=r(6540);const s={},t=a.createContext(s);function o(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);