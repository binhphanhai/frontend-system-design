"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2825],{7820:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"project-detail/react-virtuoso","title":"React Virtuoso: Deep Dive into Virtual Scrolling","description":"Master React Virtuoso\'s virtualization engine, covering implementation details, offset management, variable height handling, and performance optimization strategies for building high-performance lists","source":"@site/docs/project-detail/react-virtuoso.md","sourceDirName":"project-detail","slug":"/project-detail/react-virtuoso","permalink":"/frontend-system-design/docs/project-detail/react-virtuoso","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/react-virtuoso.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Tech Stack Cheatsheet: affiliate-framework-fe-bo","permalink":"/frontend-system-design/docs/project-detail/affiliate-framework-bo"},"next":{"title":"React Native: Under the Hood","permalink":"/frontend-system-design/docs/project-detail/react-native"}}');var i=r(4848),s=r(8453);const o={},a="React Virtuoso: Deep Dive into Virtual Scrolling",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Core Virtualization Concepts",id:"core-virtualization-concepts",level:2},{value:"What is Virtualization?",id:"what-is-virtualization",level:3},{value:"Key Benefits",id:"key-benefits",level:3},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Core Components",id:"core-components",level:3},{value:"State Management System",id:"state-management-system",level:3},{value:"Viewport Management",id:"viewport-management",level:2},{value:"Visible Range Calculation",id:"visible-range-calculation",level:3},{value:"Overscan (Buffer) Management",id:"overscan-buffer-management",level:3},{value:"Offset Calculation &amp; Management",id:"offset-calculation--management",level:2},{value:"Height-Based Offset System",id:"height-based-offset-system",level:3},{value:"Efficient Offset Updates",id:"efficient-offset-updates",level:3},{value:"Variable Height Item Handling",id:"variable-height-item-handling",level:2},{value:"Automatic Height Measurement",id:"automatic-height-measurement",level:3},{value:"Dynamic Height Estimation",id:"dynamic-height-estimation",level:3},{value:"Handling Content Loading",id:"handling-content-loading",level:3},{value:"Scroll Synchronization",id:"scroll-synchronization",level:2},{value:"Scroll Event Handling",id:"scroll-event-handling",level:3},{value:"Scroll Position Preservation",id:"scroll-position-preservation",level:3},{value:"Programmatic Scrolling",id:"programmatic-scrolling",level:3},{value:"Performance Optimization Strategies",id:"performance-optimization-strategies",level:2},{value:"Memoization and React.memo",id:"memoization-and-reactmemo",level:3},{value:"Overscan Tuning",id:"overscan-tuning",level:3},{value:"CSS Optimization",id:"css-optimization",level:3},{value:"Component Variants",id:"component-variants",level:2},{value:"Virtuoso (Basic List)",id:"virtuoso-basic-list",level:3},{value:"GroupedVirtuoso (Grouped Lists)",id:"groupedvirtuoso-grouped-lists",level:3},{value:"VirtuosoGrid (Grid Layout)",id:"virtuosogrid-grid-layout",level:3},{value:"TableVirtuoso (Table Virtualization)",id:"tablevirtuoso-table-virtualization",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Message List for Chat Applications",id:"message-list-for-chat-applications",level:3},{value:"Infinite Scrolling",id:"infinite-scrolling",level:3},{value:"Custom Scrollbars",id:"custom-scrollbars",level:3},{value:"Common Patterns &amp; Best Practices",id:"common-patterns--best-practices",level:2},{value:"Error Boundaries",id:"error-boundaries",level:3},{value:"Testing Strategies",id:"testing-strategies",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:3},{value:"Accessibility Considerations",id:"accessibility-considerations",level:3},{value:"How React Virtuoso Handles and Renders Items to the DOM",id:"how-react-virtuoso-handles-and-renders-items-to-the-dom",level:2},{value:"Visualizing the DOM Lifecycle",id:"visualizing-the-dom-lifecycle",level:3},{value:"Example: DOM Node Recycling and Buffer Management",id:"example-dom-node-recycling-and-buffer-management",level:3},{value:"Internal Buffer and Recycling Logic (Pseudocode)",id:"internal-buffer-and-recycling-logic-pseudocode",level:3},{value:"1. <strong>Viewport-Driven Rendering</strong>",id:"1-viewport-driven-rendering",level:3},{value:"2. <strong>DOM Recycling and Element Lifecycle</strong>",id:"2-dom-recycling-and-element-lifecycle",level:3},{value:"3. <strong>Dynamic Measurement and Positioning</strong>",id:"3-dynamic-measurement-and-positioning",level:3},{value:"4. <strong>Rendering Pipeline</strong>",id:"4-rendering-pipeline",level:3},{value:"5. <strong>Performance and Best Practices</strong>",id:"5-performance-and-best-practices",level:3},{value:"6. <strong>Example: DOM Rendering Lifecycle</strong>",id:"6-example-dom-rendering-lifecycle",level:3},{value:"Visual Example: What the DOM Looks Like During Virtualization",id:"visual-example-what-the-dom-looks-like-during-virtualization",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"react-virtuoso-deep-dive-into-virtual-scrolling",children:"React Virtuoso: Deep Dive into Virtual Scrolling"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Master React Virtuoso's virtualization engine, covering implementation details, offset management, variable height handling, and performance optimization strategies for building high-performance lists"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso is the most powerful virtual list component for React, providing efficient rendering of large datasets through sophisticated virtualization techniques. Unlike traditional approaches that render all items at once, Virtuoso renders only visible items plus a configurable buffer, dramatically improving performance and memory usage. This guide explores how React Virtuoso works under the hood, examining its core algorithms, offset management, variable height handling, and optimization strategies."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#core-virtualization-concepts",children:"Core Virtualization Concepts"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#architecture-overview",children:"Architecture Overview"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#viewport-management",children:"Viewport Management"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#offset-calculation--management",children:"Offset Calculation & Management"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#variable-height-item-handling",children:"Variable Height Item Handling"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#scroll-synchronization",children:"Scroll Synchronization"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#performance-optimization-strategies",children:"Performance Optimization Strategies"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#component-variants",children:"Component Variants"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#advanced-features",children:"Advanced Features"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#common-patterns--best-practices",children:"Common Patterns & Best Practices"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"core-virtualization-concepts",children:"Core Virtualization Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"what-is-virtualization",children:"What is Virtualization?"}),"\n",(0,i.jsx)(n.p,{children:"Virtualization is a rendering optimization technique that renders only the items currently visible in the viewport, plus a small buffer of items above and below for smooth scrolling. This approach transforms O(n) rendering complexity to O(1) relative to the total dataset size."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"The Problem:"})," Traditional list rendering creates DOM nodes for every single item in your dataset. If you have 10,000 items, the browser creates 10,000 DOM nodes, leading to memory bloat and sluggish performance."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"The Solution:"})," Virtual scrolling maintains the illusion of a full list while only rendering the items currently visible to the user. This dramatically reduces DOM size and maintains consistent performance regardless of data size."]}),"\n",(0,i.jsx)(n.p,{children:"The following code comparison demonstrates the fundamental difference between traditional and virtualized approaches:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// Traditional approach - renders ALL items (performance killer)\r\n// \ud83d\udd34 PROBLEM: If items array has 10,000 elements, browser creates 10,000 DOM nodes\r\n// Memory usage: High (scales with data size)\r\n// Initial render time: Slow (scales with data size)\r\n// Scroll performance: Degrades as list size increases\r\nfunction TraditionalList({ items }) {\r\n  return (\r\n    <div style={{ height: "400px", overflow: "auto" }}>\r\n      {items.map((item, index) => (\r\n        <div key={index}>{item.content}</div> // Creates DOM node for EVERY item\r\n      ))}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Virtualized approach - renders ONLY visible items\r\n// \u2705 SOLUTION: Only renders ~20 items regardless of total dataset size\r\n// Memory usage: Constant (independent of data size)\r\n// Initial render time: Fast (always renders same amount)\r\n// Scroll performance: Consistent at any scale\r\nimport { Virtuoso } from "react-virtuoso";\r\n\r\nfunction VirtualizedList({ items }) {\r\n  return (\r\n    <Virtuoso\r\n      style={{ height: "400px" }} // Fixed container height\r\n      totalCount={items.length} // Total number of items (for scroll calculations)\r\n      itemContent={(\r\n        index // Render function called only for visible items\r\n      ) => (\r\n        <div>{items[index].content}</div> // Only creates DOM nodes for visible items\r\n      )}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Differences Explained:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Traditional List"}),": Creates DOM nodes for all 10,000 items immediately"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Virtualized List"}),": Creates DOM nodes for only ~20 visible items"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Impact"}),": Virtualized approach uses 99.8% less DOM nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": Virtualized rendering time stays constant regardless of data size"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Efficiency"}),": DOM contains only visible items (~10-50 elements instead of thousands)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistent Performance"}),": Rendering time remains constant regardless of dataset size"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Smooth Scrolling"}),": Optimized rendering pipeline prevents janky scroll behavior"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Variable Heights"}),": Automatic measurement and adjustment for dynamic content"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso's architecture consists of several interconnected systems working together to provide seamless virtualization:"}),"\n",(0,i.jsx)(n.h3,{id:"core-components",children:"Core Components"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:"graph TD\r\n    A[Virtuoso Container] --\x3e B[Viewport Manager]\r\n    A --\x3e C[Item Renderer]\r\n    A --\x3e D[Scroller System]\r\n\r\n    B --\x3e E[Visible Range Calculator]\r\n    B --\x3e F[Offset Manager]\r\n\r\n    C --\x3e G[Item Measurement]\r\n    C --\x3e H[DOM Recycling]\r\n\r\n    D --\x3e I[Scroll Event Handler]\r\n    D --\x3e J[Position Synchronizer]\r\n\r\n    E --\x3e K[Buffer Management]\r\n    F --\x3e L[Height Estimation]\r\n    G --\x3e M[ResizeObserver]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"state-management-system",children:"State Management System"}),"\n",(0,i.jsx)(n.p,{children:"Virtuoso uses a reactive state management system that efficiently updates only necessary parts when data changes. This internal state tracks everything needed to maintain the virtualization illusion while keeping performance optimal."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"What This State Manages:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Viewport Tracking"}),": Current scroll position and container dimensions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Item Visibility"}),": Which items are currently visible and need rendering"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Height Measurements"}),": Actual measured heights vs estimated heights"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scroll Calculations"}),": Total scrollable area and item positioning"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"State Update Flow:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["User scrolls \u2192 ",(0,i.jsx)(n.code,{children:"scrollTop"})," updates"]}),"\n",(0,i.jsxs)(n.li,{children:["Visible range calculator runs \u2192 ",(0,i.jsx)(n.code,{children:"visibleRange"})," updates"]}),"\n",(0,i.jsx)(n.li,{children:"New items render if range changed \u2192 DOM updates"}),"\n",(0,i.jsxs)(n.li,{children:["Height measurements update \u2192 ",(0,i.jsx)(n.code,{children:"itemHeights"})," and ",(0,i.jsx)(n.code,{children:"totalHeight"})," update"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here's a simplified representation of Virtuoso's internal state structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Simplified internal state structure\r\n// This represents the core data that Virtuoso tracks internally\r\nconst virtuosoState = {\r\n  // === VIEWPORT DIMENSIONS ===\r\n  viewportHeight: 400, // Height of visible container (400px)\r\n  scrollTop: 0, // Current scroll position from top\r\n\r\n  // === ITEM MANAGEMENT ===\r\n  totalCount: 10000, // Total number of items in dataset\r\n  visibleRange: {\r\n    // Currently rendered items (what user sees)\r\n    start: 45, // First visible item index\r\n    end: 65, // Last visible item index (renders items 45-65)\r\n  },\r\n  overscan: {\r\n    // Buffer items (rendered but not visible)\r\n    start: 40, // Extra items rendered above viewport\r\n    end: 70, // Extra items rendered below viewport\r\n  },\r\n\r\n  // === HEIGHT TRACKING ===\r\n  itemHeights: new Map([\r\n    // Actual measured heights for each item\r\n    [0, 48], // Item 0 is 48px tall\r\n    [1, 52], // Item 1 is 52px tall\r\n    [2, 45], // Item 2 is 45px tall\r\n    // ... only measured items stored\r\n  ]),\r\n  estimatedItemHeight: 50, // Default height for unmeasured items\r\n  totalHeight: 500000, // Total scrollable height (all items combined)\r\n\r\n  // === OFFSET CALCULATIONS ===\r\n  itemOffsets: new Map([\r\n    // Cached Y positions for each item\r\n    [0, 0], // Item 0 starts at Y position 0\r\n    [1, 48], // Item 1 starts at Y position 48\r\n    [2, 100], // Item 2 starts at Y position 100\r\n    // ... calculated on demand\r\n  ]),\r\n  scrollOffset: 2250, // Current scroll offset in pixels\r\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"State Efficiency Features:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lazy Calculation"}),": Heights and offsets calculated only when needed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Incremental Updates"}),": Only affected portions recalculated on changes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Optimization"}),": Unmeasured items use estimated values"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cache Invalidation"}),": Smart cache clearing when item heights change"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"viewport-management",children:"Viewport Management"}),"\n",(0,i.jsx)(n.h3,{id:"visible-range-calculation",children:"Visible Range Calculation"}),"\n",(0,i.jsx)(n.p,{children:"The viewport manager is the brain of virtualization - it determines exactly which items should be rendered based on the current scroll position and container dimensions. This is the core algorithm that makes virtualization possible."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"How It Works:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Find First Visible Item"}),": Uses binary search to efficiently locate the first item that intersects with the viewport"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Calculate End Boundary"}),": Accumulates item heights until viewport height is filled"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Return Range"}),": Provides start/end indices for rendering"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Performance Optimization:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Binary search reduces time complexity from O(n) to O(log n)"}),"\n",(0,i.jsx)(n.li,{children:"Only calculates what's needed for current viewport"}),"\n",(0,i.jsx)(n.li,{children:"Caches results to avoid redundant calculations"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Input/Output Example:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Input"}),": ",(0,i.jsx)(n.code,{children:"scrollTop: 1200px"}),", ",(0,i.jsx)(n.code,{children:"viewportHeight: 400px"}),", ",(0,i.jsx)(n.code,{children:"itemHeight: 50px"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Process"}),": Binary search finds item at position 1200px (item #24)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Output"}),": ",(0,i.jsx)(n.code,{children:"{ start: 24, end: 32 }"})," (renders 8 items to fill 400px)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here's the core visible range calculation algorithm that powers Virtuoso:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Simplified visible range calculation algorithm\r\n// INPUT: Current scroll position, viewport size, item positions, total items\r\n// OUTPUT: Start and end indices of items that should be rendered\r\nfunction calculateVisibleRange(\r\n  scrollTop, // Current scroll position (e.g., 1200px)\r\n  viewportHeight, // Height of visible area (e.g., 400px)\r\n  itemOffsets, // Map of item index -> Y position\r\n  totalCount // Total number of items in dataset\r\n) {\r\n  // STEP 1: Find first visible item using binary search for efficiency\r\n  // Binary search is O(log n) vs linear search O(n)\r\n  const startIndex = binarySearchFirstVisible(scrollTop, itemOffsets);\r\n\r\n  // STEP 2: Calculate end index by accumulating heights until viewport is filled\r\n  let endIndex = startIndex;\r\n  let accumulatedHeight = 0;\r\n\r\n  // Keep adding items until we've filled the viewport height\r\n  while (endIndex < totalCount && accumulatedHeight < viewportHeight) {\r\n    accumulatedHeight += getItemHeight(endIndex, itemOffsets);\r\n    endIndex++;\r\n  }\r\n\r\n  // Add one extra item to handle partial visibility at bottom\r\n  endIndex = Math.min(endIndex + 1, totalCount);\r\n\r\n  return { start: startIndex, end: endIndex };\r\n}\r\n\r\n// Binary search to find first visible item efficiently\r\n// Instead of checking every item from 0, we use binary search for O(log n) performance\r\nfunction binarySearchFirstVisible(scrollTop, itemOffsets) {\r\n  let left = 0; // Start of search range\r\n  let right = itemOffsets.size - 1; // End of search range\r\n\r\n  // Binary search: repeatedly halve the search space\r\n  while (left < right) {\r\n    const mid = Math.floor((left + right) / 2); // Middle point\r\n    const offset = itemOffsets.get(mid) || 0; // Y position of middle item\r\n\r\n    if (offset < scrollTop) {\r\n      // Middle item is above scroll position, search upper half\r\n      left = mid + 1;\r\n    } else {\r\n      // Middle item is at or below scroll position, search lower half\r\n      right = mid;\r\n    }\r\n  }\r\n\r\n  return left; // First item that intersects viewport\r\n}\r\n\r\n// Helper function to get item height (measured or estimated)\r\nfunction getItemHeight(index, itemOffsets) {\r\n  // Return actual measured height if available, otherwise use estimate\r\n  return itemOffsets.has(index + 1)\r\n    ? itemOffsets.get(index + 1) - itemOffsets.get(index)\r\n    : 50; // Default estimated height\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Algorithm Efficiency:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Binary Search"}),": O(log n) to find first visible item"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Linear Accumulation"}),": O(k) where k = number of visible items (~10-20)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Total Complexity"}),": O(log n + k) instead of O(n) for naive approaches"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"overscan-buffer-management",children:"Overscan (Buffer) Management"}),"\n",(0,i.jsx)(n.p,{children:'Overscan (also called "buffer") is a critical optimization that renders additional items outside the visible viewport. This prevents blank spaces during fast scrolling and ensures users never see empty content while new items are being rendered.'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why Overscan is Essential:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prevents Flash of Empty Content"}),": Without overscan, users see blank spaces during fast scrolling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Smooth Scroll Experience"}),": Pre-rendered items appear instantly when scrolled into view"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Accommodation for Variable Scroll Speeds"}),": Faster scrolling needs larger buffers"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The Trade-off:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"More Overscan"}),": Smoother experience but higher memory usage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Less Overscan"}),": Better performance but potential stuttering"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Overscan Calculation Process:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Calculate visible range (items 20-30)"}),"\n",(0,i.jsx)(n.li,{children:"Add overscan buffer (5 items above, 5 below)"}),"\n",(0,i.jsx)(n.li,{children:"Final render range: items 15-35"}),"\n",(0,i.jsx)(n.li,{children:"User scrolls and process repeats"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here are different overscan configuration options and their impact:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Overscan configuration affects performance vs smoothness trade-off\r\n// Choose based on your specific use case and performance requirements\r\n\r\n// OPTION 1: Pixel-based overscan (recommended for most cases)\r\n// Renders extra content by pixel amount rather than item count\r\n<Virtuoso\r\n  totalCount={10000}\r\n  itemContent={(index) => <Item key={index} />}\r\n  // Render 200px worth of items above and below visible area\r\n  // Good for: Variable height items, consistent buffer size\r\n  increaseViewportBy={{\r\n    top: 200,     // 200px of content above viewport\r\n    bottom: 200   // 200px of content below viewport\r\n  }}\r\n/>\r\n\r\n// OPTION 2: Item count-based overscan (simpler configuration)\r\n// Renders fixed number of extra items regardless of their height\r\n<Virtuoso\r\n  totalCount={10000}\r\n  itemContent={(index) => <Item key={index} />}\r\n  // Render 5 extra items above and below visible area\r\n  // Good for: Fixed height items, predictable buffer size\r\n  overscan={5}  // Total: 10 extra items (5 above + 5 below)\r\n/>\r\n\r\n// OPTION 3: Dynamic overscan based on scroll velocity (advanced)\r\n// Adjusts buffer size based on how fast user is scrolling\r\n<Virtuoso\r\n  totalCount={10000}\r\n  itemContent={(index) => <Item key={index} />}\r\n  // Function receives scroll velocity and returns overscan count\r\n  // Good for: Optimizing for both performance and UX\r\n  overscan={(velocity) => {\r\n    // Slow scrolling: small buffer (better performance)\r\n    if (Math.abs(velocity) < 100) return 3;\r\n    // Medium scrolling: medium buffer\r\n    if (Math.abs(velocity) < 500) return 8;\r\n    // Fast scrolling: large buffer (smoother experience)\r\n    return 15;\r\n  }}\r\n/>\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Overscan Strategy Guidelines:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Small overscan (2-5 items)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Better performance (fewer DOM nodes)"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Lower memory usage"}),"\n",(0,i.jsx)(n.li,{children:"\u274c Potential scroll stuttering during fast scrolling"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": Performance-critical apps, mobile devices"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Medium overscan (6-10 items)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Good balance of performance and smoothness"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Handles most scroll speeds well"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": General purpose applications"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Large overscan (10-20 items)"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Smoothest scrolling experience"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 No blank content during fast scrolling"}),"\n",(0,i.jsx)(n.li,{children:"\u274c Higher memory usage"}),"\n",(0,i.jsx)(n.li,{children:"\u274c More DOM nodes to manage"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": Premium UX applications, desktop apps"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dynamic overscan"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Adapts to user behavior"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Optimal balance for varying scroll patterns"}),"\n",(0,i.jsx)(n.li,{children:"\u274c More complex to configure"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Best for"}),": Apps with diverse scrolling patterns"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"offset-calculation--management",children:"Offset Calculation & Management"}),"\n",(0,i.jsx)(n.h3,{id:"height-based-offset-system",children:"Height-Based Offset System"}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso maintains a sophisticated offset calculation system that tracks the exact Y-position of each item in the virtual list. This system is crucial for positioning items correctly and maintaining scroll accuracy as item heights change."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"What Are Offsets?"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Offset"}),": The Y-coordinate distance from the top of the list to the start of each item"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),": Allows precise positioning of items during virtualization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example"}),": If items 0-2 are 50px each, then item 3's offset is 150px"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why Offset Management is Complex:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Items can have variable heights (images, dynamic content)"}),"\n",(0,i.jsx)(n.li,{children:"Heights change after content loads (images, async data)"}),"\n",(0,i.jsx)(n.li,{children:"Need to maintain scroll position when heights change"}),"\n",(0,i.jsx)(n.li,{children:"Must be efficient for thousands of items"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Offset Calculation Strategy:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lazy Calculation"}),": Only calculate offsets when needed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Caching"}),": Store calculated offsets to avoid recalculation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Incremental Updates"}),": When heights change, only update affected items"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Height Estimation"}),": Use estimated heights for unmeasured items"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here's how Virtuoso's internal offset management system works:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Internal offset management system\r\n// This class handles the complex task of tracking item positions in a virtual list\r\nclass OffsetManager {\r\n  constructor() {\r\n    this.itemHeights = new Map(); // Actual measured heights: {0: 45, 1: 52, 2: 48}\r\n    this.itemOffsets = new Map(); // Cached Y positions: {0: 0, 1: 45, 2: 97}\r\n    this.totalHeight = 0; // Total scrollable height\r\n    this.estimatedItemHeight = 50; // Default height for unmeasured items\r\n  }\r\n\r\n  // Calculate offset for a specific item (Y position from top)\r\n  // INPUT: Item index (e.g., 5)\r\n  // OUTPUT: Y position in pixels (e.g., 250px)\r\n  getItemOffset(index) {\r\n    // OPTIMIZATION: Return cached offset if available\r\n    if (this.itemOffsets.has(index)) {\r\n      return this.itemOffsets.get(index);\r\n    }\r\n\r\n    // CALCULATION: Sum heights of all previous items\r\n    let offset = 0;\r\n    for (let i = 0; i < index; i++) {\r\n      offset += this.getItemHeight(i); // Add height of each previous item\r\n    }\r\n\r\n    // CACHING: Store calculated offset for future use\r\n    this.itemOffsets.set(index, offset);\r\n    return offset;\r\n  }\r\n\r\n  // Get item height (measured or estimated)\r\n  // Returns actual measured height if available, otherwise uses estimation\r\n  getItemHeight(index) {\r\n    // Return measured height if we have it, otherwise use estimate\r\n    return this.itemHeights.get(index) || this.estimatedItemHeight;\r\n  }\r\n\r\n  // Update height and recalculate affected offsets\r\n  // Called when ResizeObserver detects item height change\r\n  setItemHeight(index, height) {\r\n    const oldHeight = this.getItemHeight(index);\r\n\r\n    // EARLY EXIT: No change in height, nothing to update\r\n    if (oldHeight === height) return;\r\n\r\n    // UPDATE: Store new measured height\r\n    this.itemHeights.set(index, height);\r\n\r\n    // CACHE INVALIDATION: Clear cached offsets for items after this one\r\n    // Why? Because their Y positions have shifted due to height change\r\n    this.invalidateOffsetsAfter(index);\r\n\r\n    // TOTAL HEIGHT UPDATE: Adjust total scrollable area\r\n    const heightDelta = height - oldHeight;\r\n    this.totalHeight += heightDelta;\r\n\r\n    // SCROLL POSITION PRESERVATION: Adjust scroll if needed\r\n    this.adjustScrollForHeightChange(index, heightDelta);\r\n  }\r\n\r\n  // Invalidate cached offsets for items after changed item\r\n  // This forces recalculation when these items are next accessed\r\n  invalidateOffsetsAfter(index) {\r\n    for (let i = index + 1; i < this.totalCount; i++) {\r\n      this.itemOffsets.delete(i); // Remove cached offset\r\n    }\r\n  }\r\n\r\n  // Maintain scroll position when item heights change\r\n  // Prevents jarring scroll jumps when content loads\r\n  adjustScrollForHeightChange(changedIndex, heightDelta) {\r\n    const currentScrollTop = this.scrollContainer.scrollTop;\r\n    const changedItemOffset = this.getItemOffset(changedIndex);\r\n\r\n    // If changed item is above current scroll position, adjust scroll\r\n    if (changedItemOffset < currentScrollTop) {\r\n      this.scrollContainer.scrollTop = currentScrollTop + heightDelta;\r\n    }\r\n  }\r\n\r\n  // Batch update multiple heights efficiently\r\n  // Used when multiple items change size simultaneously\r\n  batchUpdateHeights(heightUpdates) {\r\n    let totalDelta = 0;\r\n    let minChangedIndex = Infinity;\r\n\r\n    // Apply all height changes\r\n    for (const { index, height } of heightUpdates) {\r\n      const oldHeight = this.getItemHeight(index);\r\n      this.itemHeights.set(index, height);\r\n      totalDelta += height - oldHeight;\r\n      minChangedIndex = Math.min(minChangedIndex, index);\r\n    }\r\n\r\n    // Single cache invalidation for all changes\r\n    if (minChangedIndex !== Infinity) {\r\n      this.invalidateOffsetsAfter(minChangedIndex);\r\n      this.totalHeight += totalDelta;\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Performance Optimizations:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lazy Calculation"}),": Offsets calculated only when accessed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Aggressive Caching"}),": Calculated offsets stored for reuse"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Smart Invalidation"}),": Only affected offsets cleared on changes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Batch Updates"}),": Multiple height changes processed together"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"efficient-offset-updates",children:"Efficient Offset Updates"}),"\n",(0,i.jsx)(n.p,{children:"When item heights change, Virtuoso efficiently updates only affected offsets rather than recalculating everything from scratch. This is crucial for maintaining performance when content dynamically loads (like images) or when items resize."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"The Challenge:"}),"\r\nWhen one item's height changes, all items below it shift position. A naive approach would recalculate all offsets, but Virtuoso uses smart optimization to update only what's necessary."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Optimization Strategy:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Calculate Delta"}),": Determine how much the height changed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Incremental Updates"}),": Add/subtract delta from cached offsets"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scroll Preservation"}),": Maintain user's visual position"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lazy Recalculation"}),": Clear cache for items that might be affected"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Real-World Example:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"User scrolls to item 500 in a 10,000 item list"}),"\n",(0,i.jsx)(n.li,{children:"An image in item 25 loads, changing height from 100px to 150px"}),"\n",(0,i.jsx)(n.li,{children:"Instead of recalculating 9,975 offsets, only update cached ones with +50px delta"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here's how Virtuoso handles height changes efficiently:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Example: Item height changes from 100px to 150px at index 25\r\n// Before: [0, 100, 200, 300, ..., 2500, 2600, ...]\r\n// After:  [0, 100, 200, 300, ..., 2500, 2650, ...] (+50px offset for items after 25)\r\n\r\nfunction handleHeightChange(index, newHeight, oldHeight) {\r\n  // STEP 1: Calculate the height difference\r\n  const heightDelta = newHeight - oldHeight;\r\n\r\n  // EARLY EXIT: No change means no work needed\r\n  if (heightDelta === 0) return;\r\n\r\n  // STEP 2: Update the stored height for this item\r\n  this.itemHeights.set(index, newHeight);\r\n\r\n  // STEP 3: Efficiently update subsequent offsets (O(k) where k = cached items)\r\n  // Only update items that have cached offsets, not all items\r\n  for (let i = index + 1; i < this.totalCount; i++) {\r\n    if (this.itemOffsets.has(i)) {\r\n      const currentOffset = this.itemOffsets.get(i);\r\n      this.itemOffsets.set(i, currentOffset + heightDelta);\r\n    }\r\n    // Items without cached offsets will be calculated correctly when needed\r\n  }\r\n\r\n  // STEP 4: Update total scrollable height\r\n  this.totalHeight += heightDelta;\r\n\r\n  // STEP 5: Adjust scroll position if necessary to maintain view stability\r\n  this.adjustScrollPosition(index, heightDelta);\r\n}\r\n\r\n// Advanced optimization: Batch multiple height changes\r\nfunction handleBatchHeightChanges(changes) {\r\n  // Sort changes by index to process in order\r\n  const sortedChanges = changes.sort((a, b) => a.index - b.index);\r\n\r\n  let cumulativeDelta = 0;\r\n  let minAffectedIndex = Infinity;\r\n\r\n  // STEP 1: Apply all height changes and track cumulative effect\r\n  for (const { index, newHeight, oldHeight } of sortedChanges) {\r\n    const heightDelta = newHeight - oldHeight;\r\n\r\n    this.itemHeights.set(index, newHeight);\r\n    cumulativeDelta += heightDelta;\r\n    minAffectedIndex = Math.min(minAffectedIndex, index);\r\n  }\r\n\r\n  // STEP 2: Update offsets in a single pass\r\n  for (let i = minAffectedIndex + 1; i < this.totalCount; i++) {\r\n    if (this.itemOffsets.has(i)) {\r\n      // Calculate cumulative delta for this item\r\n      let deltaForThisItem = 0;\r\n      for (const { index, newHeight, oldHeight } of sortedChanges) {\r\n        if (index < i) {\r\n          deltaForThisItem += newHeight - oldHeight;\r\n        }\r\n      }\r\n\r\n      const currentOffset = this.itemOffsets.get(i);\r\n      this.itemOffsets.set(i, currentOffset + deltaForThisItem);\r\n    }\r\n  }\r\n\r\n  // STEP 3: Update total height once\r\n  this.totalHeight += cumulativeDelta;\r\n}\r\n\r\n// Scroll position preservation during height changes\r\nfunction adjustScrollPosition(changedIndex, heightDelta) {\r\n  const scrollContainer = this.scrollContainer;\r\n  const currentScrollTop = scrollContainer.scrollTop;\r\n\r\n  // Get the offset of the changed item\r\n  const changedItemOffset = this.getItemOffset(changedIndex);\r\n\r\n  // CASE 1: Changed item is above current viewport\r\n  // Need to adjust scroll to maintain visual position\r\n  if (changedItemOffset < currentScrollTop) {\r\n    scrollContainer.scrollTop = currentScrollTop + heightDelta;\r\n    return;\r\n  }\r\n\r\n  // CASE 2: Changed item is in current viewport\r\n  // Try to maintain the relative position of visible items\r\n  const viewportBottom = currentScrollTop + this.viewportHeight;\r\n  if (changedItemOffset < viewportBottom) {\r\n    // Use more sophisticated logic for in-viewport changes\r\n    this.maintainRelativeScrollPosition(changedIndex, heightDelta);\r\n    return;\r\n  }\r\n\r\n  // CASE 3: Changed item is below viewport\r\n  // No scroll adjustment needed - user won't notice\r\n}\r\n\r\n// Sophisticated scroll position maintenance for in-viewport changes\r\nfunction maintainRelativeScrollPosition(changedIndex, heightDelta) {\r\n  const scrollContainer = this.scrollContainer;\r\n  const currentScrollTop = scrollContainer.scrollTop;\r\n  const changedItemOffset = this.getItemOffset(changedIndex);\r\n\r\n  // Calculate what portion of the changed item was above the viewport top\r\n  const portionAboveViewport = Math.max(\r\n    0,\r\n    currentScrollTop - changedItemOffset\r\n  );\r\n  const itemOldHeight = this.itemHeights.get(changedIndex) - heightDelta;\r\n\r\n  if (portionAboveViewport > 0) {\r\n    // Part of the item was above viewport, adjust proportionally\r\n    const ratio = portionAboveViewport / itemOldHeight;\r\n    const scrollAdjustment = heightDelta * ratio;\r\n    scrollContainer.scrollTop = currentScrollTop + scrollAdjustment;\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Performance Benefits:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Avoids Full Recalculation"}),": O(k) instead of O(n) where k = cached items"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Smart Caching"}),": Only updates items with existing cache entries"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Batch Processing"}),": Multiple changes processed together efficiently"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scroll Stability"}),": Maintains user's visual position during changes"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"variable-height-item-handling",children:"Variable Height Item Handling"}),"\n",(0,i.jsx)(n.h3,{id:"automatic-height-measurement",children:"Automatic Height Measurement"}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso automatically measures item heights using the ResizeObserver API, which is essential for handling dynamic content like images, expandable text, or content that loads asynchronously. This system ensures that virtualization works correctly even when item heights are unpredictable."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why Automatic Measurement is Necessary:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Content"}),": Images, videos, or async data can change item heights"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Responsive Design"}),": Item heights may change based on viewport width"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"User Interactions"}),": Expanding/collapsing content changes heights"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Font Loading"}),": Web fonts can affect text height when they load"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Measurement Strategy:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initial Measurement"}),": Measure height when item first renders"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Continuous Monitoring"}),": Use ResizeObserver to detect height changes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Efficient Updates"}),": Only recalculate affected offsets"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fallback Estimation"}),": Use estimated heights for unmeasured items"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The ResizeObserver Advantage:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automatic Detection"}),": Detects size changes without manual triggers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High Performance"}),": Browser-native implementation, very efficient"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Comprehensive"}),": Catches all types of size changes (content, CSS, etc.)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here's how Virtuoso implements automatic height measurement:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// Simplified height measurement system\r\n// This component wraps each item to automatically measure and report height changes\r\nfunction ItemRenderer({ index, style, data }) {\r\n  const itemRef = useRef(null); // Reference to DOM element for measurement\r\n\r\n  // Callback to measure and report item height\r\n  const measureHeight = useCallback(() => {\r\n    if (itemRef.current) {\r\n      // Get precise height including padding and border\r\n      const height = itemRef.current.getBoundingClientRect().height;\r\n      // Report height back to Virtuoso\'s measurement system\r\n      reportItemHeight(index, height);\r\n    }\r\n  }, [index]);\r\n\r\n  useEffect(() => {\r\n    // STEP 1: Initial measurement after render\r\n    // Important: Use requestAnimationFrame to ensure layout is complete\r\n    requestAnimationFrame(() => {\r\n      measureHeight();\r\n    });\r\n\r\n    // STEP 2: Set up ResizeObserver for dynamic content changes\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      for (const entry of entries) {\r\n        // Use ResizeObserver\'s precise measurement\r\n        // borderBoxSize gives us the exact size including border/padding\r\n        const height =\r\n          entry.borderBoxSize?.[0]?.blockSize || entry.contentRect.height;\r\n\r\n        // Report new height to Virtuoso\r\n        reportItemHeight(index, height);\r\n      }\r\n    });\r\n\r\n    // STEP 3: Start observing this item for size changes\r\n    if (itemRef.current) {\r\n      resizeObserver.observe(itemRef.current);\r\n    }\r\n\r\n    // STEP 4: Cleanup observer when component unmounts\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [measureHeight]);\r\n\r\n  return (\r\n    <div ref={itemRef} style={style}>\r\n      {data[index].content}\r\n      {/* This could contain images, dynamic text, or any content */}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Advanced measurement system with debouncing and error handling\r\nfunction AdvancedItemRenderer({ index, style, data }) {\r\n  const itemRef = useRef(null);\r\n  const [measurementState, setMeasurementState] = useState("measuring");\r\n\r\n  // Debounced height reporting to avoid excessive updates\r\n  const debouncedReportHeight = useMemo(\r\n    () =>\r\n      debounce((height) => {\r\n        reportItemHeight(index, height);\r\n        setMeasurementState("measured");\r\n      }, 16), // 16ms = ~60fps\r\n    [index]\r\n  );\r\n\r\n  useEffect(() => {\r\n    let resizeObserver = null;\r\n\r\n    const setupMeasurement = () => {\r\n      if (!itemRef.current) return;\r\n\r\n      // Initial measurement\r\n      const initialHeight = itemRef.current.getBoundingClientRect().height;\r\n      debouncedReportHeight(initialHeight);\r\n\r\n      // Set up ResizeObserver with error handling\r\n      try {\r\n        resizeObserver = new ResizeObserver((entries) => {\r\n          for (const entry of entries) {\r\n            // Handle different ResizeObserver implementations\r\n            let height;\r\n            if (entry.borderBoxSize) {\r\n              // Modern browsers\r\n              height = Array.isArray(entry.borderBoxSize)\r\n                ? entry.borderBoxSize[0].blockSize\r\n                : entry.borderBoxSize.blockSize;\r\n            } else {\r\n              // Fallback for older browsers\r\n              height = entry.contentRect.height;\r\n            }\r\n\r\n            debouncedReportHeight(height);\r\n          }\r\n        });\r\n\r\n        resizeObserver.observe(itemRef.current);\r\n      } catch (error) {\r\n        console.warn(\r\n          "ResizeObserver not supported, falling back to manual measurement"\r\n        );\r\n        // Fallback: measure on content changes\r\n        const mutationObserver = new MutationObserver(() => {\r\n          if (itemRef.current) {\r\n            const height = itemRef.current.getBoundingClientRect().height;\r\n            debouncedReportHeight(height);\r\n          }\r\n        });\r\n\r\n        mutationObserver.observe(itemRef.current, {\r\n          childList: true,\r\n          subtree: true,\r\n          attributes: true,\r\n        });\r\n\r\n        return () => mutationObserver.disconnect();\r\n      }\r\n    };\r\n\r\n    // Delay setup to ensure DOM is ready\r\n    const timeoutId = setTimeout(setupMeasurement, 0);\r\n\r\n    return () => {\r\n      clearTimeout(timeoutId);\r\n      if (resizeObserver) {\r\n        resizeObserver.disconnect();\r\n      }\r\n      debouncedReportHeight.cancel();\r\n    };\r\n  }, [debouncedReportHeight]);\r\n\r\n  return (\r\n    <div ref={itemRef} style={style} data-measurement-state={measurementState}>\r\n      {data[index].content}\r\n    </div>\r\n  );\r\n}\r\n\r\n// Helper function to debounce rapid height changes\r\nfunction debounce(func, wait) {\r\n  let timeout;\r\n\r\n  const debounced = (...args) => {\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(() => func.apply(this, args), wait);\r\n  };\r\n\r\n  debounced.cancel = () => {\r\n    clearTimeout(timeout);\r\n  };\r\n\r\n  return debounced;\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Measurement Best Practices:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use requestAnimationFrame"}),": Ensures measurement after layout completion"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Debounce Updates"}),": Prevents excessive height updates during animations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Graceful fallback when ResizeObserver unavailable"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cleanup Observers"}),": Prevent memory leaks by disconnecting observers"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"dynamic-height-estimation",children:"Dynamic Height Estimation"}),"\n",(0,i.jsx)(n.p,{children:"For unmeasured items, Virtuoso uses intelligent height estimation to maintain accurate scroll calculations and positioning. Since measuring every item would defeat the purpose of virtualization, smart estimation is crucial for performance."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why Height Estimation is Needed:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance"}),": Can't measure all 10,000 items upfront"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scroll Accuracy"}),": Need approximate heights for scroll calculations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Progressive Refinement"}),": Estimates improve as more items are measured"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Efficiency"}),": Avoid storing height data for every item"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Estimation Strategies:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initial Estimate"}),": Start with a reasonable default (e.g., 50px)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Running Average"}),": Update estimate based on measured items"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Weighted Average"}),": Favor recent measurements over old ones"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Category-Based"}),": Different estimates for different item types"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Estimation Evolution:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phase 1"}),": All items use default estimate (50px)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phase 2"}),": First few measured items update estimate (48px average)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phase 3"}),": More measurements refine estimate (52px average)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Phase 4"}),": Stable estimate based on sufficient data"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here's how Virtuoso implements intelligent height estimation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// Height estimation strategies\r\n// This class manages height estimates for unmeasured items in the virtual list\r\nclass HeightEstimator {\r\n  constructor() {\r\n    this.measuredHeights = []; // Array of actual measured heights\r\n    this.estimatedHeight = 50; // Current best estimate (starts at 50px)\r\n    this.measurements = new Map(); // Cache of individual measurements\r\n    this.categoryEstimates = new Map(); // Different estimates by item type\r\n  }\r\n\r\n  // Update estimation based on newly measured items\r\n  // INPUT: newHeight (actual measured height), itemType (optional category)\r\n  // OUTPUT: Updates internal estimate for future unmeasured items\r\n  updateEstimation(newHeight, itemType = "default") {\r\n    // STEP 1: Store the measurement\r\n    this.measuredHeights.push(newHeight);\r\n\r\n    // STEP 2: Update category-specific estimate if provided\r\n    if (itemType !== "default") {\r\n      this.updateCategoryEstimate(itemType, newHeight);\r\n    }\r\n\r\n    // STEP 3: Use different strategies based on data availability\r\n    if (this.measuredHeights.length < 10) {\r\n      // STRATEGY 1: Simple average for small samples\r\n      // With few measurements, simple average is most reliable\r\n      this.estimatedHeight = this.calculateSimpleAverage();\r\n    } else if (this.measuredHeights.length < 50) {\r\n      // STRATEGY 2: Weighted average favoring recent measurements\r\n      // With moderate data, recent items likely more representative\r\n      this.estimatedHeight = this.calculateWeightedAverage();\r\n    } else {\r\n      // STRATEGY 3: Stable average with outlier filtering\r\n      // With lots of data, filter outliers for more stable estimate\r\n      this.estimatedHeight = this.calculateFilteredAverage();\r\n    }\r\n\r\n    // STEP 4: Bound the estimate to reasonable values\r\n    this.estimatedHeight = Math.max(10, Math.min(this.estimatedHeight, 500));\r\n  }\r\n\r\n  // Simple arithmetic mean for early measurements\r\n  calculateSimpleAverage() {\r\n    const sum = this.measuredHeights.reduce((acc, height) => acc + height, 0);\r\n    return sum / this.measuredHeights.length;\r\n  }\r\n\r\n  // Weighted average favoring recent measurements\r\n  // Theory: Recent items are more likely to represent current content type\r\n  calculateWeightedAverage() {\r\n    const recentHeights = this.measuredHeights.slice(-20); // Last 20 measurements\r\n    const weights = recentHeights.map((_, i) => i + 1); // Linear weights: [1,2,3...20]\r\n\r\n    const weightedSum = recentHeights.reduce(\r\n      (sum, height, i) => sum + height * weights[i],\r\n      0\r\n    );\r\n    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);\r\n\r\n    return weightedSum / totalWeight;\r\n  }\r\n\r\n  // Filtered average that removes outliers\r\n  calculateFilteredAverage() {\r\n    const sorted = [...this.measuredHeights].sort((a, b) => a - b);\r\n\r\n    // Remove top and bottom 10% as outliers\r\n    const trimPercent = 0.1;\r\n    const trimCount = Math.floor(sorted.length * trimPercent);\r\n    const trimmed = sorted.slice(trimCount, -trimCount || undefined);\r\n\r\n    // Calculate average of remaining values\r\n    const sum = trimmed.reduce((acc, height) => acc + height, 0);\r\n    return sum / trimmed.length;\r\n  }\r\n\r\n  // Category-based estimation for different item types\r\n  updateCategoryEstimate(category, height) {\r\n    if (!this.categoryEstimates.has(category)) {\r\n      this.categoryEstimates.set(category, {\r\n        heights: [],\r\n        estimate: height,\r\n      });\r\n    }\r\n\r\n    const categoryData = this.categoryEstimates.get(category);\r\n    categoryData.heights.push(height);\r\n\r\n    // Keep only recent measurements for this category\r\n    if (categoryData.heights.length > 50) {\r\n      categoryData.heights = categoryData.heights.slice(-30);\r\n    }\r\n\r\n    // Update category estimate\r\n    const sum = categoryData.heights.reduce((acc, h) => acc + h, 0);\r\n    categoryData.estimate = sum / categoryData.heights.length;\r\n  }\r\n\r\n  // Get height estimate for a specific item\r\n  // INPUT: index, itemType (optional)\r\n  // OUTPUT: Best height estimate for this item\r\n  getEstimatedHeight(index, itemType = "default") {\r\n    // OPTION 1: Use measured height if available\r\n    if (this.measurements.has(index)) {\r\n      return this.measurements.get(index);\r\n    }\r\n\r\n    // OPTION 2: Use category-specific estimate if available\r\n    if (itemType !== "default" && this.categoryEstimates.has(itemType)) {\r\n      return this.categoryEstimates.get(itemType).estimate;\r\n    }\r\n\r\n    // OPTION 3: Use general estimate\r\n    return this.estimatedHeight;\r\n  }\r\n\r\n  // Advanced: Estimate based on content analysis\r\n  getContentBasedEstimate(content) {\r\n    // Estimate height based on content characteristics\r\n    let baseHeight = 40; // Minimum height\r\n\r\n    // Add height for text content\r\n    if (typeof content === "string") {\r\n      const lines = Math.ceil(content.length / 50); // ~50 chars per line\r\n      baseHeight += lines * 20; // 20px per line\r\n    }\r\n\r\n    // Add height for images (if detected)\r\n    if ((content && content.includes("<img")) || content.includes("image")) {\r\n      baseHeight += 200; // Average image height\r\n    }\r\n\r\n    // Add height for complex content\r\n    if (\r\n      content &&\r\n      (content.includes("<div") || content.includes("component"))\r\n    ) {\r\n      baseHeight += 50; // Extra padding for complex layouts\r\n    }\r\n\r\n    return Math.min(baseHeight, 400); // Cap at reasonable max\r\n  }\r\n\r\n  // Performance monitoring\r\n  getEstimationAccuracy() {\r\n    if (this.measuredHeights.length === 0) return null;\r\n\r\n    const actualMean = this.calculateSimpleAverage();\r\n    const estimationError = Math.abs(this.estimatedHeight - actualMean);\r\n    const accuracy = 1 - estimationError / actualMean;\r\n\r\n    return {\r\n      accuracy: Math.max(0, accuracy),\r\n      meanHeight: actualMean,\r\n      currentEstimate: this.estimatedHeight,\r\n      sampleSize: this.measuredHeights.length,\r\n    };\r\n  }\r\n}\r\n\r\n// Usage example with content-aware estimation\r\nfunction useSmartHeightEstimation(items) {\r\n  const estimator = useMemo(() => new HeightEstimator(), []);\r\n\r\n  const getItemHeight = useCallback(\r\n    (index) => {\r\n      const item = items[index];\r\n      const itemType = item?.type || "default";\r\n      const content = item?.content || "";\r\n\r\n      // Try different estimation strategies in order of accuracy\r\n      return (\r\n        estimator.getEstimatedHeight(index, itemType) ||\r\n        estimator.getContentBasedEstimate(content) ||\r\n        50\r\n      ); // Final fallback\r\n    },\r\n    [estimator, items]\r\n  );\r\n\r\n  const reportMeasurement = useCallback(\r\n    (index, height) => {\r\n      const item = items[index];\r\n      const itemType = item?.type || "default";\r\n\r\n      estimator.measurements.set(index, height);\r\n      estimator.updateEstimation(height, itemType);\r\n    },\r\n    [estimator, items]\r\n  );\r\n\r\n  return { getItemHeight, reportMeasurement };\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Estimation Accuracy Over Time:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"0-10 measurements"}),": ~70% accuracy (simple average)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"10-50 measurements"}),": ~85% accuracy (weighted average)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"50+ measurements"}),": ~95% accuracy (filtered average)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Category-specific"}),": ~90% accuracy with sufficient per-category data"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Estimation Features:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Progressive Refinement"}),": Estimates improve as more data is collected"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Category Awareness"}),": Different estimates for different content types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Outlier Filtering"}),": Removes extreme values for more stable estimates"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Content Analysis"}),": Estimates based on content characteristics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance Monitoring"}),": Tracks estimation accuracy over time"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"handling-content-loading",children:"Handling Content Loading"}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso gracefully handles scenarios where content loads asynchronously:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// Example: Images loading in list items\r\nfunction ImageListItem({ index, data }) {\r\n  const [imageLoaded, setImageLoaded] = useState(false);\r\n  const itemRef = useRef(null);\r\n\r\n  // Re-measure when image loads\r\n  const handleImageLoad = useCallback(() => {\r\n    setImageLoaded(true);\r\n    // Trigger re-measurement\r\n    if (itemRef.current) {\r\n      const height = itemRef.current.offsetHeight;\r\n      // This will trigger Virtuoso\'s height update system\r\n      requestAnimationFrame(() => {\r\n        reportHeightChange(index, height);\r\n      });\r\n    }\r\n  }, [index]);\r\n\r\n  return (\r\n    <div ref={itemRef}>\r\n      <h3>{data[index].title}</h3>\r\n      <img\r\n        src={data[index].imageUrl}\r\n        onLoad={handleImageLoad}\r\n        style={{\r\n          width: "100%",\r\n          height: imageLoaded ? "auto" : "200px",\r\n          backgroundColor: imageLoaded ? "transparent" : "#f0f0f0",\r\n        }}\r\n        alt={data[index].title}\r\n      />\r\n      <p>{data[index].description}</p>\r\n    </div>\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"scroll-synchronization",children:"Scroll Synchronization"}),"\n",(0,i.jsx)(n.h3,{id:"scroll-event-handling",children:"Scroll Event Handling"}),"\n",(0,i.jsx)(n.p,{children:"Virtuoso optimizes scroll event handling using requestAnimationFrame and throttling:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Optimized scroll handling system\r\nclass ScrollManager {\r\n  constructor() {\r\n    this.isScrolling = false;\r\n    this.scrollRaf = null;\r\n    this.lastScrollTime = 0;\r\n  }\r\n\r\n  handleScroll = (event) => {\r\n    const now = performance.now();\r\n\r\n    // Throttle scroll events for performance\r\n    if (now - this.lastScrollTime < 16) {\r\n      // ~60fps\r\n      return;\r\n    }\r\n\r\n    this.lastScrollTime = now;\r\n\r\n    // Cancel previous frame if still pending\r\n    if (this.scrollRaf) {\r\n      cancelAnimationFrame(this.scrollRaf);\r\n    }\r\n\r\n    // Schedule update for next frame\r\n    this.scrollRaf = requestAnimationFrame(() => {\r\n      this.updateScrollPosition(event.target.scrollTop);\r\n      this.scrollRaf = null;\r\n    });\r\n  };\r\n\r\n  updateScrollPosition(scrollTop) {\r\n    // Update visible range\r\n    const newVisibleRange = this.calculateVisibleRange(scrollTop);\r\n\r\n    // Only update if range actually changed\r\n    if (!this.rangesEqual(newVisibleRange, this.currentVisibleRange)) {\r\n      this.currentVisibleRange = newVisibleRange;\r\n      this.notifyRangeChange(newVisibleRange);\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"scroll-position-preservation",children:"Scroll Position Preservation"}),"\n",(0,i.jsx)(n.p,{children:"When items change height, Virtuoso maintains scroll position relative to content:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Scroll position preservation during height changes\r\nfunction preserveScrollPosition(heightChanges) {\r\n  const currentScrollTop = this.scrollContainer.scrollTop;\r\n  const currentFirstVisibleIndex = this.findFirstVisibleIndex(currentScrollTop);\r\n\r\n  // Apply height changes and recalculate offsets\r\n  this.applyHeightChanges(heightChanges);\r\n\r\n  // Calculate new scroll position to maintain visual stability\r\n  const newScrollTop = this.getItemOffset(currentFirstVisibleIndex);\r\n\r\n  // Smoothly adjust scroll position\r\n  this.scrollContainer.scrollTop = newScrollTop;\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"programmatic-scrolling",children:"Programmatic Scrolling"}),"\n",(0,i.jsx)(n.p,{children:"Virtuoso provides methods for programmatic scrolling with smooth animations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// Scroll to specific item with options\r\n<Virtuoso\r\n  ref={virtuosoRef}\r\n  totalCount={items.length}\r\n  itemContent={(index) => <Item data={items[index]} />}\r\n/>;\r\n\r\n// Usage examples\r\nfunction scrollToItem() {\r\n  // Instant scroll to item 100\r\n  virtuosoRef.current?.scrollToIndex({\r\n    index: 100,\r\n    align: "start", // \'start\' | \'center\' | \'end\'\r\n  });\r\n\r\n  // Smooth scroll to item 500\r\n  virtuosoRef.current?.scrollToIndex({\r\n    index: 500,\r\n    align: "center",\r\n    behavior: "smooth",\r\n  });\r\n\r\n  // Scroll to item only if not already visible\r\n  virtuosoRef.current?.scrollIntoView({\r\n    index: 250,\r\n    done: () => console.log("Scroll completed"),\r\n  });\r\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"performance-optimization-strategies",children:"Performance Optimization Strategies"}),"\n",(0,i.jsx)(n.h3,{id:"memoization-and-reactmemo",children:"Memoization and React.memo"}),"\n",(0,i.jsx)(n.p,{children:"Optimize item rendering using React.memo and proper dependency management:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'// Optimized item component with memoization\r\nconst ListItem = React.memo(function ListItem({\r\n  index,\r\n  data,\r\n  isSelected,\r\n  onSelect,\r\n}) {\r\n  const item = data[index];\r\n\r\n  // Memoize click handler to prevent unnecessary re-renders\r\n  const handleClick = useCallback(() => {\r\n    onSelect(item.id);\r\n  }, [item.id, onSelect]);\r\n\r\n  // Memoize computed styles\r\n  const itemStyle = useMemo(\r\n    () => ({\r\n      padding: "12px",\r\n      borderBottom: "1px solid #eee",\r\n      backgroundColor: isSelected ? "#e3f2fd" : "transparent",\r\n      cursor: "pointer",\r\n    }),\r\n    [isSelected]\r\n  );\r\n\r\n  return (\r\n    <div style={itemStyle} onClick={handleClick}>\r\n      <h4>{item.title}</h4>\r\n      <p>{item.description}</p>\r\n    </div>\r\n  );\r\n});\r\n\r\n// Usage with proper prop comparison\r\nfunction App() {\r\n  const [selectedId, setSelectedId] = useState(null);\r\n\r\n  // Memoize selection handler\r\n  const handleSelect = useCallback((id) => {\r\n    setSelectedId(id);\r\n  }, []);\r\n\r\n  return (\r\n    <Virtuoso\r\n      totalCount={items.length}\r\n      itemContent={(index) => (\r\n        <ListItem\r\n          index={index}\r\n          data={items}\r\n          isSelected={items[index].id === selectedId}\r\n          onSelect={handleSelect}\r\n        />\r\n      )}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"overscan-tuning",children:"Overscan Tuning"}),"\n",(0,i.jsx)(n.p,{children:"Balance performance vs. smoothness by adjusting overscan parameters:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// Performance-focused configuration (minimal overscan)\r\n<Virtuoso\r\n  totalCount={items.length}\r\n  itemContent={renderItem}\r\n  overscan={2} // Minimal buffer for better performance\r\n/>\r\n\r\n// Smoothness-focused configuration (larger overscan)\r\n<Virtuoso\r\n  totalCount={items.length}\r\n  itemContent={renderItem}\r\n  increaseViewportBy={{\r\n    top: 300,    // Render 300px worth of items above viewport\r\n    bottom: 300  // Render 300px worth of items below viewport\r\n  }}\r\n/>\r\n\r\n// Dynamic overscan based on scroll velocity\r\n<Virtuoso\r\n  totalCount={items.length}\r\n  itemContent={renderItem}\r\n  overscan={(velocity) => {\r\n    // More overscan for faster scrolling\r\n    return Math.min(Math.floor(Math.abs(velocity) / 100), 20);\r\n  }}\r\n/>\n"})}),"\n",(0,i.jsx)(n.h3,{id:"css-optimization",children:"CSS Optimization"}),"\n",(0,i.jsx)(n.p,{children:"Optimize CSS to work well with virtualization:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:"/* Avoid margins on items - use padding instead */\r\n.list-item {\r\n  padding: 12px; /* \u2705 Good - doesn't interfere with measurements */\r\n  /* margin: 12px; \u274c Bad - can cause measurement issues */\r\n}\r\n\r\n/* Use transform for positioning when possible */\r\n.item-container {\r\n  will-change: transform; /* Optimize for frequent changes */\r\n  contain: layout style paint; /* CSS containment for better performance */\r\n}\r\n\r\n/* Optimize for GPU acceleration */\r\n.smooth-item {\r\n  transform: translateZ(0); /* Force GPU layer */\r\n  backface-visibility: hidden;\r\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"component-variants",children:"Component Variants"}),"\n",(0,i.jsx)(n.h3,{id:"virtuoso-basic-list",children:"Virtuoso (Basic List)"}),"\n",(0,i.jsx)(n.p,{children:"The standard virtualized list component:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { Virtuoso } from "react-virtuoso";\r\n\r\nfunction BasicList({ items }) {\r\n  return (\r\n    <Virtuoso\r\n      style={{ height: "400px" }}\r\n      totalCount={items.length}\r\n      itemContent={(index) => (\r\n        <div style={{ padding: "12px", borderBottom: "1px solid #eee" }}>\r\n          {items[index].content}\r\n        </div>\r\n      )}\r\n      // Optional customizations\r\n      components={{\r\n        Header: () => <div>List Header</div>,\r\n        Footer: () => <div>List Footer</div>,\r\n        EmptyPlaceholder: () => <div>No items found</div>,\r\n      }}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"groupedvirtuoso-grouped-lists",children:"GroupedVirtuoso (Grouped Lists)"}),"\n",(0,i.jsx)(n.p,{children:"For lists with group headers and categorized content:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { GroupedVirtuoso } from "react-virtuoso";\r\n\r\nfunction GroupedList({ groups }) {\r\n  // Group structure: [{ title: \'Group 1\', items: [...] }, ...]\r\n  const groupCounts = groups.map((group) => group.items.length);\r\n\r\n  return (\r\n    <GroupedVirtuoso\r\n      style={{ height: "400px" }}\r\n      groupCounts={groupCounts}\r\n      groupContent={(index) => (\r\n        <div\r\n          style={{\r\n            padding: "8px 12px",\r\n            backgroundColor: "#f5f5f5",\r\n            fontWeight: "bold",\r\n            position: "sticky",\r\n            top: 0,\r\n            zIndex: 1,\r\n          }}\r\n        >\r\n          {groups[index].title}\r\n        </div>\r\n      )}\r\n      itemContent={(index, groupIndex) => (\r\n        <div style={{ padding: "12px", borderBottom: "1px solid #eee" }}>\r\n          {groups[groupIndex].items[index].content}\r\n        </div>\r\n      )}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"virtuosogrid-grid-layout",children:"VirtuosoGrid (Grid Layout)"}),"\n",(0,i.jsx)(n.p,{children:"For responsive grid layouts with equal-sized items:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"import { VirtuosoGrid } from 'react-virtuoso';\r\n\r\nfunction ResponsiveGrid({ items }) {\r\n  return (\r\n    <VirtuosoGrid\r\n      style={{ height: '400px' }}\r\n      totalCount={items.length}\r\n      itemContent={index => (\r\n        <div style={{\r\n          padding: '8px',\r\n          border: '1px solid #ddd',\r\n          borderRadius: '4px',\r\n          height: '200px' // Fixed height for grid items\r\n        }}>\r\n          <img src={items[index].image} alt={items[index].title} />\r\n          <h4>{items[index].title}</h4>\r\n        </div>\r\n      )}\r\n      listClassName=\"grid-container\"\r\n    />\r\n  );\r\n}\r\n\r\n/* CSS for responsive grid */\r\n.grid-container {\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\r\n  gap: 16px;\r\n  padding: 16px;\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"tablevirtuoso-table-virtualization",children:"TableVirtuoso (Table Virtualization)"}),"\n",(0,i.jsx)(n.p,{children:"For large tables with virtualized rows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { TableVirtuoso } from "react-virtuoso";\r\n\r\nfunction VirtualizedTable({ data, columns }) {\r\n  return (\r\n    <TableVirtuoso\r\n      style={{ height: "400px" }}\r\n      data={data}\r\n      components={{\r\n        Table: (props) => (\r\n          <table {...props} style={{ borderCollapse: "collapse" }} />\r\n        ),\r\n        TableHead: React.forwardRef((props, ref) => (\r\n          <thead {...props} ref={ref} />\r\n        )),\r\n        TableRow: (props) => (\r\n          <tr {...props} style={{ borderBottom: "1px solid #ddd" }} />\r\n        ),\r\n        TableBody: React.forwardRef((props, ref) => (\r\n          <tbody {...props} ref={ref} />\r\n        )),\r\n      }}\r\n      fixedHeaderContent={() => (\r\n        <tr>\r\n          {columns.map((col) => (\r\n            <th\r\n              key={col.key}\r\n              style={{\r\n                padding: "12px",\r\n                backgroundColor: "#f5f5f5",\r\n                position: "sticky",\r\n                top: 0,\r\n              }}\r\n            >\r\n              {col.title}\r\n            </th>\r\n          ))}\r\n        </tr>\r\n      )}\r\n      itemContent={(index, item) => (\r\n        <>\r\n          {columns.map((col) => (\r\n            <td key={col.key} style={{ padding: "12px" }}>\r\n              {item[col.key]}\r\n            </td>\r\n          ))}\r\n        </>\r\n      )}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,i.jsx)(n.h3,{id:"message-list-for-chat-applications",children:"Message List for Chat Applications"}),"\n",(0,i.jsx)(n.p,{children:"Specialized component for chat/message interfaces:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { VirtuosoMessageList } from "@virtuoso.dev/message-list";\r\n\r\nfunction ChatInterface() {\r\n  const [messages, setMessages] = useState([]);\r\n\r\n  return (\r\n    <VirtuosoMessageList\r\n      initialData={messages}\r\n      itemContent={(index, message) => (\r\n        <div\r\n          style={{\r\n            padding: "8px 12px",\r\n            maxWidth: "70%",\r\n            marginLeft: message.isOwn ? "auto" : "0",\r\n            marginRight: message.isOwn ? "0" : "auto",\r\n            backgroundColor: message.isOwn ? "#007bff" : "#e9ecef",\r\n            color: message.isOwn ? "white" : "black",\r\n            borderRadius: "12px",\r\n            marginBottom: "4px",\r\n          }}\r\n        >\r\n          {message.text}\r\n        </div>\r\n      )}\r\n      // Auto-scroll to bottom for new messages\r\n      followOutput="smooth"\r\n      // Handle loading older messages\r\n      startReached={() => loadOlderMessages()}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"infinite-scrolling",children:"Infinite Scrolling"}),"\n",(0,i.jsx)(n.p,{children:"Implement infinite scrolling with data loading:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'function InfiniteScrollList() {\r\n  const [items, setItems] = useState([]);\r\n  const [loading, setLoading] = useState(false);\r\n  const [hasMore, setHasMore] = useState(true);\r\n\r\n  const loadMore = useCallback(async () => {\r\n    if (loading || !hasMore) return;\r\n\r\n    setLoading(true);\r\n    try {\r\n      const newItems = await fetchMoreData(items.length);\r\n      setItems((prev) => [...prev, ...newItems]);\r\n      setHasMore(newItems.length > 0);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [items.length, loading, hasMore]);\r\n\r\n  return (\r\n    <Virtuoso\r\n      style={{ height: "400px" }}\r\n      totalCount={hasMore ? items.length + 1 : items.length}\r\n      itemContent={(index) => {\r\n        if (index === items.length) {\r\n          return (\r\n            <div style={{ padding: "20px", textAlign: "center" }}>\r\n              {loading ? "Loading..." : "Load More"}\r\n            </div>\r\n          );\r\n        }\r\n        return <Item data={items[index]} />;\r\n      }}\r\n      endReached={loadMore}\r\n      // Preload when user is near the end\r\n      overscan={5}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"custom-scrollbars",children:"Custom Scrollbars"}),"\n",(0,i.jsx)(n.p,{children:"Implement custom scrollbar styling:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"<Virtuoso\r\n  style={{ height: '400px' }}\r\n  totalCount={items.length}\r\n  itemContent={renderItem}\r\n  components={{\r\n    Scroller: React.forwardRef((props, ref) => (\r\n      <div\r\n        {...props}\r\n        ref={ref}\r\n        style={{\r\n          ...props.style,\r\n          // Custom scrollbar styles\r\n          scrollbarWidth: 'thin',\r\n          scrollbarColor: '#888 #f1f1f1'\r\n        }}\r\n        className=\"custom-scrollbar\"\r\n      />\r\n    ))\r\n  }}\r\n/>\r\n\r\n/* CSS for webkit browsers */\r\n.custom-scrollbar::-webkit-scrollbar {\r\n  width: 8px;\r\n}\r\n\r\n.custom-scrollbar::-webkit-scrollbar-track {\r\n  background: #f1f1f1;\r\n  border-radius: 4px;\r\n}\r\n\r\n.custom-scrollbar::-webkit-scrollbar-thumb {\r\n  background: #888;\r\n  border-radius: 4px;\r\n}\r\n\r\n.custom-scrollbar::-webkit-scrollbar-thumb:hover {\r\n  background: #555;\r\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"common-patterns--best-practices",children:"Common Patterns & Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"error-boundaries",children:"Error Boundaries"}),"\n",(0,i.jsx)(n.p,{children:"Wrap virtualized lists with error boundaries:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'class VirtuosoErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { hasError: false };\r\n  }\r\n\r\n  static getDerivedStateFromError(error) {\r\n    return { hasError: true };\r\n  }\r\n\r\n  componentDidCatch(error, errorInfo) {\r\n    console.error("Virtuoso error:", error, errorInfo);\r\n  }\r\n\r\n  render() {\r\n    if (this.state.hasError) {\r\n      return (\r\n        <div style={{ padding: "20px", textAlign: "center" }}>\r\n          <h3>Something went wrong rendering the list</h3>\r\n          <button onClick={() => this.setState({ hasError: false })}>\r\n            Try Again\r\n          </button>\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return this.props.children;\r\n  }\r\n}\r\n\r\n// Usage\r\nfunction App() {\r\n  return (\r\n    <VirtuosoErrorBoundary>\r\n      <Virtuoso totalCount={items.length} itemContent={renderItem} />\r\n    </VirtuosoErrorBoundary>\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"testing-strategies",children:"Testing Strategies"}),"\n",(0,i.jsx)(n.p,{children:"Test virtualized components effectively:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { render, screen } from "@testing-library/react";\r\nimport { Virtuoso } from "react-virtuoso";\r\n\r\n// Mock intersection observer for tests\r\nbeforeAll(() => {\r\n  global.IntersectionObserver = jest.fn(() => ({\r\n    observe: jest.fn(),\r\n    disconnect: jest.fn(),\r\n    unobserve: jest.fn(),\r\n  }));\r\n});\r\n\r\ntest("renders visible items correctly", async () => {\r\n  const items = Array.from({ length: 1000 }, (_, i) => ({\r\n    id: i,\r\n    content: `Item ${i}`,\r\n  }));\r\n\r\n  render(\r\n    <Virtuoso\r\n      style={{ height: "400px" }}\r\n      totalCount={items.length}\r\n      itemContent={(index) => (\r\n        <div data-testid={`item-${index}`}>{items[index].content}</div>\r\n      )}\r\n    />\r\n  );\r\n\r\n  // Only visible items should be rendered\r\n  expect(screen.queryByTestId("item-0")).toBeInTheDocument();\r\n  expect(screen.queryByTestId("item-999")).not.toBeInTheDocument();\r\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,i.jsx)(n.p,{children:"Monitor virtualization performance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"function useVirtuosoPerformance() {\r\n  const [metrics, setMetrics] = useState({});\r\n\r\n  const onScroll = useCallback((scrollTop) => {\r\n    const start = performance.now();\r\n\r\n    // Measure scroll handling time\r\n    requestAnimationFrame(() => {\r\n      const duration = performance.now() - start;\r\n      setMetrics((prev) => ({\r\n        ...prev,\r\n        scrollHandlingTime: duration,\r\n        lastScrollTop: scrollTop,\r\n      }));\r\n    });\r\n  }, []);\r\n\r\n  return { metrics, onScroll };\r\n}\r\n\r\n// Usage\r\nfunction MonitoredList() {\r\n  const { metrics, onScroll } = useVirtuosoPerformance();\r\n\r\n  return (\r\n    <>\r\n      <div>Scroll handling: {metrics.scrollHandlingTime?.toFixed(2)}ms</div>\r\n      <Virtuoso\r\n        totalCount={items.length}\r\n        itemContent={renderItem}\r\n        onScroll={onScroll}\r\n      />\r\n    </>\r\n  );\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"accessibility-considerations",children:"Accessibility Considerations"}),"\n",(0,i.jsx)(n.p,{children:"Ensure virtualized lists are accessible:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'<Virtuoso\r\n  style={{ height: "400px" }}\r\n  totalCount={items.length}\r\n  itemContent={(index) => (\r\n    <div\r\n      role="listitem"\r\n      aria-setsize={items.length}\r\n      aria-posinset={index + 1}\r\n      tabIndex={0}\r\n      onKeyDown={(e) => {\r\n        if (e.key === "Enter" || e.key === " ") {\r\n          handleItemSelect(index);\r\n        }\r\n      }}\r\n    >\r\n      {items[index].content}\r\n    </div>\r\n  )}\r\n  components={{\r\n    List: React.forwardRef((props, ref) => (\r\n      <div\r\n        {...props}\r\n        ref={ref}\r\n        role="list"\r\n        aria-label="Virtualized item list"\r\n      />\r\n    )),\r\n  }}\r\n/>\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"how-react-virtuoso-handles-and-renders-items-to-the-dom",children:"How React Virtuoso Handles and Renders Items to the DOM"}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso employs a highly optimized approach to DOM rendering, ensuring that only the necessary elements are present in the DOM at any given time, regardless of the total dataset size. Here\u2019s a detailed look at how Virtuoso manages this process:"}),"\n",(0,i.jsx)(n.h3,{id:"visualizing-the-dom-lifecycle",children:"Visualizing the DOM Lifecycle"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:"graph LR\r\n  A[Initial Render: Items 0-19 in DOM] -- Scroll Down --\x3e B[Scroll: Items 10-29 in DOM]\r\n  B -- Scroll Down --\x3e C[Scroll: Items 20-39 in DOM]\r\n  C -- Scroll Up --\x3e B\r\n  B -- Scroll Up --\x3e A\r\n  A -. Items 20+ unmounted .-> C\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"A"}),": Only the first 20 items are rendered."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"B"}),": As you scroll, the DOM updates to show the next 20 items, unmounting those that left the buffer."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"C"}),": Further scrolling continues this process, always keeping the DOM size small."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-dom-node-recycling-and-buffer-management",children:"Example: DOM Node Recycling and Buffer Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import { Virtuoso } from "react-virtuoso";\r\n\r\nfunction LoggingList({ items }) {\r\n  // This ref logs when items mount/unmount\r\n  const Item = ({ index }) => {\r\n    useEffect(() => {\r\n      console.log(`MOUNT: Item ${index}`);\r\n      return () => console.log(`UNMOUNT: Item ${index}`);\r\n    }, [index]);\r\n    return (\r\n      <div>\r\n        Item {index}: {items[index].content}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  return (\r\n    <Virtuoso\r\n      style={{ height: 300 }}\r\n      totalCount={items.length}\r\n      itemContent={(index) => <Item index={index} />}\r\n      overscan={5} // buffer of 5 items above/below\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Console Output Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"MOUNT: Item 0\r\nMOUNT: Item 1\r\n...\r\nMOUNT: Item 19\r\n// User scrolls down\r\nUNMOUNT: Item 0\r\nMOUNT: Item 20\r\n...\n"})}),"\n",(0,i.jsx)(n.p,{children:"This shows how Virtuoso mounts only visible/buffered items and unmounts those that leave the buffer, keeping the DOM light."}),"\n",(0,i.jsx)(n.h3,{id:"internal-buffer-and-recycling-logic-pseudocode",children:"Internal Buffer and Recycling Logic (Pseudocode)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function updateVisibleItems(scrollTop, viewportHeight, buffer, totalCount) {\r\n  const start = Math.max(0, findFirstVisible(scrollTop) - buffer);\r\n  const end = Math.min(\r\n    totalCount,\r\n    findLastVisible(scrollTop, viewportHeight) + buffer\r\n  );\r\n  // Only items in [start, end) are mounted\r\n  return { start, end };\r\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"1-viewport-driven-rendering",children:["1. ",(0,i.jsx)(n.strong,{children:"Viewport-Driven Rendering"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visible Range Calculation:"})," Virtuoso continuously calculates which items are visible in the viewport based on the current scroll position and container height. This is achieved using efficient algorithms (like binary search) to quickly determine the first and last visible items."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Buffer/Overscan:"})," To ensure smooth scrolling, Virtuoso renders a configurable buffer (overscan) of items above and below the visible range. This prevents blank spaces during fast scrolls and allows for seamless user experience."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"2-dom-recycling-and-element-lifecycle",children:["2. ",(0,i.jsx)(n.strong,{children:"DOM Recycling and Element Lifecycle"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Minimal DOM Nodes:"})," Only the items within the visible range (plus buffer) are mounted in the DOM. For example, in a list of 10,000 items, the DOM might only contain 20-50 elements at any time."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Element Reuse:"})," As the user scrolls, Virtuoso reuses existing DOM nodes for new data, minimizing mounting/unmounting overhead. This recycling is managed internally, so React\u2019s reconciliation is optimized for performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unmounting:"})," Items that scroll out of the overscan buffer are unmounted, freeing up memory and reducing layout/repaint costs."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"3-dynamic-measurement-and-positioning",children:["3. ",(0,i.jsx)(n.strong,{children:"Dynamic Measurement and Positioning"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automatic Height Measurement:"})," Virtuoso uses the ResizeObserver API to measure the height of each rendered item. This allows it to handle variable-height content without manual configuration."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Offset Calculation:"})," The measured heights are used to calculate the offset (distance from the top) for each item. This ensures that each item is positioned accurately within the scrollable container, even as heights change dynamically."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Efficient Updates:"})," When an item\u2019s height changes (e.g., due to image loading), only the affected offsets and DOM nodes are updated, preserving scroll position and visual stability."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"4-rendering-pipeline",children:["4. ",(0,i.jsx)(n.strong,{children:"Rendering Pipeline"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Render Pass:"})," On each scroll event (throttled and optimized with requestAnimationFrame), Virtuoso determines the new visible range and updates the DOM accordingly."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State Synchronization:"})," The internal state tracks which items are currently rendered, their heights, and their offsets. This state is updated reactively, ensuring that only necessary changes trigger re-renders."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Programmatic Control:"})," Developers can programmatically scroll to specific items, and Virtuoso will ensure the correct DOM nodes are rendered and positioned."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"5-performance-and-best-practices",children:["5. ",(0,i.jsx)(n.strong,{children:"Performance and Best Practices"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"O(1) Rendering Complexity:"})," The number of DOM nodes remains constant regardless of list size, transforming rendering complexity from O(n) to O(1)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CSS Optimization:"})," Virtuoso recommends using padding instead of margins for item spacing, and leveraging CSS containment and GPU acceleration for optimal performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Boundaries:"})," Wrapping Virtuoso in an error boundary ensures that rendering errors do not crash the entire app."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"6-example-dom-rendering-lifecycle",children:["6. ",(0,i.jsx)(n.strong,{children:"Example: DOM Rendering Lifecycle"})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initial Render:"})," Only the items visible in the viewport (plus buffer) are rendered to the DOM."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scroll Event:"})," As the user scrolls, Virtuoso calculates the new visible range and updates the DOM, recycling nodes as needed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Height Change:"})," If an item\u2019s height changes, Virtuoso re-measures and updates offsets, adjusting the scroll position if necessary to maintain visual stability."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unmounting:"})," Items that move out of the overscan buffer are unmounted from the DOM."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"visual-example-what-the-dom-looks-like-during-virtualization",children:"Visual Example: What the DOM Looks Like During Virtualization"}),"\n",(0,i.jsx)(n.p,{children:"When Virtuoso renders a large list, the DOM structure looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'<div class="virtuoso-scroller" style="overflow: auto; height: 400px;">\r\n  <div class="virtuoso-item-list" style="position: relative;">\r\n    \x3c!-- Top spacer for items 0\u201349 --\x3e\r\n    <div style="height: 2400px;"></div>\r\n\r\n    \x3c!-- Rendered items (50\u201360) --\x3e\r\n    <div style="position: absolute; top: 2400px; height: 48px;">Item 50</div>\r\n    <div style="position: absolute; top: 2448px; height: 48px;">Item 51</div>\r\n    <div style="position: absolute; top: 2496px; height: 48px;">Item 52</div>\r\n    ...\r\n    <div style="position: absolute; top: 2928px; height: 48px;">Item 60</div>\r\n\r\n    \x3c!-- Bottom spacer for items after 60 --\x3e\r\n    <div style="height: 1000px;"></div>\r\n  </div>\r\n</div>\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.strong,{children:"top spacer"})," simulates the space taken by all items above the visible window (items 0\u201349)."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.strong,{children:"rendered items"})," (50\u201360) are absolutely positioned at their calculated offsets."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.strong,{children:"bottom spacer"})," simulates the space for all items after the rendered window."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This structure allows the scroll bar to reflect the full list height, while only a small subset of items are actually in the DOM."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["For a more in-depth technical breakdown, see the ",(0,i.jsx)(n.a,{href:"https://chatgpt.com/share/689a2e39-c320-8007-bd6b-b194996873cb",children:"shared ChatGPT resource"})," and the ",(0,i.jsx)(n.a,{href:"https://virtuoso.dev/",children:"official documentation"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"React Virtuoso represents a sophisticated approach to handling large datasets in React applications. Its automatic height measurement, efficient offset management, and smooth scrolling capabilities make it an excellent choice for performance-critical applications. By understanding its internal mechanisms\u2014from viewport management to variable height handling\u2014developers can leverage its full potential while avoiding common pitfalls."}),"\n",(0,i.jsx)(n.p,{children:"Key takeaways:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Virtualization transforms O(n) to O(1)"})," rendering complexity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automatic height measurement"})," eliminates manual configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Smart offset calculation"})," maintains scroll position accuracy"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Proper memoization"})," is crucial for optimal performance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Component variants"})," address different use cases efficiently"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Whether building chat interfaces, data tables, or image galleries, React Virtuoso provides the tools needed to create smooth, performant user experiences at any scale."}),"\n",(0,i.jsxs)(n.p,{children:["Further reading: ",(0,i.jsx)(n.a,{href:"https://virtuoso.dev/",children:"React Virtuoso Documentation"})," | ",(0,i.jsx)(n.a,{href:"https://github.com/petyosi/react-virtuoso",children:"GitHub Repository"})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(6540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);