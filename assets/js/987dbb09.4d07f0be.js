"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2364],{1033:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"react-interview/designing-state-summary","title":"06-designing-state: Summary","description":"---","source":"@site/docs/react-interview/06-designing-state-summary.md","sourceDirName":"react-interview","slug":"/react-interview/designing-state-summary","permalink":"/frontend-system-design/docs/react-interview/designing-state-summary","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/react-interview/06-designing-state-summary.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"summarySidebar","previous":{"title":"05-thinking-declaratively: Summary","permalink":"/frontend-system-design/docs/react-interview/thinking-declaratively-summary"},"next":{"title":"07-react-hooks: Summary","permalink":"/frontend-system-design/docs/react-interview/react-hooks-summary"}}');var r=s(4848),i=s(8453);const a={},l="06-designing-state: Summary",o={},c=[];function d(e){const n={blockquote:"blockquote",br:"br",h1:"h1",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"06-designing-state-summary",children:"06-designing-state: Summary"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Interviewer\u2019s Intention"}),(0,r.jsx)(n.br,{}),"\n","Goal: Assess your understanding of state management in React and your ability to design scalable state solutions."]}),"\n",(0,r.jsx)(n.p,{children:"Want to see:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If you can break down state types, lifecycles, and management strategies."}),"\n",(0,r.jsx)(n.li,{children:"How you choose between local, lifted, context, and external state."}),"\n",(0,r.jsx)(n.li,{children:"If you can explain tradeoffs and best practices."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Answer Framework"})]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Types of State"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Local (component), lifted (shared), derived, server, UI, form, cache"}),"\n",(0,r.jsx)(n.li,{children:"When to use useState, useReducer, context, external stores (Redux, Zustand)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"State Management Strategies"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Keep state as local as possible"}),"\n",(0,r.jsx)(n.li,{children:"Lift state up for shared data"}),"\n",(0,r.jsx)(n.li,{children:"Use context for global, non-frequently changing state"}),"\n",(0,r.jsx)(n.li,{children:"Use external stores for large/global/async state"}),"\n",(0,r.jsx)(n.li,{children:"Normalize and structure state for scalability"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Actionable Checklist"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Identify state type and scope"}),"\n",(0,r.jsx)(n.li,{children:"Choose the right tool (useState, useReducer, context, Redux, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Avoid prop drilling and unnecessary re-renders"}),"\n",(0,r.jsx)(n.li,{children:"Memoize selectors and derived data"}),"\n",(0,r.jsx)(n.li,{children:"Test state logic and edge cases"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Example Content / Model Answer"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"\u201cI design state by keeping it as local as possible, lifting it up when needed, and using context or external stores for global state. I choose useState for simple cases, useReducer for complex logic, and Redux/Zustand for app-wide state. I normalize state and memoize selectors to avoid unnecessary renders.\u201d"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pro Tips / Common Pitfalls"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Don\u2019t put everything in context or Redux\u2014prefer local state."}),"\n",(0,r.jsx)(n.li,{children:"Avoid prop drilling by lifting state or using context."}),"\n",(0,r.jsx)(n.li,{children:"Test state logic thoroughly."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var t=s(6540);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);