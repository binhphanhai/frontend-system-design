"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4925],{3220:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"react-interview/design-patterns","title":"Design Patterns for React Interviews","description":"An exploration of React design patterns, including higher-order components, render props, and container/presentational patterns, to help you build clean, reusable, and scalable applications","source":"@site/docs/react-interview/12-design-patterns.md","sourceDirName":"react-interview","slug":"/react-interview/design-patterns","permalink":"/frontend-system-design/docs/react-interview/design-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/react-interview/12-design-patterns.md","tags":[],"version":"current","sidebarPosition":12,"frontMatter":{},"sidebar":"reactInterviewSidebar","previous":{"title":"Data Fetching in React Interviews","permalink":"/frontend-system-design/docs/react-interview/data-fetching"}}');var s=t(4848),a=t(8453);const o={},i="Design Patterns for React Interviews",c={},l=[{value:"Higher-Order Components (HOC)",id:"higher-order-components-hoc",level:2},{value:"Render Props",id:"render-props",level:2},{value:"Container/Presentational Pattern",id:"containerpresentational-pattern",level:2},{value:"Presentational Components",id:"presentational-components",level:3},{value:"Container Components",id:"container-components",level:3},{value:"Alternative Approaches",id:"alternative-approaches",level:4},{value:"What You Need to Know for Interviews",id:"what-you-need-to-know-for-interviews",level:2},{value:"Practice Questions",id:"practice-questions",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"design-patterns-for-react-interviews",children:"Design Patterns for React Interviews"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"An exploration of React design patterns, including higher-order components, render props, and container/presentational patterns, to help you build clean, reusable, and scalable applications"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"React encourages component-based architecture, but as applications grow, maintaining clean, reusable, and scalable code becomes essential. The following are some of the most common design patterns in React and when to use them."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"higher-order-components-hoc",children:"Higher-Order Components (HOC)"}),"\n",(0,s.jsx)(n.p,{children:"A Higher-order component (HOC) is a function that takes a component and returns an enhanced component with additional props or logic. It promotes code reuse across multiple components."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'function withAuth(Component) {\r\n  return function WrappedComponent(props) {\r\n    const isAuthenticated = localStorage.getItem("token"); // Check auth status\r\n    return isAuthenticated ? <Component {...props} /> : <p>Access Denied</p>;\r\n  };\r\n}\r\n\r\nfunction Dashboard() {\r\n  return <h1>Dashboard</h1>;\r\n}\r\n\r\nconst ProtectedDashboard = withAuth(Dashboard);\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"HOCs are useful for:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reusing logic across multiple components (e.g., authentication, analytics, logging, fetching data)"}),"\n",(0,s.jsx)(n.li,{children:"Adding behavior without modifying original components"}),"\n",(0,s.jsx)(n.li,{children:"Scenarios where hooks aren't an option, such as class components"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," Higher-order components were more useful in the pre-hooks era for adding functionality to components. Now that we have React hooks and the ability to create custom hooks, HOCs are no longer that widespread."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Further reading: ",(0,s.jsx)(n.a,{href:"https://www.patterns.dev/react/hoc-pattern/",children:"Higher-Order Components \u2013 React (patterns.dev)"})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"render-props",children:"Render Props"}),"\n",(0,s.jsx)(n.p,{children:"Render props involves passing a function that renders an element as a prop to a component. The component calls the prop with certain parameters, which is usually its own state."}),"\n",(0,s.jsx)(n.p,{children:"This allows the parent to the component to render based on the component state, still allowing the parent to customize the behavior/appearance from outside."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'function MouseTracker({ render }) {\r\n  const [position, setPosition] = useState({ x: 0, y: 0 });\r\n\r\n  useEffect(() => {\r\n    const handleMouseMove = (event) => {\r\n      setPosition({ x: event.clientX, y: event.clientY });\r\n    };\r\n    window.addEventListener("mousemove", handleMouseMove);\r\n    return () => window.removeEventListener("mousemove", handleMouseMove);\r\n  }, []);\r\n\r\n  return render(position);\r\n}\r\n\r\nfunction App() {\r\n  return (\r\n    <MouseTracker\r\n      render={(position) => (\r\n        <p>\r\n          Mouse: {position.x}, {position.y}\r\n        </p>\r\n      )}\r\n    />\r\n  );\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Render props are useful for:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sharing logic between components while keeping UI flexible"}),"\n",(0,s.jsx)(n.li,{children:"Scenarios where hooks aren't an option, such as class components"}),"\n",(0,s.jsx)(n.li,{children:"Headless components that provide logic and behavior while allowing customization of appearance"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Further reading: ",(0,s.jsx)(n.a,{href:"https://www.patterns.dev/react/render-props-pattern/",children:"Render Props - React (patterns.dev)"})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"containerpresentational-pattern",children:"Container/Presentational Pattern"}),"\n",(0,s.jsx)(n.p,{children:"The Container/presentational pattern is a design pattern used in React to separate state management (logic) from UI rendering (presentation). It helps in making components reusable, maintainable, and testable by ensuring a clear separation of concerns."}),"\n",(0,s.jsxs)(n.p,{children:["On the client, data can come from the user's input, fetched from an API, ",(0,s.jsx)(n.code,{children:"localStorage"}),", WebSockets, etc. Not assuming where the data comes from is a good way to structure your components."]}),"\n",(0,s.jsx)(n.h3,{id:"presentational-components",children:"Presentational Components"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Focus only on rendering the UI"}),"\n",(0,s.jsx)(n.li,{children:"Do not contain state (except local UI state like toggles)"}),"\n",(0,s.jsxs)(n.li,{children:["Receive all data via props and use event handlers (e.g. ",(0,s.jsx)(n.code,{children:"onClick"}),", ",(0,s.jsx)(n.code,{children:"onChange"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"Reusable and easy to test because they are independent of business logic"}),"\n",(0,s.jsx)(n.li,{children:"Do not assume how data is fetched"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"function UserList({ users }) {\r\n  return (\r\n    <ul>\r\n      {users.map((user) => (\r\n        <li key={user.id}>\r\n          {user.name} - {user.email}\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  );\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"container-components",children:"Container Components"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Manage state, API calls, and business logic"}),"\n",(0,s.jsx)(n.li,{children:"Pass data and functions as props to presentational components"}),"\n",(0,s.jsx)(n.li,{children:"Do not contain UI code (minimal JSX except for wrapping presentational components)"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'function UserListContainer() {\r\n  const [users, setUsers] = useState([]);\r\n\r\n  useEffect(() => {\r\n    fetch("https://jsonplaceholder.typicode.com/users")\r\n      .then((res) => res.json())\r\n      .then((data) => setUsers(data));\r\n  }, []);\r\n\r\n  return <UserList users={users} />;\r\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"This pattern allows:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reusing UI components with different data sources"}),"\n",(0,s.jsx)(n.li,{children:"A clear separation between UI and state logic"}),"\n",(0,s.jsx)(n.li,{children:"Making UI components easier to test"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"alternative-approaches",children:"Alternative Approaches"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Custom hooks (e.g. ",(0,s.jsx)(n.code,{children:"useUser"})," hook for fetching users):"]})," A more modern approach that keeps logic reusable across multiple components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State management libraries (Redux, Zustand):"})," Handle global state separately without needing explicit container components"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Further reading: ",(0,s.jsx)(n.a,{href:"https://www.patterns.dev/react/presentational-container-pattern",children:"Container/Presentational Pattern (patterns.dev)"})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"what-you-need-to-know-for-interviews",children:"What You Need to Know for Interviews"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use hooks first:"})," While HOCs and render props were once popular patterns for code reuse in React, they have largely been replaced by hooks. However, they are still useful in certain scenarios where Hooks alone may not be sufficient or usable, such as in legacy code bases still using class components."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Container/presentation goes beyond front end:"})," The key idea behind the container/presentational pattern is to separate presentation from the source of data. Separating data fetching from presentation is a powerful concept that is useful beyond front end engineering. When building back end systems, data can be fetched from other services, loaded from a database, read from a filesystem, etc. By doing such a separation, code will be easier to reuse and test."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"practice-questions",children:"Practice Questions"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Quiz:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/questions/quiz/what-are-higher-order-components-in-react?framework=react&tab=quiz",children:"What are higher order components in React?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/questions/quiz/what-is-the-flux-pattern-and-what-are-its-benefits?framework=react&tab=quiz",children:"What is the Flux pattern and what are its benefits?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/questions/quiz/explain-the-presentational-vs-container-component-pattern-in-react?framework=react&tab=quiz",children:"Explain the presentational vs container component pattern in React"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/questions/quiz/what-are-render-props-in-react-and-what-are-they-for?framework=react&tab=quiz",children:"What are render props in React and what are they for?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/questions/quiz/explain-the-composition-pattern-in-react?framework=react&tab=quiz",children:"Explain the composition pattern in React"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(6540);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);