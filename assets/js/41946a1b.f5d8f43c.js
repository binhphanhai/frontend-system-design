"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5891],{7985:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"project-detail/service-worker","title":"Service Workers: The Gateway to Progressive Web Apps","description":"Table of Contents","source":"@site/docs/project-detail/service-worker.md","sourceDirName":"project-detail","slug":"/project-detail/service-worker","permalink":"/frontend-system-design/docs/project-detail/service-worker","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/service-worker.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Web Workers: Background Threading in the Browser","permalink":"/frontend-system-design/docs/project-detail/web-worker"},"next":{"title":"Styled Components: CSS-in-JS Simplified","permalink":"/frontend-system-design/docs/project-detail/styled-component"}}');var r=t(4848),i=t(8453);const a={},o="Service Workers: The Gateway to Progressive Web Apps",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Capabilities",id:"key-capabilities",level:3},{value:"Service Worker vs Web Worker",id:"service-worker-vs-web-worker",level:3},{value:"Getting Started with Service Workers",id:"getting-started-with-service-workers",level:2},{value:"Feature Detection and Registration",id:"feature-detection-and-registration",level:3},{value:"Basic Service Worker Structure",id:"basic-service-worker-structure",level:3},{value:"Service Worker Lifecycle",id:"service-worker-lifecycle",level:2},{value:"Lifecycle States and Transitions",id:"lifecycle-states-and-transitions",level:3},{value:"Under the Hood: How Service Workers Work",id:"under-the-hood-how-service-workers-work",level:2},{value:"Browser Architecture with Service Workers",id:"browser-architecture-with-service-workers",level:3},{value:"Service Worker Global Scope",id:"service-worker-global-scope",level:3},{value:"Caching Strategies",id:"caching-strategies",level:2},{value:"Cache-First Strategy",id:"cache-first-strategy",level:3},{value:"Network-First Strategy",id:"network-first-strategy",level:3},{value:"Stale-While-Revalidate Strategy",id:"stale-while-revalidate-strategy",level:3},{value:"Advanced Caching with Expiration",id:"advanced-caching-with-expiration",level:3},{value:"Offline Functionality",id:"offline-functionality",level:2},{value:"Comprehensive Offline Strategy",id:"comprehensive-offline-strategy",level:3},{value:"Push Notifications and Background Sync",id:"push-notifications-and-background-sync",level:2},{value:"Push Notification Implementation",id:"push-notification-implementation",level:3},{value:"Background Sync",id:"background-sync",level:3},{value:"Advanced Patterns and Best Practices",id:"advanced-patterns-and-best-practices",level:2},{value:"Service Worker Update Pattern",id:"service-worker-update-pattern",level:3},{value:"Resource Versioning Strategy",id:"resource-versioning-strategy",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Secure Service Worker Implementation",id:"secure-service-worker-implementation",level:3},{value:"Debugging and Development",id:"debugging-and-development",level:2},{value:"Service Worker Debugging Tools",id:"service-worker-debugging-tools",level:3},{value:"Real-World Implementation",id:"real-world-implementation",level:2},{value:"Complete PWA Service Worker",id:"complete-pwa-service-worker",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Cache Management Best Practices",id:"cache-management-best-practices",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"When to Use Service Workers",id:"when-to-use-service-workers",level:3},{value:"Further Resources",id:"further-resources",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"service-workers-the-gateway-to-progressive-web-apps",children:"Service Workers: The Gateway to Progressive Web Apps"})}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#getting-started-with-service-workers",children:"Getting Started with Service Workers"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#service-worker-lifecycle",children:"Service Worker Lifecycle"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#under-the-hood-how-service-workers-work",children:"Under the Hood: How Service Workers Work"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#caching-strategies",children:"Caching Strategies"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#offline-functionality",children:"Offline Functionality"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#push-notifications-and-background-sync",children:"Push Notifications and Background Sync"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#advanced-patterns-and-best-practices",children:"Advanced Patterns and Best Practices"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#security-considerations",children:"Security Considerations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#debugging-and-development",children:"Debugging and Development"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#real-world-implementation",children:"Real-World Implementation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:["Service Workers are a cornerstone technology of Progressive Web Apps (PWAs), acting as programmable proxy servers between web applications and the network. As outlined in the ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API",children:"MDN Service Worker API documentation"}),", they enable powerful features like offline functionality, push notifications, and background synchronization."]}),"\n",(0,r.jsx)(n.p,{children:"Unlike regular Web Workers, Service Workers can intercept network requests, cache resources, and serve content even when the network is unavailable. They run in a separate thread from the main application, ensuring that intensive operations don't block the user interface."}),"\n",(0,r.jsx)(n.h3,{id:"key-capabilities",children:"Key Capabilities"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Network Interception"}),": Intercept and modify network requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resource Caching"}),": Store resources for offline access"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Background Processing"}),": Handle tasks when the app isn't active"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Push Notifications"}),": Receive and display notifications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Background Sync"}),": Sync data when connectivity is restored"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"service-worker-vs-web-worker",children:"Service Worker vs Web Worker"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What this comparison demonstrates:"})," The fundamental difference between Service Workers and Web Workers in terms of network access capabilities."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key differences:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service Workers:"})," Run in a separate context and can intercept all network requests from your web app"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Web Workers:"})," Execute JavaScript in background threads but cannot access the network layer directly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use cases:"})," Service Workers for PWA features (offline, caching, push notifications), Web Workers for heavy computations"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Service Worker - Can intercept network requests\n// This code runs in the Service Worker context and demonstrates network interception\nself.addEventListener("fetch", (event) => {\n  // Intercept any fetch request made by the web app\n  // event.request contains the full request object (URL, method, headers, etc.)\n  event.respondWith(\n    // Check if we have a cached version of this request\n    caches.match(event.request)\n    // If found in cache, return it; if not, this will return undefined\n    // and the browser will proceed with the original network request\n  );\n});\n\n// Web Worker - Cannot access network layer\n// Regular Web Workers run in a different context without network interception capabilities\n// They can use fetch() to make requests, but cannot intercept requests from the main thread\n// Network interception is not possible in regular Web Workers\n'})}),"\n",(0,r.jsx)(n.h2,{id:"getting-started-with-service-workers",children:"Getting Started with Service Workers"}),"\n",(0,r.jsx)(n.h3,{id:"feature-detection-and-registration",children:"Feature Detection and Registration"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What this code does:"})," Safely registers a Service Worker with proper feature detection and update handling."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Step-by-step process:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Feature Detection:"})," Check if the browser supports Service Workers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Registration:"})," Register the Service Worker file (",(0,r.jsx)(n.code,{children:"/sw.js"}),") with a specific scope"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Update Detection:"})," Listen for new Service Worker versions and notify users"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Handling:"})," Gracefully handle registration failures"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Input:"})," Service Worker file path (",(0,r.jsx)(n.code,{children:"/sw.js"}),") and configuration options\n",(0,r.jsx)(n.strong,{children:"Output:"})," Registered Service Worker with update notifications"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When to use:"})," This should be your standard Service Worker registration pattern in production apps."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Check for Service Worker support before attempting registration\n// This prevents errors in older browsers that don\'t support Service Workers\nif ("serviceWorker" in navigator) {\n  // Wait for the page to fully load before registering\n  // This ensures the main thread isn\'t blocked during initial page render\n  window.addEventListener("load", async () => {\n    try {\n      // Register the Service Worker file\n      const registration = await navigator.serviceWorker.register("/sw.js", {\n        scope: "/", // Controls which pages the SW manages (all pages in this case)\n        // Other options: updateViaCache: \'none\' | \'imports\' | \'all\'\n      });\n\n      console.log("SW registered:", registration.scope);\n\n      // Handle registration updates - crucial for deploying new versions\n      registration.addEventListener("updatefound", () => {\n        // A new Service Worker is being installed\n        const newWorker = registration.installing;\n        console.log("New service worker installing");\n\n        // Monitor the installation progress\n        newWorker.addEventListener("statechange", () => {\n          if (newWorker.state === "installed") {\n            // Check if there\'s already an active Service Worker\n            if (navigator.serviceWorker.controller) {\n              // There\'s an update available\n              console.log("New content available, please refresh");\n              showUpdateNotification();\n            } else {\n              // First time installation - everything is cached\n              console.log("Content cached for offline use");\n            }\n          }\n        });\n      });\n    } catch (error) {\n      // Registration failed - could be network issues, invalid SW file, etc.\n      console.error("SW registration failed:", error);\n    }\n  });\n} else {\n  // Graceful degradation for unsupported browsers\n  console.log("Service Workers not supported");\n}\n\n// User-friendly update notification\n// This creates a simple UI element to inform users about available updates\nfunction showUpdateNotification() {\n  const notification = document.createElement("div");\n  notification.innerHTML = `\n    <div class="update-notification" style="\n      position: fixed; \n      top: 20px; \n      right: 20px; \n      background: #4CAF50; \n      color: white; \n      padding: 12px; \n      border-radius: 4px;\n      z-index: 9999;\n    ">\n      New version available! \n      <button onclick="window.location.reload()" style="\n        background: white; \n        color: #4CAF50; \n        border: none; \n        padding: 4px 8px; \n        border-radius: 2px;\n        cursor: pointer;\n      ">Refresh</button>\n    </div>\n  `;\n  document.body.appendChild(notification);\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"basic-service-worker-structure",children:"Basic Service Worker Structure"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What this Service Worker does:"})," Implements a complete caching strategy with installation, activation, and fetch handling."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"The three main lifecycle events:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Install:"})," Downloads and caches essential resources (app shell)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Activate:"})," Cleans up old caches and takes control of all pages"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fetch:"})," Intercepts network requests and serves cached content when available"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Input:"})," Network requests from the web application\n",(0,r.jsx)(n.strong,{children:"Output:"})," Cached responses or fresh network responses, with offline fallback"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cache strategy:"})," Cache-first with network fallback and offline page support"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// sw.js - Service Worker file\n// This file must be served from your domain\'s root or a directory you want to control\n\n// Cache configuration\nconst CACHE_NAME = "my-app-v1"; // Version your cache names for easy updates\nconst urlsToCache = [\n  "/", // Home page\n  "/styles/main.css", // Critical CSS\n  "/scripts/main.js", // Core JavaScript\n  "/offline.html", // Offline fallback page\n  // Add other essential resources your app needs to work offline\n];\n\n// INSTALL EVENT - Triggered when the Service Worker is first installed\n// This is where you cache your app\'s essential resources ("app shell")\nself.addEventListener("install", (event) => {\n  console.log("Service Worker installing");\n\n  // event.waitUntil() ensures the Service Worker doesn\'t finish installing\n  // until the promise resolves (all caching is complete)\n  event.waitUntil(\n    caches\n      .open(CACHE_NAME) // Create/open the cache with our version name\n      .then((cache) => {\n        console.log("Caching app shell");\n        // cache.addAll() downloads and stores all URLs in the array\n        // If any URL fails to cache, the entire installation fails\n        return cache.addAll(urlsToCache);\n      })\n      .then(() => {\n        // Skip waiting phase to activate immediately\n        // Without this, the new SW waits until all tabs are closed\n        return self.skipWaiting();\n      })\n  );\n});\n\n// ACTIVATE EVENT - Triggered when the Service Worker becomes active\n// This is where you clean up old caches and prepare for new functionality\nself.addEventListener("activate", (event) => {\n  console.log("Service Worker activating");\n\n  event.waitUntil(\n    // Get all existing cache names\n    caches\n      .keys()\n      .then((cacheNames) => {\n        // Delete old caches that don\'t match the current version\n        return Promise.all(\n          cacheNames.map((cacheName) => {\n            // Keep only the current cache, delete everything else\n            if (cacheName !== CACHE_NAME) {\n              console.log("Deleting old cache:", cacheName);\n              return caches.delete(cacheName);\n            }\n            // Return undefined for caches we want to keep\n          })\n        );\n      })\n      .then(() => {\n        // Take control of all clients (open tabs/windows)\n        // Without this, the SW only controls pages opened after activation\n        return self.clients.claim();\n      })\n  );\n});\n\n// FETCH EVENT - Triggered for every network request made by the app\n// This is where you implement your caching strategy\nself.addEventListener("fetch", (event) => {\n  // Intercept the request and provide a custom response\n  event.respondWith(\n    // First, check if we have this request in our cache\n    caches\n      .match(event.request)\n      .then((response) => {\n        // If found in cache, return it; otherwise fetch from network\n        // This implements a "cache-first" strategy\n        return response || fetch(event.request);\n      })\n      .catch(() => {\n        // If both cache and network fail (offline + not cached)\n        // Show the offline page for HTML document requests\n        if (event.request.destination === "document") {\n          return caches.match("/offline.html");\n        }\n        // For other resources (images, CSS, JS), just let the request fail\n        // The browser will handle this gracefully\n      })\n  );\n});\n'})}),"\n",(0,r.jsx)(n.h2,{id:"service-worker-lifecycle",children:"Service Worker Lifecycle"}),"\n",(0,r.jsx)(n.h3,{id:"lifecycle-states-and-transitions",children:"Lifecycle States and Transitions"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What this ServiceWorkerManager does:"})," Provides a comprehensive system for managing Service Worker lifecycle events, updates, and user notifications."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key lifecycle states:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Installing:"})," Service Worker is downloading and setting up"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Installed:"})," Installation complete, waiting to activate"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Activating:"})," Taking control of the application"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Activated:"})," Fully operational and controlling network requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Redundant:"})," Replaced by a newer version"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Features implemented:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatic update detection"}),"\n",(0,r.jsx)(n.li,{children:"User-friendly update notifications"}),"\n",(0,r.jsx)(n.li,{children:"Periodic update checks"}),"\n",(0,r.jsx)(n.li,{children:"Graceful handling of Service Worker state transitions"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Input:"})," Service Worker registration and lifecycle events\n",(0,r.jsx)(n.strong,{children:"Output:"})," Managed Service Worker with user-controlled updates"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Monitor service worker lifecycle with a comprehensive management class\nclass ServiceWorkerManager {\n  constructor() {\n    this.registration = null; // Stores the SW registration object\n    this.isUpdateAvailable = false; // Flag to track update availability\n    this.setupServiceWorker(); // Initialize immediately\n  }\n\n  // Main setup method - handles feature detection and registration\n  async setupServiceWorker() {\n    // Feature detection - graceful degradation for unsupported browsers\n    if (!("serviceWorker" in navigator)) {\n      console.log("Service Workers not supported");\n      return;\n    }\n\n    try {\n      // Register the Service Worker and store the registration\n      this.registration = await navigator.serviceWorker.register("/sw.js");\n      console.log("Service Worker registered successfully");\n\n      // Start monitoring lifecycle events\n      this.monitorLifecycle();\n    } catch (error) {\n      // Handle registration failures (network issues, invalid SW file, etc.)\n      console.error("SW registration failed:", error);\n    }\n  }\n\n  // Set up all lifecycle event listeners\n  monitorLifecycle() {\n    // Monitor for new Service Worker installations (updates)\n    this.registration.addEventListener("updatefound", () => {\n      console.log("New Service Worker version detected");\n      const newWorker = this.registration.installing;\n      this.trackWorkerState(newWorker, "Installing");\n    });\n\n    // Monitor when the active Service Worker changes\n    navigator.serviceWorker.addEventListener("controllerchange", () => {\n      console.log("Controller changed - page refresh recommended");\n      this.handleControllerChange();\n    });\n\n    // Periodically check for updates (production apps might do this less frequently)\n    setInterval(() => {\n      console.log("Checking for Service Worker updates...");\n      this.registration.update();\n    }, 60000); // Check every minute (adjust based on your update frequency needs)\n  }\n\n  // Track state changes for a specific Service Worker instance\n  trackWorkerState(worker, phase) {\n    worker.addEventListener("statechange", () => {\n      console.log(`${phase} worker state:`, worker.state);\n\n      switch (worker.state) {\n        case "installed":\n          // Service Worker is installed and ready\n          if (navigator.serviceWorker.controller) {\n            // There\'s already an active SW, so this is an update\n            this.isUpdateAvailable = true;\n            this.notifyUpdateAvailable();\n          } else {\n            // First installation - no previous SW\n            console.log("Content cached for offline use");\n          }\n          break;\n\n        case "activated":\n          // Service Worker is now controlling the page\n          console.log("Service Worker activated and controlling pages");\n          this.isUpdateAvailable = false;\n          break;\n\n        case "redundant":\n          // Service Worker has been replaced or failed\n          console.log("Service Worker became redundant");\n          break;\n      }\n    });\n  }\n\n  // Notify the application that an update is available\n  notifyUpdateAvailable() {\n    console.log("Dispatching update available event");\n    const event = new CustomEvent("sw-update-available", {\n      detail: {\n        registration: this.registration,\n        hasWaitingWorker: !!this.registration.waiting,\n      },\n    });\n    window.dispatchEvent(event);\n  }\n\n  // Handle when the Service Worker controller changes\n  handleControllerChange() {\n    // Reload the page to ensure users get the latest version\n    // In production, you might want to show a notification instead\n    console.log("Reloading page due to Service Worker update");\n    window.location.reload();\n  }\n\n  // Force the waiting Service Worker to become active\n  async forceUpdate() {\n    if (this.registration.waiting) {\n      console.log("Forcing Service Worker update");\n      // Send message to the waiting SW to skip waiting phase\n      this.registration.waiting.postMessage({ type: "SKIP_WAITING" });\n    } else {\n      console.log("No waiting Service Worker found");\n    }\n  }\n}\n\n// Initialize the Service Worker manager\n// This should be done early in your application startup\nconst swManager = new ServiceWorkerManager();\n\n// Listen for update notifications and prompt user\nwindow.addEventListener("sw-update-available", (event) => {\n  console.log("Update available event received", event.detail);\n\n  // Show user-friendly update prompt\n  const userConfirmed = confirm(\n    "A new version of the application is available. " +\n      "Would you like to update now? (Recommended for the best experience)"\n  );\n\n  if (userConfirmed) {\n    // User wants to update - force the new Service Worker to activate\n    swManager.forceUpdate();\n  } else {\n    // User declined - they\'ll get the update next time they visit\n    console.log("User declined update - will apply on next visit");\n  }\n});\n'})}),"\n",(0,r.jsx)(n.h2,{id:"under-the-hood-how-service-workers-work",children:"Under the Hood: How Service Workers Work"}),"\n",(0,r.jsx)(n.h3,{id:"browser-architecture-with-service-workers",children:"Browser Architecture with Service Workers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Browser Process                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Main Thread              \u2502      Service Worker Thread  \u2502\n\u2502  \u251c\u2500\u2500\u2500 DOM/Rendering       \u2502      \u251c\u2500\u2500\u2500 Network Proxy     \u2502\n\u2502  \u251c\u2500\u2500\u2500 JavaScript Engine   \u2502      \u251c\u2500\u2500\u2500 Cache Management  \u2502\n\u2502  \u251c\u2500\u2500\u2500 Event Loop         \u2502      \u251c\u2500\u2500\u2500 Push Notifications \u2502\n\u2502  \u2514\u2500\u2500\u2500 User Interactions   \u2502      \u2514\u2500\u2500\u2500 Background Tasks  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502              Network Layer                              \u2502\n\u2502         (All requests pass through SW)                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"service-worker-global-scope",children:"Service Worker Global Scope"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Service Worker runs in ServiceWorkerGlobalScope\nconsole.log(self); // ServiceWorkerGlobalScope\nconsole.log(self.caches); // CacheStorage interface\nconsole.log(self.clients); // Clients interface\n\n// Available APIs in Service Worker context\nconst availableAPIs = {\n  // Network APIs\n  fetch: typeof fetch !== "undefined",\n  XMLHttpRequest: typeof XMLHttpRequest !== "undefined",\n\n  // Storage APIs\n  caches: typeof caches !== "undefined",\n  indexedDB: typeof indexedDB !== "undefined",\n\n  // Messaging APIs\n  postMessage: typeof self.postMessage !== "undefined",\n  BroadcastChannel: typeof BroadcastChannel !== "undefined",\n\n  // Notification APIs\n  Notification: typeof Notification !== "undefined",\n  showNotification: typeof self.registration?.showNotification !== "undefined",\n\n  // Not available in Service Workers\n  localStorage: typeof localStorage !== "undefined", // false\n  sessionStorage: typeof sessionStorage !== "undefined", // false\n  document: typeof document !== "undefined", // false\n  window: typeof window !== "undefined", // false\n};\n\nconsole.log("Available APIs:", availableAPIs);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"caching-strategies",children:"Caching Strategies"}),"\n",(0,r.jsx)(n.h3,{id:"cache-first-strategy",children:"Cache-First Strategy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What this strategy does:"})," Prioritizes cached content for fast loading, falling back to network only when necessary."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Best use cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Static assets (images, fonts, CSS, JavaScript)"}),"\n",(0,r.jsx)(n.li,{children:"Resources that don't change frequently"}),"\n",(0,r.jsx)(n.li,{children:"When performance and speed are more important than freshness"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Flow:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Check cache first"}),"\n",(0,r.jsx)(n.li,{children:"If found, return immediately (fastest response)"}),"\n",(0,r.jsx)(n.li,{children:"If not found, fetch from network"}),"\n",(0,r.jsx)(n.li,{children:"Cache the network response for future use"}),"\n",(0,r.jsx)(n.li,{children:"Return the network response"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros:"})," Very fast for cached resources, works offline\n",(0,r.jsx)(n.strong,{children:"Cons:"})," May serve stale content"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Cache-First Strategy Implementation\n// Best for static assets like images, fonts, and CSS files\nself.addEventListener("fetch", (event) => {\n  // Apply cache-first strategy specifically to image requests\n  if (event.request.destination === "image") {\n    event.respondWith(\n      // Step 1: Check if the request is already in cache\n      caches.match(event.request).then((cachedResponse) => {\n        // Step 2: If found in cache, return immediately (fastest path)\n        if (cachedResponse) {\n          console.log("Serving from cache:", event.request.url);\n          return cachedResponse;\n        }\n\n        // Step 3: Not in cache, fetch from network\n        console.log("Not in cache, fetching from network:", event.request.url);\n        return fetch(event.request).then((networkResponse) => {\n          // Step 4: Cache the new response for future requests\n          // Important: Clone the response because it can only be consumed once\n          const responseClone = networkResponse.clone();\n\n          // Cache asynchronously (don\'t block the response)\n          caches.open(CACHE_NAME).then((cache) => {\n            console.log("Caching new resource:", event.request.url);\n            cache.put(event.request, responseClone);\n          });\n\n          // Step 5: Return the fresh network response\n          return networkResponse;\n        });\n      })\n    );\n  }\n});\n'})}),"\n",(0,r.jsx)(n.h3,{id:"network-first-strategy",children:"Network-First Strategy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What this strategy does:"})," Always tries to fetch fresh content from the network first, using cache as a fallback when offline."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Best use cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"API calls and dynamic data"}),"\n",(0,r.jsx)(n.li,{children:"Content that changes frequently"}),"\n",(0,r.jsx)(n.li,{children:"When data freshness is critical"}),"\n",(0,r.jsx)(n.li,{children:"Social media feeds, news articles, user-generated content"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Flow:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Try network request first"}),"\n",(0,r.jsx)(n.li,{children:"If successful, update cache with fresh data"}),"\n",(0,r.jsx)(n.li,{children:"Return the fresh network response"}),"\n",(0,r.jsx)(n.li,{children:"If network fails, fall back to cached version"}),"\n",(0,r.jsx)(n.li,{children:"If no cache either, request fails gracefully"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros:"})," Always tries to serve fresh content\n",(0,r.jsx)(n.strong,{children:"Cons:"})," Slower when network is slow, requires network for first load"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Network-First Strategy Implementation\n// Best for API calls and dynamic content that changes frequently\nself.addEventListener("fetch", (event) => {\n  // Apply network-first strategy to API calls\n  if (event.request.url.includes("/api/")) {\n    event.respondWith(\n      // Step 1: Always try network first for fresh data\n      fetch(event.request)\n        .then((networkResponse) => {\n          console.log("Network request successful:", event.request.url);\n\n          // Step 2: Update cache with the fresh response\n          // Clone because response body can only be read once\n          const responseClone = networkResponse.clone();\n\n          // Update cache asynchronously (don\'t block the response)\n          caches\n            .open(CACHE_NAME)\n            .then((cache) => {\n              console.log("Updating cache with fresh data:", event.request.url);\n              cache.put(event.request, responseClone);\n            })\n            .catch((cacheError) => {\n              // Handle cache update failures gracefully\n              console.warn("Failed to update cache:", cacheError);\n            });\n\n          // Step 3: Return the fresh network response\n          return networkResponse;\n        })\n        .catch((networkError) => {\n          // Step 4: Network failed (offline, server error, etc.)\n          console.log(\n            "Network failed, trying cache:",\n            event.request.url,\n            networkError\n          );\n\n          // Step 5: Try to serve from cache as fallback\n          return caches.match(event.request).then((cachedResponse) => {\n            if (cachedResponse) {\n              console.log("Serving stale data from cache:", event.request.url);\n              return cachedResponse;\n            } else {\n              // No cache available either - let the request fail\n              console.error("No cache available for:", event.request.url);\n              throw networkError;\n            }\n          });\n        })\n    );\n  }\n});\n'})}),"\n",(0,r.jsx)(n.h3,{id:"stale-while-revalidate-strategy",children:"Stale-While-Revalidate Strategy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What this strategy does:"})," Serves cached content immediately for speed, while updating the cache in the background for next time."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Best use cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"HTML pages and documents"}),"\n",(0,r.jsx)(n.li,{children:"Content where slight staleness is acceptable"}),"\n",(0,r.jsx)(n.li,{children:"When you want both speed AND freshness"}),"\n",(0,r.jsx)(n.li,{children:"News sites, blogs, product catalogs"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Flow:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Check cache first"}),"\n",(0,r.jsx)(n.li,{children:"If found, return cached version immediately (fast response)"}),"\n",(0,r.jsx)(n.li,{children:"Simultaneously fetch from network in background"}),"\n",(0,r.jsx)(n.li,{children:"Update cache with fresh content for next visit"}),"\n",(0,r.jsx)(n.li,{children:"If no cache, wait for network response"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros:"})," Fast responses + fresh content on next visit\n",(0,r.jsx)(n.strong,{children:"Cons:"})," Users might see outdated content briefly"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Stale-While-Revalidate Strategy Implementation\n// Best for HTML documents where slight staleness is acceptable\nself.addEventListener("fetch", (event) => {\n  // Apply stale-while-revalidate strategy to HTML documents\n  if (event.request.destination === "document") {\n    event.respondWith(\n      // Step 1: Check cache for existing content\n      caches.match(event.request).then((cachedResponse) => {\n        // Step 2: Start network request in parallel (don\'t wait for it)\n        const fetchPromise = fetch(event.request)\n          .then((networkResponse) => {\n            // Step 3: Update cache in background with fresh content\n            const responseClone = networkResponse.clone();\n\n            caches\n              .open(CACHE_NAME)\n              .then((cache) => {\n                console.log("Background cache update:", event.request.url);\n                cache.put(event.request, responseClone);\n              })\n              .catch((cacheError) => {\n                console.warn("Background cache update failed:", cacheError);\n              });\n\n            return networkResponse;\n          })\n          .catch((networkError) => {\n            console.log("Background network update failed:", networkError);\n            // Don\'t throw - this is a background update\n            return null;\n          });\n\n        // Step 4: Return cached response immediately if available\n        if (cachedResponse) {\n          console.log(\n            "Serving from cache (updating in background):",\n            event.request.url\n          );\n          return cachedResponse;\n        }\n\n        // Step 5: No cache available, wait for network response\n        console.log("No cache, waiting for network:", event.request.url);\n        return fetchPromise;\n      })\n    );\n  }\n});\n'})}),"\n",(0,r.jsx)(n.h3,{id:"advanced-caching-with-expiration",children:"Advanced Caching with Expiration"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What this CacheManager does:"})," Implements intelligent cache expiration and management to prevent stale data and storage bloat."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key features:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time-based expiration:"})," Automatically expire cached content after a specified time"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom cache headers:"})," Add metadata to track when content was cached"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic cleanup:"})," Remove expired entries to free up storage space"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configurable TTL:"})," Different cache lifetimes for different types of content"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"API responses with time-sensitive data"}),"\n",(0,r.jsx)(n.li,{children:"Dynamic content that needs periodic refresh"}),"\n",(0,r.jsx)(n.li,{children:"Storage-constrained environments"}),"\n",(0,r.jsx)(n.li,{children:"Applications with strict data freshness requirements"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Input:"})," HTTP requests and responses with custom expiration logic\n",(0,r.jsx)(n.strong,{children:"Output:"})," Managed cache with automatic expiration and cleanup"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Advanced Cache Manager with time-based expiration\nclass CacheManager {\n  constructor(cacheName, maxAge = 24 * 60 * 60 * 1000) {\n    // Default to 24 hours cache lifetime\n    this.cacheName = cacheName;\n    this.maxAge = maxAge; // Maximum age in milliseconds\n    console.log(\n      `CacheManager initialized: ${cacheName}, TTL: ${maxAge / 1000}s`\n    );\n  }\n\n  // Retrieve from cache with expiration check\n  async get(request) {\n    try {\n      const cache = await caches.open(this.cacheName);\n      const response = await cache.match(request);\n\n      // No cached response found\n      if (!response) {\n        console.log("Cache miss:", request.url);\n        return null;\n      }\n\n      // Check if the cached response has expired\n      const cachedTime = response.headers.get("sw-cache-time");\n      if (cachedTime) {\n        const age = Date.now() - parseInt(cachedTime);\n\n        if (age > this.maxAge) {\n          console.log(\n            "Cache expired, removing:",\n            request.url,\n            `(age: ${age / 1000}s)`\n          );\n          // Cache expired - remove it and return null\n          await cache.delete(request);\n          return null;\n        }\n\n        console.log("Cache hit (valid):", request.url, `(age: ${age / 1000}s)`);\n      }\n\n      return response;\n    } catch (error) {\n      console.error("Cache get error:", error);\n      return null;\n    }\n  }\n\n  // Store in cache with timestamp header\n  async put(request, response) {\n    try {\n      const cache = await caches.open(this.cacheName);\n\n      // Clone the response because it can only be consumed once\n      const responseClone = response.clone();\n\n      // Add custom timestamp header to track when this was cached\n      const headers = new Headers(responseClone.headers);\n      headers.set("sw-cache-time", Date.now().toString());\n      headers.set("sw-cache-ttl", this.maxAge.toString());\n\n      // Create new response with timestamp headers\n      const responseWithTimestamp = new Response(responseClone.body, {\n        status: responseClone.status,\n        statusText: responseClone.statusText,\n        headers: headers,\n      });\n\n      // Store in cache\n      await cache.put(request, responseWithTimestamp);\n      console.log("Cached with timestamp:", request.url);\n\n      // Return the original response to the caller\n      return response;\n    } catch (error) {\n      console.error("Cache put error:", error);\n      // Return original response even if caching fails\n      return response;\n    }\n  }\n\n  // Clean up expired cache entries\n  async cleanup() {\n    try {\n      console.log("Starting cache cleanup for:", this.cacheName);\n      const cache = await caches.open(this.cacheName);\n      const requests = await cache.keys();\n\n      let deletedCount = 0;\n\n      // Check each cached item for expiration\n      const deletePromises = requests.map(async (request) => {\n        try {\n          const response = await cache.match(request);\n          const cachedTime = response.headers.get("sw-cache-time");\n\n          if (cachedTime) {\n            const age = Date.now() - parseInt(cachedTime);\n\n            if (age > this.maxAge) {\n              console.log("Deleting expired cache entry:", request.url);\n              await cache.delete(request);\n              deletedCount++;\n              return true;\n            }\n          }\n          return false;\n        } catch (error) {\n          console.error("Error checking cache entry:", request.url, error);\n          return false;\n        }\n      });\n\n      await Promise.all(deletePromises);\n      console.log(\n        `Cache cleanup complete. Deleted ${deletedCount} expired entries.`\n      );\n    } catch (error) {\n      console.error("Cache cleanup error:", error);\n    }\n  }\n\n  // Get cache statistics\n  async getStats() {\n    try {\n      const cache = await caches.open(this.cacheName);\n      const requests = await cache.keys();\n\n      let totalSize = 0;\n      let expiredCount = 0;\n\n      for (const request of requests) {\n        const response = await cache.match(request);\n        const blob = await response.blob();\n        totalSize += blob.size;\n\n        const cachedTime = response.headers.get("sw-cache-time");\n        if (cachedTime && Date.now() - parseInt(cachedTime) > this.maxAge) {\n          expiredCount++;\n        }\n      }\n\n      return {\n        name: this.cacheName,\n        entryCount: requests.length,\n        expiredCount,\n        totalSizeBytes: totalSize,\n        totalSizeMB: (totalSize / (1024 * 1024)).toFixed(2),\n      };\n    } catch (error) {\n      console.error("Error getting cache stats:", error);\n      return null;\n    }\n  }\n}\n\n// Usage in service worker with different TTLs for different content types\nconst apiCacheManager = new CacheManager("api-cache-v1", 30 * 60 * 1000); // 30 minutes for API\nconst imageCacheManager = new CacheManager(\n  "image-cache-v1",\n  7 * 24 * 60 * 60 * 1000\n); // 7 days for images\n\nself.addEventListener("fetch", (event) => {\n  const { request } = event;\n\n  // Handle API requests with short cache TTL\n  if (request.url.includes("/api/")) {\n    event.respondWith(\n      apiCacheManager.get(request).then((cachedResponse) => {\n        if (cachedResponse) {\n          console.log("Serving API response from cache");\n          return cachedResponse;\n        }\n\n        // Not in cache or expired, fetch from network\n        console.log("Fetching API response from network");\n        return fetch(request).then((networkResponse) => {\n          // Cache the response and return it\n          return apiCacheManager.put(request, networkResponse);\n        });\n      })\n    );\n  }\n\n  // Handle image requests with long cache TTL\n  else if (request.destination === "image") {\n    event.respondWith(\n      imageCacheManager.get(request).then((cachedResponse) => {\n        if (cachedResponse) {\n          return cachedResponse;\n        }\n\n        return fetch(request).then((networkResponse) => {\n          return imageCacheManager.put(request, networkResponse);\n        });\n      })\n    );\n  }\n});\n\n// Handle cleanup messages from the main thread\nself.addEventListener("message", (event) => {\n  const { data } = event;\n\n  switch (data.type) {\n    case "CLEANUP_CACHE":\n      console.log("Manual cache cleanup requested");\n      Promise.all([apiCacheManager.cleanup(), imageCacheManager.cleanup()]);\n      break;\n\n    case "GET_CACHE_STATS":\n      Promise.all([\n        apiCacheManager.getStats(),\n        imageCacheManager.getStats(),\n      ]).then((stats) => {\n        // Send stats back to main thread\n        event.ports[0].postMessage({ type: "CACHE_STATS", stats });\n      });\n      break;\n  }\n});\n\n// Automatic cleanup every hour\nsetInterval(() => {\n  console.log("Running scheduled cache cleanup");\n  apiCacheManager.cleanup();\n  imageCacheManager.cleanup();\n}, 60 * 60 * 1000); // Every hour\n'})}),"\n",(0,r.jsx)(n.h2,{id:"offline-functionality",children:"Offline Functionality"}),"\n",(0,r.jsx)(n.h3,{id:"comprehensive-offline-strategy",children:"Comprehensive Offline Strategy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What this offline strategy does:"})," Provides a robust offline experience by handling different resource types with appropriate fallback mechanisms."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Resource-specific strategies:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Documents (HTML):"})," Network-first with offline page fallback"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Images:"})," Cache-first with placeholder image fallback"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Other resources:"})," Network-first with cache fallback"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Offline experience features:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Custom offline page for when users lose connectivity"}),"\n",(0,r.jsx)(n.li,{children:"Placeholder images for missing resources"}),"\n",(0,r.jsx)(n.li,{children:"Graceful degradation for different content types"}),"\n",(0,r.jsx)(n.li,{children:"Intelligent caching based on resource characteristics"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Input:"})," Various types of network requests (documents, images, API calls, etc.)\n",(0,r.jsx)(n.strong,{children:"Output:"})," Appropriate responses with offline fallbacks for each resource type"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Define fallback resources for offline scenarios\nconst OFFLINE_PAGE = "/offline.html"; // Custom offline page\nconst FALLBACK_IMAGE = "/images/offline-image.png"; // Placeholder for missing images\nconst CACHE_NAME = "offline-cache-v1";\n\n// Main fetch event handler with resource-type routing\nself.addEventListener("fetch", (event) => {\n  const { request } = event;\n\n  console.log("Handling request:", request.url, "Type:", request.destination);\n\n  // Route different resource types to appropriate handlers\n  if (request.destination === "document") {\n    // HTML pages - prioritize fresh content but provide offline fallback\n    event.respondWith(handleDocumentRequest(request));\n  } else if (request.destination === "image") {\n    // Images - prioritize cache for performance, provide placeholder fallback\n    event.respondWith(handleImageRequest(request));\n  } else {\n    // CSS, JS, fonts, and other resources\n    event.respondWith(handleOtherRequests(request));\n  }\n});\n\n// Handle HTML document requests with network-first strategy\nasync function handleDocumentRequest(request) {\n  console.log("Handling document request:", request.url);\n\n  try {\n    // Step 1: Try network first for fresh content\n    console.log("Attempting network request for document");\n    const networkResponse = await fetch(request);\n\n    // Step 2: Cache successful responses for offline access\n    if (networkResponse.ok) {\n      console.log("Caching successful document response");\n      const cache = await caches.open(CACHE_NAME);\n      // Clone because response can only be consumed once\n      cache.put(request, networkResponse.clone());\n    }\n\n    return networkResponse;\n  } catch (error) {\n    console.log("Network failed for document, trying cache:", error.message);\n\n    // Step 3: Network failed, try cache\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      console.log("Serving cached document");\n      return cachedResponse;\n    }\n\n    // Step 4: No cache available, show offline page\n    console.log("No cache available, serving offline page");\n    const offlinePage = await caches.match(OFFLINE_PAGE);\n\n    if (offlinePage) {\n      return offlinePage;\n    } else {\n      // Fallback if offline page isn\'t cached\n      return new Response(\n        `<html><body><h1>Offline</h1><p>You are offline and this page is not cached.</p></body></html>`,\n        {\n          headers: { "Content-Type": "text/html" },\n          status: 503,\n          statusText: "Service Unavailable",\n        }\n      );\n    }\n  }\n}\n\n// Handle image requests with cache-first strategy\nasync function handleImageRequest(request) {\n  console.log("Handling image request:", request.url);\n\n  try {\n    // Step 1: Try cache first for images (performance optimization)\n    console.log("Checking cache for image");\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      console.log("Serving cached image");\n      return cachedResponse;\n    }\n\n    // Step 2: Not in cache, try network\n    console.log("Image not cached, fetching from network");\n    const networkResponse = await fetch(request);\n\n    // Step 3: Cache the image for future use\n    if (networkResponse.ok) {\n      console.log("Caching new image");\n      const cache = await caches.open(CACHE_NAME);\n      cache.put(request, networkResponse.clone());\n    }\n\n    return networkResponse;\n  } catch (error) {\n    console.log("Image request failed, serving fallback:", error.message);\n\n    // Step 4: Both cache and network failed, return fallback image\n    const fallbackImage = await caches.match(FALLBACK_IMAGE);\n\n    if (fallbackImage) {\n      return fallbackImage;\n    } else {\n      // Create a simple SVG placeholder if fallback image isn\'t available\n      const svgFallback = `\n        <svg width="300" height="200" xmlns="http://www.w3.org/2000/svg">\n          <rect width="100%" height="100%" fill="#f0f0f0"/>\n          <text x="50%" y="50%" font-family="Arial, sans-serif" font-size="14" \n                fill="#666" text-anchor="middle" dy=".3em">\n            Image not available offline\n          </text>\n        </svg>`;\n\n      return new Response(svgFallback, {\n        headers: {\n          "Content-Type": "image/svg+xml",\n          "Cache-Control": "no-cache",\n        },\n      });\n    }\n  }\n}\n\n// Handle other resource requests (CSS, JS, fonts, etc.)\nasync function handleOtherRequests(request) {\n  console.log(\n    "Handling other resource:",\n    request.url,\n    "Type:",\n    request.destination\n  );\n\n  try {\n    // Step 1: Try network first for most resources\n    console.log("Attempting network request");\n    const networkResponse = await fetch(request);\n\n    // Step 2: Cache successful responses\n    if (networkResponse.ok) {\n      const cache = await caches.open(CACHE_NAME);\n      cache.put(request, networkResponse.clone());\n    }\n\n    return networkResponse;\n  } catch (error) {\n    console.log("Network failed for resource, trying cache:", error.message);\n\n    // Step 3: Network failed, try cache\n    const cachedResponse = await caches.match(request);\n\n    if (cachedResponse) {\n      console.log("Serving cached resource");\n      return cachedResponse;\n    } else {\n      console.log("Resource not available offline:", request.url);\n\n      // For CSS files, return empty stylesheet to prevent broken styles\n      if (request.destination === "style" || request.url.includes(".css")) {\n        return new Response("/* Stylesheet not available offline */", {\n          headers: { "Content-Type": "text/css" },\n        });\n      }\n\n      // For JavaScript files, return empty script\n      if (request.destination === "script" || request.url.includes(".js")) {\n        return new Response("// Script not available offline", {\n          headers: { "Content-Type": "application/javascript" },\n        });\n      }\n\n      // For other resources, let the request fail\n      throw error;\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"push-notifications-and-background-sync",children:"Push Notifications and Background Sync"}),"\n",(0,r.jsx)(n.h3,{id:"push-notification-implementation",children:"Push Notification Implementation"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What this push notification system does:"})," Handles incoming push messages from a server and displays rich, interactive notifications to users."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key components:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Push event handler:"})," Receives messages from push service and creates notifications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Notification click handler:"})," Manages user interactions with notifications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rich notification options:"})," Icons, images, action buttons, and custom data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Window management:"})," Intelligently handles app focus and window opening"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notification flow:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Server sends push message to browser's push service"}),"\n",(0,r.jsx)(n.li,{children:"Browser delivers message to Service Worker"}),"\n",(0,r.jsx)(n.li,{children:"Service Worker creates and displays notification"}),"\n",(0,r.jsx)(n.li,{children:"User interacts with notification"}),"\n",(0,r.jsx)(n.li,{children:"Service Worker handles the interaction (open app, perform action, etc.)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Input:"})," Push messages from server with notification payload\n",(0,r.jsx)(n.strong,{children:"Output:"})," Rich, interactive notifications with proper click handling"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// PUSH EVENT HANDLER - Receives push messages and displays notifications\nself.addEventListener("push", (event) => {\n  console.log("Push message received", event);\n\n  // Extract notification data from push message\n  let notificationData = {};\n\n  if (event.data) {\n    try {\n      // Parse JSON payload from push service\n      notificationData = event.data.json();\n      console.log("Push data:", notificationData);\n    } catch (error) {\n      console.error("Failed to parse push data:", error);\n      // Use text data as fallback\n      notificationData = { body: event.data.text() };\n    }\n  } else {\n    console.log("Push message has no data");\n  }\n\n  // Configure notification options with fallbacks\n  const options = {\n    // Basic notification content\n    title: notificationData.title || "New Notification",\n    body: notificationData.body || "You have a new message",\n\n    // Visual elements\n    icon: notificationData.icon || "/images/icon-192x192.png", // App icon\n    badge: notificationData.badge || "/images/badge-72x72.png", // Small monochrome icon\n    image: notificationData.image, // Large image (optional)\n\n    // Custom data to pass to click handler\n    data: {\n      url: notificationData.url || "/", // URL to open when clicked\n      timestamp: Date.now(),\n      ...notificationData.data, // Additional custom data\n    },\n\n    // Action buttons (max 2 on most platforms)\n    actions: notificationData.actions || [\n      {\n        action: "view", // Unique identifier\n        title: "View", // Button text\n        icon: "/images/view-icon.png", // Button icon (optional)\n      },\n      {\n        action: "dismiss",\n        title: "Dismiss",\n        icon: "/images/dismiss-icon.png",\n      },\n    ],\n\n    // Behavior options\n    requireInteraction: notificationData.requireInteraction || false, // Stay visible until interaction\n    silent: notificationData.silent || false, // No sound/vibration\n    renotify: false, // Don\'t replace existing notifications with same tag\n    tag: notificationData.tag || "default", // Group related notifications\n\n    // Additional options\n    dir: "auto", // Text direction\n    lang: "en-US", // Language\n    vibrate: notificationData.vibrate || [200, 100, 200], // Vibration pattern\n  };\n\n  // Display the notification\n  // event.waitUntil ensures the Service Worker stays alive until notification is shown\n  event.waitUntil(\n    self.registration\n      .showNotification(options.title, options)\n      .then(() => {\n        console.log("Notification displayed successfully");\n      })\n      .catch((error) => {\n        console.error("Failed to show notification:", error);\n      })\n  );\n});\n\n// NOTIFICATION CLICK HANDLER - Manages user interactions with notifications\nself.addEventListener("notificationclick", (event) => {\n  console.log(\n    "Notification clicked:",\n    event.notification.title,\n    "Action:",\n    event.action\n  );\n\n  // Close the notification\n  event.notification.close();\n\n  // Handle different actions\n  if (event.action === "view") {\n    // User clicked "View" action button\n    console.log("Opening specific URL from notification data");\n    const targetUrl = event.notification.data?.url || "/";\n\n    event.waitUntil(\n      clients\n        .openWindow(targetUrl)\n        .then((windowClient) => {\n          if (windowClient) {\n            console.log("Opened new window:", targetUrl);\n          } else {\n            console.log("Failed to open window (popup blocked?)");\n          }\n        })\n        .catch((error) => {\n          console.error("Error opening window:", error);\n        })\n    );\n  } else if (event.action === "dismiss") {\n    // User clicked "Dismiss" action button\n    console.log("Notification dismissed by user");\n\n    // Optional: Send analytics or perform cleanup\n    // Example: track dismissal event\n    // sendAnalytics(\'notification_dismissed\', event.notification.data);\n\n    return; // Just close notification, no other action needed\n  } else {\n    // Default action - user clicked notification body (not an action button)\n    console.log("Default notification click - finding or opening app window");\n\n    event.waitUntil(\n      // First, try to find an existing window to focus\n      clients\n        .matchAll({\n          type: "window",\n          includeUncontrolled: true, // Include windows not controlled by this SW\n        })\n        .then((clientList) => {\n          console.log(`Found ${clientList.length} existing windows`);\n\n          // Look for an existing window from our app\n          for (const client of clientList) {\n            if (\n              client.url.includes(self.location.origin) &&\n              "focus" in client\n            ) {\n              console.log("Focusing existing window:", client.url);\n              return client.focus();\n            }\n          }\n\n          // No existing window found, open new one\n          console.log("No existing window found, opening new one");\n          const targetUrl = event.notification.data?.url || "/";\n          return clients.openWindow(targetUrl);\n        })\n        .then((windowClient) => {\n          if (windowClient) {\n            console.log("Successfully handled notification click");\n\n            // Optional: Send message to the opened/focused window\n            windowClient.postMessage({\n              type: "NOTIFICATION_CLICKED",\n              data: event.notification.data,\n            });\n          }\n        })\n        .catch((error) => {\n          console.error("Error handling notification click:", error);\n        })\n    );\n  }\n});\n\n// NOTIFICATION CLOSE HANDLER - Track when notifications are closed\nself.addEventListener("notificationclose", (event) => {\n  console.log("Notification closed:", event.notification.title);\n\n  // Optional: Track notification close events for analytics\n  // This helps understand user engagement with notifications\n  const notificationData = {\n    title: event.notification.title,\n    tag: event.notification.tag,\n    timestamp: Date.now(),\n  };\n\n  // Example: Send to analytics service\n  // sendAnalytics(\'notification_closed\', notificationData);\n});\n'})}),"\n",(0,r.jsx)(n.h3,{id:"background-sync",children:"Background Sync"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What Background Sync does:"})," Ensures reliable data synchronization by retrying failed network requests when connectivity is restored."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key benefits:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reliable data delivery:"})," Guarantees important data reaches the server eventually"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Offline resilience:"})," Handles network failures gracefully"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Battery efficient:"})," Browser optimizes sync timing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"User-friendly:"})," No manual retry needed"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Form submissions"}),"\n",(0,r.jsx)(n.li,{children:"Chat messages"}),"\n",(0,r.jsx)(n.li,{children:"Analytics events"}),"\n",(0,r.jsx)(n.li,{children:"User-generated content"}),"\n",(0,r.jsx)(n.li,{children:"Critical API calls"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Background Sync flow:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"App attempts network request while offline"}),"\n",(0,r.jsx)(n.li,{children:"Request fails, data is stored locally (IndexedDB)"}),"\n",(0,r.jsx)(n.li,{children:"Service Worker registers a sync event"}),"\n",(0,r.jsx)(n.li,{children:"When connectivity returns, browser triggers sync event"}),"\n",(0,r.jsx)(n.li,{children:"Service Worker processes pending data"}),"\n",(0,r.jsx)(n.li,{children:"Successfully synced data is removed from local storage"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Input:"})," Failed network requests and their data\n",(0,r.jsx)(n.strong,{children:"Output:"})," Reliable delivery of data when connectivity is available"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// BACKGROUND SYNC EVENT HANDLER\n// Triggered by the browser when connectivity is restored\nself.addEventListener("sync", (event) => {\n  console.log("Sync event triggered, tag:", event.tag);\n\n  // Handle different types of sync operations\n  switch (event.tag) {\n    case "background-sync":\n      // General purpose background sync\n      event.waitUntil(doBackgroundSync());\n      break;\n\n    case "chat-messages":\n      // Specific sync for chat messages\n      event.waitUntil(syncChatMessages());\n      break;\n\n    case "user-actions":\n      // Sync user interactions (likes, shares, etc.)\n      event.waitUntil(syncUserActions());\n      break;\n\n    default:\n      console.log("Unknown sync tag:", event.tag);\n  }\n});\n\n// Main background sync function\nasync function doBackgroundSync() {\n  console.log("Starting background sync process");\n\n  try {\n    // Step 1: Get all pending data from local storage (IndexedDB)\n    const pendingData = await getPendingData();\n    console.log(`Found ${pendingData.length} pending sync items`);\n\n    if (pendingData.length === 0) {\n      console.log("No pending data to sync");\n      return;\n    }\n\n    // Step 2: Process each pending item\n    let successCount = 0;\n    let failureCount = 0;\n\n    for (const item of pendingData) {\n      try {\n        console.log(`Syncing item ${item.id}:`, item.type);\n\n        // Step 3: Attempt to send data to server\n        const response = await fetch(item.endpoint || "/api/sync", {\n          method: item.method || "POST",\n          body: JSON.stringify(item.data),\n          headers: {\n            "Content-Type": "application/json",\n            "X-Sync-Item-ID": item.id,\n            "X-Sync-Timestamp": item.timestamp.toString(),\n            ...item.headers, // Additional headers from original request\n          },\n        });\n\n        if (response.ok) {\n          // Step 4: Success - remove from pending queue\n          console.log(`Successfully synced item ${item.id}`);\n          await removePendingData(item.id);\n          successCount++;\n\n          // Optional: Store sync result for app to use\n          await storeSyncResult(item.id, {\n            success: true,\n            timestamp: Date.now(),\n            response: await response.json(),\n          });\n        } else {\n          // Server error - keep in queue for retry\n          console.log(\n            `Server error for item ${item.id}:`,\n            response.status,\n            response.statusText\n          );\n          failureCount++;\n\n          // Update retry count and timestamp\n          await updatePendingItem(item.id, {\n            retryCount: (item.retryCount || 0) + 1,\n            lastAttempt: Date.now(),\n            lastError: `HTTP ${response.status}: ${response.statusText}`,\n          });\n        }\n      } catch (networkError) {\n        // Network error - keep in queue for retry\n        console.log(`Network error for item ${item.id}:`, networkError.message);\n        failureCount++;\n\n        await updatePendingItem(item.id, {\n          retryCount: (item.retryCount || 0) + 1,\n          lastAttempt: Date.now(),\n          lastError: networkError.message,\n        });\n      }\n    }\n\n    console.log(\n      `Background sync complete. Success: ${successCount}, Failed: ${failureCount}`\n    );\n\n    // Step 5: Notify the app about sync results\n    await notifyAppOfSyncResults({\n      totalItems: pendingData.length,\n      successCount,\n      failureCount,\n      timestamp: Date.now(),\n    });\n  } catch (error) {\n    console.error("Background sync process failed:", error);\n\n    // Re-register sync for retry if the entire process failed\n    await self.registration.sync.register("background-sync");\n  }\n}\n\n// Specialized sync function for chat messages\nasync function syncChatMessages() {\n  console.log("Syncing chat messages");\n\n  try {\n    const pendingMessages = await getPendingDataByType("chat-message");\n\n    for (const message of pendingMessages) {\n      const response = await fetch("/api/chat/send", {\n        method: "POST",\n        body: JSON.stringify({\n          text: message.text,\n          timestamp: message.timestamp,\n          roomId: message.roomId,\n        }),\n        headers: {\n          "Content-Type": "application/json",\n          Authorization: `Bearer ${message.token}`,\n        },\n      });\n\n      if (response.ok) {\n        await removePendingData(message.id);\n        console.log("Chat message synced:", message.id);\n      }\n    }\n  } catch (error) {\n    console.error("Chat message sync failed:", error);\n  }\n}\n\n// Notify the application about sync results\nasync function notifyAppOfSyncResults(results) {\n  try {\n    // Send message to all open windows/tabs\n    const clients = await self.clients.matchAll({\n      includeUncontrolled: true,\n      type: "window",\n    });\n\n    clients.forEach((client) => {\n      client.postMessage({\n        type: "BACKGROUND_SYNC_COMPLETE",\n        results: results,\n      });\n    });\n\n    console.log("Notified", clients.length, "clients about sync results");\n  } catch (error) {\n    console.error("Failed to notify app of sync results:", error);\n  }\n}\n\n// Helper functions for IndexedDB operations\n// Note: These would typically be imported from a separate module\n\nasync function getPendingData() {\n  // Implementation would use IndexedDB to retrieve all pending sync items\n  // Example structure:\n  return [\n    {\n      id: "sync-item-1",\n      type: "user-action",\n      endpoint: "/api/users/action",\n      method: "POST",\n      data: { action: "like", postId: "123" },\n      timestamp: Date.now() - 60000,\n      retryCount: 0,\n    },\n    // ... more items\n  ];\n}\n\nasync function removePendingData(itemId) {\n  // Remove successfully synced item from IndexedDB\n  console.log("Removing synced item from storage:", itemId);\n}\n\nasync function updatePendingItem(itemId, updates) {\n  // Update retry count and error info for failed items\n  console.log("Updating pending item:", itemId, updates);\n}\n\nasync function storeSyncResult(itemId, result) {\n  // Store sync results for the app to access\n  console.log("Storing sync result:", itemId, result);\n}\n\nasync function getPendingDataByType(type) {\n  // Get pending items of a specific type\n  const allPending = await getPendingData();\n  return allPending.filter((item) => item.type === type);\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-patterns-and-best-practices",children:"Advanced Patterns and Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"service-worker-update-pattern",children:"Service Worker Update Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Handle service worker updates gracefully\nself.addEventListener("message", (event) => {\n  if (event.data.type === "SKIP_WAITING") {\n    self.skipWaiting();\n  }\n});\n\n// In main application\nclass ServiceWorkerUpdateManager {\n  constructor() {\n    this.refreshing = false;\n    this.setupUpdateHandling();\n  }\n\n  setupUpdateHandling() {\n    navigator.serviceWorker.addEventListener("controllerchange", () => {\n      if (this.refreshing) return;\n      this.refreshing = true;\n      window.location.reload();\n    });\n  }\n\n  async checkForUpdates() {\n    const registration = await navigator.serviceWorker.ready;\n    registration.update();\n  }\n\n  async promptUpdate() {\n    const registration = await navigator.serviceWorker.ready;\n\n    if (registration.waiting) {\n      const userWantsUpdate = confirm(\n        "A new version is available. Would you like to update?"\n      );\n\n      if (userWantsUpdate) {\n        registration.waiting.postMessage({ type: "SKIP_WAITING" });\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"resource-versioning-strategy",children:"Resource Versioning Strategy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const CACHE_VERSION = "v2.1.0";\nconst STATIC_CACHE = `static-${CACHE_VERSION}`;\nconst DYNAMIC_CACHE = `dynamic-${CACHE_VERSION}`;\n\nconst STATIC_FILES = [\n  "/",\n  "/styles/main.css",\n  "/scripts/main.js",\n  "/images/logo.png",\n  "/manifest.json",\n];\n\nself.addEventListener("install", (event) => {\n  event.waitUntil(\n    Promise.all([\n      caches.open(STATIC_CACHE).then((cache) => cache.addAll(STATIC_FILES)),\n      caches.open(DYNAMIC_CACHE), // Create dynamic cache\n    ])\n  );\n});\n\nself.addEventListener("activate", (event) => {\n  event.waitUntil(\n    caches.keys().then((cacheNames) => {\n      return Promise.all(\n        cacheNames.map((cacheName) => {\n          if (\n            !cacheName.includes(CACHE_VERSION) &&\n            (cacheName.startsWith("static-") ||\n              cacheName.startsWith("dynamic-"))\n          ) {\n            console.log("Deleting old cache:", cacheName);\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n'})}),"\n",(0,r.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"secure-service-worker-implementation",children:"Secure Service Worker Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Validate requests in service worker\nself.addEventListener("fetch", (event) => {\n  // Only handle same-origin requests\n  if (!event.request.url.startsWith(self.location.origin)) {\n    return;\n  }\n\n  // Validate request method\n  if (!["GET", "POST", "PUT", "DELETE"].includes(event.request.method)) {\n    return;\n  }\n\n  // Handle different request types securely\n  if (event.request.url.includes("/api/")) {\n    event.respondWith(handleAPIRequest(event.request));\n  } else {\n    event.respondWith(handleStaticRequest(event.request));\n  }\n});\n\nasync function handleAPIRequest(request) {\n  // Don\'t cache sensitive API requests\n  if (request.url.includes("/auth/") || request.url.includes("/user/")) {\n    return fetch(request);\n  }\n\n  // Use network-first for API requests\n  try {\n    const response = await fetch(request);\n\n    // Only cache successful responses\n    if (response.ok) {\n      const cache = await caches.open(DYNAMIC_CACHE);\n      cache.put(request, response.clone());\n    }\n\n    return response;\n  } catch (error) {\n    return caches.match(request);\n  }\n}\n\n// Content Security Policy headers\nself.addEventListener("fetch", (event) => {\n  if (event.request.destination === "document") {\n    event.respondWith(\n      fetch(event.request).then((response) => {\n        // Add security headers\n        const headers = new Headers(response.headers);\n        headers.set(\n          "Content-Security-Policy",\n          "default-src \'self\'; script-src \'self\' \'unsafe-eval\'; style-src \'self\' \'unsafe-inline\'"\n        );\n        headers.set("X-Frame-Options", "DENY");\n        headers.set("X-Content-Type-Options", "nosniff");\n\n        return new Response(response.body, {\n          status: response.status,\n          statusText: response.statusText,\n          headers: headers,\n        });\n      })\n    );\n  }\n});\n'})}),"\n",(0,r.jsx)(n.h2,{id:"debugging-and-development",children:"Debugging and Development"}),"\n",(0,r.jsx)(n.h3,{id:"service-worker-debugging-tools",children:"Service Worker Debugging Tools"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Development utilities\nclass ServiceWorkerDebugger {\n  static logCacheContents() {\n    caches.keys().then((cacheNames) => {\n      console.group("Cache Contents");\n\n      cacheNames.forEach((cacheName) => {\n        caches.open(cacheName).then((cache) => {\n          cache.keys().then((requests) => {\n            console.group(cacheName);\n            requests.forEach((request) => {\n              console.log(request.url);\n            });\n            console.groupEnd();\n          });\n        });\n      });\n\n      console.groupEnd();\n    });\n  }\n\n  static clearAllCaches() {\n    return caches.keys().then((cacheNames) => {\n      return Promise.all(\n        cacheNames.map((cacheName) => {\n          console.log("Deleting cache:", cacheName);\n          return caches.delete(cacheName);\n        })\n      );\n    });\n  }\n\n  static async getCacheSize() {\n    const cacheNames = await caches.keys();\n    let totalSize = 0;\n\n    for (const cacheName of cacheNames) {\n      const cache = await caches.open(cacheName);\n      const requests = await cache.keys();\n\n      for (const request of requests) {\n        const response = await cache.match(request);\n        const blob = await response.blob();\n        totalSize += blob.size;\n      }\n    }\n\n    return totalSize;\n  }\n}\n\n// Expose debugging tools in development\nif (self.location.hostname === "localhost") {\n  self.debug = ServiceWorkerDebugger;\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"real-world-implementation",children:"Real-World Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"complete-pwa-service-worker",children:"Complete PWA Service Worker"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"What this production-ready Service Worker does:"})," Implements a comprehensive caching strategy suitable for real-world Progressive Web Apps."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Production features implemented:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Version-based cache management:"})," Automatic cleanup of old cache versions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resource-specific strategies:"})," Different caching approaches for different content types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Offline resilience:"})," Graceful handling of network failures"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance optimization:"})," Strategic precaching of critical resources"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error handling:"})," Robust error recovery and fallback mechanisms"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Architecture overview:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"App Shell Pattern:"})," Critical resources cached during installation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Runtime Caching:"})," Dynamic content cached as needed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Offline First:"})," Local content served first when available"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Network Resilience:"})," Fallbacks for every type of failure"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Input:"})," All application network requests\n",(0,r.jsx)(n.strong,{children:"Output:"})," Fast, reliable responses with offline capability"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// CONFIGURATION - Update version to trigger cache updates\nconst APP_VERSION = "1.0.0";\nconst CACHE_NAME = `pwa-cache-${APP_VERSION}`; // Static resources cache\nconst API_CACHE = `api-cache-${APP_VERSION}`; // API responses cache\nconst RUNTIME_CACHE = `runtime-cache-${APP_VERSION}`; // Dynamic resources cache\n\n// PRECACHE URLS - Critical resources for offline functionality (App Shell)\nconst PRECACHE_URLS = [\n  "/", // Home page\n  "/index.html", // Main HTML file\n  "/styles/app.css", // Critical CSS\n  "/scripts/app.js", // Core JavaScript\n  "/images/icon-192.png", // App icon\n  "/manifest.json", // PWA manifest\n  "/offline.html", // Offline fallback page\n  // Add other critical resources your app needs to work offline\n];\n\n// INSTALL EVENT - Cache critical resources (App Shell)\nself.addEventListener("install", (event) => {\n  console.log(`Service Worker ${APP_VERSION} installing...`);\n\n  event.waitUntil(\n    // Open the static cache and precache all critical resources\n    caches\n      .open(CACHE_NAME)\n      .then((cache) => {\n        console.log("Precaching app shell resources");\n        return cache.addAll(PRECACHE_URLS);\n      })\n      .then(() => {\n        console.log("App shell cached successfully");\n        // Skip waiting to activate immediately (optional - be careful in production)\n        return self.skipWaiting();\n      })\n      .catch((error) => {\n        console.error("Failed to precache app shell:", error);\n        throw error;\n      })\n  );\n});\n\n// ACTIVATE EVENT - Clean up old caches and take control\nself.addEventListener("activate", (event) => {\n  console.log(`Service Worker ${APP_VERSION} activating...`);\n\n  event.waitUntil(\n    Promise.all([\n      // Step 1: Clean up old cache versions\n      caches.keys().then((cacheNames) => {\n        console.log("Existing caches:", cacheNames);\n\n        return Promise.all(\n          cacheNames.map((cacheName) => {\n            // Delete caches that don\'t match current version\n            if (\n              cacheName !== CACHE_NAME &&\n              cacheName !== API_CACHE &&\n              cacheName !== RUNTIME_CACHE\n            ) {\n              console.log("Deleting old cache:", cacheName);\n              return caches.delete(cacheName);\n            }\n          })\n        );\n      }),\n\n      // Step 2: Take control of all clients immediately\n      self.clients.claim().then(() => {\n        console.log("Service Worker now controlling all pages");\n      }),\n    ])\n  );\n});\n\n// FETCH EVENT - Main request handler with intelligent routing\nself.addEventListener("fetch", (event) => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n  // Skip non-GET requests for caching\n  if (request.method !== "GET") {\n    return;\n  }\n\n  // Skip cross-origin requests (unless specifically configured)\n  if (url.origin !== self.location.origin) {\n    return;\n  }\n\n  console.log("Handling request:", url.pathname, "Type:", request.destination);\n\n  // Route to appropriate handler based on request type\n  if (url.pathname.startsWith("/api/")) {\n    // API requests - network-first with cache fallback\n    event.respondWith(handleAPIRequest(request));\n  } else if (request.destination === "document") {\n    // HTML pages - network-first with offline fallback\n    event.respondWith(handleDocumentRequest(request));\n  } else {\n    // Static resources - cache-first with network fallback\n    event.respondWith(handleResourceRequest(request));\n  }\n});\n\n// API REQUEST HANDLER - Network-first strategy for dynamic data\nasync function handleAPIRequest(request) {\n  console.log("Handling API request:", request.url);\n  const cache = await caches.open(API_CACHE);\n\n  try {\n    // Step 1: Try network first for fresh data\n    const response = await fetch(request);\n    console.log("API network response:", response.status);\n\n    // Step 2: Cache successful responses\n    if (response.ok) {\n      // Clone response for caching (response can only be consumed once)\n      const responseClone = response.clone();\n\n      // Add timestamp header for cache management\n      const headers = new Headers(responseClone.headers);\n      headers.set("sw-cached-at", Date.now().toString());\n\n      const timestampedResponse = new Response(responseClone.body, {\n        status: responseClone.status,\n        statusText: responseClone.statusText,\n        headers: headers,\n      });\n\n      cache.put(request, timestampedResponse);\n      console.log("API response cached");\n    }\n\n    return response;\n  } catch (error) {\n    // Step 3: Network failed, try cache\n    console.log("API network failed, trying cache:", error.message);\n    const cachedResponse = await cache.match(request);\n\n    if (cachedResponse) {\n      console.log("Serving stale API data from cache");\n      return cachedResponse;\n    } else {\n      // No cache available, return error response\n      console.log("No API cache available");\n      return new Response(\n        JSON.stringify({\n          error: "Offline",\n          message: "This feature requires an internet connection",\n        }),\n        {\n          status: 503,\n          statusText: "Service Unavailable",\n          headers: { "Content-Type": "application/json" },\n        }\n      );\n    }\n  }\n}\n\n// DOCUMENT REQUEST HANDLER - Network-first for HTML pages\nasync function handleDocumentRequest(request) {\n  console.log("Handling document request:", request.url);\n\n  try {\n    // Step 1: Try network first for fresh content\n    const response = await fetch(request);\n    console.log("Document network response:", response.status);\n\n    // Step 2: Cache successful HTML responses\n    if (response.ok) {\n      const cache = await caches.open(RUNTIME_CACHE);\n      cache.put(request, response.clone());\n      console.log("Document cached");\n    }\n\n    return response;\n  } catch (error) {\n    // Step 3: Network failed, try cache\n    console.log("Document network failed, trying cache:", error.message);\n\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      console.log("Serving cached document");\n      return cachedResponse;\n    }\n\n    // Step 4: No cache, serve offline page\n    console.log("No document cache, serving offline page");\n    return caches.match("/offline.html");\n  }\n}\n\n// RESOURCE REQUEST HANDLER - Cache-first for static assets\nasync function handleResourceRequest(request) {\n  console.log(\n    "Handling resource request:",\n    request.url,\n    "Type:",\n    request.destination\n  );\n\n  // Step 1: Try cache first for performance\n  const cachedResponse = await caches.match(request);\n\n  if (cachedResponse) {\n    console.log("Serving resource from cache:", request.url);\n    return cachedResponse;\n  }\n\n  try {\n    // Step 2: Not in cache, fetch from network\n    console.log("Resource not cached, fetching from network");\n    const response = await fetch(request);\n\n    // Step 3: Cache successful responses\n    if (response.ok) {\n      const cache = await caches.open(RUNTIME_CACHE);\n      console.log("Caching new resource:", request.url);\n      cache.put(request, response.clone());\n    }\n\n    return response;\n  } catch (error) {\n    console.log("Resource network failed:", error.message);\n\n    // Step 4: Provide appropriate fallbacks\n    if (request.destination === "image") {\n      // Return fallback image\n      const fallbackImage = await caches.match("/images/fallback.png");\n      if (fallbackImage) {\n        return fallbackImage;\n      }\n    }\n\n    // For other resources, let the request fail\n    throw error;\n  }\n}\n\n// ERROR HANDLING - Global error handler\nself.addEventListener("error", (event) => {\n  console.error("Service Worker error:", event.error);\n});\n\nself.addEventListener("unhandledrejection", (event) => {\n  console.error("Service Worker unhandled promise rejection:", event.reason);\n});\n\n// MESSAGING - Handle messages from main thread\nself.addEventListener("message", (event) => {\n  const { data } = event;\n\n  switch (data.type) {\n    case "GET_VERSION":\n      event.ports[0].postMessage({ version: APP_VERSION });\n      break;\n\n    case "CLEAR_CACHE":\n      caches\n        .keys()\n        .then((cacheNames) => {\n          return Promise.all(\n            cacheNames.map((cacheName) => caches.delete(cacheName))\n          );\n        })\n        .then(() => {\n          event.ports[0].postMessage({ success: true });\n        });\n      break;\n\n    case "SKIP_WAITING":\n      self.skipWaiting();\n      break;\n  }\n});\n\nconsole.log(`Service Worker ${APP_VERSION} loaded and ready`);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"cache-management-best-practices",children:"Cache Management Best Practices"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Efficient cache management\nclass OptimizedCacheManager {\n  constructor() {\n    this.maxCacheSize = 50 * 1024 * 1024; // 50MB\n    this.maxCacheAge = 7 * 24 * 60 * 60 * 1000; // 7 days\n  }\n\n  async maintainCache() {\n    await this.removeExpiredEntries();\n    await this.enforcesCacheLimit();\n  }\n\n  async removeExpiredEntries() {\n    const cacheNames = await caches.keys();\n\n    for (const cacheName of cacheNames) {\n      const cache = await caches.open(cacheName);\n      const requests = await cache.keys();\n\n      for (const request of requests) {\n        const response = await cache.match(request);\n        const dateHeader = response.headers.get("date");\n\n        if (dateHeader) {\n          const age = Date.now() - new Date(dateHeader).getTime();\n          if (age > this.maxCacheAge) {\n            await cache.delete(request);\n          }\n        }\n      }\n    }\n  }\n\n  async enforcesCacheLimit() {\n    const totalSize = await this.calculateCacheSize();\n\n    if (totalSize > this.maxCacheSize) {\n      await this.removeOldestEntries(totalSize - this.maxCacheSize);\n    }\n  }\n\n  async calculateCacheSize() {\n    // Implementation for calculating total cache size\n    const cacheNames = await caches.keys();\n    let totalSize = 0;\n\n    for (const cacheName of cacheNames) {\n      const cache = await caches.open(cacheName);\n      const requests = await cache.keys();\n\n      for (const request of requests) {\n        const response = await cache.match(request);\n        const blob = await response.blob();\n        totalSize += blob.size;\n      }\n    }\n\n    return totalSize;\n  }\n}\n\n// Run cache maintenance periodically\nconst cacheManager = new OptimizedCacheManager();\nsetInterval(() => {\n  cacheManager.maintainCache();\n}, 24 * 60 * 60 * 1000); // Daily\n'})}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"Service Workers are a fundamental technology for building modern web applications that provide native-like experiences. They enable powerful features like offline functionality, push notifications, and background synchronization while maintaining security and performance."}),"\n",(0,r.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lifecycle Management"}),": Understanding the install, activate, and fetch phases is crucial for effective Service Worker implementation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Caching Strategies"}),": Different caching strategies (cache-first, network-first, stale-while-revalidate) serve different use cases and performance requirements."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Security First"}),": Service Workers require HTTPS and careful consideration of security implications, including proper scope management and input validation."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Progressive Enhancement"}),": Service Workers should enhance the user experience without breaking functionality for unsupported browsers."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Performance Impact"}),": While Service Workers can significantly improve performance through caching, they require careful management to avoid bloating storage and degrading performance."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-service-workers",children:"When to Use Service Workers"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Building Progressive Web Apps (PWAs)"}),"\n",(0,r.jsx)(n.li,{children:"Implementing offline functionality"}),"\n",(0,r.jsx)(n.li,{children:"Optimizing resource loading and caching"}),"\n",(0,r.jsx)(n.li,{children:"Adding push notification capabilities"}),"\n",(0,r.jsx)(n.li,{children:"Performing background data synchronization"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["As detailed in the ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API",children:"MDN Service Worker API documentation"}),", Service Workers represent a paradigm shift toward more resilient, performant web applications that can compete with native mobile apps in terms of user experience and reliability."]}),"\n",(0,r.jsx)(n.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API",children:"MDN Service Worker API Documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://developers.google.com/web/fundamentals/primers/service-workers",children:"Google Developers - Service Worker Guide"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://w3c.github.io/ServiceWorker/",children:"Service Worker Specification"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://developers.google.com/web/tools/workbox",children:"Workbox - Production-ready Service Worker Libraries"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);