"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3914],{3550:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"project-detail/single-spa","title":"Single-SPA: Microfrontend Framework","description":"Table of Contents","source":"@site/docs/project-detail/single-spa.md","sourceDirName":"project-detail","slug":"/project-detail/single-spa","permalink":"/frontend-system-design/docs/project-detail/single-spa","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/single-spa.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Recharts: React Data Visualization Library","permalink":"/frontend-system-design/docs/project-detail/recharts"},"next":{"title":"Simple Interpreter: Building a Vietnamese Programming Language","permalink":"/frontend-system-design/docs/project-detail/simple-interpreter"}}');var a=t(4848),r=t(8453);const i={},s="Single-SPA: Microfrontend Framework",l={},c=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Benefits",id:"key-benefits",level:3},{value:"Getting Started",id:"getting-started",level:2},{value:"Installation and Setup",id:"installation-and-setup",level:3},{value:"Basic Root Config Setup",id:"basic-root-config-setup",level:3},{value:"HTML Setup with Import Maps",id:"html-setup-with-import-maps",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Applications vs Parcels",id:"applications-vs-parcels",level:3},{value:"Creating a React Microfrontend",id:"creating-a-react-microfrontend",level:3},{value:"Under the Hood: How Single-SPA Works",id:"under-the-hood-how-single-spa-works",level:2},{value:"Application Registration and Routing",id:"application-registration-and-routing",level:3},{value:"Application Lifecycle",id:"application-lifecycle",level:2},{value:"Lifecycle Functions",id:"lifecycle-functions",level:3},{value:"Inter-App Communication",id:"inter-app-communication",level:2},{value:"1. Custom Events",id:"1-custom-events",level:3},{value:"2. Shared State Management",id:"2-shared-state-management",level:3},{value:"3. Parcel Communication",id:"3-parcel-communication",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Application Structure",id:"1-application-structure",level:3},{value:"2. Error Boundaries and Resilience",id:"2-error-boundaries-and-resilience",level:3},{value:"3. Performance Optimization",id:"3-performance-optimization",level:3},{value:"4. Development vs Production Configuration",id:"4-development-vs-production-configuration",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Module Federation Integration",id:"module-federation-integration",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Further Resources",id:"further-resources",level:3}];function p(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"single-spa-microfrontend-framework",children:"Single-SPA: Microfrontend Framework"})}),"\n",(0,a.jsx)(e.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#getting-started",children:"Getting Started"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#core-concepts",children:"Core Concepts"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#under-the-hood-how-single-spa-works",children:"Under the Hood: How Single-SPA Works"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#application-lifecycle",children:"Application Lifecycle"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#inter-app-communication",children:"Inter-App Communication"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#advanced-patterns",children:"Advanced Patterns"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(e.p,{children:["Single-SPA is a JavaScript framework for building microfrontends that allows multiple JavaScript applications to coexist and be written with their own frameworks. As highlighted in the ",(0,a.jsx)(e.a,{href:"https://github.com/single-spa/single-spa",children:"Single-SPA GitHub repository"}),", it enables you to use multiple frameworks on the same page, write new code without rewriting existing apps, and lazy load code for improved performance."]}),"\n",(0,a.jsx)(e.h3,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Framework Agnostic"}),": Mix React, Angular, Vue, or any framework"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Independent Deployment"}),": Deploy microfrontends separately"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Lazy Loading"}),": Load applications on demand"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Legacy Integration"}),": Gradually migrate existing applications"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Team Autonomy"}),": Different teams can work independently"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,a.jsx)(e.h3,{id:"installation-and-setup",children:"Installation and Setup"}),"\n",(0,a.jsx)(e.p,{children:"This section demonstrates how to set up Single-SPA from scratch. The CLI provides scaffolding for different types of modules in the microfrontend ecosystem."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Sets up the Single-SPA development environment and creates different types of modules\n",(0,a.jsx)(e.strong,{children:"Input"}),": Command line instructions\n",(0,a.jsx)(e.strong,{children:"Output"}),": Generated project structures for root config, applications, and utility modules"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"# Step 1: Install Single-SPA CLI globally for project scaffolding\nnpm install --global create-single-spa\n\n# Step 2: Create a new root config (orchestrates all microfrontends)\nnpx create-single-spa --moduleType root-config\n\n# Step 3: Create a microfrontend application (individual app that can be mounted/unmounted)\nnpx create-single-spa --moduleType app-parcel\n\n# Step 4: Create a utility module (shared code between microfrontends)\nnpx create-single-spa --moduleType util-module\n"})}),"\n",(0,a.jsx)(e.h3,{id:"basic-root-config-setup",children:"Basic Root Config Setup"}),"\n",(0,a.jsx)(e.p,{children:"The root config is the central orchestrator that manages when and how microfrontends are loaded. It defines which applications should be active based on the current URL and handles the lifecycle of mounting and unmounting applications."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Registers multiple microfrontend applications with their loading strategies and activation conditions\n",(0,a.jsx)(e.strong,{children:"Input"}),": Application configurations with names, loading functions, and activation rules\n",(0,a.jsx)(e.strong,{children:"Output"}),": A configured Single-SPA instance that manages application lifecycles based on routing\n",(0,a.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Import Single-SPA core functions"}),"\n",(0,a.jsx)(e.li,{children:"Register each microfrontend with its activation condition"}),"\n",(0,a.jsx)(e.li,{children:"Start the Single-SPA router"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// src/root-config.js\nimport { registerApplication, start } from "single-spa";\n\n// Register applications with their routing logic\n\n// Navbar: Always visible across all routes\nregisterApplication({\n  name: "navbar", // Unique identifier for this microfrontend\n  app: () => import("@org/navbar"), // Lazy loading function that returns the application\n  activeWhen: () => true, // Always mounted - navbar should be visible everywhere\n});\n\n// Home application: Only active on the root path\nregisterApplication({\n  name: "home-app",\n  app: () => import("@org/home"), // Dynamic import enables code splitting\n  activeWhen: (location) => location.pathname === "/", // Only mount on homepage\n});\n\n// Dashboard application: Active on all dashboard routes\nregisterApplication({\n  name: "dashboard-app",\n  app: () => import("@org/dashboard"),\n  activeWhen: (location) => location.pathname.startsWith("/dashboard"), // Mount on /dashboard/*\n});\n\n// Profile application: Simple string-based routing\nregisterApplication({\n  name: "profile-app",\n  app: () => import("@org/profile"),\n  activeWhen: "/profile", // Shorthand for exact path match\n});\n\n// Start Single-SPA with configuration options\nstart({\n  urlRerouteOnly: true, // Only reroute on URL changes, not on popstate events\n});\n'})}),"\n",(0,a.jsx)(e.h3,{id:"html-setup-with-import-maps",children:"HTML Setup with Import Maps"}),"\n",(0,a.jsx)(e.p,{children:"The HTML file serves as the entry point for the microfrontend application. Import maps provide a way to resolve module specifiers without bundlers, enabling native ES modules to work with friendly names instead of full URLs."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Sets up the HTML structure and module resolution for the Single-SPA application\n",(0,a.jsx)(e.strong,{children:"Input"}),": HTML template with import maps and module loading\n",(0,a.jsx)(e.strong,{children:"Output"}),": A web page that can dynamically load and render microfrontends\n",(0,a.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Define import maps for module resolution"}),"\n",(0,a.jsx)(e.li,{children:"Load the root config as an ES module"}),"\n",(0,a.jsx)(e.li,{children:"Provide DOM containers for applications"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-html",children:'<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <title>Microfrontend Application</title>\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n\n    \x3c!-- Import maps for module resolution - maps friendly names to actual URLs --\x3e\n    <script type="importmap">\n      {\n        "imports": {\n          \x3c!-- Core Single-SPA framework from CDN --\x3e\n          "single-spa": "https://cdn.jsdelivr.net/npm/single-spa@6.0.0/lib/system/single-spa.min.js",\n\n          \x3c!-- Shared dependencies - React ecosystem --\x3e\n          "react": "https://cdn.jsdelivr.net/npm/react@18.2.0/index.js",\n          "react-dom": "https://cdn.jsdelivr.net/npm/react-dom@18.2.0/index.js",\n\n          \x3c!-- Application modules - these will be loaded dynamically --\x3e\n          "@org/root-config": "/root-config.js", \x3c!-- Main orchestrator --\x3e\n          "@org/navbar": "/navbar.js", \x3c!-- Navigation component --\x3e\n          "@org/home": "/home.js", \x3c!-- Home page application --\x3e\n          "@org/dashboard": "/dashboard.js", \x3c!-- Dashboard application --\x3e\n          "@org/profile": "/profile.js" \x3c!-- Profile application --\x3e\n        }\n      }\n    <\/script>\n\n    \x3c!-- Load and execute the root config to start Single-SPA --\x3e\n    <script type="module">\n      import("@org/root-config"); // This starts the entire microfrontend orchestration\n    <\/script>\n  </head>\n  <body>\n    \x3c!-- DOM containers for applications --\x3e\n    <div id="single-spa-application:navbar"></div>\n    \x3c!-- Navbar will mount here --\x3e\n    <div id="main-content"></div>\n    \x3c!-- Other apps will mount here --\x3e\n  </body>\n</html>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,a.jsx)(e.h3,{id:"applications-vs-parcels",children:"Applications vs Parcels"}),"\n",(0,a.jsx)(e.p,{children:"Single-SPA distinguishes between two types of microfrontends: Applications and Parcels. Applications are route-based and automatically managed by Single-SPA's router, while Parcels are manually controlled components that can be mounted anywhere."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Demonstrates the difference between Applications (route-controlled) and Parcels (manually controlled)\n",(0,a.jsx)(e.strong,{children:"Input"}),": Lifecycle methods for both application types\n",(0,a.jsx)(e.strong,{children:"Output"}),": Functional microfrontend components that can be integrated into the Single-SPA ecosystem\n",(0,a.jsx)(e.strong,{children:"Key Differences"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Applications: Automatically mounted/unmounted based on routes"}),"\n",(0,a.jsx)(e.li,{children:"Parcels: Manually controlled, can be used like regular components"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"// Application - Routed by Single-SPA (automatically managed)\nconst Application = {\n  // Initialize the application once when first loaded\n  bootstrap: () => Promise.resolve(),\n\n  // Mount the application when route becomes active\n  mount: (props) => {\n    // Props include: name, singleSpa, mountParcel, and custom props\n    // domElement is automatically provided based on application name\n    return ReactDOM.render(<App {...props} />, props.domElement);\n  },\n\n  // Unmount when route becomes inactive\n  unmount: (props) => {\n    // Clean up all React components and event listeners\n    ReactDOM.unmountComponentAtNode(props.domElement);\n    return Promise.resolve();\n  },\n};\n\n// Parcel - Manually controlled component (like a reusable widget)\nconst Parcel = {\n  // One-time initialization\n  bootstrap: () => Promise.resolve(),\n\n  // Mount the parcel when explicitly requested\n  mount: (props) => {\n    // Props are passed manually when mounting the parcel\n    // domElement must be provided by the parent application\n    return ReactDOM.render(<Widget {...props} />, props.domElement);\n  },\n\n  // Unmount when explicitly requested\n  unmount: (props) => {\n    ReactDOM.unmountComponentAtNode(props.domElement);\n    return Promise.resolve();\n  },\n\n  // Optional: handle prop updates without full remount\n  update: (props) => {\n    // Re-render with new props for better performance\n    return ReactDOM.render(<Widget {...props} />, props.domElement);\n  },\n};\n"})}),"\n",(0,a.jsx)(e.h3,{id:"creating-a-react-microfrontend",children:"Creating a React Microfrontend"}),"\n",(0,a.jsxs)(e.p,{children:["This section shows how to create a React-based microfrontend using the ",(0,a.jsx)(e.code,{children:"single-spa-react"})," helper library. This library automatically generates the required lifecycle methods (bootstrap, mount, unmount) for React applications."]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Creates a React microfrontend with automatic lifecycle management and error handling\n",(0,a.jsx)(e.strong,{children:"Input"}),": React components and configuration\n",(0,a.jsx)(e.strong,{children:"Output"}),": A Single-SPA compatible application with bootstrap, mount, and unmount methods\n",(0,a.jsx)(e.strong,{children:"Steps"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Import required dependencies and the root React component"}),"\n",(0,a.jsx)(e.li,{children:"Configure single-spa-react with error boundary"}),"\n",(0,a.jsx)(e.li,{children:"Export lifecycle methods for Single-SPA"}),"\n",(0,a.jsx)(e.li,{children:"Optionally export component for parcel usage"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// src/app.js - React microfrontend entry point\nimport React from "react";\nimport ReactDOM from "react-dom";\nimport singleSpaReact from "single-spa-react"; // Helper for React integration\nimport RootComponent from "./root.component";\n\n// Generate Single-SPA lifecycle methods automatically\nconst lifecycles = singleSpaReact({\n  React, // React library reference\n  ReactDOM, // ReactDOM for rendering\n  rootComponent: RootComponent, // Main React component to render\n\n  // Error boundary for handling React errors gracefully\n  errorBoundary(err, info, props) {\n    console.error("React microfrontend error:", err, info);\n    // Return fallback UI when component crashes\n    return <div>Something went wrong: {err.message}</div>;\n  },\n});\n\n// Export the generated lifecycle methods for Single-SPA\nexport const { bootstrap, mount, unmount } = lifecycles;\n\n// Optional: export for parcel usage in other microfrontends\nexport const App = RootComponent;\n'})}),"\n",(0,a.jsx)(e.h2,{id:"under-the-hood-how-single-spa-works",children:"Under the Hood: How Single-SPA Works"}),"\n",(0,a.jsx)(e.h3,{id:"application-registration-and-routing",children:"Application Registration and Routing"}),"\n",(0,a.jsx)(e.p,{children:"This section provides a simplified implementation of how Single-SPA works internally. Understanding this helps developers grasp the framework's core concepts: application registration, lifecycle management, and routing logic."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Demonstrates Single-SPA's internal architecture for managing microfrontend lifecycles\n",(0,a.jsx)(e.strong,{children:"Input"}),": Application configurations and browser navigation events\n",(0,a.jsx)(e.strong,{children:"Output"}),": Automatic mounting/unmounting of applications based on current route\n",(0,a.jsx)(e.strong,{children:"Key Components"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Application registry with status tracking"}),"\n",(0,a.jsx)(e.li,{children:"Route-based activation logic"}),"\n",(0,a.jsx)(e.li,{children:"Lifecycle state management"}),"\n",(0,a.jsx)(e.li,{children:"Error handling and recovery"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Simplified Single-SPA implementation concept\nclass SingleSPA {\n  constructor() {\n    this.apps = []; // Registry of all registered applications\n    this.started = false; // Flag to track if Single-SPA has been started\n  }\n\n  // Register a new microfrontend application\n  registerApplication(appConfig) {\n    const app = {\n      name: appConfig.name, // Unique identifier\n      loadApp: appConfig.app, // Function that loads the application\n      activeWhen: appConfig.activeWhen, // Route matching logic\n      customProps: appConfig.customProps || {}, // Props passed to application\n      status: "NOT_LOADED", // Initial lifecycle status\n    };\n\n    this.apps.push(app);\n\n    // If Single-SPA is already started, check if this app should be mounted\n    if (this.started) {\n      this.reroute();\n    }\n  }\n\n  // Start Single-SPA and begin listening for route changes\n  start(opts = {}) {\n    this.started = true;\n    this.urlRerouteOnly = opts.urlRerouteOnly;\n\n    // Listen for browser navigation events\n    window.addEventListener("hashchange", () => this.reroute()); // Hash-based routing\n    window.addEventListener("popstate", () => this.reroute()); // History API navigation\n\n    // Override pushState and replaceState to catch programmatic navigation\n    this.overrideHistoryAPI();\n\n    // Perform initial routing to mount appropriate applications\n    this.reroute();\n  }\n\n  // Core routing logic - determines which apps to mount/unmount\n  async reroute() {\n    const currentLocation = window.location;\n\n    // Find applications that should be active but aren\'t mounted\n    const appsToMount = this.apps.filter(\n      (app) =>\n        this.shouldBeActive(app, currentLocation) && app.status !== "MOUNTED"\n    );\n\n    // Find applications that are mounted but should no longer be active\n    const appsToUnmount = this.apps.filter(\n      (app) =>\n        !this.shouldBeActive(app, currentLocation) && app.status === "MOUNTED"\n    );\n\n    // Unmount inactive apps first to free up resources\n    await Promise.all(appsToUnmount.map((app) => this.unmountApp(app)));\n\n    // Mount newly active apps\n    await Promise.all(appsToMount.map((app) => this.mountApp(app)));\n  }\n\n  // Determine if an application should be active based on current location\n  shouldBeActive(app, location) {\n    if (typeof app.activeWhen === "function") {\n      // Custom function for complex routing logic\n      return app.activeWhen(location);\n    }\n    if (typeof app.activeWhen === "string") {\n      // Simple string matching for path prefixes\n      return location.pathname.startsWith(app.activeWhen);\n    }\n    return false;\n  }\n\n  // Mount an application through its complete lifecycle\n  async mountApp(app) {\n    try {\n      // Step 1: Load the application if not already loaded\n      if (app.status === "NOT_LOADED") {\n        app.status = "LOADING";\n        app.instance = await app.loadApp(); // Dynamic import of the application\n        app.status = "LOADED";\n      }\n\n      // Step 2: Bootstrap the application (one-time initialization)\n      if (app.status === "LOADED") {\n        app.status = "BOOTSTRAPPING";\n        await app.instance.bootstrap(); // Initialize app resources\n        app.status = "NOT_MOUNTED";\n      }\n\n      // Step 3: Mount the application to the DOM\n      if (app.status === "NOT_MOUNTED") {\n        app.status = "MOUNTING";\n        await app.instance.mount({\n          name: app.name, // Application name\n          singleSpa: this, // Reference to Single-SPA instance\n          ...app.customProps, // Custom properties\n        });\n        app.status = "MOUNTED";\n      }\n    } catch (error) {\n      // Mark app as broken to prevent further mount attempts\n      app.status = "SKIP_BECAUSE_BROKEN";\n      console.error(`Failed to mount app ${app.name}:`, error);\n    }\n  }\n\n  // Unmount an application and clean up resources\n  async unmountApp(app) {\n    if (app.status === "MOUNTED") {\n      app.status = "UNMOUNTING";\n      await app.instance.unmount(); // Clean up DOM and event listeners\n      app.status = "NOT_MOUNTED"; // Ready to be mounted again later\n    }\n  }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"application-lifecycle",children:"Application Lifecycle"}),"\n",(0,a.jsx)(e.h3,{id:"lifecycle-functions",children:"Lifecycle Functions"}),"\n",(0,a.jsx)(e.p,{children:"Every Single-SPA application must implement specific lifecycle functions that Single-SPA calls at different stages. These functions control how applications are initialized, mounted to the DOM, unmounted, and optionally updated."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Implements the complete lifecycle for a React-based microfrontend\n",(0,a.jsx)(e.strong,{children:"Input"}),": Props object containing application name, DOM element, and custom properties\n",(0,a.jsx)(e.strong,{children:"Output"}),": Promises that resolve when each lifecycle phase completes\n",(0,a.jsx)(e.strong,{children:"Lifecycle Stages"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Bootstrap"}),": One-time initialization when app is first loaded"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Mount"}),": Render the application to the DOM when route becomes active"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Unmount"}),": Clean up and remove from DOM when route becomes inactive"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Update"}),": (Optional) Handle prop changes without full remount"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Detailed lifecycle implementation for a React microfrontend\nconst MyApp = {\n  // 1. Bootstrap - Initialize app (runs once per browser session)\n  bootstrap: async (props) => {\n    console.log("Bootstrapping app", props.name);\n\n    // One-time setup operations:\n    // - Initialize global state stores\n    // - Setup error boundaries and monitoring\n    // - Configure third-party libraries\n    // - Setup shared resources that persist between mounts\n    await initializeApp();\n\n    return Promise.resolve();\n  },\n\n  // 2. Mount - Render app to DOM (called every time route becomes active)\n  mount: async (props) => {\n    console.log("Mounting app", props.name);\n\n    // Find or create the DOM container for this application\n    // Single-SPA automatically creates elements with id="single-spa-application:{name}"\n    const domElement =\n      props.domElement ||\n      document.getElementById(`single-spa-application:${props.name}`);\n\n    // Create React 18 root for concurrent features\n    const root = ReactDOM.createRoot(domElement);\n\n    // Render the application with all props passed from Single-SPA\n    // Props may include: routing info, shared state, custom data\n    root.render(\n      <App\n        {...props} // All Single-SPA props\n        history={props.history} // Routing history object\n        basename={props.basename} // Base path for routing\n      />\n    );\n\n    // Store React root reference for cleanup during unmount\n    props.reactRoot = root;\n\n    return Promise.resolve();\n  },\n\n  // 3. Unmount - Cleanup and remove from DOM (called when route becomes inactive)\n  unmount: async (props) => {\n    console.log("Unmounting app", props.name);\n\n    // Cleanup React application and free memory\n    if (props.reactRoot) {\n      props.reactRoot.unmount(); // React 18 cleanup\n    }\n\n    // Critical cleanup operations:\n    // - Remove event listeners\n    // - Clear intervals/timeouts\n    // - Cancel pending requests\n    // - Cleanup WebSocket connections\n    // - Remove global state subscriptions\n    cleanup();\n\n    return Promise.resolve();\n  },\n\n  // 4. Update - Handle prop changes (optional, for performance optimization)\n  update: async (props) => {\n    console.log("Updating app", props.name);\n\n    // Re-render with new props without full unmount/mount cycle\n    // Useful for:\n    // - Theme changes\n    // - User preference updates\n    // - Shared state updates\n    if (props.reactRoot) {\n      props.reactRoot.render(<App {...props} />);\n    }\n\n    return Promise.resolve();\n  },\n};\n'})}),"\n",(0,a.jsx)(e.h2,{id:"inter-app-communication",children:"Inter-App Communication"}),"\n",(0,a.jsx)(e.h3,{id:"1-custom-events",children:"1. Custom Events"}),"\n",(0,a.jsx)(e.p,{children:"Custom events provide a decoupled way for microfrontends to communicate without direct dependencies. This pattern uses the browser's native event system to enable pub/sub communication across applications."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Implements a cross-application event bus for microfrontend communication\n",(0,a.jsx)(e.strong,{children:"Input"}),": Event names and data payloads\n",(0,a.jsx)(e.strong,{children:"Output"}),": Dispatched events that any application can listen to\n",(0,a.jsx)(e.strong,{children:"Use Cases"}),": User authentication, theme changes, notifications, shared state updates\n",(0,a.jsx)(e.strong,{children:"Benefits"}),": Loose coupling, framework agnostic, no shared dependencies"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Utility for cross-app communication using browser\'s native event system\nclass EventBus {\n  // Emit an event that any microfrontend can listen to\n  static emit(eventName, data) {\n    // Use CustomEvent to send structured data between apps\n    window.dispatchEvent(new CustomEvent(eventName, { detail: data }));\n  }\n\n  // Listen for events from other microfrontends\n  static on(eventName, callback) {\n    window.addEventListener(eventName, callback);\n\n    // Return cleanup function for proper memory management\n    // This prevents memory leaks when components unmount\n    return () => window.removeEventListener(eventName, callback);\n  }\n}\n\n// Example: Authentication app publishes login events\nconst publishUserLogin = (user) => {\n  // Emit event with user data and metadata\n  EventBus.emit("user:login", {\n    user, // User object with profile info\n    timestamp: Date.now(), // When the login occurred\n    source: "auth-app", // Which app published the event\n  });\n};\n\n// Example: Navigation app subscribes to login events\nconst cleanup = EventBus.on("user:login", (event) => {\n  // Extract data from the event detail\n  const { user, timestamp } = event.detail;\n\n  console.log("User logged in:", user);\n\n  // Update UI based on the login event\n  updateNavbarUser(user);\n  showWelcomeMessage(user.name);\n  updateUserMenuOptions(user.permissions);\n});\n\n// Critical: Always clean up event listeners in unmount\nexport const unmount = () => {\n  cleanup(); // Remove event listener to prevent memory leaks\n  return Promise.resolve();\n};\n'})}),"\n",(0,a.jsx)(e.h3,{id:"2-shared-state-management",children:"2. Shared State Management"}),"\n",(0,a.jsx)(e.p,{children:"Shared state management allows microfrontends to share data through a centralized store. This pattern is useful for maintaining consistent state across applications while avoiding prop drilling through the Single-SPA boundary."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Creates a global state store that multiple microfrontends can read from and write to\n",(0,a.jsx)(e.strong,{children:"Input"}),": State updates from any microfrontend\n",(0,a.jsx)(e.strong,{children:"Output"}),": Synchronized state across all subscribed applications\n",(0,a.jsx)(e.strong,{children:"Use Cases"}),": User authentication state, theme preferences, shopping cart data, notification queues\n",(0,a.jsx)(e.strong,{children:"Pattern"}),": Observer pattern with pub/sub for state synchronization"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// shared-store.js - Global state store for cross-application data sharing\nclass SharedStore {\n  constructor() {\n    // Initialize global application state\n    this.state = {\n      user: null, // Current authenticated user\n      theme: "light", // UI theme preference\n      notifications: [], // Global notification queue\n      shoppingCart: [], // E-commerce cart items\n      permissions: [], // User permissions\n    };\n\n    // Array of callback functions that get notified on state changes\n    this.subscribers = [];\n  }\n\n  // Get current state snapshot (read-only)\n  getState() {\n    return this.state; // Return current state for reading\n  }\n\n  // Update state and notify all subscribers\n  setState(newState) {\n    // Merge new state with existing state (immutable update)\n    this.state = { ...this.state, ...newState };\n\n    // Notify all subscribed microfrontends of the change\n    this.notifySubscribers();\n  }\n\n  // Subscribe to state changes (returns unsubscribe function)\n  subscribe(callback) {\n    this.subscribers.push(callback);\n\n    // Return cleanup function for memory management\n    return () => {\n      this.subscribers = this.subscribers.filter((sub) => sub !== callback);\n    };\n  }\n\n  // Internal method to notify all subscribers of state changes\n  notifySubscribers() {\n    // Call each subscriber with the new state\n    this.subscribers.forEach((callback) => callback(this.state));\n  }\n}\n\n// Create singleton instance on window object to ensure one store per page\n// This pattern ensures the same store instance across all microfrontends\nwindow.__SHARED_STORE__ = window.__SHARED_STORE__ || new SharedStore();\n\nexport default window.__SHARED_STORE__;\n\n// Usage in microfrontends - React component example\nimport sharedStore from "@org/shared-store";\n\n// React component that subscribes to global user state\nconst UserProfile = () => {\n  // Initialize with current user from shared store\n  const [user, setUser] = useState(sharedStore.getState().user);\n\n  useEffect(() => {\n    // Subscribe to state changes when component mounts\n    const unsubscribe = sharedStore.subscribe((state) => {\n      // Update local state when global state changes\n      setUser(state.user);\n    });\n\n    // Cleanup subscription when component unmounts\n    return unsubscribe;\n  }, []);\n\n  return <div>{user ? `Welcome, ${user.name}` : "Please log in"}</div>;\n};\n\n// Update global state from any microfrontend\nconst handleLogin = (userData) => {\n  // This will trigger updates in all subscribed components across all apps\n  sharedStore.setState({\n    user: userData,\n    permissions: userData.permissions,\n  });\n};\n'})}),"\n",(0,a.jsx)(e.h3,{id:"3-parcel-communication",children:"3. Parcel Communication"}),"\n",(0,a.jsx)(e.p,{children:"Parcels are manually controlled microfrontend components that can be mounted anywhere in any application. They're perfect for reusable UI components that need to be shared across different microfrontends."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Creates a reusable modal component that any microfrontend can use\n",(0,a.jsx)(e.strong,{children:"Input"}),": Props including title, content, and callback functions\n",(0,a.jsx)(e.strong,{children:"Output"}),": A mounted modal component that can be controlled programmatically\n",(0,a.jsx)(e.strong,{children:"Use Cases"}),": Shared modals, widgets, notifications, tooltips, confirmation dialogs\n",(0,a.jsx)(e.strong,{children:"Benefits"}),": Reusable across apps, framework agnostic, controlled lifecycle"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Modal parcel that can be used across any microfrontend\nconst ModalParcel = {\n  // One-time initialization\n  bootstrap: () => Promise.resolve(),\n\n  // Mount the modal to a specific DOM element\n  mount: (props) => {\n    // Extract props passed from the parent application\n    const { domElement, title, content, onClose, theme = "light" } = props;\n\n    // Create modal structure with dynamic content\n    const modal = document.createElement("div");\n    modal.className = `modal-overlay modal-overlay--${theme}`;\n\n    // Build modal HTML with provided content\n    modal.innerHTML = `\n      <div class="modal modal--${theme}" role="dialog" aria-modal="true">\n        <div class="modal__header">\n          <h2 class="modal__title">${title}</h2>\n          <button class="modal__close" aria-label="Close modal">&times;</button>\n        </div>\n        <div class="modal__content">${content}</div>\n        <div class="modal__footer">\n          <button class="btn btn--primary close-btn">Close</button>\n        </div>\n      </div>\n    `;\n\n    // Add event listeners for close functionality\n    const closeBtn = modal.querySelector(".close-btn");\n    const closeX = modal.querySelector(".modal__close");\n\n    const handleClose = () => {\n      onClose && onClose(); // Call parent\'s close handler\n    };\n\n    closeBtn.onclick = handleClose;\n    closeX.onclick = handleClose;\n\n    // Close on overlay click\n    modal.onclick = (e) => {\n      if (e.target === modal) handleClose();\n    };\n\n    // Add to DOM and focus for accessibility\n    domElement.appendChild(modal);\n    modal.querySelector(".modal").focus();\n\n    return Promise.resolve();\n  },\n\n  // Cleanup when modal is closed\n  unmount: (props) => {\n    // Remove all content and event listeners\n    props.domElement.innerHTML = "";\n    return Promise.resolve();\n  },\n};\n\n// Usage across different microfrontends\nimport { mountRootParcel } from "single-spa";\n\n// Function to programmatically show a modal from any app\nconst showModal = async (title, content, options = {}) => {\n  // Mount the modal parcel with configuration\n  const parcel = mountRootParcel(ModalParcel, {\n    domElement: document.getElementById("modal-container"), // Global modal container\n    title, // Modal title\n    content, // Modal body content\n    theme: options.theme || "light", // Theme preference\n    onClose: () => {\n      // Cleanup function when modal is closed\n      parcel.unmount();\n      options.onClose && options.onClose(); // Custom close handler\n    },\n  });\n\n  return parcel; // Return parcel reference for manual control\n};\n\n// Example usage in different microfrontends:\n\n// From an e-commerce app:\nconst showProductDetails = (product) => {\n  showModal(\n    product.name,\n    `<img src="${product.image}" alt="${product.name}" />\n     <p>${product.description}</p>\n     <p>Price: $${product.price}</p>`,\n    { theme: "dark" }\n  );\n};\n\n// From a user management app:\nconst showUserProfile = (user) => {\n  showModal(\n    `User: ${user.name}`,\n    `<p>Email: ${user.email}</p>\n     <p>Role: ${user.role}</p>\n     <p>Last Login: ${user.lastLogin}</p>`,\n    {\n      onClose: () => console.log("User profile closed"),\n    }\n  );\n};\n'})}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(e.h3,{id:"1-application-structure",children:"1. Application Structure"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"// Recommended folder structure\n/*\nroot-config/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 index.ejs\n\u2502   \u251c\u2500\u2500 root-config.js\n\u2502   \u2514\u2500\u2500 microfrontend-layout.html\n\nshared-dependencies/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 react.js\n\u2502   \u251c\u2500\u2500 react-dom.js\n\u2502   \u2514\u2500\u2500 shared-utils.js\n\nnavbar/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 app.js\n\u2502   \u251c\u2500\u2500 root.component.js\n\u2502   \u2514\u2500\u2500 navbar.component.js\n\nhome-app/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 app.js\n\u2502   \u251c\u2500\u2500 root.component.js\n\u2502   \u2514\u2500\u2500 components/\n*/\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-error-boundaries-and-resilience",children:"2. Error Boundaries and Resilience"}),"\n",(0,a.jsx)(e.p,{children:"Error handling is crucial in microfrontend architectures to prevent one failing application from breaking the entire system. This pattern implements graceful degradation and fallback mechanisms."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Wraps application registration with error handling and fallback UI\n",(0,a.jsx)(e.strong,{children:"Input"}),": Application configuration with potential loading failures\n",(0,a.jsx)(e.strong,{children:"Output"}),": Either the successfully loaded application or a fallback error UI\n",(0,a.jsx)(e.strong,{children:"Benefits"}),": System resilience, graceful degradation, improved user experience\n",(0,a.jsx)(e.strong,{children:"Error Scenarios"}),": Network failures, JavaScript errors, missing dependencies, server downtime"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Global error handling wrapper for application registration\nconst registerApplicationWithErrorHandling = (config) => {\n  registerApplication({\n    ...config, // Spread original config (name, activeWhen, etc.)\n\n    // Wrap the app loading function with error handling\n    app: async () => {\n      try {\n        // Attempt to load the application normally\n        return await config.app();\n      } catch (error) {\n        // Log the error for debugging and monitoring\n        console.error(`Failed to load ${config.name}:`, error);\n\n        // Send error to monitoring service (optional)\n        if (window.errorReporting) {\n          window.errorReporting.captureException(error, {\n            tags: {\n              microfrontend: config.name,\n              type: "loading_failure",\n            },\n          });\n        }\n\n        // Return a fallback application with basic lifecycle methods\n        return {\n          // No initialization needed for fallback\n          bootstrap: () => Promise.resolve(),\n\n          // Mount fallback UI instead of the failed application\n          mount: (props) => {\n            // Create user-friendly error message\n            props.domElement.innerHTML = `\n              <div class="error-fallback" role="alert">\n                <div class="error-fallback__icon">\u26a0\ufe0f</div>\n                <h3 class="error-fallback__title">Unable to load ${config.name}</h3>\n                <p class="error-fallback__message">\n                  This feature is temporarily unavailable. Please try refreshing the page.\n                </p>\n                <button class="error-fallback__retry" onclick="window.location.reload()">\n                  Refresh Page\n                </button>\n                <details class="error-fallback__details">\n                  <summary>Technical Details</summary>\n                  <pre>${error.message}</pre>\n                </details>\n              </div>\n            `;\n            return Promise.resolve();\n          },\n\n          // Clean up fallback UI\n          unmount: (props) => {\n            props.domElement.innerHTML = "";\n            return Promise.resolve();\n          },\n        };\n      }\n    },\n  });\n};\n\n// Usage with enhanced error handling\nregisterApplicationWithErrorHandling({\n  name: "critical-dashboard",\n  app: () => import("@org/dashboard"),\n  activeWhen: "/dashboard",\n  customProps: {\n    fallbackMessage: "Dashboard temporarily unavailable",\n  },\n});\n'})}),"\n",(0,a.jsx)(e.h3,{id:"3-performance-optimization",children:"3. Performance Optimization"}),"\n",(0,a.jsx)(e.p,{children:"Performance optimization in microfrontends involves strategic loading, preloading, and caching strategies. These techniques reduce perceived load times and improve user experience."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Implements preloading strategies to improve application performance\n",(0,a.jsx)(e.strong,{children:"Input"}),": User interactions and routing patterns\n",(0,a.jsx)(e.strong,{children:"Output"}),": Faster application loading through strategic resource preloading\n",(0,a.jsx)(e.strong,{children:"Techniques"}),": Module preloading, hover-based prefetching, route-based optimization\n",(0,a.jsx)(e.strong,{children:"Benefits"}),": Reduced time to interactive, better perceived performance, improved UX"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Advanced lazy loading with intelligent preloading strategies\n\n// Preload application modules based on user behavior\nconst preloadApp = (appName) => {\n  // Check if already preloaded to avoid duplicate requests\n  if (document.querySelector(`link[href*="${appName}"]`)) {\n    return;\n  }\n\n  // Create modulepreload link for browser optimization\n  const link = document.createElement("link");\n  link.rel = "modulepreload"; // Browser hint for module preloading\n  link.href = `/apps/${appName}.js`; // Path to the application bundle\n  link.crossOrigin = "anonymous"; // CORS handling\n\n  // Add to document head for browser processing\n  document.head.appendChild(link);\n\n  console.log(`Preloading ${appName} for faster navigation`);\n};\n\n// Register application with preloading strategy\nregisterApplication({\n  name: "dashboard",\n  app: () => import("@org/dashboard"), // Lazy load when actually needed\n  activeWhen: "/dashboard",\n});\n\n// Strategy 1: Preload on user intent (hover)\ndocument.addEventListener("DOMContentLoaded", () => {\n  const dashboardLink = document.querySelector(".dashboard-link");\n\n  if (dashboardLink) {\n    // Preload when user hovers (indicates intent to navigate)\n    dashboardLink.addEventListener("mouseenter", () => {\n      preloadApp("dashboard");\n    });\n\n    // Also preload on focus for keyboard navigation\n    dashboardLink.addEventListener("focus", () => {\n      preloadApp("dashboard");\n    });\n  }\n});\n\n// Strategy 2: Preload based on user role/permissions\nconst preloadBasedOnUser = (user) => {\n  // Preload applications the user is likely to access\n  if (user.role === "admin") {\n    preloadApp("admin-panel");\n    preloadApp("user-management");\n  }\n\n  if (user.permissions.includes("analytics")) {\n    preloadApp("analytics-dashboard");\n  }\n};\n\n// Strategy 3: Preload during idle time\nconst preloadDuringIdle = () => {\n  // Use requestIdleCallback for non-critical preloading\n  if ("requestIdleCallback" in window) {\n    requestIdleCallback(() => {\n      // Preload less critical applications during browser idle time\n      preloadApp("settings");\n      preloadApp("help-center");\n    });\n  }\n};\n\n// Strategy 4: Intelligent preloading based on navigation patterns\nclass NavigationPreloader {\n  constructor() {\n    this.navigationHistory = [];\n    this.preloadCache = new Set();\n  }\n\n  // Track user navigation patterns\n  trackNavigation(route) {\n    this.navigationHistory.push({\n      route,\n      timestamp: Date.now(),\n    });\n\n    // Keep only recent history (last 10 navigations)\n    if (this.navigationHistory.length > 10) {\n      this.navigationHistory.shift();\n    }\n\n    // Predict and preload next likely route\n    this.predictAndPreload();\n  }\n\n  // Predict next route based on patterns\n  predictAndPreload() {\n    const recentRoutes = this.navigationHistory.slice(-5);\n\n    // If user visited dashboard -> analytics 3+ times, preload analytics when on dashboard\n    const currentRoute = window.location.pathname;\n\n    if (currentRoute === "/dashboard") {\n      const analyticsPattern = recentRoutes.filter(\n        (nav, index) =>\n          nav.route === "/analytics" &&\n          recentRoutes[index - 1]?.route === "/dashboard"\n      );\n\n      if (analyticsPattern.length >= 2 && !this.preloadCache.has("analytics")) {\n        preloadApp("analytics");\n        this.preloadCache.add("analytics");\n      }\n    }\n  }\n}\n\n// Initialize navigation tracking\nconst navPreloader = new NavigationPreloader();\n\n// Track navigation changes\nwindow.addEventListener("single-spa:routing-event", (event) => {\n  navPreloader.trackNavigation(window.location.pathname);\n});\n'})}),"\n",(0,a.jsx)(e.h3,{id:"4-development-vs-production-configuration",children:"4. Development vs Production Configuration"}),"\n",(0,a.jsx)(e.p,{children:"Different environments require different configuration strategies. This pattern allows seamless switching between local development and production deployments while maintaining the same codebase."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Configures application loading based on the current environment\n",(0,a.jsx)(e.strong,{children:"Input"}),": Environment variables and build configurations\n",(0,a.jsx)(e.strong,{children:"Output"}),": Environment-appropriate application loading strategies\n",(0,a.jsx)(e.strong,{children:"Use Cases"}),": Local development, staging, production, testing environments\n",(0,a.jsx)(e.strong,{children:"Benefits"}),": Unified codebase, environment-specific optimization, easier debugging"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// Environment-based app loading with comprehensive configuration\nconst isLocal = process.env.NODE_ENV === "development";\nconst isStaging = process.env.NODE_ENV === "staging";\nconst isProduction = process.env.NODE_ENV === "production";\n\n// Environment-specific base URLs\nconst getAppUrl = (appName) => {\n  if (isLocal) {\n    // Local development URLs with hot reloading\n    const localPorts = {\n      navbar: 8080,\n      dashboard: 8081,\n      profile: 8082,\n      analytics: 8083,\n    };\n    return `http://localhost:${localPorts[appName]}/${appName}.js`;\n  }\n\n  if (isStaging) {\n    // Staging environment with version hashes for testing\n    return `https://staging-cdn.myapp.com/apps/${appName}.${process.env.BUILD_HASH}.js`;\n  }\n\n  if (isProduction) {\n    // Production CDN with optimized bundles\n    return `https://cdn.myapp.com/apps/${appName}.min.js`;\n  }\n\n  // Fallback for unknown environments\n  return `/apps/${appName}.js`;\n};\n\n// Register applications with environment-aware loading\nregisterApplication({\n  name: "navbar",\n  app: () => import(getAppUrl("navbar")),\n  activeWhen: () => true,\n  customProps: {\n    // Pass environment info to applications\n    environment: process.env.NODE_ENV,\n    apiUrl: process.env.API_BASE_URL,\n    debugMode: isLocal,\n  },\n});\n\nregisterApplication({\n  name: "dashboard",\n  app: () => {\n    // Add development-specific features\n    if (isLocal) {\n      // Enable hot module replacement in development\n      if (module.hot) {\n        module.hot.accept();\n      }\n\n      // Load unminified version for better debugging\n      return import(getAppUrl("dashboard"));\n    }\n\n    // Production optimizations\n    return import(getAppUrl("dashboard"));\n  },\n  activeWhen: "/dashboard",\n  customProps: {\n    // Environment-specific feature flags\n    enableAnalytics: isProduction,\n    enableDebugPanel: isLocal,\n    apiTimeout: isLocal ? 30000 : 10000, // Longer timeout in dev\n  },\n});\n\n// Development-only applications\nif (isLocal) {\n  registerApplication({\n    name: "dev-tools",\n    app: () => import("http://localhost:9000/dev-tools.js"),\n    activeWhen: () => window.location.search.includes("debug=true"),\n    customProps: {\n      showPerformanceMetrics: true,\n      enableStateInspector: true,\n    },\n  });\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,a.jsx)(e.h3,{id:"module-federation-integration",children:"Module Federation Integration"}),"\n",(0,a.jsx)(e.p,{children:"Module Federation enables dynamic code sharing between applications at runtime. When combined with Single-SPA, it provides powerful capabilities for sharing components, libraries, and even entire applications."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"What this code does"}),": Integrates Webpack Module Federation with Single-SPA for dynamic module sharing\n",(0,a.jsx)(e.strong,{children:"Input"}),": Webpack configuration and federated module imports\n",(0,a.jsx)(e.strong,{children:"Output"}),": Applications that can share code and components at runtime\n",(0,a.jsx)(e.strong,{children:"Benefits"}),": Reduced bundle sizes, shared dependencies, runtime code sharing\n",(0,a.jsx)(e.strong,{children:"Use Cases"}),": Shared component libraries, micro-frontends with common dependencies"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'// webpack.config.js for the shell application (host)\nconst ModuleFederationPlugin = require("@module-federation/webpack");\n\nmodule.exports = {\n  mode: "development",\n  devServer: {\n    port: 3000, // Shell application port\n  },\n\n  plugins: [\n    new ModuleFederationPlugin({\n      name: "shell", // Name of this application\n\n      // Define remote applications that this shell can consume\n      remotes: {\n        // Map friendly names to actual federated module URLs\n        navbar: "navbar@http://localhost:3001/remoteEntry.js",\n        dashboard: "dashboard@http://localhost:3002/remoteEntry.js",\n        profile: "profile@http://localhost:3003/remoteEntry.js",\n      },\n\n      // Share dependencies to avoid duplication\n      shared: {\n        react: {\n          singleton: true, // Only one React instance across all apps\n          requiredVersion: "^18.0.0",\n          eager: true, // Load immediately, don\'t wait for async\n        },\n        "react-dom": {\n          singleton: true,\n          requiredVersion: "^18.0.0",\n          eager: true,\n        },\n        "react-router-dom": {\n          singleton: true, // Shared routing\n          requiredVersion: "^6.0.0",\n        },\n        // Share utility libraries\n        lodash: {\n          requiredVersion: "^4.17.0",\n        },\n      },\n    }),\n  ],\n};\n\n// webpack.config.js for a microfrontend (remote)\nmodule.exports = {\n  mode: "development",\n  devServer: {\n    port: 3001, // Navbar application port\n  },\n\n  plugins: [\n    new ModuleFederationPlugin({\n      name: "navbar",\n      filename: "remoteEntry.js", // Entry point for federation\n\n      // Expose components/modules for other applications to consume\n      exposes: {\n        "./App": "./src/App", // Main application\n        "./Navigation": "./src/components/Navigation", // Shared component\n        "./UserMenu": "./src/components/UserMenu", // Reusable widget\n      },\n\n      // Same shared dependencies as shell\n      shared: {\n        react: { singleton: true, requiredVersion: "^18.0.0" },\n        "react-dom": { singleton: true, requiredVersion: "^18.0.0" },\n        "react-router-dom": { singleton: true },\n      },\n    }),\n  ],\n};\n\n// Loading federated modules in Single-SPA with error handling\nregisterApplication({\n  name: "dashboard",\n  app: async () => {\n    try {\n      // Import the federated module\n      const module = await import("dashboard/App");\n\n      // The module might export Single-SPA lifecycle methods directly\n      if (module.bootstrap && module.mount && module.unmount) {\n        return module; // Return the lifecycle methods\n      }\n\n      // Or it might export a React component that needs wrapping\n      const Component = module.default;\n\n      // Wrap React component with Single-SPA lifecycle\n      return singleSpaReact({\n        React,\n        ReactDOM,\n        rootComponent: Component,\n      });\n    } catch (error) {\n      console.error("Failed to load federated dashboard:", error);\n\n      // Return fallback application\n      return {\n        bootstrap: () => Promise.resolve(),\n        mount: (props) => {\n          props.domElement.innerHTML =\n            "<div>Dashboard temporarily unavailable</div>";\n          return Promise.resolve();\n        },\n        unmount: (props) => {\n          props.domElement.innerHTML = "";\n          return Promise.resolve();\n        },\n      };\n    }\n  },\n  activeWhen: "/dashboard",\n});\n\n// Advanced pattern: Dynamically discover and register federated modules\nconst registerFederatedApp = async (remoteName, remoteUrl, routePath) => {\n  try {\n    // Dynamically add remote to Module Federation\n    const remoteContainer = await import(remoteUrl);\n\n    registerApplication({\n      name: remoteName,\n      app: async () => {\n        const module = await remoteContainer.get("./App");\n        return module();\n      },\n      activeWhen: routePath,\n      customProps: {\n        federated: true,\n        remoteUrl: remoteUrl,\n      },\n    });\n  } catch (error) {\n    console.error(`Failed to register federated app ${remoteName}:`, error);\n  }\n};\n\n// Register multiple federated applications\nconst federatedApps = [\n  {\n    name: "analytics",\n    url: "http://localhost:3004/remoteEntry.js",\n    route: "/analytics",\n  },\n  {\n    name: "reports",\n    url: "http://localhost:3005/remoteEntry.js",\n    route: "/reports",\n  },\n];\n\nfederatedApps.forEach((app) => {\n  registerFederatedApp(app.name, app.url, app.route);\n});\n'})}),"\n",(0,a.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(e.p,{children:"Single-SPA provides a powerful foundation for building microfrontend architectures that enable independent development, deployment, and scaling of web applications. By understanding its lifecycle management, communication patterns, and best practices, teams can build maintainable and performant distributed frontend systems."}),"\n",(0,a.jsx)(e.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Application Lifecycle"}),": Proper implementation of bootstrap, mount, and unmount functions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Communication Patterns"}),": Use custom events, shared state, and parcels for inter-app communication"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Error Resilience"}),": Implement proper error boundaries and fallback mechanisms"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Performance"}),": Leverage lazy loading, preloading, and shared dependencies"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Team Independence"}),": Enable autonomous development while maintaining integration"]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:["As referenced in the ",(0,a.jsx)(e.a,{href:"https://github.com/single-spa/single-spa",children:"Single-SPA GitHub repository"}),", the framework continues to evolve with strong community support and comprehensive tooling for modern microfrontend development."]}),"\n",(0,a.jsx)(e.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://single-spa.js.org/",children:"Single-SPA Documentation"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://github.com/single-spa/single-spa",children:"Single-SPA GitHub Repository"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://single-spa.js.org/docs/getting-started-overview",children:"Single-SPA Workshop"})}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(p,{...n})}):p(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>s});var o=t(6540);const a={},r=o.createContext(a);function i(n){const e=o.useContext(r);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:i(n.components),o.createElement(r.Provider,{value:e},n.children)}}}]);