"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8632],{336:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"project-detail/web-socket","title":"WebSockets: Real-Time Communication Under the Hood","description":"Table of Contents","source":"@site/docs/project-detail/web-socket.md","sourceDirName":"project-detail","slug":"/project-detail/web-socket","permalink":"/frontend-system-design/docs/project-detail/web-socket","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/project-detail/web-socket.md","tags":[],"version":"current","frontMatter":{},"sidebar":"projectDetailSidebar","previous":{"title":"Dexie.js and IndexedDB: Under the Hood","permalink":"/frontend-system-design/docs/project-detail/dexie-and-indexed-db"}}');var s=r(4848),o=r(8453);const a={},i="WebSockets: Real-Time Communication Under the Hood",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Key Advantages",id:"key-advantages",level:3},{value:"Common Use Cases",id:"common-use-cases",level:3},{value:"Getting Started with WebSockets",id:"getting-started-with-websockets",level:2},{value:"Basic Client Implementation",id:"basic-client-implementation",level:3},{value:"Enhanced WebSocket Client Class",id:"enhanced-websocket-client-class",level:3},{value:"WebSocket Protocol Deep Dive",id:"websocket-protocol-deep-dive",level:2},{value:"Protocol Overview",id:"protocol-overview",level:3},{value:"HTTP to WebSocket Upgrade Process",id:"http-to-websocket-upgrade-process",level:3},{value:"WebSocket Header Analysis",id:"websocket-header-analysis",level:3},{value:"Connection Establishment and Handshake",id:"connection-establishment-and-handshake",level:2},{value:"Client-Side Connection Process",id:"client-side-connection-process",level:3},{value:"Server-Side Handshake Validation",id:"server-side-handshake-validation",level:3},{value:"Frame Structure and Message Types",id:"frame-structure-and-message-types",level:2},{value:"WebSocket Frame Format",id:"websocket-frame-format",level:3},{value:"Frame Processing Implementation",id:"frame-processing-implementation",level:3},{value:"Connection Management and Lifecycle",id:"connection-management-and-lifecycle",level:2},{value:"Keep-Alive and Heartbeat",id:"keep-alive-and-heartbeat",level:3},{value:"Connection Pool Management",id:"connection-pool-management",level:3},{value:"Server-Side Implementation",id:"server-side-implementation",level:2},{value:"Node.js WebSocket Server",id:"nodejs-websocket-server",level:3},{value:"Real-Time Communication Patterns",id:"real-time-communication-patterns",level:2},{value:"Request-Response Pattern",id:"request-response-pattern",level:3},{value:"Pub/Sub Pattern",id:"pubsub-pattern",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Secure WebSocket Implementation",id:"secure-websocket-implementation",level:3},{value:"Rate Limiting and DDoS Protection",id:"rate-limiting-and-ddos-protection",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Connection Pooling and Load Balancing",id:"connection-pooling-and-load-balancing",level:3},{value:"Message Compression and Batching",id:"message-compression-and-batching",level:3},{value:"Real-World Implementation Examples",id:"real-world-implementation-examples",level:2},{value:"Real-Time Chat Application",id:"real-time-chat-application",level:3},{value:"Error Handling and Debugging",id:"error-handling-and-debugging",level:2},{value:"Comprehensive Error Handling",id:"comprehensive-error-handling",level:3},{value:"WebSocket Debugging Tools",id:"websocket-debugging-tools",level:3},{value:"Best Practices and Common Pitfalls",id:"best-practices-and-common-pitfalls",level:2},{value:"Connection Management Best Practices",id:"connection-management-best-practices",level:3},{value:"Message Handling Best Practices",id:"message-handling-best-practices",level:3},{value:"Performance Optimization Tips",id:"performance-optimization-tips",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Future Considerations",id:"future-considerations",level:3},{value:"Further Resources",id:"further-resources",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"websockets-real-time-communication-under-the-hood",children:"WebSockets: Real-Time Communication Under the Hood"})}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#getting-started-with-websockets",children:"Getting Started with WebSockets"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#websocket-protocol-deep-dive",children:"WebSocket Protocol Deep Dive"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#connection-establishment-and-handshake",children:"Connection Establishment and Handshake"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#frame-structure-and-message-types",children:"Frame Structure and Message Types"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#connection-management-and-lifecycle",children:"Connection Management and Lifecycle"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#server-side-implementation",children:"Server-Side Implementation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#real-time-communication-patterns",children:"Real-Time Communication Patterns"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#security-considerations",children:"Security Considerations"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#real-world-implementation-examples",children:"Real-World Implementation Examples"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#error-handling-and-debugging",children:"Error Handling and Debugging"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#websocket-libraries-and-frameworks",children:"WebSocket Libraries and Frameworks"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#best-practices-and-common-pitfalls",children:"Best Practices and Common Pitfalls"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"WebSockets provide a full-duplex communication channel between a client and server over a single TCP connection. Unlike traditional HTTP requests, WebSockets enable real-time, bidirectional communication with minimal overhead, making them ideal for applications requiring instant data exchange."}),"\n",(0,s.jsxs)(n.p,{children:["As defined in the ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API",children:"WebSocket API specification"}),", WebSockets overcome the limitations of HTTP polling by establishing a persistent connection that allows both client and server to send data at any time."]}),"\n",(0,s.jsx)(n.h3,{id:"key-advantages",children:"Key Advantages"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Full-Duplex Communication"}),": Both client and server can send data simultaneously"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Low Latency"}),": No HTTP header overhead after initial handshake"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Real-Time Updates"}),": Instant data exchange without polling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient Resource Usage"}),": Single persistent connection vs multiple HTTP requests"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Binary and Text Support"}),": Flexible data transmission formats"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Real-time chat applications"}),"\n",(0,s.jsx)(n.li,{children:"Live gaming and multiplayer experiences"}),"\n",(0,s.jsx)(n.li,{children:"Financial trading platforms"}),"\n",(0,s.jsx)(n.li,{children:"Collaborative editing tools"}),"\n",(0,s.jsx)(n.li,{children:"Live notifications and alerts"}),"\n",(0,s.jsx)(n.li,{children:"IoT device communication"}),"\n",(0,s.jsx)(n.li,{children:"Real-time analytics dashboards"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"getting-started-with-websockets",children:"Getting Started with WebSockets"}),"\n",(0,s.jsx)(n.h3,{id:"basic-client-implementation",children:"Basic Client Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Create a new WebSocket connection\r\nconst socket = new WebSocket("ws://localhost:8080");\r\n\r\n// Connection opened\r\nsocket.addEventListener("open", (event) => {\r\n  console.log("Connected to WebSocket server");\r\n  socket.send("Hello Server!");\r\n});\r\n\r\n// Listen for messages\r\nsocket.addEventListener("message", (event) => {\r\n  console.log("Message from server:", event.data);\r\n});\r\n\r\n// Handle errors\r\nsocket.addEventListener("error", (event) => {\r\n  console.error("WebSocket error:", event);\r\n});\r\n\r\n// Connection closed\r\nsocket.addEventListener("close", (event) => {\r\n  console.log("Connection closed:", event.code, event.reason);\r\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"enhanced-websocket-client-class",children:"Enhanced WebSocket Client Class"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WebSocketClient {\r\n  constructor(url, protocols = []) {\r\n    this.url = url;\r\n    this.protocols = protocols;\r\n    this.socket = null;\r\n    this.reconnectAttempts = 0;\r\n    this.maxReconnectAttempts = 5;\r\n    this.reconnectInterval = 1000;\r\n    this.messageQueue = [];\r\n    this.eventListeners = {};\r\n  }\r\n\r\n  connect() {\r\n    try {\r\n      this.socket = new WebSocket(this.url, this.protocols);\r\n      this.setupEventListeners();\r\n    } catch (error) {\r\n      console.error("Failed to create WebSocket:", error);\r\n      this.handleReconnect();\r\n    }\r\n  }\r\n\r\n  setupEventListeners() {\r\n    this.socket.onopen = (event) => {\r\n      console.log("WebSocket connected");\r\n      this.reconnectAttempts = 0;\r\n      this.processMessageQueue();\r\n      this.emit("open", event);\r\n    };\r\n\r\n    this.socket.onmessage = (event) => {\r\n      const data = this.parseMessage(event.data);\r\n      this.emit("message", data);\r\n    };\r\n\r\n    this.socket.onerror = (event) => {\r\n      console.error("WebSocket error:", event);\r\n      this.emit("error", event);\r\n    };\r\n\r\n    this.socket.onclose = (event) => {\r\n      console.log("WebSocket closed:", event.code, event.reason);\r\n      this.emit("close", event);\r\n\r\n      if (!event.wasClean) {\r\n        this.handleReconnect();\r\n      }\r\n    };\r\n  }\r\n\r\n  send(data) {\r\n    if (this.isConnected()) {\r\n      const message = this.formatMessage(data);\r\n      this.socket.send(message);\r\n    } else {\r\n      this.messageQueue.push(data);\r\n    }\r\n  }\r\n\r\n  isConnected() {\r\n    return this.socket && this.socket.readyState === WebSocket.OPEN;\r\n  }\r\n\r\n  parseMessage(data) {\r\n    try {\r\n      return JSON.parse(data);\r\n    } catch {\r\n      return data;\r\n    }\r\n  }\r\n\r\n  formatMessage(data) {\r\n    return typeof data === "object" ? JSON.stringify(data) : data;\r\n  }\r\n\r\n  processMessageQueue() {\r\n    while (this.messageQueue.length > 0) {\r\n      const message = this.messageQueue.shift();\r\n      this.send(message);\r\n    }\r\n  }\r\n\r\n  handleReconnect() {\r\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n      this.reconnectAttempts++;\r\n      console.log(`Reconnecting... Attempt ${this.reconnectAttempts}`);\r\n\r\n      setTimeout(() => {\r\n        this.connect();\r\n      }, this.reconnectInterval * this.reconnectAttempts);\r\n    } else {\r\n      console.error("Max reconnection attempts reached");\r\n      this.emit("maxReconnectAttemptsReached");\r\n    }\r\n  }\r\n\r\n  on(event, callback) {\r\n    if (!this.eventListeners[event]) {\r\n      this.eventListeners[event] = [];\r\n    }\r\n    this.eventListeners[event].push(callback);\r\n  }\r\n\r\n  off(event, callback) {\r\n    if (this.eventListeners[event]) {\r\n      this.eventListeners[event] = this.eventListeners[event].filter(\r\n        (cb) => cb !== callback\r\n      );\r\n    }\r\n  }\r\n\r\n  emit(event, data) {\r\n    if (this.eventListeners[event]) {\r\n      this.eventListeners[event].forEach((callback) => callback(data));\r\n    }\r\n  }\r\n\r\n  close(code = 1000, reason = "Normal closure") {\r\n    if (this.socket) {\r\n      this.socket.close(code, reason);\r\n    }\r\n  }\r\n\r\n  getState() {\r\n    if (!this.socket) return "UNINITIALIZED";\r\n\r\n    switch (this.socket.readyState) {\r\n      case WebSocket.CONNECTING:\r\n        return "CONNECTING";\r\n      case WebSocket.OPEN:\r\n        return "OPEN";\r\n      case WebSocket.CLOSING:\r\n        return "CLOSING";\r\n      case WebSocket.CLOSED:\r\n        return "CLOSED";\r\n      default:\r\n        return "UNKNOWN";\r\n    }\r\n  }\r\n}\r\n\r\n// Usage example\r\nconst client = new WebSocketClient("ws://localhost:8080");\r\n\r\nclient.on("open", () => {\r\n  console.log("Connected successfully");\r\n  client.send({ type: "greeting", message: "Hello from client!" });\r\n});\r\n\r\nclient.on("message", (data) => {\r\n  console.log("Received:", data);\r\n});\r\n\r\nclient.on("error", (error) => {\r\n  console.error("Connection error:", error);\r\n});\r\n\r\nclient.connect();\n'})}),"\n",(0,s.jsx)(n.h2,{id:"websocket-protocol-deep-dive",children:"WebSocket Protocol Deep Dive"}),"\n",(0,s.jsx)(n.h3,{id:"protocol-overview",children:"Protocol Overview"}),"\n",(0,s.jsx)(n.p,{children:"WebSockets operate over TCP and use HTTP/1.1 for the initial handshake. Once established, the connection switches to the WebSocket protocol, enabling bidirectional communication with minimal overhead."}),"\n",(0,s.jsx)(n.h3,{id:"http-to-websocket-upgrade-process",children:"HTTP to WebSocket Upgrade Process"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Client Request:\r\nGET /chat HTTP/1.1\r\nHost: server.example.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Protocol: chat, superchat\r\nOrigin: http://example.com\r\n\r\nServer Response:\r\nHTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\nSec-WebSocket-Protocol: chat\n"})}),"\n",(0,s.jsx)(n.h3,{id:"websocket-header-analysis",children:"WebSocket Header Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// WebSocket handshake validation\r\nclass WebSocketHandshake {\r\n  static generateKey() {\r\n    // Generate 16-byte random value and encode as base64\r\n    const bytes = new Uint8Array(16);\r\n    crypto.getRandomValues(bytes);\r\n    return btoa(String.fromCharCode(...bytes));\r\n  }\r\n\r\n  static validateAcceptKey(clientKey, serverAccept) {\r\n    const magicString = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";\r\n    const concatenated = clientKey + magicString;\r\n\r\n    // SHA-1 hash and base64 encode\r\n    return crypto.subtle\r\n      .digest("SHA-1", new TextEncoder().encode(concatenated))\r\n      .then((hashBuffer) => {\r\n        const hashArray = new Uint8Array(hashBuffer);\r\n        const expectedAccept = btoa(String.fromCharCode(...hashArray));\r\n        return expectedAccept === serverAccept;\r\n      });\r\n  }\r\n\r\n  static parseUpgradeHeaders(headers) {\r\n    return {\r\n      upgrade: headers.get("Upgrade")?.toLowerCase(),\r\n      connection: headers.get("Connection")?.toLowerCase(),\r\n      key: headers.get("Sec-WebSocket-Key"),\r\n      version: headers.get("Sec-WebSocket-Version"),\r\n      protocol: headers.get("Sec-WebSocket-Protocol"),\r\n      extensions: headers.get("Sec-WebSocket-Extensions"),\r\n    };\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"connection-establishment-and-handshake",children:"Connection Establishment and Handshake"}),"\n",(0,s.jsx)(n.h3,{id:"client-side-connection-process",children:"Client-Side Connection Process"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WebSocketConnection {\r\n  constructor(url, options = {}) {\r\n    this.url = url;\r\n    this.options = {\r\n      protocols: options.protocols || [],\r\n      timeout: options.timeout || 30000,\r\n      ...options,\r\n    };\r\n    this.connectionState = "IDLE";\r\n  }\r\n\r\n  async connect() {\r\n    return new Promise((resolve, reject) => {\r\n      this.connectionState = "CONNECTING";\r\n\r\n      const socket = new WebSocket(this.url, this.options.protocols);\r\n      const timeout = setTimeout(() => {\r\n        socket.close();\r\n        reject(new Error("Connection timeout"));\r\n      }, this.options.timeout);\r\n\r\n      socket.onopen = () => {\r\n        clearTimeout(timeout);\r\n        this.connectionState = "CONNECTED";\r\n        this.socket = socket;\r\n        this.setupHeartbeat();\r\n        resolve(socket);\r\n      };\r\n\r\n      socket.onerror = (error) => {\r\n        clearTimeout(timeout);\r\n        this.connectionState = "ERROR";\r\n        reject(error);\r\n      };\r\n\r\n      socket.onclose = () => {\r\n        clearTimeout(timeout);\r\n        this.connectionState = "CLOSED";\r\n        this.cleanup();\r\n      };\r\n    });\r\n  }\r\n\r\n  setupHeartbeat() {\r\n    this.heartbeatInterval = setInterval(() => {\r\n      if (this.socket?.readyState === WebSocket.OPEN) {\r\n        this.socket.send(JSON.stringify({ type: "ping" }));\r\n      }\r\n    }, 30000); // Send ping every 30 seconds\r\n  }\r\n\r\n  cleanup() {\r\n    if (this.heartbeatInterval) {\r\n      clearInterval(this.heartbeatInterval);\r\n      this.heartbeatInterval = null;\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"server-side-handshake-validation",children:"Server-Side Handshake Validation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Node.js WebSocket server handshake handling\r\nconst crypto = require("crypto");\r\nconst { EventEmitter } = require("events");\r\n\r\nclass WebSocketServer extends EventEmitter {\r\n  constructor(options = {}) {\r\n    super();\r\n    this.port = options.port || 8080;\r\n    this.protocols = options.protocols || [];\r\n  }\r\n\r\n  handleUpgrade(request, socket, head) {\r\n    const headers = request.headers;\r\n\r\n    // Validate WebSocket headers\r\n    if (!this.validateHeaders(headers)) {\r\n      socket.write("HTTP/1.1 400 Bad Request\\r\\n\\r\\n");\r\n      socket.destroy();\r\n      return;\r\n    }\r\n\r\n    // Generate accept key\r\n    const acceptKey = this.generateAcceptKey(headers["sec-websocket-key"]);\r\n\r\n    // Select protocol\r\n    const selectedProtocol = this.selectProtocol(\r\n      headers["sec-websocket-protocol"]\r\n    );\r\n\r\n    // Send handshake response\r\n    const responseHeaders = [\r\n      "HTTP/1.1 101 Switching Protocols",\r\n      "Upgrade: websocket",\r\n      "Connection: Upgrade",\r\n      `Sec-WebSocket-Accept: ${acceptKey}`,\r\n    ];\r\n\r\n    if (selectedProtocol) {\r\n      responseHeaders.push(`Sec-WebSocket-Protocol: ${selectedProtocol}`);\r\n    }\r\n\r\n    socket.write(responseHeaders.join("\\r\\n") + "\\r\\n\\r\\n");\r\n\r\n    // Create WebSocket connection\r\n    const websocket = new WebSocketConnection(socket);\r\n    this.emit("connection", websocket);\r\n  }\r\n\r\n  validateHeaders(headers) {\r\n    return (\r\n      headers.upgrade?.toLowerCase() === "websocket" &&\r\n      headers.connection?.toLowerCase().includes("upgrade") &&\r\n      headers["sec-websocket-key"] &&\r\n      headers["sec-websocket-version"] === "13"\r\n    );\r\n  }\r\n\r\n  generateAcceptKey(clientKey) {\r\n    const magicString = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";\r\n    const hash = crypto\r\n      .createHash("sha1")\r\n      .update(clientKey + magicString)\r\n      .digest("base64");\r\n    return hash;\r\n  }\r\n\r\n  selectProtocol(requestedProtocols) {\r\n    if (!requestedProtocols) return null;\r\n\r\n    const protocols = requestedProtocols.split(",").map((p) => p.trim());\r\n    return protocols.find((protocol) => this.protocols.includes(protocol));\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"frame-structure-and-message-types",children:"Frame Structure and Message Types"}),"\n",(0,s.jsx)(n.h3,{id:"websocket-frame-format",children:"WebSocket Frame Format"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:" 0                   1                   2                   3\r\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\r\n+-+-+-+-+-------+-+-------------+-------------------------------+\r\n|F|R|R|R| opcode|M| Payload len |    Extended payload length    |\r\n|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\r\n|N|V|V|V|       |S|             |   (if payload len==126/127)   |\r\n| |1|2|3|       |K|             |                               |\r\n+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\r\n|     Extended payload length continued, if payload len == 127  |\r\n+ - - - - - - - - - - - - - - - +-------------------------------+\r\n|                               |Masking-key, if MASK set to 1  |\r\n+-------------------------------+-------------------------------+\r\n| Masking-key (continued)       |          Payload Data         |\r\n+-------------------------------- - - - - - - - - - - - - - - - +\r\n:                     Payload Data continued ...                :\r\n+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\r\n|                     Payload Data continued ...                |\r\n+---------------------------------------------------------------+\n"})}),"\n",(0,s.jsx)(n.h3,{id:"frame-processing-implementation",children:"Frame Processing Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WebSocketFrame {\r\n  constructor() {\r\n    this.fin = false;\r\n    this.rsv1 = false;\r\n    this.rsv2 = false;\r\n    this.rsv3 = false;\r\n    this.opcode = 0;\r\n    this.masked = false;\r\n    this.payloadLength = 0;\r\n    this.maskingKey = null;\r\n    this.payload = null;\r\n  }\r\n\r\n  static OPCODES = {\r\n    CONTINUATION: 0x0,\r\n    TEXT: 0x1,\r\n    BINARY: 0x2,\r\n    CLOSE: 0x8,\r\n    PING: 0x9,\r\n    PONG: 0xa,\r\n  };\r\n\r\n  static createTextFrame(data, masked = true) {\r\n    const frame = new WebSocketFrame();\r\n    frame.fin = true;\r\n    frame.opcode = WebSocketFrame.OPCODES.TEXT;\r\n    frame.masked = masked;\r\n    frame.payload = Buffer.from(data, "utf8");\r\n    frame.payloadLength = frame.payload.length;\r\n\r\n    if (masked) {\r\n      frame.maskingKey = crypto.randomBytes(4);\r\n      frame.payload = WebSocketFrame.maskPayload(\r\n        frame.payload,\r\n        frame.maskingKey\r\n      );\r\n    }\r\n\r\n    return frame;\r\n  }\r\n\r\n  static createBinaryFrame(data, masked = true) {\r\n    const frame = new WebSocketFrame();\r\n    frame.fin = true;\r\n    frame.opcode = WebSocketFrame.OPCODES.BINARY;\r\n    frame.masked = masked;\r\n    frame.payload = Buffer.isBuffer(data) ? data : Buffer.from(data);\r\n    frame.payloadLength = frame.payload.length;\r\n\r\n    if (masked) {\r\n      frame.maskingKey = crypto.randomBytes(4);\r\n      frame.payload = WebSocketFrame.maskPayload(\r\n        frame.payload,\r\n        frame.maskingKey\r\n      );\r\n    }\r\n\r\n    return frame;\r\n  }\r\n\r\n  static createPingFrame(data = Buffer.alloc(0)) {\r\n    const frame = new WebSocketFrame();\r\n    frame.fin = true;\r\n    frame.opcode = WebSocketFrame.OPCODES.PING;\r\n    frame.payload = data;\r\n    frame.payloadLength = data.length;\r\n    return frame;\r\n  }\r\n\r\n  static createPongFrame(data = Buffer.alloc(0)) {\r\n    const frame = new WebSocketFrame();\r\n    frame.fin = true;\r\n    frame.opcode = WebSocketFrame.OPCODES.PONG;\r\n    frame.payload = data;\r\n    frame.payloadLength = data.length;\r\n    return frame;\r\n  }\r\n\r\n  static maskPayload(payload, maskingKey) {\r\n    const masked = Buffer.alloc(payload.length);\r\n    for (let i = 0; i < payload.length; i++) {\r\n      masked[i] = payload[i] ^ maskingKey[i % 4];\r\n    }\r\n    return masked;\r\n  }\r\n\r\n  toBuffer() {\r\n    let headerLength = 2;\r\n    let payloadLengthBytes = 0;\r\n\r\n    // Determine payload length representation\r\n    if (this.payloadLength < 126) {\r\n      payloadLengthBytes = 0;\r\n    } else if (this.payloadLength < 65536) {\r\n      payloadLengthBytes = 2;\r\n      headerLength += 2;\r\n    } else {\r\n      payloadLengthBytes = 8;\r\n      headerLength += 8;\r\n    }\r\n\r\n    if (this.masked) {\r\n      headerLength += 4;\r\n    }\r\n\r\n    const buffer = Buffer.alloc(headerLength + this.payloadLength);\r\n    let offset = 0;\r\n\r\n    // First byte: FIN + RSV + Opcode\r\n    buffer[offset] =\r\n      (this.fin ? 0x80 : 0) |\r\n      (this.rsv1 ? 0x40 : 0) |\r\n      (this.rsv2 ? 0x20 : 0) |\r\n      (this.rsv3 ? 0x10 : 0) |\r\n      (this.opcode & 0x0f);\r\n    offset++;\r\n\r\n    // Second byte: MASK + Payload length\r\n    if (this.payloadLength < 126) {\r\n      buffer[offset] = (this.masked ? 0x80 : 0) | this.payloadLength;\r\n    } else if (this.payloadLength < 65536) {\r\n      buffer[offset] = (this.masked ? 0x80 : 0) | 126;\r\n      offset++;\r\n      buffer.writeUInt16BE(this.payloadLength, offset);\r\n      offset += 2;\r\n    } else {\r\n      buffer[offset] = (this.masked ? 0x80 : 0) | 127;\r\n      offset++;\r\n      buffer.writeUInt32BE(0, offset); // High 32 bits\r\n      buffer.writeUInt32BE(this.payloadLength, offset + 4); // Low 32 bits\r\n      offset += 8;\r\n    }\r\n    offset++;\r\n\r\n    // Masking key\r\n    if (this.masked && this.maskingKey) {\r\n      this.maskingKey.copy(buffer, offset);\r\n      offset += 4;\r\n    }\r\n\r\n    // Payload\r\n    if (this.payload) {\r\n      this.payload.copy(buffer, offset);\r\n    }\r\n\r\n    return buffer;\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"connection-management-and-lifecycle",children:"Connection Management and Lifecycle"}),"\n",(0,s.jsx)(n.h3,{id:"keep-alive-and-heartbeat",children:"Keep-Alive and Heartbeat"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WebSocketKeepAlive {\r\n  constructor(socket, options = {}) {\r\n    this.socket = socket;\r\n    this.pingInterval = options.pingInterval || 30000;\r\n    this.pongTimeout = options.pongTimeout || 5000;\r\n    this.maxMissedPongs = options.maxMissedPongs || 3;\r\n    this.missedPongs = 0;\r\n    this.isAlive = true;\r\n  }\r\n\r\n  start() {\r\n    this.heartbeatTimer = setInterval(() => {\r\n      if (!this.isAlive) {\r\n        this.missedPongs++;\r\n\r\n        if (this.missedPongs >= this.maxMissedPongs) {\r\n          console.log("Connection appears dead, closing");\r\n          this.socket.terminate();\r\n          return;\r\n        }\r\n      }\r\n\r\n      this.isAlive = false;\r\n      this.socket.ping();\r\n\r\n      // Set timeout for pong response\r\n      this.pongTimer = setTimeout(() => {\r\n        console.log("Pong timeout");\r\n        this.isAlive = false;\r\n      }, this.pongTimeout);\r\n    }, this.pingInterval);\r\n\r\n    this.socket.on("pong", () => {\r\n      this.isAlive = true;\r\n      this.missedPongs = 0;\r\n      if (this.pongTimer) {\r\n        clearTimeout(this.pongTimer);\r\n      }\r\n    });\r\n  }\r\n\r\n  stop() {\r\n    if (this.heartbeatTimer) {\r\n      clearInterval(this.heartbeatTimer);\r\n    }\r\n    if (this.pongTimer) {\r\n      clearTimeout(this.pongTimer);\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"connection-pool-management",children:"Connection Pool Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WebSocketPool {\r\n  constructor(options = {}) {\r\n    this.connections = new Map();\r\n    this.groups = new Map();\r\n    this.maxConnections = options.maxConnections || 1000;\r\n    this.cleanupInterval = options.cleanupInterval || 60000;\r\n    this.startCleanup();\r\n  }\r\n\r\n  addConnection(id, socket, metadata = {}) {\r\n    if (this.connections.size >= this.maxConnections) {\r\n      throw new Error("Maximum connections reached");\r\n    }\r\n\r\n    const connection = {\r\n      id,\r\n      socket,\r\n      metadata,\r\n      connectedAt: Date.now(),\r\n      lastActivity: Date.now(),\r\n    };\r\n\r\n    this.connections.set(id, connection);\r\n    this.setupConnectionHandlers(connection);\r\n\r\n    console.log(`Connection added: ${id} (Total: ${this.connections.size})`);\r\n    return connection;\r\n  }\r\n\r\n  removeConnection(id) {\r\n    const connection = this.connections.get(id);\r\n    if (connection) {\r\n      connection.socket.terminate();\r\n      this.connections.delete(id);\r\n      this.removeFromAllGroups(id);\r\n      console.log(\r\n        `Connection removed: ${id} (Total: ${this.connections.size})`\r\n      );\r\n    }\r\n  }\r\n\r\n  setupConnectionHandlers(connection) {\r\n    connection.socket.on("message", (data) => {\r\n      connection.lastActivity = Date.now();\r\n    });\r\n\r\n    connection.socket.on("close", () => {\r\n      this.removeConnection(connection.id);\r\n    });\r\n\r\n    connection.socket.on("error", (error) => {\r\n      console.error(`Connection error for ${connection.id}:`, error);\r\n      this.removeConnection(connection.id);\r\n    });\r\n  }\r\n\r\n  broadcast(message, excludeId = null) {\r\n    const data =\r\n      typeof message === "string" ? message : JSON.stringify(message);\r\n    let sent = 0;\r\n\r\n    this.connections.forEach((connection) => {\r\n      if (connection.id !== excludeId && connection.socket.readyState === 1) {\r\n        connection.socket.send(data);\r\n        sent++;\r\n      }\r\n    });\r\n\r\n    return sent;\r\n  }\r\n\r\n  broadcastToGroup(groupId, message, excludeId = null) {\r\n    const group = this.groups.get(groupId);\r\n    if (!group) return 0;\r\n\r\n    const data =\r\n      typeof message === "string" ? message : JSON.stringify(message);\r\n    let sent = 0;\r\n\r\n    group.forEach((connectionId) => {\r\n      if (connectionId !== excludeId) {\r\n        const connection = this.connections.get(connectionId);\r\n        if (connection && connection.socket.readyState === 1) {\r\n          connection.socket.send(data);\r\n          sent++;\r\n        }\r\n      }\r\n    });\r\n\r\n    return sent;\r\n  }\r\n\r\n  addToGroup(groupId, connectionId) {\r\n    if (!this.groups.has(groupId)) {\r\n      this.groups.set(groupId, new Set());\r\n    }\r\n    this.groups.get(groupId).add(connectionId);\r\n  }\r\n\r\n  removeFromGroup(groupId, connectionId) {\r\n    const group = this.groups.get(groupId);\r\n    if (group) {\r\n      group.delete(connectionId);\r\n      if (group.size === 0) {\r\n        this.groups.delete(groupId);\r\n      }\r\n    }\r\n  }\r\n\r\n  removeFromAllGroups(connectionId) {\r\n    this.groups.forEach((group, groupId) => {\r\n      group.delete(connectionId);\r\n      if (group.size === 0) {\r\n        this.groups.delete(groupId);\r\n      }\r\n    });\r\n  }\r\n\r\n  startCleanup() {\r\n    this.cleanupTimer = setInterval(() => {\r\n      const now = Date.now();\r\n      const staleConnections = [];\r\n\r\n      this.connections.forEach((connection) => {\r\n        // Remove connections inactive for more than 10 minutes\r\n        if (now - connection.lastActivity > 600000) {\r\n          staleConnections.push(connection.id);\r\n        }\r\n      });\r\n\r\n      staleConnections.forEach((id) => this.removeConnection(id));\r\n\r\n      if (staleConnections.length > 0) {\r\n        console.log(`Cleaned up ${staleConnections.length} stale connections`);\r\n      }\r\n    }, this.cleanupInterval);\r\n  }\r\n\r\n  getStats() {\r\n    const now = Date.now();\r\n    let activeConnections = 0;\r\n    let totalGroups = this.groups.size;\r\n\r\n    this.connections.forEach((connection) => {\r\n      if (connection.socket.readyState === 1) {\r\n        activeConnections++;\r\n      }\r\n    });\r\n\r\n    return {\r\n      totalConnections: this.connections.size,\r\n      activeConnections,\r\n      totalGroups,\r\n      uptime: now - this.startTime,\r\n    };\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"server-side-implementation",children:"Server-Side Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"nodejs-websocket-server",children:"Node.js WebSocket Server"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const WebSocket = require("ws");\r\nconst http = require("http");\r\nconst crypto = require("crypto");\r\n\r\nclass CustomWebSocketServer {\r\n  constructor(options = {}) {\r\n    this.port = options.port || 8080;\r\n    this.server = http.createServer();\r\n    this.wss = new WebSocket.Server({ server: this.server });\r\n    this.connectionPool = new WebSocketPool();\r\n    this.messageHandlers = new Map();\r\n    this.middleware = [];\r\n\r\n    this.setupRoutes();\r\n    this.setupWebSocketHandlers();\r\n  }\r\n\r\n  setupRoutes() {\r\n    this.server.on("request", (req, res) => {\r\n      if (req.url === "/health") {\r\n        res.writeHead(200, { "Content-Type": "application/json" });\r\n        res.end(JSON.stringify(this.connectionPool.getStats()));\r\n      } else {\r\n        res.writeHead(404);\r\n        res.end("Not Found");\r\n      }\r\n    });\r\n  }\r\n\r\n  setupWebSocketHandlers() {\r\n    this.wss.on("connection", (ws, req) => {\r\n      const connectionId = this.generateConnectionId();\r\n      const connection = this.connectionPool.addConnection(connectionId, ws, {\r\n        userAgent: req.headers["user-agent"],\r\n        ip: req.connection.remoteAddress,\r\n      });\r\n\r\n      // Setup keep-alive\r\n      const keepAlive = new WebSocketKeepAlive(ws);\r\n      keepAlive.start();\r\n\r\n      ws.on("message", async (data) => {\r\n        try {\r\n          await this.processMessage(connection, data);\r\n        } catch (error) {\r\n          console.error("Error processing message:", error);\r\n          this.sendError(ws, "Message processing failed");\r\n        }\r\n      });\r\n\r\n      ws.on("close", () => {\r\n        keepAlive.stop();\r\n        console.log(`Client disconnected: ${connectionId}`);\r\n      });\r\n\r\n      // Send welcome message\r\n      this.send(ws, {\r\n        type: "connection",\r\n        id: connectionId,\r\n        message: "Connected successfully",\r\n      });\r\n    });\r\n  }\r\n\r\n  async processMessage(connection, rawData) {\r\n    // Apply middleware\r\n    for (const middleware of this.middleware) {\r\n      const result = await middleware(connection, rawData);\r\n      if (result === false) return; // Middleware rejected the message\r\n    }\r\n\r\n    let message;\r\n    try {\r\n      message = JSON.parse(rawData.toString());\r\n    } catch (error) {\r\n      this.sendError(connection.socket, "Invalid JSON");\r\n      return;\r\n    }\r\n\r\n    const handler = this.messageHandlers.get(message.type);\r\n    if (handler) {\r\n      await handler(connection, message);\r\n    } else {\r\n      this.sendError(\r\n        connection.socket,\r\n        `Unknown message type: ${message.type}`\r\n      );\r\n    }\r\n  }\r\n\r\n  addMessageHandler(type, handler) {\r\n    this.messageHandlers.set(type, handler);\r\n  }\r\n\r\n  addMiddleware(middleware) {\r\n    this.middleware.push(middleware);\r\n  }\r\n\r\n  send(ws, data) {\r\n    if (ws.readyState === WebSocket.OPEN) {\r\n      ws.send(JSON.stringify(data));\r\n    }\r\n  }\r\n\r\n  sendError(ws, message) {\r\n    this.send(ws, { type: "error", message });\r\n  }\r\n\r\n  broadcast(message, excludeId = null) {\r\n    return this.connectionPool.broadcast(message, excludeId);\r\n  }\r\n\r\n  generateConnectionId() {\r\n    return crypto.randomBytes(16).toString("hex");\r\n  }\r\n\r\n  start() {\r\n    this.server.listen(this.port, () => {\r\n      console.log(`WebSocket server listening on port ${this.port}`);\r\n    });\r\n  }\r\n}\r\n\r\n// Usage example\r\nconst server = new CustomWebSocketServer({ port: 8080 });\r\n\r\n// Add authentication middleware\r\nserver.addMiddleware(async (connection, data) => {\r\n  // Check authentication token\r\n  const message = JSON.parse(data.toString());\r\n  if (message.type !== "auth" && !connection.authenticated) {\r\n    server.sendError(connection.socket, "Authentication required");\r\n    return false;\r\n  }\r\n  return true;\r\n});\r\n\r\n// Add message handlers\r\nserver.addMessageHandler("auth", async (connection, message) => {\r\n  // Validate token\r\n  if (message.token === "valid-token") {\r\n    connection.authenticated = true;\r\n    server.send(connection.socket, { type: "auth", status: "success" });\r\n  } else {\r\n    server.sendError(connection.socket, "Invalid token");\r\n    connection.socket.close();\r\n  }\r\n});\r\n\r\nserver.addMessageHandler("chat", async (connection, message) => {\r\n  if (!connection.authenticated) return;\r\n\r\n  const chatMessage = {\r\n    type: "chat",\r\n    id: crypto.randomUUID(),\r\n    user: connection.metadata.userId,\r\n    message: message.content,\r\n    timestamp: Date.now(),\r\n  };\r\n\r\n  server.broadcast(chatMessage, connection.id);\r\n});\r\n\r\nserver.start();\n'})}),"\n",(0,s.jsx)(n.h2,{id:"real-time-communication-patterns",children:"Real-Time Communication Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"request-response-pattern",children:"Request-Response Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WebSocketRPC {\r\n  constructor(socket) {\r\n    this.socket = socket;\r\n    this.pendingRequests = new Map();\r\n    this.requestId = 0;\r\n    this.setupMessageHandler();\r\n  }\r\n\r\n  setupMessageHandler() {\r\n    this.socket.addEventListener("message", (event) => {\r\n      const data = JSON.parse(event.data);\r\n\r\n      if (data.id && this.pendingRequests.has(data.id)) {\r\n        const { resolve, reject } = this.pendingRequests.get(data.id);\r\n        this.pendingRequests.delete(data.id);\r\n\r\n        if (data.error) {\r\n          reject(new Error(data.error));\r\n        } else {\r\n          resolve(data.result);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  async call(method, params = {}, timeout = 5000) {\r\n    return new Promise((resolve, reject) => {\r\n      const id = ++this.requestId;\r\n\r\n      const timer = setTimeout(() => {\r\n        this.pendingRequests.delete(id);\r\n        reject(new Error("Request timeout"));\r\n      }, timeout);\r\n\r\n      this.pendingRequests.set(id, {\r\n        resolve: (result) => {\r\n          clearTimeout(timer);\r\n          resolve(result);\r\n        },\r\n        reject: (error) => {\r\n          clearTimeout(timer);\r\n          reject(error);\r\n        },\r\n      });\r\n\r\n      this.socket.send(\r\n        JSON.stringify({\r\n          id,\r\n          method,\r\n          params,\r\n        })\r\n      );\r\n    });\r\n  }\r\n}\r\n\r\n// Usage\r\nconst rpc = new WebSocketRPC(socket);\r\n\r\ntry {\r\n  const result = await rpc.call("getUserProfile", { userId: 123 });\r\n  console.log("User profile:", result);\r\n} catch (error) {\r\n  console.error("RPC error:", error);\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"pubsub-pattern",children:"Pub/Sub Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WebSocketPubSub {\r\n  constructor(socket) {\r\n    this.socket = socket;\r\n    this.subscriptions = new Map();\r\n    this.setupMessageHandler();\r\n  }\r\n\r\n  setupMessageHandler() {\r\n    this.socket.addEventListener("message", (event) => {\r\n      const data = JSON.parse(event.data);\r\n\r\n      if (data.type === "publish") {\r\n        const callbacks = this.subscriptions.get(data.channel);\r\n        if (callbacks) {\r\n          callbacks.forEach((callback) => {\r\n            try {\r\n              callback(data.payload);\r\n            } catch (error) {\r\n              console.error("Subscription callback error:", error);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  subscribe(channel, callback) {\r\n    if (!this.subscriptions.has(channel)) {\r\n      this.subscriptions.set(channel, new Set());\r\n\r\n      // Send subscription request to server\r\n      this.socket.send(\r\n        JSON.stringify({\r\n          type: "subscribe",\r\n          channel,\r\n        })\r\n      );\r\n    }\r\n\r\n    this.subscriptions.get(channel).add(callback);\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n      const callbacks = this.subscriptions.get(channel);\r\n      if (callbacks) {\r\n        callbacks.delete(callback);\r\n\r\n        if (callbacks.size === 0) {\r\n          this.subscriptions.delete(channel);\r\n\r\n          // Send unsubscription request to server\r\n          this.socket.send(\r\n            JSON.stringify({\r\n              type: "unsubscribe",\r\n              channel,\r\n            })\r\n          );\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  publish(channel, payload) {\r\n    this.socket.send(\r\n      JSON.stringify({\r\n        type: "publish",\r\n        channel,\r\n        payload,\r\n      })\r\n    );\r\n  }\r\n}\r\n\r\n// Usage\r\nconst pubsub = new WebSocketPubSub(socket);\r\n\r\n// Subscribe to user events\r\nconst unsubscribe = pubsub.subscribe("user.events", (data) => {\r\n  console.log("User event:", data);\r\n});\r\n\r\n// Publish a message\r\npubsub.publish("user.events", {\r\n  action: "login",\r\n  userId: 123,\r\n  timestamp: Date.now(),\r\n});\r\n\r\n// Unsubscribe later\r\nunsubscribe();\n'})}),"\n",(0,s.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"secure-websocket-implementation",children:"Secure WebSocket Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class SecureWebSocketClient {\r\n  constructor(url, options = {}) {\r\n    this.url = url;\r\n    this.options = options;\r\n    this.authToken = null;\r\n    this.csrfToken = null;\r\n  }\r\n\r\n  async connect(credentials) {\r\n    // Use WSS for secure connections\r\n    const secureUrl = this.url.replace("ws://", "wss://");\r\n\r\n    // Get authentication token\r\n    this.authToken = await this.authenticate(credentials);\r\n    this.csrfToken = await this.getCSRFToken();\r\n\r\n    const socket = new WebSocket(secureUrl, [], {\r\n      headers: {\r\n        Authorization: `Bearer ${this.authToken}`,\r\n        "X-CSRF-Token": this.csrfToken,\r\n      },\r\n    });\r\n\r\n    return new Promise((resolve, reject) => {\r\n      socket.onopen = () => {\r\n        this.socket = socket;\r\n        this.setupSecurityHandlers();\r\n        resolve(socket);\r\n      };\r\n\r\n      socket.onerror = reject;\r\n    });\r\n  }\r\n\r\n  setupSecurityHandlers() {\r\n    this.socket.addEventListener("message", (event) => {\r\n      try {\r\n        const data = JSON.parse(event.data);\r\n\r\n        // Validate message structure\r\n        if (!this.validateMessage(data)) {\r\n          console.warn("Invalid message structure received");\r\n          return;\r\n        }\r\n\r\n        // Check for token refresh\r\n        if (data.type === "token_refresh") {\r\n          this.authToken = data.token;\r\n        }\r\n\r\n        this.handleMessage(data);\r\n      } catch (error) {\r\n        console.error("Message processing error:", error);\r\n      }\r\n    });\r\n  }\r\n\r\n  validateMessage(data) {\r\n    // Implement message validation logic\r\n    return (\r\n      typeof data === "object" &&\r\n      data !== null &&\r\n      typeof data.type === "string" &&\r\n      data.type.length > 0\r\n    );\r\n  }\r\n\r\n  sendSecureMessage(data) {\r\n    const message = {\r\n      ...data,\r\n      timestamp: Date.now(),\r\n      nonce: crypto.randomUUID(),\r\n      auth: this.authToken,\r\n    };\r\n\r\n    this.socket.send(JSON.stringify(message));\r\n  }\r\n\r\n  async authenticate(credentials) {\r\n    const response = await fetch("/api/auth", {\r\n      method: "POST",\r\n      headers: { "Content-Type": "application/json" },\r\n      body: JSON.stringify(credentials),\r\n    });\r\n\r\n    const data = await response.json();\r\n    return data.token;\r\n  }\r\n\r\n  async getCSRFToken() {\r\n    const response = await fetch("/api/csrf-token");\r\n    const data = await response.json();\r\n    return data.token;\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"rate-limiting-and-ddos-protection",children:"Rate Limiting and DDoS Protection"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WebSocketRateLimiter {\r\n  constructor(options = {}) {\r\n    this.windowMs = options.windowMs || 60000; // 1 minute\r\n    this.maxRequests = options.maxRequests || 100;\r\n    this.clients = new Map();\r\n    this.cleanupInterval = setInterval(() => this.cleanup(), this.windowMs);\r\n  }\r\n\r\n  checkLimit(clientId) {\r\n    const now = Date.now();\r\n    const client = this.clients.get(clientId) || {\r\n      requests: [],\r\n      blocked: false,\r\n    };\r\n\r\n    // Remove old requests outside the window\r\n    client.requests = client.requests.filter(\r\n      (timestamp) => now - timestamp < this.windowMs\r\n    );\r\n\r\n    // Check if client is blocked\r\n    if (client.blocked && client.blockExpiry > now) {\r\n      return false;\r\n    }\r\n\r\n    // Check rate limit\r\n    if (client.requests.length >= this.maxRequests) {\r\n      client.blocked = true;\r\n      client.blockExpiry = now + this.windowMs;\r\n      this.clients.set(clientId, client);\r\n      return false;\r\n    }\r\n\r\n    // Add current request\r\n    client.requests.push(now);\r\n    client.blocked = false;\r\n    this.clients.set(clientId, client);\r\n\r\n    return true;\r\n  }\r\n\r\n  cleanup() {\r\n    const now = Date.now();\r\n    for (const [clientId, client] of this.clients.entries()) {\r\n      // Remove expired blocks and old request records\r\n      if (client.blocked && client.blockExpiry <= now) {\r\n        client.blocked = false;\r\n        client.requests = [];\r\n      }\r\n\r\n      // Remove clients with no recent activity\r\n      if (client.requests.length === 0 && !client.blocked) {\r\n        this.clients.delete(clientId);\r\n      }\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    clearInterval(this.cleanupInterval);\r\n  }\r\n}\r\n\r\n// Server integration\r\nconst rateLimiter = new WebSocketRateLimiter({\r\n  windowMs: 60000, // 1 minute\r\n  maxRequests: 50, // 50 requests per minute\r\n});\r\n\r\nserver.addMiddleware(async (connection, data) => {\r\n  const clientId = connection.metadata.ip;\r\n\r\n  if (!rateLimiter.checkLimit(clientId)) {\r\n    server.sendError(connection.socket, "Rate limit exceeded");\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"connection-pooling-and-load-balancing",children:"Connection Pooling and Load Balancing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WebSocketLoadBalancer {\r\n  constructor(servers) {\r\n    this.servers = servers.map((server, index) => ({\r\n      ...server,\r\n      id: index,\r\n      connections: 0,\r\n      healthy: true,\r\n    }));\r\n    this.currentIndex = 0;\r\n    this.healthCheckInterval = setInterval(() => this.healthCheck(), 30000);\r\n  }\r\n\r\n  getServer() {\r\n    // Round-robin with health check\r\n    const healthyServers = this.servers.filter((server) => server.healthy);\r\n\r\n    if (healthyServers.length === 0) {\r\n      throw new Error("No healthy servers available");\r\n    }\r\n\r\n    const server = healthyServers[this.currentIndex % healthyServers.length];\r\n    this.currentIndex = (this.currentIndex + 1) % healthyServers.length;\r\n\r\n    return server;\r\n  }\r\n\r\n  async healthCheck() {\r\n    for (const server of this.servers) {\r\n      try {\r\n        const response = await fetch(\r\n          `http://${server.host}:${server.port}/health`\r\n        );\r\n        server.healthy = response.ok;\r\n      } catch (error) {\r\n        server.healthy = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  connect(url) {\r\n    const server = this.getServer();\r\n    const serverUrl = `ws://${server.host}:${server.port}${url}`;\r\n\r\n    const socket = new WebSocket(serverUrl);\r\n\r\n    socket.addEventListener("open", () => {\r\n      server.connections++;\r\n    });\r\n\r\n    socket.addEventListener("close", () => {\r\n      server.connections--;\r\n    });\r\n\r\n    return socket;\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"message-compression-and-batching",children:"Message Compression and Batching"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WebSocketOptimizer {\r\n  constructor(socket, options = {}) {\r\n    this.socket = socket;\r\n    this.batchSize = options.batchSize || 10;\r\n    this.batchTimeout = options.batchTimeout || 100;\r\n    this.compressionThreshold = options.compressionThreshold || 1024;\r\n    this.messageQueue = [];\r\n    this.batchTimer = null;\r\n  }\r\n\r\n  send(data) {\r\n    this.messageQueue.push({\r\n      data,\r\n      timestamp: Date.now(),\r\n    });\r\n\r\n    if (this.messageQueue.length >= this.batchSize) {\r\n      this.flush();\r\n    } else if (!this.batchTimer) {\r\n      this.batchTimer = setTimeout(() => this.flush(), this.batchTimeout);\r\n    }\r\n  }\r\n\r\n  flush() {\r\n    if (this.batchTimer) {\r\n      clearTimeout(this.batchTimer);\r\n      this.batchTimer = null;\r\n    }\r\n\r\n    if (this.messageQueue.length === 0) return;\r\n\r\n    const messages = this.messageQueue.splice(0);\r\n\r\n    if (messages.length === 1) {\r\n      this.sendSingle(messages[0].data);\r\n    } else {\r\n      this.sendBatch(messages.map((m) => m.data));\r\n    }\r\n  }\r\n\r\n  sendSingle(data) {\r\n    const serialized = JSON.stringify(data);\r\n\r\n    if (serialized.length > this.compressionThreshold) {\r\n      this.sendCompressed(serialized);\r\n    } else {\r\n      this.socket.send(serialized);\r\n    }\r\n  }\r\n\r\n  sendBatch(messages) {\r\n    const batchMessage = {\r\n      type: "batch",\r\n      messages,\r\n      count: messages.length,\r\n    };\r\n\r\n    this.sendSingle(batchMessage);\r\n  }\r\n\r\n  async sendCompressed(data) {\r\n    try {\r\n      // Use compression (browser CompressionStream API)\r\n      const stream = new CompressionStream("gzip");\r\n      const writer = stream.writable.getWriter();\r\n      const reader = stream.readable.getReader();\r\n\r\n      writer.write(new TextEncoder().encode(data));\r\n      writer.close();\r\n\r\n      const chunks = [];\r\n      let done = false;\r\n\r\n      while (!done) {\r\n        const { value, done: readerDone } = await reader.read();\r\n        done = readerDone;\r\n        if (value) chunks.push(value);\r\n      }\r\n\r\n      const compressed = new Uint8Array(\r\n        chunks.reduce((acc, chunk) => acc + chunk.length, 0)\r\n      );\r\n\r\n      let offset = 0;\r\n      for (const chunk of chunks) {\r\n        compressed.set(chunk, offset);\r\n        offset += chunk.length;\r\n      }\r\n\r\n      this.socket.send(compressed);\r\n    } catch (error) {\r\n      console.warn("Compression failed, sending uncompressed:", error);\r\n      this.socket.send(data);\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-implementation-examples",children:"Real-World Implementation Examples"}),"\n",(0,s.jsx)(n.h3,{id:"real-time-chat-application",children:"Real-Time Chat Application"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class ChatApplication {\r\n  constructor() {\r\n    this.socket = null;\r\n    this.messages = [];\r\n    this.users = new Map();\r\n    this.currentRoom = null;\r\n    this.typing = new Set();\r\n  }\r\n\r\n  async connect(username, room) {\r\n    const socket = new WebSocketClient("ws://localhost:8080/chat");\r\n\r\n    socket.on("open", () => {\r\n      socket.send({\r\n        type: "join",\r\n        username,\r\n        room,\r\n      });\r\n    });\r\n\r\n    socket.on("message", (data) => {\r\n      this.handleMessage(data);\r\n    });\r\n\r\n    this.socket = socket;\r\n    await socket.connect();\r\n    this.currentRoom = room;\r\n  }\r\n\r\n  handleMessage(data) {\r\n    switch (data.type) {\r\n      case "message":\r\n        this.addMessage(data);\r\n        break;\r\n      case "userJoined":\r\n        this.addUser(data.user);\r\n        break;\r\n      case "userLeft":\r\n        this.removeUser(data.user);\r\n        break;\r\n      case "typing":\r\n        this.handleTyping(data);\r\n        break;\r\n      case "stopTyping":\r\n        this.handleStopTyping(data);\r\n        break;\r\n    }\r\n  }\r\n\r\n  sendMessage(content) {\r\n    const message = {\r\n      type: "message",\r\n      content,\r\n      room: this.currentRoom,\r\n      timestamp: Date.now(),\r\n    };\r\n\r\n    this.socket.send(message);\r\n  }\r\n\r\n  startTyping() {\r\n    this.socket.send({\r\n      type: "typing",\r\n      room: this.currentRoom,\r\n    });\r\n  }\r\n\r\n  stopTyping() {\r\n    this.socket.send({\r\n      type: "stopTyping",\r\n      room: this.currentRoom,\r\n    });\r\n  }\r\n\r\n  addMessage(message) {\r\n    this.messages.push(message);\r\n    this.renderMessage(message);\r\n  }\r\n\r\n  addUser(user) {\r\n    this.users.set(user.id, user);\r\n    this.updateUserList();\r\n  }\r\n\r\n  removeUser(user) {\r\n    this.users.delete(user.id);\r\n    this.updateUserList();\r\n  }\r\n\r\n  handleTyping(data) {\r\n    this.typing.add(data.user);\r\n    this.updateTypingIndicator();\r\n  }\r\n\r\n  handleStopTyping(data) {\r\n    this.typing.delete(data.user);\r\n    this.updateTypingIndicator();\r\n  }\r\n\r\n  renderMessage(message) {\r\n    const messagesContainer = document.getElementById("messages");\r\n    const messageElement = document.createElement("div");\r\n    messageElement.className = "message";\r\n    messageElement.innerHTML = `\r\n      <span class="username">${message.username}:</span>\r\n      <span class="content">${message.content}</span>\r\n      <span class="timestamp">${new Date(\r\n        message.timestamp\r\n      ).toLocaleTimeString()}</span>\r\n    `;\r\n    messagesContainer.appendChild(messageElement);\r\n    messagesContainer.scrollTop = messagesContainer.scrollHeight;\r\n  }\r\n\r\n  updateUserList() {\r\n    const userList = document.getElementById("userList");\r\n    userList.innerHTML = "";\r\n\r\n    this.users.forEach((user) => {\r\n      const userElement = document.createElement("div");\r\n      userElement.className = "user";\r\n      userElement.textContent = user.username;\r\n      userList.appendChild(userElement);\r\n    });\r\n  }\r\n\r\n  updateTypingIndicator() {\r\n    const indicator = document.getElementById("typingIndicator");\r\n\r\n    if (this.typing.size > 0) {\r\n      const users = Array.from(this.typing).join(", ");\r\n      indicator.textContent = `${users} ${\r\n        this.typing.size === 1 ? "is" : "are"\r\n      } typing...`;\r\n      indicator.style.display = "block";\r\n    } else {\r\n      indicator.style.display = "none";\r\n    }\r\n  }\r\n}\r\n\r\n// Initialize chat application\r\nconst chat = new ChatApplication();\r\n\r\ndocument.getElementById("joinButton").addEventListener("click", async () => {\r\n  const username = document.getElementById("username").value;\r\n  const room = document.getElementById("room").value;\r\n\r\n  if (username && room) {\r\n    await chat.connect(username, room);\r\n    document.getElementById("loginForm").style.display = "none";\r\n    document.getElementById("chatContainer").style.display = "block";\r\n  }\r\n});\r\n\r\ndocument.getElementById("messageInput").addEventListener("keypress", (e) => {\r\n  if (e.key === "Enter") {\r\n    const content = e.target.value.trim();\r\n    if (content) {\r\n      chat.sendMessage(content);\r\n      e.target.value = "";\r\n    }\r\n  }\r\n});\r\n\r\n// Typing indicators\r\nlet typingTimer;\r\ndocument.getElementById("messageInput").addEventListener("input", () => {\r\n  chat.startTyping();\r\n\r\n  clearTimeout(typingTimer);\r\n  typingTimer = setTimeout(() => {\r\n    chat.stopTyping();\r\n  }, 1000);\r\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling-and-debugging",children:"Error Handling and Debugging"}),"\n",(0,s.jsx)(n.h3,{id:"comprehensive-error-handling",children:"Comprehensive Error Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WebSocketErrorHandler {\r\n  constructor(socket) {\r\n    this.socket = socket;\r\n    this.errorCounts = new Map();\r\n    this.setupErrorHandlers();\r\n  }\r\n\r\n  setupErrorHandlers() {\r\n    this.socket.addEventListener("error", (event) => {\r\n      this.handleError("connection", event);\r\n    });\r\n\r\n    this.socket.addEventListener("close", (event) => {\r\n      if (!event.wasClean) {\r\n        this.handleError("close", event);\r\n      }\r\n    });\r\n\r\n    // Catch message parsing errors\r\n    const originalOnMessage = this.socket.onmessage;\r\n    this.socket.onmessage = (event) => {\r\n      try {\r\n        if (originalOnMessage) {\r\n          originalOnMessage.call(this.socket, event);\r\n        }\r\n      } catch (error) {\r\n        this.handleError("message", error, event.data);\r\n      }\r\n    };\r\n  }\r\n\r\n  handleError(type, error, context = null) {\r\n    const errorInfo = {\r\n      type,\r\n      error: error.message || error.toString(),\r\n      timestamp: Date.now(),\r\n      context,\r\n      stack: error.stack,\r\n    };\r\n\r\n    // Track error frequency\r\n    const key = `${type}:${error.message}`;\r\n    this.errorCounts.set(key, (this.errorCounts.get(key) || 0) + 1);\r\n\r\n    // Log error\r\n    console.error("WebSocket error:", errorInfo);\r\n\r\n    // Report to error tracking service\r\n    this.reportError(errorInfo);\r\n\r\n    // Handle specific error types\r\n    switch (type) {\r\n      case "connection":\r\n        this.handleConnectionError(error);\r\n        break;\r\n      case "close":\r\n        this.handleCloseError(error);\r\n        break;\r\n      case "message":\r\n        this.handleMessageError(error, context);\r\n        break;\r\n    }\r\n  }\r\n\r\n  handleConnectionError(error) {\r\n    // Implement connection error recovery\r\n    console.log("Attempting to recover from connection error");\r\n  }\r\n\r\n  handleCloseError(event) {\r\n    const closeReasons = {\r\n      1000: "Normal closure",\r\n      1001: "Going away",\r\n      1002: "Protocol error",\r\n      1003: "Unsupported data",\r\n      1004: "Reserved",\r\n      1005: "No status received",\r\n      1006: "Abnormal closure",\r\n      1007: "Invalid frame payload data",\r\n      1008: "Policy violation",\r\n      1009: "Message too big",\r\n      1010: "Missing extension",\r\n      1011: "Internal error",\r\n      1015: "TLS handshake failure",\r\n    };\r\n\r\n    const reason = closeReasons[event.code] || "Unknown reason";\r\n    console.log(`Connection closed: ${event.code} - ${reason}`);\r\n  }\r\n\r\n  handleMessageError(error, data) {\r\n    console.error("Failed to process message:", data, error);\r\n  }\r\n\r\n  reportError(errorInfo) {\r\n    // Send to error tracking service\r\n    if (window.errorTracker) {\r\n      window.errorTracker.captureException(errorInfo);\r\n    }\r\n  }\r\n\r\n  getErrorStats() {\r\n    return Object.fromEntries(this.errorCounts);\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"websocket-debugging-tools",children:"WebSocket Debugging Tools"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class WebSocketDebugger {\r\n  constructor(socket) {\r\n    this.socket = socket;\r\n    this.logs = [];\r\n    this.stats = {\r\n      messagesSent: 0,\r\n      messagesReceived: 0,\r\n      bytesSent: 0,\r\n      bytesReceived: 0,\r\n      connectTime: null,\r\n      lastActivity: null,\r\n    };\r\n\r\n    this.setupLogging();\r\n  }\r\n\r\n  setupLogging() {\r\n    const originalSend = this.socket.send.bind(this.socket);\r\n    this.socket.send = (data) => {\r\n      this.logMessage("sent", data);\r\n      this.stats.messagesSent++;\r\n      this.stats.bytesSent += this.getDataSize(data);\r\n      this.stats.lastActivity = Date.now();\r\n      return originalSend(data);\r\n    };\r\n\r\n    this.socket.addEventListener("open", (event) => {\r\n      this.stats.connectTime = Date.now();\r\n      this.logEvent("connected", event);\r\n    });\r\n\r\n    this.socket.addEventListener("message", (event) => {\r\n      this.logMessage("received", event.data);\r\n      this.stats.messagesReceived++;\r\n      this.stats.bytesReceived += this.getDataSize(event.data);\r\n      this.stats.lastActivity = Date.now();\r\n    });\r\n\r\n    this.socket.addEventListener("close", (event) => {\r\n      this.logEvent("closed", event);\r\n    });\r\n\r\n    this.socket.addEventListener("error", (event) => {\r\n      this.logEvent("error", event);\r\n    });\r\n  }\r\n\r\n  logMessage(direction, data) {\r\n    const entry = {\r\n      type: "message",\r\n      direction,\r\n      data: this.formatData(data),\r\n      size: this.getDataSize(data),\r\n      timestamp: Date.now(),\r\n    };\r\n\r\n    this.logs.push(entry);\r\n    this.trimLogs();\r\n\r\n    console.log(`WebSocket ${direction}:`, entry);\r\n  }\r\n\r\n  logEvent(type, event) {\r\n    const entry = {\r\n      type: "event",\r\n      event: type,\r\n      details: this.formatEvent(event),\r\n      timestamp: Date.now(),\r\n    };\r\n\r\n    this.logs.push(entry);\r\n    this.trimLogs();\r\n\r\n    console.log(`WebSocket ${type}:`, entry);\r\n  }\r\n\r\n  formatData(data) {\r\n    if (typeof data === "string") {\r\n      try {\r\n        return JSON.parse(data);\r\n      } catch {\r\n        return data;\r\n      }\r\n    }\r\n    return data;\r\n  }\r\n\r\n  formatEvent(event) {\r\n    return {\r\n      type: event.type,\r\n      code: event.code,\r\n      reason: event.reason,\r\n      wasClean: event.wasClean,\r\n    };\r\n  }\r\n\r\n  getDataSize(data) {\r\n    if (typeof data === "string") {\r\n      return new Blob([data]).size;\r\n    } else if (data instanceof ArrayBuffer) {\r\n      return data.byteLength;\r\n    } else if (data instanceof Blob) {\r\n      return data.size;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  trimLogs() {\r\n    if (this.logs.length > 1000) {\r\n      this.logs = this.logs.slice(-500);\r\n    }\r\n  }\r\n\r\n  exportLogs() {\r\n    return {\r\n      logs: this.logs,\r\n      stats: this.stats,\r\n      exportTime: Date.now(),\r\n    };\r\n  }\r\n\r\n  printStats() {\r\n    console.table(this.stats);\r\n  }\r\n}\r\n\r\n// Usage\r\nconst debugger = new WebSocketDebugger(socket);\r\n\r\n// Export logs for analysis\r\nconst logs = debugger.exportLogs();\r\nconsole.log("WebSocket debug data:", logs);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-and-common-pitfalls",children:"Best Practices and Common Pitfalls"}),"\n",(0,s.jsx)(n.h3,{id:"connection-management-best-practices",children:"Connection Management Best Practices"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// \u2705 Good: Proper connection lifecycle management\r\nclass RobustWebSocketClient {\r\n  constructor(url, options = {}) {\r\n    this.url = url;\r\n    this.options = options;\r\n    this.socket = null;\r\n    this.reconnectEnabled = true;\r\n    this.eventListeners = new Map();\r\n  }\r\n\r\n  async connect() {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        this.socket = new WebSocket(this.url);\r\n\r\n        const timeout = setTimeout(() => {\r\n          this.socket.close();\r\n          reject(new Error("Connection timeout"));\r\n        }, 10000);\r\n\r\n        this.socket.onopen = () => {\r\n          clearTimeout(timeout);\r\n          resolve();\r\n        };\r\n\r\n        this.socket.onerror = (error) => {\r\n          clearTimeout(timeout);\r\n          reject(error);\r\n        };\r\n\r\n        this.setupEventHandlers();\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  setupEventHandlers() {\r\n    this.socket.onclose = (event) => {\r\n      if (this.reconnectEnabled && !event.wasClean) {\r\n        this.handleReconnect();\r\n      }\r\n    };\r\n  }\r\n\r\n  disconnect() {\r\n    this.reconnectEnabled = false;\r\n    if (this.socket) {\r\n      this.socket.close(1000, "Normal closure");\r\n    }\r\n  }\r\n}\r\n\r\n// \u274c Bad: No error handling or connection management\r\nclass BadWebSocketClient {\r\n  constructor(url) {\r\n    this.socket = new WebSocket(url); // Can throw immediately\r\n    // No error handling, no reconnection logic\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"message-handling-best-practices",children:"Message Handling Best Practices"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// \u2705 Good: Structured message handling with validation\r\nclass MessageHandler {\r\n  constructor() {\r\n    this.handlers = new Map();\r\n    this.middleware = [];\r\n  }\r\n\r\n  addHandler(type, handler) {\r\n    this.handlers.set(type, handler);\r\n  }\r\n\r\n  async processMessage(rawData) {\r\n    try {\r\n      let message = this.parseMessage(rawData);\r\n\r\n      // Apply middleware\r\n      for (const middleware of this.middleware) {\r\n        message = await middleware(message);\r\n        if (!message) return; // Middleware rejected message\r\n      }\r\n\r\n      // Validate message structure\r\n      if (!this.validateMessage(message)) {\r\n        throw new Error("Invalid message structure");\r\n      }\r\n\r\n      // Handle message\r\n      const handler = this.handlers.get(message.type);\r\n      if (handler) {\r\n        await handler(message);\r\n      } else {\r\n        console.warn(`No handler for message type: ${message.type}`);\r\n      }\r\n    } catch (error) {\r\n      console.error("Message processing error:", error);\r\n    }\r\n  }\r\n\r\n  parseMessage(data) {\r\n    if (typeof data === "string") {\r\n      return JSON.parse(data);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  validateMessage(message) {\r\n    return message && typeof message.type === "string";\r\n  }\r\n}\r\n\r\n// \u274c Bad: No error handling or validation\r\nclass BadMessageHandler {\r\n  handleMessage(data) {\r\n    const message = JSON.parse(data); // Can throw\r\n    this.handlers[message.type](message); // Can be undefined\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"performance-optimization-tips",children:"Performance Optimization Tips"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// \u2705 Good: Efficient message batching and throttling\r\nclass OptimizedWebSocket {\r\n  constructor(socket) {\r\n    this.socket = socket;\r\n    this.messageQueue = [];\r\n    this.batchTimer = null;\r\n    this.lastSend = 0;\r\n    this.minInterval = 16; // ~60fps\r\n  }\r\n\r\n  send(data) {\r\n    const now = Date.now();\r\n\r\n    if (now - this.lastSend < this.minInterval) {\r\n      // Batch messages to avoid flooding\r\n      this.messageQueue.push(data);\r\n      this.scheduleBatch();\r\n    } else {\r\n      this.sendImmediate(data);\r\n    }\r\n  }\r\n\r\n  sendImmediate(data) {\r\n    this.socket.send(JSON.stringify(data));\r\n    this.lastSend = Date.now();\r\n  }\r\n\r\n  scheduleBatch() {\r\n    if (!this.batchTimer) {\r\n      this.batchTimer = setTimeout(() => {\r\n        this.flushBatch();\r\n      }, this.minInterval);\r\n    }\r\n  }\r\n\r\n  flushBatch() {\r\n    if (this.messageQueue.length > 0) {\r\n      const batch = {\r\n        type: "batch",\r\n        messages: this.messageQueue.splice(0),\r\n      };\r\n      this.sendImmediate(batch);\r\n    }\r\n    this.batchTimer = null;\r\n  }\r\n}\r\n\r\n// \u274c Bad: Sending messages without any throttling\r\nclass BadWebSocket {\r\n  send(data) {\r\n    this.socket.send(JSON.stringify(data)); // Can flood the connection\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"WebSockets provide a powerful foundation for real-time web applications, enabling efficient bidirectional communication between clients and servers. Understanding the underlying protocol, from the initial HTTP handshake to frame-level communication, is crucial for building robust applications."}),"\n",(0,s.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Protocol Understanding"}),": The WebSocket handshake process and frame structure enable efficient real-time communication while maintaining compatibility with existing web infrastructure."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Connection Management"}),": Proper connection lifecycle management, including reconnection strategies and heartbeat mechanisms, ensures reliable real-time communication."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Security Considerations"}),": Implementing proper authentication, rate limiting, and using secure connections (WSS) is essential for production applications."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance Optimization"}),": Message batching, compression, and efficient connection pooling can significantly improve application performance."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),": Comprehensive error handling and debugging tools are crucial for maintaining stable WebSocket connections in production environments."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"future-considerations",children:"Future Considerations"}),"\n",(0,s.jsx)(n.p,{children:"WebSocket technology continues to evolve with new standards like WebTransport providing enhanced capabilities for specific use cases. However, WebSockets remain the standard choice for most real-time web applications due to their widespread support and proven reliability."}),"\n",(0,s.jsx)(n.h3,{id:"further-resources",children:"Further Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API",children:"WebSocket API Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://tools.ietf.org/html/rfc6455",children:"RFC 6455 - The WebSocket Protocol"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers",children:"WebSocket Security Considerations"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://socket.io/docs/",children:"Socket.IO Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/WebTransport",children:"WebTransport API"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The WebSocket ecosystem continues to grow with libraries and frameworks that simplify development while providing advanced features like automatic reconnection, room management, and scaling solutions for production applications."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>i});var t=r(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);