"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7025],{7615:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"react-interview/thinking-declaratively","title":"Thinking Declaratively in React","description":"Guide on thinking in declarative and state-driven approaches in React, featuring practical examples like a todo list to illustrate building dynamic, maintainable UIs","source":"@site/docs/react-interview/05-thinking-declaratively.md","sourceDirName":"react-interview","slug":"/react-interview/thinking-declaratively","permalink":"/frontend-system-design/docs/react-interview/thinking-declaratively","draft":false,"unlisted":false,"editUrl":"https://github.com/binhphanhai/frontend-system-design/tree/main/Summarize/docs/react-interview/05-thinking-declaratively.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"reactInterviewSidebar","previous":{"title":"Basic React Concepts for Interviews","permalink":"/frontend-system-design/docs/react-interview/basic-react-concepts"},"next":{"title":"Designing State in React Interviews","permalink":"/frontend-system-design/docs/react-interview/designing-state"}}');var a=n(4848),s=n(8453);const r={},l="Thinking Declaratively in React",o={},c=[{value:"Declarative UI vs Imperative UI",id:"declarative-ui-vs-imperative-ui",level:2},{value:"Analogy: Imperative vs Declarative",id:"analogy-imperative-vs-declarative",level:3},{value:"Practical Example: Todo List (Imperative vs Declarative)",id:"practical-example-todo-list-imperative-vs-declarative",level:2},{value:"How to Think About UI Declaratively",id:"how-to-think-about-ui-declaratively",level:2},{value:"1. Identify Visual States in the Components",id:"1-identify-visual-states-in-the-components",level:3},{value:"2. Determine the Actions That Trigger State Changes",id:"2-determine-the-actions-that-trigger-state-changes",level:3},{value:"3. Design a Minimal Structure to Represent the State",id:"3-design-a-minimal-structure-to-represent-the-state",level:3},{value:"4. Call Actions Within Event Handlers",id:"4-call-actions-within-event-handlers",level:3},{value:"Full Example: Declarative Todo List",id:"full-example-declarative-todo-list",level:2},{value:"What You Need to Know for Interviews",id:"what-you-need-to-know-for-interviews",level:2},{value:"Practice Questions",id:"practice-questions",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"thinking-declaratively-in-react",children:"Thinking Declaratively in React"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"Guide on thinking in declarative and state-driven approaches in React, featuring practical examples like a todo list to illustrate building dynamic, maintainable UIs"})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.p,{children:"One of the core principles of React is its declarative nature. Instead of manually updating the DOM step by step (imperative programming), React allows you to define what the UI should look like based on the current state, and it takes care of the updates for you. This approach makes UI development more predictable, scalable, and easier to reason about."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"declarative-ui-vs-imperative-ui",children:"Declarative UI vs Imperative UI"}),"\n",(0,a.jsx)(t.p,{children:"In imperative programming, you give explicit instructions on how things should happen. DOM APIs are inherently imperative. When manipulating the DOM, this often means selecting elements and modifying them manually."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const button = document.createElement('button');\r\nbutton.textContent = 'Click me';\r\nbutton.style.backgroundColor = 'blue';\r\ndocument.body.appendChild(button);\r\n\r\nbutton.addEventListener('click', () => {\r\n  button.style.backgroundColor = 'red';\r\n  alert('Button clicked!');\r\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:"Every single action is explicitly defined: creating the button, setting styles, appending it to the DOM, and changing properties in response to an event."}),"\n",(0,a.jsx)(t.p,{children:"Declarative programming, on the other hand, focuses on describing the desired outcome rather than detailing how to achieve it. React components allow us to declare what the UI should look like, and React takes care of updating it when state changes."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:"function App() {\r\n  const [color, setColor] = React.useState('blue');\r\n  return (\r\n    <button\r\n      style={{ backgroundColor: color }}\r\n      onClick={() => setColor('red')}\r\n    >\r\n      Click me\r\n    </button>\r\n  );\r\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In this example, we define the button's UI based on ",(0,a.jsx)(t.code,{children:"color"})," state. When the state changes, React automatically updates the DOM without us having to manage it manually."]}),"\n",(0,a.jsx)(t.h3,{id:"analogy-imperative-vs-declarative",children:"Analogy: Imperative vs Declarative"}),"\n",(0,a.jsx)(t.p,{children:"Think of making a cup of coffee:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Imperative:"}),' "Take a mug, pour hot water, add coffee, stir, and serve"']}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Declarative:"}),' "I want a cup of coffee"']}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"In a declarative approach, the details of execution are abstracted away. You describe the final outcome, and a system (e.g. a coffee machine, a barista, or React) ensures it happens correctly."}),"\n",(0,a.jsx)(t.p,{children:"The benefit of declarative programming might not be too obvious in the button example above because it is small."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"practical-example-todo-list-imperative-vs-declarative",children:"Practical Example: Todo List (Imperative vs Declarative)"}),"\n",(0,a.jsx)(t.p,{children:"Let's use a slightly more complex example of a todo list that allows adding, deleting, and completing of tasks. The UI should show the task list and the total number of tasks as well as completed tasks."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Imperative approach:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Every interaction requires manually finding, updating, and re-rendering elements."}),"\n",(0,a.jsx)(t.li,{children:"Adding, completing, or deleting a task means updating the DOM and keeping counts in sync manually."}),"\n",(0,a.jsx)(t.li,{children:"As features grow, the code becomes harder to maintain and reason about."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Declarative approach (React):"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"You describe the UI that should be shown based on the updated tasks state, and React figures out the necessary DOM operations."}),"\n",(0,a.jsx)(t.li,{children:"React's virtual DOM and reconciliation process efficiently update only what is needed."}),"\n"]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"how-to-think-about-ui-declaratively",children:"How to Think About UI Declaratively"}),"\n",(0,a.jsx)(t.p,{children:"Thinking declaratively requires shifting your focus from how to update the UI to what the UI should be at any given moment."}),"\n",(0,a.jsx)(t.p,{children:"Let's use the same todo list example above and demonstrate how declarative programming is better. To make things a bit more complex, the todo list supports filtering (All, Complete, Incomplete)."}),"\n",(0,a.jsx)(t.h3,{id:"1-identify-visual-states-in-the-components",children:"1. Identify Visual States in the Components"}),"\n",(0,a.jsx)(t.p,{children:"A todo list has several possible UI states:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Input field that can accept text input from the user"}),"\n",(0,a.jsx)(t.li,{children:"A list of tasks, which can be empty or non-empty"}),"\n",(0,a.jsx)(t.li,{children:"Each task can be completed or incomplete"}),"\n",(0,a.jsx)(t.li,{children:"Selector for task filters and the selected option"}),"\n",(0,a.jsx)(t.li,{children:"The list of tasks can be filtered (All, Active, Completed)"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"2-determine-the-actions-that-trigger-state-changes",children:"2. Determine the Actions That Trigger State Changes"}),"\n",(0,a.jsx)(t.p,{children:"Define the actions that affect state:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Adding a task"}),"\n",(0,a.jsx)(t.li,{children:"Completing a task"}),"\n",(0,a.jsx)(t.li,{children:"Deleting a task"}),"\n",(0,a.jsx)(t.li,{children:"Filtering tasks (show All, Active, or Completed)"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"3-design-a-minimal-structure-to-represent-the-state",children:"3. Design a Minimal Structure to Represent the State"}),"\n",(0,a.jsx)(t.p,{children:"Here's one possible design:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const [tasks, setTasks] = useState([\r\n  { id: 1, title: 'Learn React', completed: false },\r\n  { id: 2, title: 'Build a project', completed: true },\r\n]);\r\nconst [filter, setFilter] = useState('all'); // all | active | completed\n"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"tasks"})," is an array where each task has an ",(0,a.jsx)(t.code,{children:"id"}),", ",(0,a.jsx)(t.code,{children:"title"}),", and ",(0,a.jsx)(t.code,{children:"completed"})," status"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"filter"})," determines which tasks to display"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["To avoid redundant state, instead of keeping a separate ",(0,a.jsx)(t.code,{children:"completedTasks"})," array, we can derive completed tasks from ",(0,a.jsx)(t.code,{children:"tasks"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"4-call-actions-within-event-handlers",children:"4. Call Actions Within Event Handlers"}),"\n",(0,a.jsx)(t.p,{children:"Actions are triggered in response to two kinds of events:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"User events:"})," Actions directly performed by the user, such as clicking a button, typing in an input field, or selecting an option from a dropdown"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Background events:"})," Actions triggered without direct user interaction such as API responses, timers and intervals, WebSocket real-time updates"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"For the todo list at hand, we only need to care about user events. It's advisable to write a function for each of these actions, and call the state setters within each action function. This centralizes state update logic and keeps the code maintainable."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"full-example-declarative-todo-list",children:"Full Example: Declarative Todo List"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:"import { useState } from 'react';\r\n\r\nfunction TodoApp() {\r\n  const [tasks, setTasks] = useState([]);\r\n  const [filter, setFilter] = useState('all');\r\n  const [taskInput, setTaskInput] = useState('');\r\n\r\n  // Add a task\r\n  function addTask() {\r\n    if (taskInput.trim() === '') return;\r\n    const newTask = { id: Date.now(), text: taskInput, completed: false };\r\n    setTasks([...tasks, newTask]);\r\n    setTaskInput('');\r\n  }\r\n\r\n  // Toggle task completion\r\n  function toggleTask(id) {\r\n    setTasks(\r\n      tasks.map(task =>\r\n        task.id === id ? { ...task, completed: !task.completed } : task\r\n      )\r\n    );\r\n  }\r\n\r\n  // Delete a task\r\n  function deleteTask(id) {\r\n    setTasks(tasks.filter(task => task.id !== id));\r\n  }\r\n\r\n  // Get tasks based on filter\r\n  const filteredTasks = tasks.filter(task => {\r\n    if (filter === 'active') return !task.completed;\r\n    if (filter === 'completed') return task.completed;\r\n    return true; // \"all\" case\r\n  });\r\n\r\n  return (\r\n    <div>\r\n      <h2>Todo List</h2>\r\n      <input\r\n        value={taskInput}\r\n        onChange={e => setTaskInput(e.target.value)}\r\n        placeholder=\"Add a new task...\"\r\n      />\r\n      <button onClick={addTask}>Add</button>\r\n      <div>\r\n        <button onClick={() => setFilter('all')}>All</button>\r\n        <button onClick={() => setFilter('active')}>Active</button>\r\n        <button onClick={() => setFilter('completed')}>Completed</button>\r\n      </div>\r\n      <ul>\r\n        {filteredTasks.map(task => (\r\n          <li\r\n            key={task.id}\r\n            style={{ textDecoration: task.completed ? 'line-through' : 'none' }}\r\n          >\r\n            {task.text}\r\n            <button onClick={() => toggleTask(task.id)}>\r\n              {task.completed ? 'Undo' : 'Complete'}\r\n            </button>\r\n            <button onClick={() => deleteTask(task.id)}>\u274c</button>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default TodoApp;\n"})}),"\n",(0,a.jsx)(t.p,{children:"This todo list is declarative because:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"UI updates automatically:"})," When ",(0,a.jsx)(t.code,{children:"tasks"})," or ",(0,a.jsx)(t.code,{children:"filter"})," changes, React re-renders the UI accordingly"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"No manual DOM manipulation:"})," No need to select elements, manually remove tasks, or update styles via ",(0,a.jsx)(t.code,{children:"document.querySelector"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Minimal and structured state:"})," The UI is derived from a ",(0,a.jsx)(t.strong,{children:"single source of truth"})," (",(0,a.jsx)(t.code,{children:"tasks"})," and ",(0,a.jsx)(t.code,{children:"filter"}),")"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Event handlers update state, not the DOM:"})," The functions ",(0,a.jsx)(t.code,{children:"addTask"}),", ",(0,a.jsx)(t.code,{children:"toggleTask"}),", and ",(0,a.jsx)(t.code,{children:"deleteTask"})," only update state, React handles the re-rendering."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"This example shows how thinking declaratively simplifies UI development in React:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["Identify ",(0,a.jsx)(t.strong,{children:"UI states"})]}),"\n",(0,a.jsxs)(t.li,{children:["Determine ",(0,a.jsx)(t.strong,{children:"state-changing actions/operations"})]}),"\n",(0,a.jsxs)(t.li,{children:["Design a ",(0,a.jsx)(t.strong,{children:"minimal state structure"})]}),"\n",(0,a.jsxs)(t.li,{children:["Use ",(0,a.jsx)(t.strong,{children:"event handlers"})," to update state"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Instead of micromanaging DOM updates, we let React ",(0,a.jsx)(t.strong,{children:"react"})," to state changes \u2013 making our code cleaner, scalable, and easier to maintain."]}),"\n",(0,a.jsx)(t.p,{children:"Thinking declaratively in React means shifting from a step-by-step, command-driven mindset to a state-driven approach. By focusing on defining what the UI should be based on state, you create components that are more readable, predictable, and maintainable."}),"\n",(0,a.jsx)(t.p,{children:"Embracing this paradigm makes it easier to manage complex UIs and lets React do the heavy lifting of figuring out how to update the DOM efficiently."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"what-you-need-to-know-for-interviews",children:"What You Need to Know for Interviews"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Think declaratively and design the component:"})," Given a UI and the requirements, you should be able to think in a declarative fashion to define the various necessary components, props, state, operations that change the state, and connect all of them together."]}),"\n"]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"practice-questions",children:"Practice Questions"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Coding:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/questions/user-interface/tweet/react?framework=react&tab=coding",children:"Tweet"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/questions/user-interface/progress-bar/react?framework=react&tab=coding",children:"Progress Bar"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/questions/user-interface/progress-bars/react?framework=react&tab=coding",children:"Progress Bars"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/questions/user-interface/file-explorer/react?framework=react&tab=coding",children:"File Explorer"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/questions/user-interface/file-explorer-ii/react?framework=react&tab=coding",children:"File Explorer II"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/questions/user-interface/file-explorer-iii/react?framework=react&tab=coding",children:"File Explorer III"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>l});var i=n(6540);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);